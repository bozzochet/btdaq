// file padlib.c
//
// Collection of Peter's aal software in one (well, in two) file(s).
//
// A.Lebedev - Oct-2007...

#include "padlib.h"

//~============================================================================

//  cmdopt.c   getopt_long replacement

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Lake Howard Hotel, Taiwan

#ifdef __cplusplus
extern "C" {
#endif

char *optarg = 0;
int   optind = -1;
int   opterr = 1;
int   optopt = 0;
static int newinv = 1;

int CmdOptGet (int argc, char *const argv[], const char *optstring,
               const struct _CmdOpt *longopts, int *longindex)
{
static int nextchar;

// New invocation.

  if (newinv == 1)
  {
    optind = 0;
    nextchar = 0;
    newinv = 0;
  }

// No arguments left.

  if (optind + 1 == argc)
  {
    ++optind;
    newinv = 1;
    return -1;
  }

// New argument.

  if (nextchar == 0)
  {
    ++optind;

// Long option or end-of-options marker.

    if (argv[optind][0] == '-' && argv[optind][1] == '-')
    {
      if (argv[optind][2] == '\0')
      {
        ++optind;
        return -1;
      }
      else
      {
      const char *begin = argv[optind] + 2;
      const char *end;
      const struct _CmdOpt *op;
                
        end = strchr (begin, '=');
        if (end == 0)
        {
          end = begin + strlen (begin);
        }

        for (op = longopts; op->name || op->val; ++op)
        {
          if ( ! op->name)
            continue;

          if (end - begin == strlen (op->name)
              && strncmp (begin, op->name, end - begin) == 0)
          {
          int ret = 0;

            if (! op->has_arg && *end == '=')
            {
              if (opterr)
              {
                fprintf (stderr, "%s: option `--%s' doesn't"
                         " allow an argument\n", argv[0], op->name);
              }
              ret = '?';
            }
            else
            {
              if (op->has_arg)
              {
                optarg = 0;
                if (*end == '=')
                {
                  optarg = (char*) end + 1;
                }
                else if (optind + 1 >= argc
                         && op->has_arg == required_argument)
                {
                  if (opterr)
                  {
                    fprintf (stderr, "%s: option `--%s' requires"
                             " an argument\n", argv[0], op->name);
                  }
                  return '?';
                }
                else if (optind + 1 >= argc)
                {
                  ; // do nothing.
                }
                else if (argv[optind + 1][0] != '-'
                         || op->has_arg == required_argument)
                {
                  optarg = argv[optind + 1];
                  ++optind;
                }
              }
              if (longindex)
              {
                *longindex = op - longopts;
              }
              if (op->flag)
              {
                *(((struct _CmdOpt*)op)->flag) = op->val;
              }
              else
              {
                ret = op->val;
              }
            }
            return ret;
          }
        }
        if (opterr)
        {
          fprintf (stderr, "%s: unrecognized option `--%s'\n",
                   argv[0], begin);
        }
        return '?';
      }
    }

// Short option.

    else if (argv[optind][0] == '-' && argv[optind][1] != '\0')
    {
      nextchar = 1;
    }

// Non-option.

    else
    {
      newinv = 1;
      return -1;
    }
  } 

// Second+ character of a short option.  Note that this cannot be an
// else block because nextchar is updated in the block above.

  if (nextchar)
  {
  const char *op = strchr (optstring, argv[optind][nextchar]);

    ++nextchar;
    if (op)
    {
      if (op[1] == ':')
      {
        if (argv[optind][nextchar] != '\0')
        {
          optarg = argv[optind] + nextchar;
          nextchar = 0;
        }
        else if (optind + 1 >= argc)
        {
          if (opterr)
          {
            fprintf (stderr, "%s: option requires an argument -- %c\n", 
                     argv[0], *op);
          }
          return '?';
        }
        else
        {
          optarg = argv[optind + 1];
          ++optind;
          nextchar = 0;
        }
      }

			if (argv[optind][nextchar] == '\0')
      {
        nextchar = 0;
			}
      return *op;
    }
    else
    {
      if (opterr)
      {
        fprintf (stderr, "%s: invalid option -- %c\n",
                 argv[0], argv[optind][nextchar - 1]);
      }
      return '?';
    }
  }

  return -1;
}

void CmdOptUsage (const char *optstring, const struct _CmdOpt *longopts)
{
int i;
int ts1, ts2; 
const char *cp;
int arg;
int bracket;
int col;
int cnt;

//  Determine the column widths

  ts1 = 0;
  ts2 = 0;

  for (i=0; longopts[i].name || longopts[i].val; i++)
  {
    bracket = 0;
    col = 0;
    cnt = 0;
    arg = 0;
    for (cp=optstring; *cp; cp++)
    {
      if (*cp == ':')
      {
        arg = 1;
      }
      else
      {
        if (*cp == longopts[i].val)
        {
          if (longopts[i].name && ! bracket)
          {
            bracket = 1;
            col += 1;
          }
          if (cnt)
            col += 1;
          col += 2;
          cnt++;
        }
        arg = 0;
      }
    }

    if (longopts[i].name)
    {
      if (cnt)
        col += 1;
      col += 2 + strlen(longopts[i].name);
      cnt++;
    }

    if (bracket)
      col += 1;

    if (col > ts1)
      ts1 = col;

    if (longopts[i].ArgName)
    {
      if (ts2 < strlen(longopts[i].ArgName))
        ts2 = strlen(longopts[i].ArgName);
    }
  }

  ts1 += 3;
  ts2 += ts1 + 3;

  for (i=0; longopts[i].name || longopts[i].val; i++)
  {
    bracket = 0;
    col = 0;
    cnt = 0;
    arg = 0;
    for (cp=optstring; *cp; cp++)
    {
      if (*cp == ':')
      {
        ;
      }
      else
      {
        if (*cp == longopts[i].val)
        {
          if (*(cp+1) == ':')
            arg = 1;
          else
            arg = 0;
          if (((arg == 0) && (longopts[i].has_arg != 0)) ||
              ((arg != 0) && (longopts[i].has_arg == 0)))
          {
            if (opterr)
            {
              fprintf (stderr, "Option flag inconsistant.  Index %d Option '%c'\n",
                       i, *cp);
            }
          }
          if (longopts[i].name && ! bracket)
          {
            bracket = 1;
            col += printf("{");
          }
          if (cnt)
            col += printf(" ");
          col += printf("-%c", *cp);
          cnt++;
        }
      }
    }

    if (longopts[i].name)
    {
      if (cnt)
        col += printf(" ");
      col += printf("--%s", longopts[i].name);
      cnt++;
    }

    if (bracket)
      col += printf("}");

    while (col < ts1)
      col += printf(" ");

    if (longopts[i].ArgName)
      col += printf("%s", longopts[i].ArgName);

    while (col < ts2)
      col += printf(" ");

    if (longopts[i].Description)
    {
      //      col += printf("%s", longopts[i].Description);
      for (cp = longopts[i].Description; *cp; cp++)
      {
        if ((*cp == '\n') || ((col > 70) && isspace(*cp)))
        {
          printf("\n");
          col = 0;
          while (col < ts2)
            col += printf(" ");
        }
        else
          col += printf("%c", *cp);
      }
    }

    printf("\n");
  }
}

#ifdef __cplusplus
}
#endif

//~============================================================================

//  acop6tlib.c   Interface for ACOP6T board

//  Revision History
//    May 2003 by Peter Dennett
//      - Initial version at PADSOFT
//    Dec 2003 by Peter Dennett
//      - Conversion of PIT work to APLS

static int RxAinsync = 0;
static int RxBinsync = 0;

//=============================================================================

/*
static __inline int16 unpack(int16 code, int16 mask) {
  int16 LSB = mask & (mask ^ mask << 1);
  return (code & mask) / LSB;
}

//~----------------------------------------------------------------------------

static __inline int32 pack32(int32 *code, int32 mask, int16 number) {
  int32 LSB = mask & (mask ^ mask << 1);
  *code = (*code & ~mask) | (number * LSB);
}

//~----------------------------------------------------------------------------

static __inline int32 unpack32(int32 code, int32 mask) {
  int32 LSB = mask & (mask ^ mask << 1);
  return (code & mask) / LSB;
}

//~----------------------------------------------------------------------------

static __inline void pack(int16 *code, int16 mask, int16 number) {
  int16 LSB = mask & (mask ^ mask << 1);
  *code = (*code & ~mask) | (number * LSB);
}

//~----------------------------------------------------------------------------

static __inline int16 invert_bit_order(int16 code) {
  int16 new_code = 0;
  int i;

  for (i=0; i<16; i++) {
    new_code <<= 1;
    if (code & 0x0001 << i) new_code |= 0x0001;
  }
  return new_code;
}
*/

ACOP6TPDall ACOP6TPD;

int ACOP6T_FH;
static char *HRDLDevice = "/dev/acop6t";

#undef DIRECT_MMAP

#ifdef DIRECT_MMAP
static unsigned long *HRDLRegisters;
static unsigned char *HRDLDpram;
#endif

int ACOP6TReadReg(int Reg, int32 *pVal)
{
int rtn;

#ifdef DIRECT_MMAP
  rtn =  (*Val = *(HRDLRegisters+((Reg)>>2)));
#else
  rtn = ioctl(ACOP6T_FH, ACOP6T_IOC_GET_REG | (Reg & 0xff), (int32) pVal);
#endif

  return rtn;
}

int ACOP6TWriteReg(int Reg, int32 Val)
{
int rtn;

#ifdef DIRECT_MMAP
  rtn = (*(HRDLRegisters+((Reg)>>2)) = (Val));
#else
  rtn = ioctl(ACOP6T_FH, ACOP6T_IOC_SET_REG | (Reg & 0xff), (int32) Val);
#endif

  return rtn;
}

int ACOP6TRead(int32 Offset, int8 *Buff, int Cnt)
{
int rtn;

#ifdef DIRECT_MMAP
  memcpy(Buff, HRDLDpram+Offset, Cnt);
  rtn = Cnt;
#else
	ACOP6T_DATA d;

	d.pci_off = Offset;
	d.data = (int32) Buff;
	d.size = Cnt;

	rtn = read(ACOP6T_FH, (void *) &d, Cnt);
#endif

  return rtn;
}

int ACOP6TWrite(int32 Offset, int8 *Buff, int Cnt)
{
int rtn;

#ifdef DIRECT_MMAP
  memcpy(HRDLDpram+Offset, Buff, Cnt);
  rtn = Cnt;
#else
	ACOP6T_DATA d;

	d.pci_off = Offset;
	d.data = (int32) Buff;
	d.size = Cnt;

	rtn = write(ACOP6T_FH, (void *) &d, Cnt);
#endif

  return rtn;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TOpen
int ACOP6TOpen(void)
//-Synopsis:    Open the ACOP6T device driver
//-Desciption:  Open the ACOP6T device driver
//-Returns:     FALSE on failure
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:  ACOP6TReadReg(ACOP6T_CSR_RASTT, &RegValue);

//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  if ( (ACOP6T_FH = open(HRDLDevice, O_RDWR)) < 0 ) 
    return 0;

  printf("ACOP6TOpen handle %d\n", ACOP6T_FH);

#ifdef DIRECT_MMAP
  HRDLDpram = mmap(0, ACOP6T_MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, 
                   ACOP6T_FH, 0xba000000);
  HRDLRegisters = mmap(0, ACOP6T_REG_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
                       ACOP6T_FH, 0xba100000);
#endif

#ifdef DEBUG
  printf("DPRAM mmap: 0x%X Registers mmap: 0x%X\n", 
         (int)HRDLDpram, (int)HRDLRegisters); 
#endif

  RxAinsync = 0;
  RxBinsync = 0;
  memset((char *)&ACOP6TPD, 0, sizeof (struct _ACOP6TPDall));

  return 1;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TClose
int ACOP6TClose(void)
//-Synopsis:    Close the device
//-Desciption:  Close the device
//-Returns:     TRUE unless device type is not valid
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:  ACOP6TReadReg(ACOP6T_CSR_RASTT, &RegValue);

//-Bugs:
//-Revisions:
//-End:
{
#ifdef DIRECT_MMAP
	munmap(HRDLRegisters, ACOP6T_REG_SIZE);
	munmap(HRDLDpram, ACOP6T_MEM_SIZE);
#endif

  close(ACOP6T_FH);

  return 1;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TConfig
int ACOP6TConfig(int EnableMask, int FrameSize, int FifoSizeTxA, 
                 int FifoSizeRxA, int FifoSizeTxB, int FifoSizeRxB,
                 int DataA, int SyncA, int PadA,
                 int DataB, int SyncB, int PadB)
//-Synopsis:    Configure the ACOP6T board for operation.
//-Desciption:  Configure the ACOP6T board for operation.
//-ARG_I:       EnableMask      Mask determining which interfaces are enable for
//-                             operation.
//-
//-                             Constructed with the following bits:
//-                             ACOP6T_TxA 0x01
//-                             ACOP6T_RxA 0x02
//-                             ACOP6T_TxB 0x04
//-                             ACOP6T_RxB 0x08
//-
//-                             Any negative value results in using the
//-                             default value ACOP6T_TxA | ACOP6T_RxA
//-ARG_I:       FrameSize       Number bytes for each HRDL frame.
//-
//-                             Any negative value results in using the
//-                             default value 4084.
//-ARG_I:       FifoSizeTxA     Number of frames for TxA FIFO
//-
//-                             Any negative value results in using the
//-                             default value currently in the board.
//-ARG_I:       FifoSizeTxA     Number of frames for RxA FIFO
//-
//-                             Any negative value results in using the
//-                             default value currently in the board.
//-ARG_I:       FifoSizeTxB     Number of frames for TxB FIFO
//-
//-                             Any negative value results in using the
//-                             default value currently in the board.
//-ARG_I:       FifoSizeRxB     Number of frames for RxB FIFO
//-
//-                             Any negative value results in using the
//-                             default value currently in the board.
//-ARG_I:       DataA           Data/Sync ratio for interface A.
//-ARG_I:       SyncA           Data/Sync ratio for interface A.
//-ARG_I:       PadA            Intra-frame sync pad for interface A (min).
//-ARG_I:       DataB           Data/Sync ratio for interface B.
//-ARG_I:       SyncB           Data/Sync ratio for interface B.
//-ARG_I:       PadB            Intra-frame sync pad for interface B (min).
//-Returns:     TRUE if sucessful
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 RegValue;
int cha = 0;
int chb = 0;
int tx = 0;
int rx = 0;
int32 FrameSizeA, FrameSizeB;
int blocks;

  if (FrameSize <= 0)
    FrameSize = 4084;

  if (EnableMask < 0)
    EnableMask = ACOP6T_TxA | ACOP6T_RxA;

  FrameSizeA = FrameSize;
  FrameSizeB = FrameSize;

  if (EnableMask & ACOP6T_TxA)
  {
    cha = 1;
    tx = 1;
  }

  if (EnableMask & ACOP6T_TxA)
  {
    cha = 1;
    rx = 1;
  }

  if (EnableMask & ACOP6T_TxB)
  {
    chb = 1;
    tx = 1;
  }

  if (EnableMask & ACOP6T_TxB)
  {
    chb = 1;
    rx = 1;
  }

// Disable Transmitters and light

  RegValue = 0;
  ACOP6TWriteReg(ACOP6T_TXA_EN, RegValue);
  ACOP6TWriteReg(ACOP6T_TXB_EN, RegValue);

//?? Should wait here (under timeout) to see TXx_TX_IN_CFG
//?? become asserted in ACOP6T_TX[AB]_STATUS

// Set Packet Size

//  printf("Write FrameSize = %ld\n", FrameSizeA);
  if (cha) 
    ACOP6TWriteReg(ACOP6T_TXA_PCKT_SIZE, FrameSizeA - 1);
  if (chb) 
    ACOP6TWriteReg(ACOP6T_TXB_PCKT_SIZE, FrameSizeB - 1);

// Configure the data parsing parameters (data/sync ratio)

  if ((DataA >= 0) && (SyncA >= 0))
  {
    RegValue = ((SyncA & 0xFF) << 8) | (DataA & 0xFF); 
    //    printf("Setting Data/Sync ratio parameters 0x%lX\n", RegValue);
    ACOP6TWriteReg(ACOP6T_TXA_DATA_RATE, RegValue);
  }

  if (PadA >= 0)
  {
    RegValue = PadA;
    ACOP6TWriteReg(ACOP6T_TXA_GAP, RegValue);
  }

  if ((DataB >= 0) && (SyncB >= 0))
  {
    RegValue = ((SyncB & 0xFF) << 8) | (DataB & 0xFF); 
    ACOP6TWriteReg(ACOP6T_TXB_DATA_RATE, RegValue);
  }

  if (PadB >= 0)
  {
    RegValue = PadB;
    ACOP6TWriteReg(ACOP6T_TXB_GAP, RegValue);
  }

//  First read the current Fifo size settings and get any default
//  values taken care of.  Then go thru and validate what we have
//  been requested to do is possible

  ACOP6TReadReg(ACOP6T_BCFG, &RegValue);

  if (FifoSizeTxA <= 0)
    FifoSizeTxA = ((RegValue >> 16) & 0xFF);
 
  if (FifoSizeTxB <= 0)
  {
    FifoSizeTxB = ((RegValue >> 8) & 0xFF);
    FifoSizeTxB -= ((RegValue >> 16) & 0xFF);
  }

  if (FifoSizeRxA <= 0)
  {
    FifoSizeRxA = ((RegValue) & 0xFF);
    FifoSizeRxA -= ((RegValue >> 8) & 0xFF);
  }

  if (FifoSizeRxB <= 0)
  {
    FifoSizeRxB = 256;
    FifoSizeRxB -= ((RegValue) & 0xFF);
  }

  if (FifoSizeRxB <= 0)
  {
    FifoSizeRxB = 1;
    FifoSizeRxA -= 1;
  }

  if (FifoSizeRxA <= 0)
  {
    FifoSizeRxA = 1;
    FifoSizeTxB -= 1;
  }

  if (FifoSizeTxB <= 0)
  {
    FifoSizeTxB = 1;
    FifoSizeTxA -= 1;
  }

  blocks = FifoSizeTxA + FifoSizeRxA + FifoSizeTxB; // + FifoSizeRxB;

  if (blocks > 250)
  {
    printf("ACOP6TConfig: Failed.\n  BRDCFG: 0x%08X\n", RegValue);
    printf("  FifoSizes: TxA %d TxB %d RxA %d RxB %d\n", FifoSizeTxA, FifoSizeTxB,
           FifoSizeRxA, FifoSizeRxB);
    return 0;
  }

  FifoSizeRxB = 256 - blocks;

//  Figure out what we want to enable and build the BDCFG value

  RegValue = 0;

#ifdef LITTLE_ENDIAN
//  This byte swaps all transfered data (not registers)

  RegValue |= BCFG_LITTLE_ENDIAN;
#endif

  if (EnableMask & ACOP6T_LoopBackA)
    RegValue |= BCFG_TXA_HLPBCK;

  if (EnableMask & ACOP6T_LoopBackB)
    RegValue |= BCFG_TXB_HLPBCK;

  blocks = FifoSizeTxA;
  pack32(&RegValue, BCFG_RXA_BUFFER_START, blocks);
  blocks += FifoSizeRxA;
  pack32(&RegValue, BCFG_TXB_BUFFER_START, blocks);
  blocks += FifoSizeTxB;
  pack32(&RegValue, BCFG_RXB_BUFFER_START, blocks);

#if 0
  printf("New ACOP6T_BCFG: 0x%08lX\n", RegValue);
  printf("  FifoSizes: TxA %d TxB %d RxA %d RxB %d\n", FifoSizeTxA, FifoSizeTxB,
            FifoSizeRxA, FifoSizeRxB);
#endif

  ACOP6TWriteReg(ACOP6T_BCFG, RegValue);

//  Set our interrupt points

  pack32(&RegValue, TXx_ALE_TH, FifoSizeTxA/2);
  ACOP6TWriteReg(ACOP6T_TXA_ALE_TH, RegValue);

  pack32(&RegValue, TXx_ALE_TH, FifoSizeTxB/2);
  ACOP6TWriteReg(ACOP6T_TXB_ALE_TH, RegValue);

  pack32(&RegValue, RXx_ALF_TH, FifoSizeRxA/2);
  ACOP6TWriteReg(ACOP6T_RXA_ALF_TH, RegValue);

  pack32(&RegValue, RXx_ALF_TH, FifoSizeRxB/2);
  ACOP6TWriteReg(ACOP6T_RXB_ALF_TH, RegValue);

//  Re-enable the board transmits

  RegValue = TXx_OUT_EN | TXx_DATA_EN;

  if (EnableMask & ACOP6T_TxA)
    ACOP6TWriteReg(ACOP6T_TXA_EN, RegValue);

  if (EnableMask & ACOP6T_TxB)
    ACOP6TWriteReg(ACOP6T_TXB_EN, RegValue);

//?? Should wait here (under timeout) to see ACOP6T_STT_TXCONFIG
//?? de-assert

  return 1;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TChkRx
int ACOP6TChkRx(int Interface)
//-Synopsis:    Check if a frame is available to receive
//-Desciption:  Check if a frame is available to receive
//-ARG_I:       Interface      Which interface to use ACOP6T_INTB or A
//-Returns:     TRUE if frame available to receive.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 RegValue;

// Check RX data available

  if (Interface == ACOP6T_INTB)
    ACOP6TReadReg(ACOP6T_RXB_STATUS, &RegValue);
  else
    ACOP6TReadReg(ACOP6T_RXA_STATUS, &RegValue);

  return (RegValue & RXx_RX_NE) != 0;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TGetRx
int32 ACOP6TGetRx(int Interface)
//-Synopsis:    Get the Rx frame address offset available to receive
//-Desciption:  Get the Rx frame address offset available to receive
//-ARG_I:       Interface      Which interface to use ACOP6T_INTB or A
//-Returns:     The memory offset for the first block to recieve
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 RegValue;
int32 rxa_cpu;

  if (Interface == ACOP6T_INTB)
    ACOP6TReadReg(ACOP6T_RXB_STATUS, &RegValue);
  else
    ACOP6TReadReg(ACOP6T_RXA_STATUS, &RegValue);

  rxa_cpu = (RegValue >> 24) & 0xFF;

  return (rxa_cpu << 12);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TIncRx
int ACOP6TIncRx(int Interface)
//-Synopsis:    Increment the Rx frame number
//-Desciption:  Increment the Rx frame number.  Indicates the frame
//-             has been read.
//-ARG_I:       Interface      Which interface to use ACOP6T_INTB or A
//-Returns:     TRUE
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  if (Interface == ACOP6T_INTB)
    ACOP6TWriteReg(ACOP6T_RXB_RD, 1);
  else
    ACOP6TWriteReg(ACOP6T_RXA_RD, 1);

  return 1;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TChkTx
int ACOP6TChkTx(int Interface)
//-Synopsis:    Check if there is room for a transmit frame
//-Desciption:  Check if there is room for a transmit frame
//-ARG_I:       Interface      Which interface to use ACOP6T_INTB or A
//-Returns:     TRUE if room is available for another transmit frame
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 RegValue;

// Check TX room available

  if (Interface == ACOP6T_INTB)
    ACOP6TReadReg(ACOP6T_TXB_STATUS, &RegValue);
  else
    ACOP6TReadReg(ACOP6T_TXA_STATUS, &RegValue);

  return (RegValue & TXx_TX_NF) != 0;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TGetTx
int32 ACOP6TGetTx(int Interface)
//-Synopsis:    Get the Tx frame number available to transmit
//-Desciption:  Get the Tx frame number available to transmit
//-ARG_I:       Interface      Which interface to use ACOP6T_INTB or A
//-Returns:     The memory offset for the first block to transmit
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 RegValue;
int32 txa_cpu;

  if (Interface == ACOP6T_INTB)
    ACOP6TReadReg(ACOP6T_TXB_STATUS, &RegValue);
  else
    ACOP6TReadReg(ACOP6T_TXA_STATUS, &RegValue);

  txa_cpu = (RegValue >> 24) & 0xFF;

  return txa_cpu << 12;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TIncTx
int ACOP6TIncTx(int Interface)
//-Synopsis:    Increment the Tx frame number
//-Desciption:  Increment the Tx frame number.  Indicates the frame
//-             should be transmitted.
//-ARG_I:       Interface      Which interface to use ACOP6T_INTB or A
//-Returns:     TRUE
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  if (Interface == ACOP6T_INTB)
    ACOP6TWriteReg(ACOP6T_TXB_WR, 1);
  else
    ACOP6TWriteReg(ACOP6T_TXA_WR, 1);

  return 1;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TShowCondition
int ACOP6TShowCondition(void)
//-Synopsis:    Show the condition of the interfaces by printf
//-Desciption:  Show the condition of the interfaces by printf.  
//-Returns:     TRUE
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 RegValue;
int32 RegValue2;

  ACOP6TReadReg(ACOP6T_INT_STATUS, &RegValue);
  ACOP6TReadReg(ACOP6T_INT_MASK,   &RegValue2);
  printf("ACOP6T_INT_STATUS:   0x%08X  MASK:  0x%08X\n", RegValue, RegValue2);

  ACOP6TReadReg(ACOP6T_BCFG, &RegValue);
  printf("ACOP6T_BCFG:         0x%08X\n", RegValue);

  ACOP6TReadReg(ACOP6T_BSTT, &RegValue);
  printf("ACOP6T_BSTT:         0x%08X\n", RegValue);

  ACOP6TReadReg(ACOP6T_TXA_EN, &RegValue);
  ACOP6TReadReg(ACOP6T_TXA_PCKT_SIZE, &RegValue2);
  printf("Interface A:         Light %s Data %s FrameSize %d\n", 
         (RegValue&TXx_OUT_EN)?"On ":"Off",
         (RegValue&TXx_DATA_EN)?"On ":"Off",
         RegValue2);

  ACOP6TReadReg(ACOP6T_TXB_EN, &RegValue);
  ACOP6TReadReg(ACOP6T_TXB_PCKT_SIZE, &RegValue2);
  printf("Interface B:         Light %s Data %s FrameSize %d\n", 
         (RegValue&TXx_OUT_EN)?"On ":"Off",
         (RegValue&TXx_DATA_EN)?"On ":"Off",
         RegValue2);

  ACOP6TReadReg(ACOP6T_TXA_STATUS, &RegValue);
  printf("ACOP6T_TXA_STATUS:         0x%08X\n", RegValue);

  ACOP6TReadReg(ACOP6T_TXB_STATUS, &RegValue);
  printf("ACOP6T_TXB_STATUS:         0x%08X\n", RegValue);

  ACOP6TReadReg(ACOP6T_RXA_STATUS, &RegValue);
  printf("ACOP6T_RXA_STATUS:         0x%08X\n", RegValue);

  ACOP6TReadReg(ACOP6T_RXB_STATUS, &RegValue);
  printf("ACOP6T_RXB_STATUS:         0x%08X\n", RegValue);

  return 1;
}

//~============================================================================

//  frmConstruct.c   AMS Block Framing Routines

//  Revision History
//    Apr 2002 by Peter Dennett
//      - Initial version in Kemah office (AALFRM)
//    Sep 2003 by Peter Dennett
//      - Conversion for use in payload simulator
//      - Overhaul to support formats of the CDH ICD
//    Oct 2003 by Peter Dennett
//      - Clean up and test/debug for CheckWord, CRC, Randomize
//    Nov 2003 by Peter Dennett
//      - The frame routines no longer bytes swap while the local block
//        routines do.
//    Jun 2004 by Peter Dennett
//      - Changed to AMS CRC polynomial
//    Jul 2004 by Peter Dennett
//      - Conversion from MDCSoftware

////////////////////////////////////////////////////////////////////////////
//-Extern: frmConstruct
bool frmConstruct(pFRAME pFRM, int32 APID, int32 FrameSize, int32 Options)
//-Synopsis:  Create an object for mapping AMS blocks into CCSDS frames
//-Returns: TRUE if no errors, else FALSE
//-ARG_I:       pFRM       Object for this instance
//-ARG_I:       APID       APID to use for this frame
//-ARG_I:       FrameSize  Number of bytes for CCSDS frame, including 
//-                        its headers.
//-ARG_I:       Options    Controls format options: see FO_ constants
//-Description: Create an object for mapping AMS blocks into CCSDS frames
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  if (FrameSize & 1)
    return Panic("FrameOpen: FrameSize must be even");

  memset(pFRM, 0, sizeof *pFRM);

  pFRM->APID = APID;
  pFRM->FrameSize = FrameSize;
  pFRM->Options = Options;

  pFRM->NASAHdrSize = 16;                 // CCSDS headers
  if (pFRM->Options & FO_PLMDM)
    //pFRM->NASAHdrSize += 8;             // Subset ID, service, and C&W
    pFRM->NASAHdrSize += 10;              // Subset ID, service, and C&W -- PLMDM sequence number -- Added by X.Cai
  if (pFRM->Options & FO_PLMDMCMD)
    //pFRM->NASAHdrSize += 4;             // ReservedWord and LegalStationMode
    pFRM->NASAHdrSize += 6;               // ReservedWord and LegalStationMode -- PLMDM sequence number -- Added by X.Cai

  pFRM->AMSHdrSize = 2;                   // FrameStatus & Pointer
  if (pFRM->Options & FO_CHD)
    pFRM->AMSHdrSize += FRAME_CHD_BYTES ; // Critical health data

//  Make sure the frame is of reasonable size - at least 12 bytes of data

  if (FrameSize < (pFRM->NASAHdrSize + pFRM->AMSHdrSize + 2 + 2 + 12))
    return Panic("FrameOpen: FrameSize %ld not large enough", FrameSize);

  pFRM->DataSize = FrameSize - (pFRM->NASAHdrSize + pFRM->AMSHdrSize);
  if (pFRM->Options & FO_CHECKWORD)
    pFRM->DataSize -= 2;
  if (pFRM->Options & FO_CRC)
    pFRM->DataSize -= 2;

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmDestruct
bool frmDestruct(pFRAME pFRM)
//-Synopsis:  Terminte the AMS block handling
//-Returns: TRUE if no errors, else FALSE
//-ARG_I:       pFRM       Object for this instance
//-Description: Terminte the AMS block handling
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:       Caller should perform their own "flush" using
//-             FrameBlock()
//-Bugs:
//-Revisions:
//-End:
{
  if (pFRM->Block)
    aalFree((char *)pFRM->Block);

  memset(pFRM, 0, sizeof *pFRM);

  return TRUE;
}

//~============================================================================

//  fep.c   Front end processor interface

//  Revision History
//    Mar 2004 by Peter Dennett
//      - Initial development at PADSOFT, conversion of TaskUDP
//    May 2004 by Peter Dennett
//      - Conversion to single thread select supporting multiple
//        clients.  
//      - Supports "TCP" (CCSDS header) server.  
//      - Infrastructure for "RIC" (EXPRESS header) server.
//    Jun 2004 by Peter Dennett
//      - Munged UDP support into taskric to make generic tasknet
//      - TCP connections converted to private streams with our own
//        reply point.  This work done at 36k feet over the North
//        Atlantic.
//    Jul 2004 by Peter Dennett
//      - Munged tasknet into fep.c

#undef FEP_DEBUG

static void aalSleep(int sec, int usec)
{
struct timeval selTimeout; 

  selTimeout.tv_sec = sec;
  selTimeout.tv_usec = usec;
  select(0, NULL, NULL, NULL, &selTimeout);

  return;
}

static bool fepRCBConnect(void *reg, void *call)
{
pFEP pFep = reg;
int Client = (int) call;

#ifdef FEP_DEBUG
  if (pFep->Debug > 2)
    printf("  %s: fepRCBConnect Client[%d]\n", pFep->TaskName, Client);
#endif

  pFep->Callback(pFep, fepClientConnect, Client);

  return TRUE;
}

static bool fepRCBDisconnect(void *reg, void *call)
{
pFEP pFep = reg;
int Client = (int) call;

#ifdef FEP_DEBUG
  if (pFep->Debug > 2)
    printf("  %s: fepRCBDisconnect Client[%d]\n", pFep->TaskName, Client);
#endif

  pFep->Callback(pFep, fepClientDisconnect, Client);

  return TRUE;
}

static bool fepRCBRecv(void *reg, void *call)
{
pFEP pFep = reg;
int Client = (int) call;

#ifdef FEP_DEBUG
  if (pFep->Debug > 2)
    printf("  %s: fepRCBRecv Client[%d]\n", pFep->TaskName, Client);
#endif

  pFep->Callback(pFep, fepClientRecv, Client);

  return TRUE;
}

static int UnInstallThread(pFEP pFep);
static int InstallThread(pFEP pFep);

////////////////////////////////////////////////////////////////////////////
//-Extern: fepConstruct
bool fepConstruct(pFEP pFep, int Port, fepCallback Callback, char *TaskName,
                  int Debug)
//-Synopsis:    Construct a Front End Processor object
//-Returns:     TRUE if no errors, else FALSE
//-ARG_I:       FEP            The object area
//-ARG_I:       Port           Port number to listen to for connections.
//-ARG_I:       CallBack       Routine to call back to inform the
//-                            caller that there has been activity
//-                            on the front end. (see: rcb.h).
//-
//-                            The caller should
//-                            assume that this call back is made in
//-                            a different context (ie: a different
//-                            thread, some type of signal, alarm, or 
//-                            interrupt service).  Thus the called back 
//-                            routine should use some type synchronization
//-                            that is reentrant (mutex).  It should not itself 
//-                            perform any processing - just note that
//-                            processing is needed.
//-
//-                            The call back routine will be called back
//-                            with reg_data FEP_CLIENT_ACCEPTED,
//-                            FEP_CLIENT_CLOSE, and FEP_CLIENT_RECV.
//-                            For all call backs call_data be a client
//-                            handle describing the connection.  This
//-                            handle is used to identify a particular 
//-                            connection on other calls.
//-ARG_I:       TaskName       Pointer to statically allocated string for
//-                            display id's
//-Description: Construct a Front End Processor object
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  memset(pFep, 0, sizeof *pFep);

  pFep->ThreadInstalled = FALSE;
  pFep->Port = Port;
  pFep->TaskName = TaskName;
  pFep->Debug = Debug;
  pFep->Callback = Callback;

  rcbRegister(&pFep->ClientConnect, fepRCBConnect, pFep);
  rcbRegister(&pFep->ClientDisconnect, fepRCBDisconnect, pFep);
  rcbRegister(&pFep->ClientRecv, fepRCBRecv, pFep);

  InstallThread(pFep);

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: fepDestruct
bool fepDestruct(pFEP pFep)
//-Synopsis:    Destruct a Front End Processor object
//-Returns:     TRUE if no errors, else FALSE
//-ARG_I:       FEP            The object area
//-Description: Destruct a Front End Processor object
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  UnInstallThread(pFep);

  rcbDeregister(&pFep->ClientConnect, fepRCBConnect, pFep);
  rcbDeregister(&pFep->ClientDisconnect, fepRCBDisconnect, pFep);
  rcbDeregister(&pFep->ClientRecv, fepRCBRecv, pFep);

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: fepRecv
bool fepRecv(pFEP pFep, pAMSBlock *pRequest, int32 Client)
//-Synopsis:    Receive an AMSBlock
//-Returns:     TRUE an AMSBlock is returned.  FALSE if none is returned
//-             (or there is an error).
//-ARG_I:       FEP            The object area
//-Description: Receive an AMSBlock.  Should be called within a callback
//-             that has indicated a AMSFrame has been received.  The calls
//-             should continue until FALSE is returned.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
bool rtn;

  if ((Client >= FEP_MAX_CLIENTS) || (Client < 0))
    return Panic("%s: fepRecv Client out of range %ld", Client);

  if ( ! pFep->Client[Client].FRMOpened)
  {
    if (pFep->Debug > 1)
      printf("%s: fepRecv frmConstruct\n", pFep->TaskName);

    if ( ! frmConstruct(&pFep->Client[Client].FRM, pFep->Client[Client].APID, 
                                 pFep->Client[Client].FrameSize, 0))
      return Panic("%s: Client[%ld] Error on frmConstruct", pFep->TaskName, Client);
    pFep->Client[Client].FRMOpened = TRUE;
  }

  if (pFep->Debug > 1)
    printf("%s: fepRecv frmListDeblock\n", pFep->TaskName);

  rtn = frmListDeblock(&pFep->Client[Client].FramesIn, 
                       &pFep->Client[Client].FRM, pRequest);

  if ((pFep->Debug > 2) && rtn)
    abiPrint2(pFep->TaskName, "fepRecv", *pRequest, 22);
 
//  Take care of connections that have terminated and we just finished
//  all the pending input

  if ( ! rtn && ! pFep->Client[Client].Accepted)
  {
    frmListHeadDestruct(&pFep->Client[Client].FramesIn); 
  }

  return rtn;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: fepSend
bool fepSend(pFEP pFep, pAMSBlock pRequest, int32 Client)
//-Synopsis:    Send an AMSBlock reply to a client
//-Returns:     TRUE.
//-ARG_I:       FEP            The object area
//-ARG_I:       pRequest       The AMSBlock to send.  This AMSBlock is
//-                            -NOT- released.
//-Description: Send an AMSBlock reply to a client.  This nominally is a 
//-             reply to an earlier fepRecv.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  if ((Client >= FEP_MAX_CLIENTS) || (Client < 0))
    return Panic("%s: fepSend Client out of range %ld", Client);

  if ( ! pFep->Client[Client].Accepted)
    return FALSE;

  if (pFep->Debug > 2)
    abiPrint2(pFep->TaskName, "fepSend", pRequest, 24);

//  For now we do not pend any replies across AMSFrames.  We 
//  just allocate and create frames, flushing at the end of
//  this AMSBlock.  

//--- Changed by A.Lebedev to suppress yet another secondary header
#if 0
  if ( ! frmConstruct(&pFep->Client[Client].FRMReply, pFep->Client[Client].APID, 
                         pFep->Client[Client].FrameSize, FO_TQMHEADER))
#endif
  if ( ! frmConstruct(&pFep->Client[Client].FRMReply, pFep->Client[Client].APID, 
                       pFep->Client[Client].FrameSize, 0))
//---
    return Panic("%s: Error on FrameOpen", pFep->TaskName);

  if ( ! frmListBlock(&pFep->Client[Client].FramesOut, 
                      &pFep->Client[Client].FRMReply, pRequest))
    return Panic("%s: Error on frmListBlock", pFep->TaskName);

//  Flush

  if ( ! frmListBlock(&pFep->Client[Client].FramesOut, 
                      &pFep->Client[Client].FRMReply, NULL))
    return Panic("%s: Error on frmListBlock", pFep->TaskName);

  frmDestruct(&pFep->Client[Client].FRMReply);

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: fepShow
bool fepShow(pFEP pFep)
//-Synopsis:    Show the state of an FEP object
//-Returns:     TRUE if no errors, else FALSE
//-ARG_I:       FEP            The object area
//-Description: Show the state of an FEP object
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int i;

  printf("FEP Status\n");
  for (i=0; i<FEP_MAX_CLIENTS; i++)
  {
    if (pFep->Client[i].Accepted)
    {
      printf("Client[%d] %s\n", i, pFep->Client[i].WriteReady?"WR":"  ");
    }
  }
  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
static bool CreateServerSocket(pFEP pFep)
{
struct sockaddr_in ServAddr;      // Local address
const int on=1;
int ServSock;

//  Create socket for incoming connections

  if ((ServSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
  {
    printf("  %s: Failed to create socket for server\n", pFep->TaskName);
    return FALSE;
  }

//  Construct local address structure 

  memset(&ServAddr, 0, sizeof(ServAddr));       // Zero out structure 
  ServAddr.sin_family = AF_INET;                // Internet address family
  ServAddr.sin_addr.s_addr = htonl(INADDR_ANY); // Any incoming interface
  ServAddr.sin_port = htons(pFep->Port);        // Local port

//  Reuse port for socket

  if ( setsockopt(ServSock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) != 0 )
    printf("  %s: Can't reuse address/ports\n", pFep->TaskName);

//  Bind to the local address

  if (bind(ServSock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) < 0)
  {
    printf("  %s: Bind failed for server\n", pFep->TaskName);
    close(ServSock);
    return FALSE;
  }

//  Mark the socket so it will listen for incoming connections

#define MAXPENDING 5    // Maximum outstanding connection requests 

  if (listen(ServSock, MAXPENDING) < 0)
  {
    printf("  %s: Listen failed for server\n", pFep->TaskName);
    close(ServSock);
    return FALSE;
  }

  pFep->TCPSock = ServSock;
  return TRUE;
}

//~----------------------------------------------------------------------------

static int AcceptClient(pFEP pFep) {

  int i, j;
  socklen_t length;
  static int Last = 0;

//  Find a Client structure that is not Accepted and for which all
//  past commands have been processed.

  i = Last;

  for (j=0; j<sizeof(pFep->Client)/sizeof(pFep->Client[0]); j++) {
    i++;
    if (i >= sizeof(pFep->Client) / sizeof(pFep->Client[0])) i = 0;
    if (!pFep->Client[i].Accepted && !pFep->Client[i].FramesIn.Next) {
      memset(&pFep->Client[i], 0 , sizeof(pFep->Client[i]));
      length = sizeof(pFep->Client[i].ClntAddr);
      pFep->Client[i].ClntSock = 
        accept(pFep->TCPSock, (struct sockaddr *) &pFep->Client[i].ClntAddr, &length);
      if (pFep->Client[i].ClntSock >= 0) {
        frmListHeadConstruct(&pFep->Client[i].FramesIn, pFep->TaskName);
        pFep->Client[i].FramesIn.Debug = pFep->Debug;
        frmListHeadConstruct(&pFep->Client[i].FramesOut, pFep->TaskName);
        pFep->Client[i].FramesOut.Debug = pFep->Debug;
        pFep->Client[i].WriteReady = FALSE;
        pFep->Client[i].FrameSize  = PETER_TCP_PACKET_LENGTH;
        pFep->Client[i].FRMOpened  = FALSE;
        pFep->Client[i].Accepted   = TRUE;
        if (pFep->Debug > 3) printf("  %s: Client[%d] Accepting %s\n", pFep->TaskName, i,
                                     inet_ntoa(pFep->Client[i].ClntAddr.sin_addr));
        Last = i;
        rcbDo(&pFep->ClientConnect, (void *) i);
        return i;
      }
      else {
        if (pFep->Debug > 0) printf("  %s: Error accepting client %d\n", pFep->TaskName, i);
      }
    }
  }

  if (pFep->Debug > 0) printf("  %s: Max clients already active\n", pFep->TaskName);

  return (-1);
}

//~----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////
static int TerminateClient(pFEP pFep, int Client)
{
  if (pFep->Debug > 3)
    printf("  %s: Client[%d] Closing\n", pFep->TaskName, Client);

  rcbDo(&pFep->ClientDisconnect, (void *) Client);

  close(pFep->Client[Client].ClntSock);
  pFep->Client[Client].Accepted = FALSE;
  frmListHeadDestruct(&pFep->Client[Client].FramesOut);
  //??  frmListHeadDestruct(&pFep->Client[i].Framesin);  //??? When should we destuct?

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Static: NETThread
static int NETThread(pFEP pFep)
//-Synopsis:    A thread to wait on NET traffic
//-Returns:     N/A
//-Description: A thread to wait on NET traffic
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
fd_set RecvSet;                   // Sets of socket descriptors for select()
fd_set XmitSet;
fd_set ExcpSet;
pfrmListEnt pFrame;

int i, j;
struct timeval selTimeout;        // Timeout for select()
int maxDescriptor;                // Maximum socket descriptor value
int wr;

  signal(SIGPIPE, SIG_IGN);

  if ( ! CreateServerSocket(pFep))
  {
    printf("  %s: TCP listen failed, nothing to do\n", pFep->TaskName);
    pFep->ThreadInstalled = FALSE;
    return FALSE;
  }

  if (pFep->Debug > 0)
    printf("  %s: Listening to TCP port %d\n", pFep->TaskName, pFep->Port);

  while (pFep->ThreadInstalled)
  {
    maxDescriptor = -1;
    FD_ZERO(&RecvSet);
    FD_ZERO(&XmitSet);
    FD_ZERO(&ExcpSet);

    wr = 0;                     // Count the available client slots

    for (i=0; i<((sizeof pFep->Client) / (sizeof pFep->Client[0])); i++)
    {
      if (( ! pFep->Client[i].Accepted) &&  ( ! pFep->Client[i].FramesIn.Next))
        wr++;
    }

//  On allow accepts if we have a slot

    if (wr > 0)
      FD_SET(pFep->TCPSock, &RecvSet);

    FD_SET(pFep->TCPSock, &ExcpSet);
    if (pFep->TCPSock > maxDescriptor) maxDescriptor = pFep->TCPSock;

    wr = 0;                     // Count the write-readys

    for (i=0; i<((sizeof pFep->Client) / (sizeof pFep->Client[0])); i++)
    {
      if (pFep->Client[i].Accepted)
      {
        FD_SET(pFep->Client[i].ClntSock, &RecvSet);
        FD_SET(pFep->Client[i].ClntSock, &ExcpSet);
        if (( ! pFep->Client[i].WriteReady) || (pFep->Client[i].FramesOut.Next))
        {
          FD_SET(pFep->Client[i].ClntSock, &XmitSet);
          wr++;
        }
        if (pFep->Client[i].ClntSock > maxDescriptor) maxDescriptor = pFep->Client[i].ClntSock;
      }
    }

    selTimeout.tv_sec = 0;          // timeout (secs.)
    selTimeout.tv_usec = 10000;     // microseconds 

    if (select(maxDescriptor + 1, &RecvSet, wr?&XmitSet:NULL, &ExcpSet, &selTimeout) == 0)
    {
      ;
    }
    else
    {
      if (FD_ISSET(pFep->TCPSock, &RecvSet))
        AcceptClient(pFep);

      for (i=0; i<((sizeof pFep->Client) / (sizeof pFep->Client[0])); i++)
      {
        if (pFep->Client[i].Accepted)
        {
          if (FD_ISSET(pFep->Client[i].ClntSock, &RecvSet))
          {
            pFrame = frmListEntConstruct(&pFep->Client[i].FramesIn, 
                                         pFep->Client[i].FrameSize);
            if (!pFrame)
            {
              printf("  %s: Out of memory for command frame\n", pFep->TaskName);
              break;
            }

//??  Not so proud of this

            for (wr=0, j=0; (wr != pFep->Client[i].FrameSize) && (j < 100); j++)
            {
              wr += recv(pFep->Client[i].ClntSock, pFrame->Buffer+wr,
                         pFep->Client[i].FrameSize-wr, 0);
              if ((j > 10) && (wr != pFep->Client[i].FrameSize))
                aalSleep(0, 100);
            }

            if (wr != pFep->Client[i].FrameSize)
            {
              frmListEntDestruct(&pFep->Client[i].FramesIn, pFrame);
              TerminateClient(pFep, i);
            }
            else // Queue the input
            {
              if (pFep->Debug > 1)
                printf("  %s: Client[%d] Rx %d bytes\n", pFep->TaskName, i, wr);

              frmListAdd(&pFep->Client[i].FramesIn, pFrame);
              rcbDo(&pFep->ClientRecv, (void *) i);
            }
          }

          if (FD_ISSET(pFep->Client[i].ClntSock, &XmitSet))
          {
            if ( ! pFep->Client[i].WriteReady)
            {
              pFep->Client[i].WriteReady = TRUE;
              //????????????????????????? Should use RCB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            }
          }

          if (FD_ISSET(pFep->Client[i].ClntSock, &ExcpSet))
          {
            if (pFep->Debug > 0)
              printf("  %s: Exception, closed client %d\n", pFep->TaskName, i);
            TerminateClient(pFep, i);
          }
 
          if ((pFep->Client[i].WriteReady) && (pFep->Client[i].FramesOut.Next))
          {
            pFrame = frmListRemove(&pFep->Client[i].FramesOut);

            if (pFep->Debug > 1) 
              printf("%s: pFep->Client[%d] send %d bytes\n", pFep->TaskName, i,
                     pFrame->FrameSize);
            send(pFep->Client[i].ClntSock, pFrame->Buffer, pFrame->FrameSize, 
                 MSG_NOSIGNAL);
            frmListEntDestruct(&pFep->Client[i].FramesOut, pFrame);
          }
        }
      }
    }
  }

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Static: UnInstallThread
static int UnInstallThread(pFEP pFep)
//-Synopsis:    UnInstalls the ACOP6T ISR
//-Returns:     TRUE if successful.  FALSE on failure.
//-Description: UnInstalls the ACOP6T ISR.  
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
	if (pFep->ThreadInstalled)
  {
    pFep->ThreadInstalled = FALSE;
    close(pFep->TCPSock);  // Slap thread about the head and shoulders
		pthread_join(pFep->hThread , &pFep->ThreadResult);
    if (pFep->Debug > 2)
      printf("  %s: ISR Thread joined\n", pFep->TaskName);
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////
//-Static: InstallThread
static int InstallThread(pFEP pFep)
//-Synopsis:    Installs the NET thread
//-Returns:     TRUE if successful.  FALSE on failure.
//-Description: Installs the NET thread
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
	if (pFep->ThreadInstalled)
  {
    if ( ! UnInstallThread(pFep))
    {
      printf("%s: Failed to UnInstall prior thread\n", pFep->TaskName);
      return FALSE;
    }
  }

	pFep->ThreadInstalled = TRUE;

//  Create our thread

	if ( pthread_create(&pFep->hThread, NULL, (void*)NETThread, pFep))
  {
    printf("%s: Failed to create thread\n", pFep->TaskName);
    return FALSE;
	}

  if (pFep->Debug > 2)
    printf("  %s: Thread created\n", pFep->TaskName);

  return TRUE;
}

//~============================================================================

//  frmList.c   AMS Frame list handling

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Kemah office 

 
////////////////////////////////////////////////////////////////////////////
//-Extern: frmListHeadConstruct
bool frmListHeadConstruct(pfrmListHead pFLH, char *TaskName)
//-Synopsis:    Initialize the list head for a list of frames.
//-Returns:     TRUE if success, else FALSE
//-ARG_I:       pFLH       Memory area to build list head in.
//-ARG_I:       TaskName   Pointer to a static text string for error message
//-                        identification.
//-Description: Initialize the list head for a list of frames.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  memset((char *) pFLH, 0, sizeof *pFLH);

  pFLH->Next = NULL;
  pFLH->Block = NULL;
  pFLH->Deblock = NULL;
  pFLH->TaskName = TaskName;
  pFLH->Debug = 0;
  aalMutexInit(&pFLH->BufferMutex, NULL);

#ifdef  ASSERT_FRMLIST
  pFLH->Marker = frmListHeadMarker;
  ASSERT_frmListHeader(pFLH);
#endif

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListHeadDestruct
bool frmListHeadDestruct(pfrmListHead pFLH)
//-Synopsis:    Destruct the list head for a list of frames.
//-Returns:     TRUE if success, else FALSE
//-ARG_I:       pFLH       The list head to operate on
//-Description: Destruct the list head for a list of frames.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  ASSERT_frmListHeader(pFLH);

  frmListEmpty(pFLH);

  if (pFLH->Block)
    frmListEntDestruct(pFLH, pFLH->Block);

  if (pFLH->Deblock)
    frmListEntDestruct(pFLH, pFLH->Deblock);

  if (pFLH->PDEntConstructed != pFLH->PDEntDestructed)
    printf("%s: PDEntConstructed (%d) != PDEntDestructed (%d)\n", pFLH->TaskName,
           pFLH->PDEntConstructed, pFLH->PDEntDestructed);

#ifdef  ASSERT_FRMLIST
  pFLH->Marker = 0xBBBB;
#endif

  aalMutexDestroy(&pFLH->BufferMutex);

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListEntConstruct
pfrmListEnt frmListEntConstruct(pfrmListHead pFLH, int FrameSize)
//-Synopsis:    Initialize a list entry.
//-Returns:     Pointer to aalAlloc'd list entry, or NULL if out of memory.
//-ARG_I:       pFLH       The list head to operate on.
//-ARG_I:       FrameSize  Number of bytes for frame.
//-Description: Initialize a list entry.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
pfrmListEnt pFLE;

  ASSERT_frmListHeader(pFLH);

  if (FrameSize > sizeof(pFLE->Buffer))
    Panic("%s: FrameSize too large %d", "frmListEntConstruct", FrameSize);

  pFLE = (pfrmListEnt) aalMalloc(sizeof *pFLE);
  if ( ! pFLE)
    Panic("%s: Out of memory for frame list", pFLH->TaskName);
  else
  {
    pFLE->FrameSize = FrameSize;
    pFLE->Next = NULL;

#ifdef  ASSERT_FRMLIST
    pFLE->Marker = frmListEntMarker;
    ASSERT_frmListEnt(pFLE);
#endif

    pFLH->PDEntConstructed++;
  }

  return pFLE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListEntDestruct
bool frmListEntDestruct(pfrmListHead pFLH, pfrmListEnt pFLE)
//-Synopsis:    Destruct a list entry.
//-Returns:     TRUE if success, else FALSE
//-ARG_I:       pFLH       The list head to operate on.
//-ARG_I:       pFLE       The list entry to operate on
//-Description: Destruct a list entry.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  ASSERT_frmListHeader(pFLH);
  ASSERT_frmListEnt(pFLE);

#ifdef  ASSERT_FRMLIST
  pFLE->Marker = 0xAAAA;
#endif

  pFLH->PDEntDestructed++;

  aalFree((char *) pFLE);

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListAdd
bool frmListAdd(pfrmListHead pFLH, pfrmListEnt pFLE)
//-Synopsis:    Add an entry to a list
//-Returns:     TRUE if success, else FALSE
//-ARG_I:       pFLH       The list head to operate on.
//-ARG_I:       pFLE       The list entry to operate on
//-Description: Add an entry to a list
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
pfrmListEnt pEnt;

  ASSERT_frmListHeader(pFLH);
  ASSERT_frmListEnt(pFLE);

  pFLE->Next = 0;

  aalMutexLock(&pFLH->BufferMutex);

  if (pFLH->Next == NULL)
  {
    pFLH->Next = pFLE;
  }
  else
  {
    for (pEnt=pFLH->Next; pEnt->Next; ) 
      pEnt = pEnt->Next;
    pEnt->Next = pFLE;
  }

  aalMutexUnlock(&pFLH->BufferMutex);

  pFLH->PDFramesAdded++;
  pFLH->PDFramesInList++;

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListRemove
pfrmListEnt frmListRemove(pfrmListHead pFLH)
//-Synopsis:    Remove an entry from a list
//-Returns:     Pointer to the entry removed, or NULL if none available.
//-ARG_I:       pFLH       The list head to operate on.
//-Description: Remove an entry from a list
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
pfrmListEnt pEnt;

  ASSERT_frmListHeader(pFLH);

  aalMutexLock(&pFLH->BufferMutex);

  pEnt = pFLH->Next;
  if (pEnt)
    pFLH->Next = pEnt->Next;
  else
    pFLH->Next = NULL;

  aalMutexUnlock(&pFLH->BufferMutex);

  if (pEnt)
  {
    ASSERT_frmListEnt(pEnt);
    pFLH->PDFramesRemoved++;
    pFLH->PDFramesInList--;
  }

  return pEnt;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListEmpty
bool frmListEmpty(pfrmListHead pFLH)
//-Synopsis:    Remove all entries from a list
//-Returns:     TRUE
//-ARG_I:       pFLH       The list head to operate on.
//-Description: Remove all entries from a list
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  ASSERT_frmListHeader(pFLH);

  while(pFLH->Next)
    frmListEntDestruct(pFLH, frmListRemove(pFLH));

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListBlock
bool frmListBlock(pfrmListHead pFLH, pFRAME pFrm, pAMSBlock pRequest)
//-Synopsis:    Frame an AMSBlock to a list
//-Returns:     TRUE if successfull, else FALSE
//-ARG_I:       pFLH       The list head to operate on.
//-Description: Frame an AMSBlock to a list
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  ASSERT_frmListHeader(pFLH);

  if ( ! pFLH->Block)
    pFLH->Block = frmListEntConstruct(pFLH, pFrm->FrameSize);

  if ( ! pFLH->Block)
    return Panic("%s: out of memory for frames", pFLH->TaskName);

  if ((pFLH->Debug > 2) && (pRequest))
    abiPrint2(pFLH->TaskName, "TxFrm", pRequest, 24);

  while ( ! frmBlock(pFrm, &(pFLH->Block->Buffer[0]), pRequest))
  {
    if (pFLH->Debug > 1)
      printf("%s: frmBlock emitting frame\n", pFLH->TaskName);

    frmListAdd(pFLH, pFLH->Block);
    pFLH->Block = frmListEntConstruct(pFLH, pFrm->FrameSize);

    if ( ! pFLH->Block)
      return Panic("%s: out of memory for frames", pFLH->TaskName);
  }

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmListDeblock
bool frmListDeblock(pfrmListHead pFLH, pFRAME pFrm, pAMSBlock *pRequest)
//-Synopsis:    Deframe AMSBlocks from a list
//-Returns:     TRUE if successfull, else FALSE
//-ARG_I:       pFLH       The list head to operate on.
//-Description: Deframe AMSBlocks from a list
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  ASSERT_frmListHeader(pFLH);

  if ( ! pFLH->Deblock)
    pFLH->Deblock = frmListRemove(pFLH);

  while(pFLH->Deblock)
  {
    if (pFrm->FrameSize != pFLH->Deblock->FrameSize)
    {
      printf("%s: frmListDeblock - Warning frame size problems\n", pFLH->TaskName);
      frmListEntDestruct(pFLH, pFLH->Deblock);
      pFLH->Deblock = NULL;
      return FALSE;
    }

    while (frmDeblock(pFrm, &(pFLH->Deblock->Buffer[0]), pRequest))
    {
      if (pFLH->Debug > 2)
        abiPrint2(pFLH->TaskName, "RxFrm", *pRequest, 24);
      return TRUE;
    }

    frmListEntDestruct(pFLH, pFLH->Deblock);
    pFLH->Deblock = frmListRemove(pFLH);
  }

  return FALSE;
}

//~============================================================================

//  frmDeblock.c   AMSBlock deframing Routines

//  Revision History
//    Apr 2002 by Peter Dennett
//      - Initial version in Kemah office (AALFRM)
//    Sep 2003 by Peter Dennett
//      - Conversion for use in payload simulator
//      - Overhaul to support formats of the CDH ICD
//    Oct 2003 by Peter Dennett
//      - Clean up and test/debug for CheckWord, CRC, Randomize
//    Nov 2003 by Peter Dennett
//      - The frame routines no longer bytes swap while the local block
//        routines do.
//    Jun 2004 by Peter Dennett
//      - Changed to AMS CRC polynomial
//    Jul 2004 by Peter Dennett
//      - Conversion from MDCSoftware
//      - FO_BYTESWAP support
//    Jan 2005 by Alexei Lebedev
//      - NASA commands handling added

#ifdef LITTLE_ENDIAN
# include <byteswap.h>
#endif

////////////////////////////////////////////////////////////////////////////
//-Extern: frmDeblock
bool frmDeblock(pFRAME pFRM, int8 *Frame, pAMSBlock *Block)
//-Synopsis:  De-Block an AMS Frame
//-Returns: TRUE if a block is returned, else FALSE
//-ARG_I:       pFRM       Object for this instance
//-ARG_I:       Frame      The frame currently being de-blocked.  The contents
//-                        maybe modified by this process.
//-ARG_U:       Block      Pointers to returned AMSBlocks
//-Description: De-block an AMS Frame.
//-
//-             This routine must be called repeatly with the same frame until
//-             it returns FALSE indicating the frame is completely processed.
//-
//-             On a return of TRUE a pointer to a DADQMalloc AMSBlock is
//-             returned.  The caller is responsible to DAQDFree the AMSBlock.
//-
//-             The application should process this AMSBlock as desired and call
//-             again, with the same "Frame", to continue its processing.
//-
//-             On a return of FALSE the application should pass in a new
//-             "Frame" for processing.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int8 *cp;
int32 Sequence;
int32 First, w;
int32 SeqFlags;
int i;
int16 *w16;

  pFRM->DeBlocking = TRUE;

//  See if done with an old frame

  if (pFRM->Index >= pFRM->DataSize)
  {
#if FO_DEBUG
    if (pFRM->Options & FO_DEBUG)
      printf("frmDeblock: Index %d DataSize %d\n", pFRM->Index, pFRM->DataSize);
#endif
    pFRM->Index = 0;
    return FALSE;
  }

//  See if new frame

  if ( ! pFRM->Index)
  {

#if FO_DEBUG
    if (pFRM->Options & FO_DEBUG)
      printf("frmDeblock: Starting frame size: %d\n", pFRM->FrameSize);
#endif

    if (pFRM->Options & FO_BYTESWAP)
      cp = Frame + pFRM->NASAHdrSize + 1;
    else
      cp = Frame + pFRM->NASAHdrSize;

    w = (*cp >> 4);

//  See if we are psuedo randomized from frame status
//  If so we de-randomize in place-- we warned you in the
//  document header....

    if (((w & FS_RANDOMIZE) != 0) &&
        ((pFRM->Options & FO_BYTESWAP) != 0))
      Panic("%s: Bug! the combo of RANDOMIZE and BYTESWAP is broken", "frmDeblock");

    if (w & FS_RANDOMIZE)
    {
      pFRM->Options |= FO_RANDOMIZE;
      frmRandomize(Frame + pFRM->NASAHdrSize + 2,
                   pFRM->FrameSize - (pFRM->NASAHdrSize + 2));
    }
    else
    {
      pFRM->Options &= ~FO_RANDOMIZE;
    }

    if (pFRM->Options & FO_BYTESWAP)
      i = *(Frame + 10);
    else
      i = *(Frame + 11);

    if (i & (1<<5))   // See if NASA CheckWord present
    {
      pFRM->Options |= FO_CHECKWORD;
      Sequence = frmCheckWord(Frame, pFRM->FrameSize, ((pFRM->Options & FO_BYTESWAP) ? TRUE : FALSE), FALSE);
      if (pFRM->Options & FO_BYTESWAP)
        First = (*(Frame + pFRM->FrameSize - 1) << 8) + (*(Frame + pFRM->FrameSize - 2));
      else
        First = (*(Frame + pFRM->FrameSize - 1)) + (*(Frame + pFRM->FrameSize - 2) << 8);

      if (First != Sequence)
      {
//#if FO_DEBUG	// X.Cai - Changed
        //??        if (pFRM->Options & FO_DEBUG)
          printf("frmDeblock: CheckWord error. Recv 0x%04X CW: 0x%04X\n", Sequence, First);
//#endif	// X.Cai - Changed
        pFRM->ErrorsCheckWord++;
        pFRM->Index = 0;
        pFRM->Done = 0;
        return FALSE;
      }
    }
    else
    {
      pFRM->Options &= ~FO_CHECKWORD;
    }

//  See if this buffer has CRC.  If so check it and reject frames
//  that are incorrect.

    if (w & FS_CRC)
    {
#if FO_DEBUG
      if (pFRM->Options & FO_DEBUG)
        printf("frmDeblock: CRC on frame\n");
#endif
      pFRM->Options |= FO_CRC;
      if (pFRM->Options & FO_CHECKWORD)
      {
        if (CRC16_Check(Frame, pFRM->FrameSize - 2))
        {
          pFRM->ErrorsCRC++;
          pFRM->Index = 0;
          pFRM->Done = 0;
          printf("frmDeblock: CRC error\n");	// X.Cai - Added
          return FALSE;
        }
      }
      else
      {
        if (CRC16_Check(Frame, pFRM->FrameSize))
        {
#if FO_DEBUG
          if (pFRM->Options & FO_DEBUG)
            printf("frmDeblock: CRC error\n");
#endif
          pFRM->ErrorsCRC++;
          pFRM->Index = 0;
          pFRM->Done = 0;
          printf("frmDeblock: CRC error\n");	// X.Cai - Added
          return FALSE;
        }
      }
    }
    else
    {
      pFRM->Options &= ~FO_CRC;
    }

#ifdef LITTLE_ENDIAN
    if (pFRM->Options & FO_BYTESWAP)
    {
      i = (pFRM->FrameSize/2);
      for (w16=(int16 *)Frame; i>0; i--, w16++)
        *w16 = __bswap_16(*w16);
    }
#endif

    if (w & FS_CHD)
      pFRM->Options |= FO_CHD;
    else
      pFRM->Options &= ~FO_CHD;

    pFRM->AMSHdrSize = 2;
    if (pFRM->Options & FO_CHD)
      pFRM->AMSHdrSize += FRAME_CHD_BYTES;

    pFRM->DataSize = pFRM->FrameSize - (pFRM->NASAHdrSize + pFRM->AMSHdrSize);
    if (pFRM->Options & FO_CHECKWORD)
      pFRM->DataSize -= 2;
    if (pFRM->Options & FO_CRC)
      pFRM->DataSize -= 2;

//  When we start a new frame we do some validation.
//  First check that we like the sequence numbering.

// X.Cai - Changed for PLMDM sequence number
    if ( pFRM->Options & FO_PLMDM )         cp = Frame + 16 + 8;
    else if ( pFRM->Options & FO_PLMDMCMD ) cp = Frame + 16 + 4;
    else                                    cp = Frame + 2;

// X.Cai - end changes
    SeqFlags = (*cp) >> 6;
    Sequence = ((*cp++) & 0x3F) << 8;
    Sequence |= *cp;

//  We are forced to believe the first sequence number.

    if (pFRM->FrameCount == 0)
      pFRM->Sequence = Sequence;

//  All frames should be "UNSEGMENTED" per SSP52050 but
//  we go through the drill anyway...

    switch (SeqFlags)
    {
      default:
        pFRM->ErrorsData++;
        break;

       case 3:   // CCSDS_SEQ_UNSEGMENTED:
         // For now treat as sequenced....
         // break;
       case 0:   // CCSDS_SEQ_CONTINUE:
       case 2:   // CCSDS_SEQ_LAST:
        if (Sequence != pFRM->Sequence)
            pFRM->ErrorsSeqGap++;
        pFRM->Sequence = (Sequence+1) & 0x3FFF;
        break;

      case 1:    // CCSDS_SEQ_FIRST:
        pFRM->Sequence = (Sequence+1) & 0x3FFF;
        break;
    }

    cp = Frame + pFRM->NASAHdrSize;

    First =  *cp++ << 8;
    First |= *cp++;
    First &= 0x0FFF;

//  See if fill frame we can ignore....

    if (First == 0x0FFF)     // Fill frame
    {
      pFRM->FillCount++;
      pFRM->Index = 0;
      pFRM->Done = 0;
      return FALSE;
    }

    pFRM->FrameCount++;

//  Check that our first pointer does not point outside our frame

// X.Cai - Added

    if ( First != 0xFFE ) First <<= 1;

// X.Cai - End

    if ((First != 0xFFE) && ((First + pFRM->NASAHdrSize) > pFRM->FrameSize))
    {
      Panic("frmDeblock: Invalid first block pointer: 0x%0X", First);
      pFRM->ErrorsData++;
      pFRM->InSync = FALSE;
      pFRM->Index = 0;
      pFRM->Done = 0;
      pFRM->Doing = 0;
      return FALSE;
    }

//  If some block starts in this frame and we are working on a block
//  from the past frame make sure the pointers are consistant.

    if (pFRM->Doing)
    {
      if (! pFRM->Done)
        Panic("DeBlock: We think blocksize and blockheader are together in the frame");

      w = pFRM->Doing - pFRM->Done;
      if (First != 0x0FFE)   // No block starts
      {
        if (First != (((w + 1) >> 1) << 1))	// X.Cai - Changed for 16-bit word align
        {
          Panic("frmDeblock: Invalid 1st block ptr on continue: First: %d Left: %d",
                    First, w);
          pFRM->InSync = FALSE;
          pFRM->ErrorsBlockSync++;
          pFRM->Done = 0;
          pFRM->Doing = 0;
          pFRM->Index = 0;   // See if we can recover within this block
        }
      }
    }

//  If we are not in sync look to see if we can recover in this frame.

    if ( ! pFRM->InSync )
    {
      pFRM->Done = 0;
      pFRM->Doing = 0;

      if (First == 0x0FFE)   // No block starts
      {
        pFRM->Index = 0;
        return FALSE;
      }

      pFRM->Index = First;
      if (pFRM->Index >= pFRM->DataSize)
      {
        Panic("frmDeblock: Invalid first block pointer: 0x%0X", First);
        HexDump(Frame, pFRM->FrameSize, TRUE);
        pFRM->Index = 0;
        pFRM->ErrorsBlockSync++;
        return FALSE;
      }

      pFRM->InSync = TRUE;
    }
  }

//  See if we need to start a new block.  In this case our index points
//  to the block length

  if ( ! pFRM->Doing)
  {
    cp = Frame + pFRM->NASAHdrSize + pFRM->AMSHdrSize + pFRM->Index;

    w = 0;
    if (*cp & 0x80)
    {
      w = (*cp++) & ~0x80;
      w = (w << 8) | (*cp++);
      pFRM->Index += 2;
    }
    w = (w << 8) | (*cp++);
    w = (w << 8) | (*cp++);
    pFRM->Index += 2;

    if (w == END_OF_FRAME)
    {
      pFRM->Index = 0;
      return FALSE;
    }

    w -= 2;  // Reduce by nominal header size

#undef FRM_DEBUG
#ifdef FRM_DEBUG  // For now limit the blocks to "reasonable" sizes
    if (w > 4096)
    {
      Panic("frmDeblock: At %d doing %d done %d Block size of 0x%lX size problem",
                pFRM->Index, pFRM->Doing, pFRM->Done, w);
      HexDump(Frame, pFRM->FrameSize, TRUE);
      pFRM->ErrorsData++;
      pFRM->InSync = FALSE;
      pFRM->Index = 0;
      pFRM->Done = 0;
      pFRM->Doing = 0;
      return FALSE;
    }
#endif

    pFRM->Doing = w;
    pFRM->Done  = 0;

//  Allocate an AMSBlock to de-block into.  If we running out
//  of space declare an error and re-sync to the next block

    pFRM->Block = abiConstruct(0, 0, w, 0, 0);
    if ( ! pFRM->Block)
    {
      Panic("frmDeblock: Out of memory: Block size of %lx", w);
      pFRM->ErrorsData++;
      pFRM->InSync = FALSE;
      pFRM->Index = 0;
      pFRM->Done = 0;
      pFRM->Doing = 0;
      return FALSE;
    }

//  Get the block header information

    w  = (*cp++) << 8;
    w |= (*cp++);
    pFRM->Index += 2;

    pFRM->Block->BlockType    = (w >> 14) & 0x3;
    pFRM->Block->NodeAddress  = (w >>  5) & 0x1FF;
    pFRM->Block->DataType     = (w)       & 0x1F;
    if (pFRM->Block->DataType == 0x1F)
    {
      w  = (*cp++) << 8;
      w |= (*cp++);
      pFRM->Index += 2;
      pFRM->Block->DataType = w | 0x1F0000;

//  Fix other assumptions about the block size.

      pFRM->Block->DataCount -= 2;
      pFRM->Doing -= 2;
    }

    if (pFRM->Index >= pFRM->DataSize)
    {
#if 0
      Panic("frmDeblock: Block header at end of frame");
      HexDump(Frame, pFRM->FrameSize, TRUE);
      pFRM->ErrorsData++;
#endif
      pFRM->InSync = FALSE;
      pFRM->Index = 0;
      pFRM->Done = 0;
      pFRM->Doing = 0;
      abiDestruct(pFRM->Block);
      pFRM->Block = NULL;
      *Block = NULL;
      return FALSE;
    }
  }

//  Figure out how much more we need and the how much this
//  frame has.

  w = pFRM->Doing - pFRM->Done;
  if (w > (pFRM->DataSize - pFRM->Index))
    w = pFRM->DataSize - pFRM->Index;

  cp = Frame + pFRM->NASAHdrSize + pFRM->AMSHdrSize + pFRM->Index;
  memcpy(abiDataPtr8(pFRM->Block)+(pFRM->Done), cp, w);
  pFRM->Done += w;
  pFRM->Index += w;

//  If we are done with a block give it to the caller

  *Block = pFRM->Block;

  if (pFRM->Done >= pFRM->Doing)
  {
    pFRM->Done = 0;
    pFRM->Doing = 0;

// X.Cai - Added for align to word
    if ( pFRM->Index & 1 ) pFRM->Index++;

    return TRUE;
  }

//  See if done with an old frame, but not the block

  if (pFRM->Index >= pFRM->DataSize)
  {
    pFRM->Index = 0;
    return FALSE;
  }

  Panic("DeBlock: Spanning block did not complete frame");
  return FALSE;
}

//~============================================================================

//  hexdump.c   Dump utility

//  Revision History
//    Oct 2003 by Peter Dennett
//      - Initial version in Kemah office 

////////////////////////////////////////////////////////////////////////////
//-Extern: HexDump
void HexDump(void *Buffer, int32 Bytes, bool ByteSwap)
//-Synopsis:    Dump in hex to stdout
//-Returns:     N/A
//-ARG_I:       Buffer     Buffer to dump
//-ARG_I:       Bytes      Number of bytes to dump
//-ARG_I:       ByteSwap   TRUE if bytes are swapped (little endian)
//-Description: Dump in hex to stdout
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int i;
int16 *wp = (int16 *) Buffer;
int8 *cp = (int8 *) Buffer;
#define BPL (16*2)   // 2 bytes/word

  for (i=0; i<Bytes; i+=2)
  {
    if ((i % BPL) == 0) 
      printf("%5d: ", i);

    if (ByteSwap)
    {
      printf("%02X",  *cp++); 
      printf("%02X ", *cp++);
    }
    else
      printf("%04X ", *wp++); 

    if ((i % BPL) == (BPL-2)) 
      printf("\n");
  }

  if ((i % BPL) != 0) 
      printf("\n");

  return;
}

//~============================================================================

//  panic.c   Common diagnostic routine

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Extraction from MDCSoftware

////////////////////////////////////////////////////////////////////////////
//-Extern: Panic
bool Panic(char *Format, ...)
//-Synopsis:    Log or display an error message a restart the system
//-Returns:     FALSE (if it returns at all)
//-ARG_I:       Format         Printf style format string
//-Description: Log or display an error message a restart the system.
//-             <p>
//-             This is for debugging only. Currently the message is
//-             just formatted and printf'd.
//-             <p> A value of FALSE is returned.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:       This routine should terminate or force WDT to expire.
//-Bugs:
//-Revisions:
//-End:
{
va_list arg_marker;
char msg[128];
extern FILE *stdout;

  if ( ! Format)
    return FALSE;

  va_start(arg_marker, Format);
  vsnprintf(msg, sizeof msg - 2, Format, arg_marker);
  printf("%s\n", msg);

  fflush(stdout);
  
  return FALSE;
}

//~============================================================================

//  frmBlock.c   AMS Block Framing Routines

//  Revision History
//    Apr 2002 by Peter Dennett
//      - Initial version in Kemah office (AALFRM)
//    Sep 2003 by Peter Dennett
//      - Conversion for use in payload simulator
//      - Overhaul to support formats of the CDH ICD
//    Oct 2003 by Peter Dennett
//      - Clean up and test/debug for CheckWord, CRC, Randomize
//    Nov 2003 by Peter Dennett
//      - The frame routines no longer bytes swap while the local block
//        routines do.
//    Jun 2004 by Peter Dennett
//      - Changed to AMS CRC polynomial
//    Jul 2004 by Peter Dennett
//      - Conversion from MDCSoftware
//      - Added ByteSwap support for 1553 which does hardware swap
//    Jan 2005 by Alexei Lebedev
//      - NASA commands handling added

#ifdef LITTLE_ENDIAN
# include <byteswap.h>
#endif

int16 frmFixedCHD[3];    // The fixed part of CHD
int16 frmTDMCHD[256];    // The time multiplexed part

static aalTIMEVAL frmTIME;      // Time stamp for CCSDS headers

////////////////////////////////////////////////////////////////////////////
//-Static: frmCCSDS
static bool frmCCSDS(pFRAME pFRM, int8 *Frame)
//-Synopsis:    Build a CCSDS header into the frame
//-Returns:     TRUE
//-ARG_I:       pFRM       Object for this instance
//-ARG_I:       Frame      Place to build the frame into 
//-Description: Build a CCSDS header
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int32 w;
int8 *cp;
int32 Time;
int32 Fine;

//  The ISS uses a unique epoch.  This is the number of seconds 
//  later that this epoch begins from the DAQD "LINUX" epoch

#define ISSEPOCH 318664800

  timeGet(&frmTIME);

  Time = frmTIME.tv_sec - ISSEPOCH;
  Fine = frmTIME.tv_usec / 6400;

#ifdef FRM_DEBUG
  memset(Frame, 0x33, pFRM->FrameSize);
#endif

  cp = Frame;

//  Build top bits of APID plus TYPE=1 and SECHDR=1 into the first 
//  byte.   Next complete the first 16 bit word with the rest of the APID
//  WORD 1

  *cp++ = (int8)(((pFRM->APID >> 8) & 0x07) | 0x18);
  *cp++ = (int8) pFRM->APID;

//  Put the sequence number info in the next word
//  WORD 2

  w = 0x3;

  *cp++ = (int8)((w << 6) | ((pFRM->Sequence >>8 ) & 0x3F));
  *cp++ = (int8) pFRM->Sequence;
  
//  The packet length takes the next word
//  WORD 3

  w = pFRM->FrameSize - 7;
  *cp++ = (int8)(w >> 8);
  *cp++ = (int8) w;

//  Now start the secondary header with the time since midnight between
//  Jan 5 and 6 1980.  
//  WORD 4
//  WORD 5

  *cp++ = (int8)(Time >> 24);
  *cp++ = (int8)(Time >> 16);
  *cp++ = (int8)(Time >>  8);
  *cp++ = (int8)(Time);

//  Use fine from clock
//  TimeId 01 (data generation)
//  Request check word if applicable
//  Data is not from ZOE (not from comm recorder)
//  Packet type is 0110b = Payload Private/Science
//  WORD 6

  *cp++ = (int8) Fine;     // Fine time
  *cp++ = (int8) 0x46 | ((pFRM->Options & FO_CHECKWORD)?(1<<5):0);

//  The element and packet IDs 
//  WORD 7
//  WORD 8

#define PID1 0x1111
#define PID2 0x2222

  *cp++ = (int8) (PID1 >> 8);
  *cp++ = (int8) (PID1);

  *cp++ = (int8) (PID2 >> 8);
  *cp++ = (int8) (PID2);

//  Handle PLMDM Health and Status (subset) header.

#define AMS02_SUBSET_ID 0x134

  if ( pFRM->Options & FO_PLMDM )
  {
    w = AMS02_SUBSET_ID; // AMS-02 Program assigned SubSetID
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);

    w = 0x0;             // ServiceRequestID
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);

    w = 0x0;             // ServiceRequestData
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);

    w = 0x0;             // CautionWarning
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);

// X.Cai - Add sequence number here

    *cp++ = (int8)((pFRM->Sequence >>8 ) & 0x3F);
    *cp++ = (int8) pFRM->Sequence;
  }

//  Handle FO_PLMDMCMD which inserts a couple of 16-bit words

  if (pFRM->Options & FO_PLMDMCMD)
  {
    w = 0;		// 0x6666;          // Reserved
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);

    w = 0x07F;           // LegalStationMode
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);

// X.Cai - Add sequence number here

    *cp++ = (int8)((pFRM->Sequence >>8 ) & 0x3F);
    *cp++ = (int8) pFRM->Sequence;
  }

// X.Cai - Move to the place after PLMDM words  
  pFRM->Sequence++;
  
//  Insert the frame status bits and set the first block
//  pointer to "fill"

  *cp++ = 0x0F | ((((pFRM->Options & FO_CRC)      ? FS_CRC:0)       |
                   ((pFRM->Options & FO_RANDOMIZE)? FS_RANDOMIZE:0) |
                   ((pFRM->Options & FO_CHD)      ? FS_CHD:0)       |
                   ((pFRM->Options & FO_EXTCMD)   ? FS_EXTCMD:0)) << 4);
  *cp++ = 0xFF;

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: frmBlock
bool frmBlock(pFRAME pFRM, int8 *Frame, pAMSBlock Block)
//-Synopsis:  Process an AMS block
//-Returns:     TRUE if block is complete, else FALSE and frame is emitted
//-ARG_I:       pFRM       Object for this instance
//-ARG_I:       Frame      Place to build the frame into 
//-ARG_I:       Block      The AMSBlock to pack into frame(s)
//-Description: Process an AMS block.
//-
//-             This routine must be called repeatly with the same block and
//-             frame until the call returns TRUE indicating the block is 
//-             completely processed.
//-
//-             On a return of FALSE the "Frame" is full with a complete 
//-             CCSDS frame.  The application should process this frame as 
//-             desired and call again to complete the "Block" processing. 
//-             The "Frame" parameter can indicate a new buffer in this case.
//-
//-             If the Block parameter is NULL the CCSDS frame is
//-             flushed.  The return value indicates is a frame was
//-             emitted.
//-
//-             FrameBlock and FrameDeBlock handle byte swapping on
//-             little endian systems (INTEL).  All AMSBlocks are
//-             assumed to be constructed of 16-bit words and are
//-             byte swapped.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:       Till shown why I shouldn't I am forcing the first data
//-             word to be in the same frame has the block header.
//-Bugs:
//-Revisions:
//-End:
{
int32 w;
int8 *cp;
int hb, i;
int16 *w16;

  if (pFRM->DeBlocking)
  {
    Panic("frmBlock: Can not frame and block at same time");
    return TRUE;
  }

//  If flush requested or our next block is too big to fit...
//  We need to know the length of bytes for header, including
//  the length field

  if ( ! Block)
  {
    hb = 0;
  }
  else
  {
    hb = (Block->DataType>31) ? 4 : 2;
    if ((Block->DataCount + hb) > 0x7FFF)
      hb += 2;
    hb += 2;
#if FO_TQMHEADER
    if (pFRM->Options & FO_TQMHEADER)
      hb += 2;
#endif
  }

  if (( ! Block) || ((pFRM->Index + hb  >=  pFRM->DataSize)))
  {

//  If requesting a flush and nothing yet in block and we dont
//  need fill frames just return "no frame"

    if (( ! Block) && ( ! pFRM->Index) && (! (pFRM->Options & FO_FILLFRAMES)))
      return TRUE;

    cp = Frame + pFRM->NASAHdrSize;

//  If some data but no block started in frame we need to update the first 
//  pointer.  If no data we need a CCSDS header for the fill frame

    if (pFRM->Index)
    {
      if ( ((*(cp) & 0x0F) == 0x0F) && (*(cp+1) == 0xFF))
        *(cp + 1) = 0xFE;
    }
    else
    {
      frmCCSDS(pFRM, Frame);
    }

//  Insert the end of frame marker if done with block and
//  there is room

    if ((! pFRM->Done) && (pFRM->DataSize > pFRM->Index))
    {
      cp += pFRM->AMSHdrSize + pFRM->Index;
      w = END_OF_FRAME;
      *cp++ = (int8) (w>>8);
      *cp++ = (int8) (w);
      pFRM->Index += 2;

#ifdef FRM_DEBUG
//  Debug Pad end of frame with 0x55 
      if (pFRM->DataSize > pFRM->Index)
      {
        w = pFRM->DataSize - pFRM->Index;
        if (w > 4096)
        {
          printf("frmBlock: prevent memory spray DataSize %ld Index %ld\n",
                 pFRM->DataSize, pFRM->Index);
          fflush(stdout);
          *cp = *((char *)NULL);
        }
        if (w)
          memset(cp, 0x55, w);
      }
#endif
    }

    if (pFRM->Options & FO_CHD)
    {
      cp = Frame + pFRM->NASAHdrSize + 2;

      *cp++ = (int8)(pFRM->CHDFrame);
      *cp++ = (int8)(pFRM->CHDCmdCount);

      w = frmFixedCHD[0];
      *cp++ = (int8)(w >> 8);
      *cp++ = (int8) w;

      w = frmFixedCHD[1];
      *cp++ = (int8)(w >> 8);
      *cp++ = (int8) w;

      w = frmFixedCHD[2];
      *cp++ = (int8)(w >> 8);
      *cp++ = (int8) w;

      w = frmTDMCHD[(int8)pFRM->CHDFrame];
      *cp++ = (int8)(w >> 8);
      *cp++ = (int8) w;

      pFRM->CHDFrame++;   //  Increment the CHD frame number
    }

#ifdef LITTLE_ENDIAN
    if (pFRM->Options & FO_BYTESWAP)
    {
      i = (pFRM->FrameSize/2);
      for (w16=(int16 *)Frame; i>0; i--, w16++)
        *w16 = __bswap_16(*w16);
    }
#endif

    if (pFRM->Options & FO_CRC)
    {
      if (pFRM->Options & FO_CHECKWORD)
        CRC16_Attach(Frame, pFRM->FrameSize - 2);
      else
        CRC16_Attach(Frame, pFRM->FrameSize);
    }

    if (pFRM->Options & FO_CHECKWORD)
      frmCheckWord(Frame, pFRM->FrameSize, 
                   (pFRM->Options & FO_BYTESWAP)!=0, TRUE);

    if (pFRM->Options & FO_RANDOMIZE)
      frmRandomize(Frame + pFRM->NASAHdrSize + 2, 
                     pFRM->FrameSize - (pFRM->NASAHdrSize + 2));

//  Mark the "next" frame as empty and pass the frame back

#if FO_DEBUG
    if (pFRM->Options & FO_DEBUG)
      printf("frmBlock: Returning frame size: %d\n", pFRM->FrameSize);
#endif

    pFRM->Index = 0;
    return FALSE;
  }

#if 0  // No longer force even number of bytes
  if (Block->DataCount & 1)
  {
    Panic("frmBlock: blocks must be an even number of bytes");
    return TRUE;
  }
#endif

//  If we are just starting the frame, build a CCSDS header

  if ( ! pFRM->Index)
    frmCCSDS(pFRM, Frame);

//  If this is the start of a new block we need block header 
//  processing

  if (! pFRM->Done)
  {
// See if the first block in the frame, if so set the first
// block pointer

    cp = Frame + pFRM->NASAHdrSize;

//  If no block started in frame we need to update the first 
//  pointer

    if ( ((*(cp) & 0x0F) == 0x0F) && (*(cp+1) == 0xFF))
    {
      w = (pFRM->Index + 1) >> 1;       // X.Cai - Chnaged for word pointer,    w = pFRM->Index;
      *cp   = (*cp & 0xF0) | ((int8)(w >> 8) & 0x3F);
      cp++;
      *cp++ = (int8) w;
    }

    cp = Frame + pFRM->NASAHdrSize + pFRM->AMSHdrSize + pFRM->Index;

//  See if we need "format 2" block length

    w = Block->DataCount + 2;
    if (Block->DataType > 31)
      w += 2;

#if FO_TQMHEADER
    if (pFRM->Options & FO_TQMHEADER)
      w += 2;
#endif

    if (w > 0x7FFF)
    {
      *cp++ = (int8) ((w >> 24) | 0x80);
      *cp++ = (int8)  (w >> 16);
      pFRM->Index += 2;
    }
    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);
    pFRM->Index += 2;

//  Put the block type, node address, and some DataType

    if ((Block->DataType > 31) && ((Block->DataType & 0x1F0000) != 0x1F0000))
      Panic("frmBlock: Invalid DataType 0x%X", Block->DataType);

    w = ((Block->BlockType & 3) << 14) | ((Block->NodeAddress & 0x1FF) << 5);
    if (Block->DataType < 32)
      w |= Block->DataType;
    else
      w |= 0x1F;

    *cp++ = (int8) (w >> 8);
    *cp++ = (int8) (w);
    pFRM->Index += 2;

//  If the DataType is larger then 31 we have an extended type
//  and need another 16 bits. 

    if (Block->DataType > 31)
    {
      w = Block->DataType;
      *cp++ = (int8) (w >> 8);
      *cp++ = (int8) (w);
      pFRM->Index += 2;
    }

#if FO_TQMHEADER
    if (pFRM->Options & FO_TQMHEADER)
    {
      *cp++ = Block->Source;
      *cp++ = Block->Error;
      pFRM->Index += 2;
    }
#endif

    pFRM->Done = 2;    // A dirty lie - see below
  }

//  Point to where to move the data to

  cp = Frame + pFRM->NASAHdrSize + pFRM->AMSHdrSize + pFRM->Index;

//  See how much room is left.  Note: pFRM->Done includes
//  2 bytes for header, our dirty lie so we can tell we have
//  done the block header

  w = pFRM->DataSize - pFRM->Index;
  if (w < (Block->DataCount - (pFRM->Done-2)))
  {
    memcpy(cp, abiDataPtr8(Block)+(pFRM->Done-2), w);
    pFRM->Done += w;
    pFRM->Index +=w;

//  Recursive call to finalize and flush
    frmBlock(pFRM, Frame, NULL);

    return FALSE;
  }

  w = Block->DataCount - (pFRM->Done-2);
  memcpy(cp, abiDataPtr8(Block)+(pFRM->Done-2), w);
  pFRM->Done = 0;
  pFRM->Index += w;

  if ( pFRM->Index & 1 ) {		// X.Cai - Added for align to word
    cp = Frame + pFRM->NASAHdrSize + pFRM->AMSHdrSize + pFRM->Index;
    *cp = 0;
    pFRM->Index++;
  }
  if ( pFRM->Index < pFRM->DataSize ) {
    cp = Frame + pFRM->NASAHdrSize + pFRM->AMSHdrSize + pFRM->Index;
    *cp++ = 0;
    *cp++ = 0;
  }

  return TRUE;
}

//~============================================================================

/* -*-C-*-
 * crc.c - CRC Utilities
 *
 *-----------------------------------------------------------------------
 *
 * Project          : Linux
 * Moduletyp        : C-Code
 * Author           : Xudong CAI
 * Changed          : 23 Apr. 2003 Changed from Peter's program
 *
 *-----------------------------------------------------------------------
 */


/************************************************************************
  CRC16 tables
 ************************************************************************/

static UINT8 crc16_lut_hi[256];
static UINT8 crc16_lut_lo[256];
static INT table_filled = FALSE;

/************************************************************************
  Function:
    CRC16_TableInit - Initialize CRC16 loop-up table

  INPUTS:
    none

  RETURNS:
    none
 ************************************************************************/
void CRC16_TableInit(void) {
    UINT16 crc;
    int i, j;

    /* Check if table already filled */
    if ( table_filled ) return;

    /* Fill CRC16 loop-up table */
    for ( i = 0; i < 256; i++ ) {
	crc = i << 8;
	for ( j = 0; j < 8; j++ )
	    crc = (crc & 0x8000) ? ((crc << 1) ^ CRC16_POLYNOMIAL) : (crc << 1);
	crc16_lut_hi[i] = (unsigned char) (crc >> 8);
	crc16_lut_lo[i] = (unsigned char) (crc & 0xff);
    }

    /* Set flag */
    table_filled = TRUE;
    return;
}

/************************************************************************
  Function:
    CRC16_Calc - Calculate CRC16 value

  INPUTS:
    msg ---- input data for CRC16
    len ---- number of bytes for CRC16

  RETURNS:
    CRC16 value
 ************************************************************************/
UINT16 CRC16_Calc(UINT8 *msg, INT len) {
    register UINT8 crc_hi = 0xFF;	/* high CRC byte initialized */
    register UINT8 crc_lo = 0xFF;	/* low CRC byte initialized */
    register UINT8 index;		/* will index into CRC lookup table */

    /* Check if table is filled */
    if ( !table_filled ) CRC16_TableInit();

    while (len--) {			/* pass through message buffer */
	index = crc_hi ^ *msg++;         /* calculate the CRC */
	crc_hi = crc_lo ^ crc16_lut_hi[index];
	crc_lo = crc16_lut_lo[index];
    }

    return ((crc_hi << 8) | crc_lo);
}

/************************************************************************
  Function:
    CRC16_Check - Check CRC16 word at the end of the buffer

  INPUTS:
    msg ---- input data including CRC16
    len ---- number of bytes including CRC16

  RETURNS:
    TRUE  - CRC incorrect
    FALSE - CRC correct
 ************************************************************************/
INT CRC16_Check(UINT8 *msg, INT len) {
    UINT16 chk;

    chk = CRC16_Calc(msg, len-2);

    if (chk == (msg[len-2]*256 + msg[len-1])) return FALSE;

    return 0x80000000 | chk;
}

/************************************************************************
  Function:
    CRC16_Attach - Calculate CRC16 and attach it to the end of buffer

  INPUTS:
    msg ---- input data including CRC16
    len ---- number of bytes including CRC16

  RETURNS:
    CRC16 value
 ************************************************************************/
UINT16 CRC16_Attach(UINT8 *msg, INT len) {
    UINT16 chk;

    chk = CRC16_Calc(msg, len-2);

    msg[len-2] = (UINT8) (chk >> 8);
    msg[len-1] = (UINT8) chk;

    return chk;
}

/************************************************************************
  Function:
    CRC16_Continue - Continue a calculation of CRC16

  INPUTS:
    msg ---- input data for continue
    len ---- number of bytes of data
    crc ---- last CRc16 value to be continued

  RETURNS:
    new CRC16 value
 ************************************************************************/
UINT16 CRC16_Continue(UINT8 *msg, INT len, UINT16 crc) {
    register UINT8 crc_hi = crc >> 8;		/* Initial high CRC byte */
    register UINT8 crc_lo = crc & 0xFF;		/* Initial low CRC byte */
    register UINT8 index;			/* will index into CRC lookup table */

    while (len--) {				/* pass through message buffer */
        index = crc_hi ^ *msg++;            	/* calculate the CRC */
        crc_hi = crc_lo ^ crc16_lut_hi[index];
        crc_lo = crc16_lut_lo[index];
    }

    return ((crc_hi << 8) | crc_lo);
}

//~============================================================================

//  frmRandomize.c   AMS Frame randomizer

//  Revision History
//    Apr 2002 by Peter Dennett
//      - Initial version in Kemah office (AALFRM)
//    Sep 2003 by Peter Dennett
//      - Conversion for use in payload simulator

//  From Alexei's AMS-1 deframing program

static int16 PsuedoRandom[255] = 
{
    0xFF48, 0x0EC0, 0x9A0D, 0x70BC, 0x8E2C, 0x93AD, 0xA7B7, 0x46CE,
    0x5A97, 0x7DCC, 0x32A2, 0xBF3E, 0x0A10, 0xF188, 0x94CD, 0xEAB1,
    0xFE90, 0x1D81, 0x341A, 0xE179, 0x1C59, 0x275B, 0x4F6E, 0x8D9C,
    0xB52E, 0xFB98, 0x6545, 0x7E7C, 0x1421, 0xE311, 0x299B, 0xD563,
    0xFD20, 0x3B02, 0x6835, 0xC2F2, 0x38B2, 0x4EB6, 0x9EDD, 0x1B39,
    0x6A5D, 0xF730, 0xCA8A, 0xFCF8, 0x2843, 0xC622, 0x5337, 0xAAC7,
    0xFA40, 0x7604, 0xD06B, 0x85E4, 0x7164, 0x9D6D, 0x3DBA, 0x3672,
    0xD4BB, 0xEE61, 0x9515, 0xF9F0, 0x5087, 0x8C44, 0xA66F, 0x558F,
    0xF480, 0xEC09, 0xA0D7, 0x0BC8, 0xE2C9, 0x3ADA, 0x7B74, 0x6CE5,
    0xA977, 0xDCC3, 0x2A2B, 0xF3E0, 0xA10F, 0x1889, 0x4CDE, 0xAB1F,
    0xE901, 0xD813, 0x41AE, 0x1791, 0xC592, 0x75B4, 0xF6E8, 0xD9CB,
    0x52EF, 0xB986, 0x5457, 0xE7C1, 0x421E, 0x3112, 0x99BD, 0x563F,
    0xD203, 0xB026, 0x835C, 0x2F23, 0x8B24, 0xEB69, 0xEDD1, 0xB396,
    0xA5DF, 0x730C, 0xA8AF, 0xCF82, 0x843C, 0x6225, 0x337A, 0xAC7F,
    0xA407, 0x604D, 0x06B8, 0x5E47, 0x1649, 0xD6D3, 0xDBA3, 0x672D,
    0x4BBE, 0xE619, 0x515F, 0x9F05, 0x0878, 0xC44A, 0x66F5, 0x58FF,
    0x480E, 0xC09A, 0x0D70, 0xBC8E, 0x2C93, 0xADA7, 0xB746, 0xCE5A,
    0x977D, 0xCC32, 0xA2BF, 0x3E0A, 0x10F1, 0x8894, 0xCDEA, 0xB1FE,
    0x901D, 0x8134, 0x1AE1, 0x791C, 0x5927, 0x5B4F, 0x6E8D, 0x9CB5,
    0x2EFB, 0x9865, 0x457E, 0x7C14, 0x21E3, 0x1129, 0x9BD5, 0x63FD,
    0x203B, 0x0268, 0x35C2, 0xF238, 0xB24E, 0xB69E, 0xDD1B, 0x396A,
    0x5DF7, 0x30CA, 0x8AFC, 0xF828, 0x43C6, 0x2253, 0x37AA, 0xC7FA,
    0x4076, 0x04D0, 0x6B85, 0xE471, 0x649D, 0x6D3D, 0xBA36, 0x72D4,
    0xBBEE, 0x6195, 0x15F9, 0xF050, 0x878C, 0x44A6, 0x6F55, 0x8FF4,
    0x80EC, 0x09A0, 0xD70B, 0xC8E2, 0xC93A, 0xDA7B, 0x746C, 0xE5A9,
    0x77DC, 0xC32A, 0x2BF3, 0xE0A1, 0x0F18, 0x894C, 0xDEAB, 0x1FE9,
    0x01D8, 0x1341, 0xAE17, 0x91C5, 0x9275, 0xB4F6, 0xE8D9, 0xCB52,
    0xEFB9, 0x8654, 0x57E7, 0xC142, 0x1E31, 0x1299, 0xBD56, 0x3FD2,
    0x03B0, 0x2683, 0x5C2F, 0x238B, 0x24EB, 0x69ED, 0xD1B3, 0x96A5,
    0xDF73, 0x0CA8, 0xAFCF, 0x8284, 0x3C62, 0x2533, 0x7AAC, 0x7FA4,
    0x0760, 0x4D06, 0xB85E, 0x4716, 0x49D6, 0xD3DB, 0xA367, 0x2D4B,
    0xBEE6, 0x1951, 0x5F9F, 0x0508, 0x78C4, 0x4A66, 0xF558
};

////////////////////////////////////////////////////////////////////////////
//-Extern: frmRandomize
void frmRandomize(int8 *Frame, int32 Bytes)
//-Synopsis:  Perform psuedo randomization funtion on data
//-Returns: N/A
//-ARG_I:       Framer     Place to perform function.
//-ARG_I:       Bytes      Number of bytes to for the frame
//-Description: Perform psuedo randomization function on a data block.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:       Orginal code from Alexei's AMS-1 de-framing software
//-Bugs:
//-Revisions:
//-End:
{
int i;
int16 *p, *endp;

#ifndef AMS_FLIGHT_SOFTWARE
  if (((int32) Frame) & 1)  //??
    Panic("frmRandomize: Data alignment problem in frame");
#endif

  i = 0;
  endp = (unsigned short *)Frame + (Bytes/2);

  for (p=(unsigned short *) Frame; p<endp; p++) 
  {
    // *p = ((*p) >> 8) | ((*p) << 8); //? Byte swap I assume
    *p ^= PsuedoRandom[i++];
    i %= 255;  
  }

  return;
}

//~============================================================================

//  acop6tisr.c   ISR support routines for ACOP6T

//  Revision History
//    Dec 2003 by Peter Dennett
//      - Initial version at PADSOFT

extern int ACOP6T_FH;

static int32 ISRStatus;
static int32 ISRInstalled;
static ACOP6TISR *pISR;
static pthread_t  hThread;
static void       *ThreadResult;

////////////////////////////////////////////////////////////////////////////
//-Static: ACOP6TISRDispatcher
static int ACOP6TISRDispatcher(void)
//-Synopsis:    The ACOP6T ISR Thread
//-Returns:     N/A
//-Description: Waits in the ACOP6T driver for an interrupt.  On interrupt
//-             calls the registered interrupt routine.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int stat;
int ISRCnt;
static int lastISRCnt;

	while (1)
  {
//  Block on interrupts

    ISRStatus = 4; // HZ/4 timeout

    stat = ioctl(ACOP6T_FH, ACOP6T_IOC_BLOCK, &ISRStatus);
    //?? printf("ACOP6TISR: Thread waking stat: 0x%X ISRStatus 0x%X\n", stat, ISRStatus);

    if (stat == (-1))
    {
      if (errno == ETIME)
      {
        //??        printf("blocking timeout\n");
        if (((ISRStatus & 0xFFFF) != 0) && pISR)
        {
          printf("ACOP6TISR: Timeout with ISR 0x%X\n", ISRStatus);
          pISR(ISRStatus & 0xFFFF);
        }
        continue;
      }

      printf("ACOP6TISRDispatcher: IOCTL error.  Thread exiting. %d errno %d ACOP6T_FH %d\n",
              stat, errno, ACOP6T_FH);
      ISRInstalled = FALSE;
      pthread_exit((void *)-errno);
    }

//  Uninstalling, clean up thread

		if( ! ISRInstalled)
    {
      printf("ACOP6TISRDispatcher: ISR UnInstalling.  Thread exiting\n");
			pthread_exit((void *)0);
    }

    if (pISR)
      pISR(ISRStatus & 0xFFFF);

    ISRCnt = ISRStatus >> 16;
#if 0
    if (ISRCnt != (lastISRCnt+1))
    {
      printf("ACOP6T: Missed interrupt lastISRCnt %d ", lastISRCnt);
      printf("ISRCnt: %d\n", ISRCnt);
    }
#endif
    lastISRCnt = ISRCnt;
	}
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TInstallISR
int ACOP6TInstallISR(ACOP6TISR *pUserISR)
//-Synopsis:    Installs the ACOP6T ISR
//-Returns:     TRUE if successful.  FALSE on failure.
//-ARG_I:       pUserISR     The callers ISR routine to call on interrupt
//-Description: Installs the ACOP6T ISR.  This creates a thread to wait (sleep)
//-             in the driver for an interrupt.  On interrupt the thread
//-             is awoken and calls any registered user routine.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
#define SET_ISR_THREAD_PRIORITY 1
#if SET_ISR_THREAD_PRIORITY
#define POLICY SCHED_FIFO
  //#define POLICY SCHED_RR
  //#define POLICY SCHED_OTHER
int priority;
int policy;
int stat;
#endif

	if (ISRInstalled)
  {
    if ( ! ACOP6TUnInstallISR())
    {
      printf("ACOP6TInstallISR: Failed to UnInstall prior ISR\n");
      return FALSE;
    }
  }

  pISR = pUserISR;

//  Request the device driver install interrupts

  if (ioctl(ACOP6T_FH, ACOP6T_IOC_INSTALL, NULL) == (-1))
  {
    printf("ACOP6TInstallISR: ioctl failed %d\n", errno);
    return FALSE;
  }

	ISRInstalled = TRUE;

//  Create our thread

	if ( pthread_create(&hThread, NULL, (void*)ACOP6TISRDispatcher, NULL))
  {
    printf("ACOP6TLIB: Failed to create thread\n");
    return FALSE;
	}
  //  printf("  ACOP6TLIB: ISR Thread created\n");

#if SET_ISR_THREAD_PRIORITY
  //  printf("getpriority(PRIO_PROCESS, getpid()) = %d\n", getpriority(PRIO_PROCESS, getpid()));
  stat = pthread_getschedparam(hThread, &policy, (void *)&priority);
  //  printf("ACOP6TInstallISR: getschedparam stat %d Policy %d Param: %d\n", 
  //          stat, policy, priority);
  priority = (sched_get_priority_max(POLICY) - sched_get_priority_min(POLICY)) / 2;
  policy   = POLICY;
  stat = pthread_setschedparam(hThread, policy, (void *)&priority);
  //  printf("ACOP6TInstallISR: setschedparam stat %d Policy %d Param: %d\n", 
  //          stat, policy, priority);
#endif

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: ACOP6TUnInstallISR
int ACOP6TUnInstallISR(void)
//-Synopsis:    UnInstalls the ACOP6T ISR
//-Returns:     TRUE if successful.  FALSE on failure.
//-Description: UnInstalls the ACOP6T ISR.  
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  //  printf("ACOP6TISR: UnInstall %ld\n", ISRInstalled);

	if (ISRInstalled)
  {
    ISRInstalled = FALSE;
    pISR = NULL;
    ioctl(ACOP6T_FH, ACOP6T_IOC_REMOVE, NULL);
		pthread_join(hThread , &ThreadResult);
    //    printf("  ACOP6TLIB: ISR Thread joined\n");
	}

	return TRUE;
}

//~============================================================================

// file chd.c
//
// CHD data display
//
// developed by Alexei Lebedev
//

//~----------------------------------------------------------------------------

void display_CHD(int16 Status, int8 *Frame) {

  int i;
  struct {
    int   mod;
    int   ind;
    int8  msk;
    char *fmt;
    char *nam;
    int   jnd;
    int8  chk;
    char *err;
  } CHD[100] = {
    { 1, 1, 0xFF, " %3d", "HB"},
    { 1, 2, 0xFF, " %3d", "CC"},

    { 1, 3, 0xC0, " %3d", "ID"},
    { 1, 3, 0x20, " %3d", "SF"},
    { 1, 3, 0x10, " %3d", "VE"},
    { 1, 3, 0x08, " %3d", "AL"},
    { 1, 3, 0x07, " %3d", "PS"},

    { 1, 4, 0x80, " %3d", "HA"},
    { 1, 4, 0x40, " %3d", "HV"},
    { 2, 4, 0x30, " %3d", "HO", 4, 0x40, "   ?"},
    { 1, 4, 0x08, " %3d", "MA"},
    { 1, 4, 0x04, " %3d", "MV"},
    { 2, 4, 0x03, " %3d", "MO", 4, 0x04, "   ?"},

    { 1, 5, 0x80, " %3d", "LA"},
    { 1, 5, 0x40, " %3d", "LV"},
    { 2, 5, 0x30, " %3d", "LO", 5, 0x40, "   ?"},
    { 1, 5, 0x08, " %3d", "DA"},
    { 1, 5, 0x04, " %3d", "DV"},
    { 2, 5, 0x03, " %3d", "DO", 5, 0x04, "   ?"},

    { 1, 6, 0x80, " %3d", "TV"},
    { 1, 6, 0x40, " %3d", "TI"},
    { 1, 6, 0x3F, " %3d", "ID"},
  
    { 1, 7, 0xFF, "  %02X", "B0"},
    { 1, 8, 0xFF, "  %02X", "B1"},
    { 1, 9, 0xFF, "  %02X", "B2"},
    { 1,10, 0xFF, "  %02X", "B3"},
  
    { 0}};
  
  printf("\rCHD:   %04X", Status);

  for (i=0; i<100; i++) {

    int ind, jnd;

    if (!CHD[i].mod) break;
    ind = (CHD[i].ind - 1) ^ 1;

    switch (CHD[i].mod) {
    
    case 1:
      printf(CHD[i].fmt, unpack16((int16)Frame[ind], (int16)CHD[i].msk));
      break;

    case 2:
      jnd = (CHD[i].jnd - 1) ^ 1;
      if ((Frame[jnd] & CHD[i].chk) == 0) {
        printf(CHD[i].err);
      }
      else {
        printf(CHD[i].fmt, unpack16((int16)Frame[ind], (int16)CHD[i].msk));
      }
      break;
    
    }
  }

  //for ( i=0; i < 10; i += 2 ) printf(" %02X %02X", Frame[i+1], Frame[i]);

  printf("\nCHD: Status");

  for (i=0; i<100; i++) {
    if (!CHD[i].mod) break;
    printf(" %3s", CHD[i].nam);
  }
  fflush(stdout);
}

//~============================================================================

//  rcb.c   Regisgtered call back routines

// This set of routines provides services to maintain and use registered
// call back lists.

//  Revision History
//    May 1994 by Peter Dennett
//      - Initial version developed for the EPS project
//    Jul 2004 by Peter Dennett
//      - Munged for AMS-02 in Taiwan

////////////////////////////////////////////////////////////////////////////
//-Extern: rcbRegister
bool rcbRegister(prcbCallback *list, rcbRoutine routine, void *reg_data)
//-Synopsis:    Register a call back on a list of call backs.
//-Returns:     TRUE if no errors, else FALSE
//-ARG_U:       list          Pointer to the list head of call backs.
//-ARG_I:       routine       Pointer to the routine which will be called.
//-ARG_I:       reg_data      Pointer to a data area to be passed to the
//-                           the callback routine.
//-Description: Register a call back on a list of call backs.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
prcbCallback callback;

  callback = (prcbCallback) aalMalloc(sizeof(*callback));
  if ( ! callback)
      return FALSE;

  callback->callback_func = routine;
  callback->reg_data = reg_data;
  callback->cbnest = 0;

  callback->next = *list;
  *list = callback;

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: rcbDo
bool rcbDo(prcbCallback *list, void *call_data)
//-Synopsis:    Perform a list of registered callbacks.
//-ARG_U:       list          Pointer to the list head of call backs.
//-ARG_I:       call_data     Pointer to a data area to be passed to the
//-                           the callback routine.
//-Description: Perform a list of registered callbacks.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
static int cbnest = 0;
prcbCallback wlist;
int cbkey;

  if (list == NULL)
      return TRUE;

//  First establish our bit mask value that indicates that this callback
//  is to be done.

  cbkey = 1 << cbnest++;
  if (cbkey <= 0)
  {
      cbnest--;
      Panic("rcbDo: Too deep %d", cbnest);
      return FALSE;
  }

//  Now set this bit in all current callbacks

  for (wlist=(*list); wlist!=NULL; wlist=wlist->next)
      wlist->cbnest |= cbkey;

//  Now start at front of list and call each routine not yet called
//  (bit mask value is still one), then clear is value indicating it has
//  been called.  Start at front of list again each time a routine
//  is called in case the callback created or deleted a call back
//  resulting in a change in the list we are working.  If the routine
//  has been called press on down the list.

  for (wlist=*(list); wlist!=NULL;)
  {
    if ((wlist->cbnest & cbkey) != 0)
    {
      wlist->cbnest &= ~cbkey;
      (*(wlist->callback_func))(wlist->reg_data, call_data);
      wlist = (*list);
    }
    else
    {
      wlist = wlist->next;
    }
  }

  cbnest--;

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: rcbDelete
bool rcbDelete(prcbCallback *list, prcbCallback callback)
//-Synopsis:    Delete a registered call back from a list.
//-ARG_U:       list          Pointer to the list head of call backs.
//-ARG_I:       callback      Pointer to the structure defining the callback.
//-Description: Delete a registered call back from a list.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
prcbCallback pcb;

  if (callback == *list)
  {
    *list = callback->next;
  }
  else
  {
    for (pcb= *list; pcb!=NULL && pcb->next!=callback;)
      pcb=pcb->next;

    if (pcb == NULL)
    {
      Panic("rcbDelete: Not found");
      return FALSE;
    }

    pcb->next = callback->next;
  }

  aalFree( (char *) callback);

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: rcbDeregister
bool rcbDeregister(prcbCallback *list, rcbRoutine routine, void *reg_data)
//-Synopsis:    De-register a call back on a list of call backs.
//-ARG_U:       list          Pointer to the list head of call backs.
//-ARG_I:       routine       Pointer to the routine which will be called.
//-ARG_I:       reg_data      Pointer to a data area to be passed to the
//-                           the callback routine.
//-Description: De-register a call back on a list of call backs.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
prcbCallback callback, tcb;

  for (callback = *list; callback!=NULL; )
  {
    if (callback->callback_func==routine&&callback->reg_data==reg_data)
    {
      tcb = callback->next;
      rcbDelete(list, callback);
      callback = tcb;
    }
    else
    {
      callback = callback->next;
    }
  }

  return TRUE;
}

//~============================================================================

//  frmCheckword.c   Compute and optionally apply the NASA CheckWord

//  Revision History
//    Sep 2003 by Peter Dennett
//      - Conversion from PIT software
//    Jul 2004 by Peter Dennett
//      - Added ByteSwap support for 1553 which does hardware swap
//    Jul 2004 by Alexei Lebedev
//      - fixed ChekWord calculation

#ifdef LITTLE_ENDIAN
# include <byteswap.h>
#endif // LITTLE_ENDIAN

////////////////////////////////////////////////////////////////////////////
//-Extern: frmCheckWord
int16 frmCheckWord(int8 *Frame, int FrameSize, bool ByteSwap, bool Apply)
//-Synopsis:    Compute the NASA CCSDS check word for a frame
//-Returns:     The computed check word
//-ARG_I:       Frame     Pointer to the area to perform the calculation on
//-ARG_I:       FrameSize Number of bytes for frame.  The check sum is
//-                       computed on two less bytes then this.
//-ARG_I:       ByteSwap  Store (apply) computed value in reversed byte order
//-ARG_I:       Apply     If TRUE apply the checksum (store in the last two
//-                       bytes of the frame), otherwise just return it.
//-Description: Compute the NASA CCSDS check word for a frame.
//-
//-             Optionlly the computed value can be placed into the frame.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int16 cs,*w;
int len, i;

  cs = 0;
  len = (FrameSize - 2) / 2;
  w = (int16 *)Frame;
  for (i=0; i<len; i++) {
    if (ByteSwap) cs += *w++;
    else cs += __bswap_16(*w++);
  }

#define Peter 1

#ifdef Peter
  if (Apply)
  {
#ifdef LITTLE_ENDIAN
    if (ByteSwap)
      cs =  __bswap_16(cs);
#endif

    Frame = Frame + FrameSize - 2;
    *Frame++ = (int8) (cs>>8);
    *Frame   = (int8) (cs);
 
#ifdef LITTLE_ENDIAN
    if (ByteSwap)
      cs =  __bswap_16(cs);
#endif
  }
#else
  if (Apply) {
    Frame = Frame + FrameSize - 2;
    *Frame++ = (int8) (cs & 0x00FF);
    *Frame   = (int8) (cs >> 8);
  }
#endif

  return cs;
}

//~============================================================================

//  abiConstruct.c   AMS Block construction and destruction routines

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Lake Howard Hotel, Taiwan
//        based on MDCSoftware coding

static char TaskName[] = "abi";

#define abiDebug 1

////////////////////////////////////////////////////////////////////////////
//-Extern: abiConstruct
pAMSBlock abiConstruct(int32 NodeAddress, int32 DataType, int32 DataCount, 
                       int32 BlockType, int32 AttachSize)
//-Synopsis:    Allocate memory for and construct and AMSBlock
//-Returns:     Pointer to the created AMSBlock.  Can be NULL in the
//-             event memory is exhausted.
//-ARG_I:       NodeAddress     NodeAddress for the AMSBlock
//-ARG_I:       DataType        AMSBlock DataType
//-ARG_I:       DataCount       Number of bytes to allocate for the contents
//-ARG_I:       BlockType       BT_REQUEST, BT_REPLY, BT_WRITEREAD, BT_WRITE
//-ARG_I:       AttachSize      Number of 16-bit words for attachment
//-Description: Allocate memory for and construct and AMSBlock.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
pAMSBlock Block;
int32 len;

  len = sizeof(struct _AMSBlock) + DataCount + 
        (AttachSize * sizeof (Block->Attachment->Data[0]));
  if (len & 1) len++;

  Block = (pAMSBlock) aalMalloc(len);
  if ( ! Block)
  {
#ifdef abiDebug
    if (abiDebug > 0)
      printf("%s: Out of memory: Block size of %d\n", TaskName, len);
#endif

    return NULL;
  }

  memset((char *)Block, 0, sizeof(*Block));

  Block->NodeAddress = NodeAddress;
  Block->BufferSize = DataCount;
  Block->DataType = DataType;
  Block->DataCount = DataCount;
  Block->BlockType = BlockType & 3;
  Block->Contents = (void *)&Block->DataStart[0];

  if (AttachSize)
  {
    len = DataCount;
    if (len & 1) 
      len++;

    Block->Attachment = (pabiAttachment) (abiDataPtr8(Block)+len);
    memset(Block->Attachment, 0, sizeof (*(Block->Attachment)));
    Block->Attachment->Length = AttachSize;
  }

  return Block;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiDestruct
void abiDestruct(pAMSBlock Block)
//-Synopsis:    Release all resources for an AMSBlock
//-Returns:     N/A
//-ARG_I:       Block           Pointer to AMSBlock to release
//-Description: Release all resource for an AMSBlock
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  if ( !Block ) return;
  if (Block->Status & abiStatusFreeData)
    aalFree((char *)abiDataPtr8(Block));
  if (Block->Status & abiStatusFreeAttachment)
    aalFree((char *)Block->Attachment);

  aalFree((char *)Block);

  return;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiClone
pAMSBlock abiClone(pAMSBlock Block, int32 DataCount)
//-Synopsis:    Construct a clone of an AMSBlock
//-Returns:     Pointer to the created AMSBlock.  Can be NULL in the
//-             event memory is exhausted.
//-ARG_I:       Block           AMSBlock to clone
//-ARG_I:       DataCount       Number of bytes to allocate for the contents
//-Description: Allocate memory for and clone an AMSBlock.  This propagates
//-             attachments.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
pAMSBlock Clone;
int32 len;

  len = sizeof(struct _AMSBlock) + DataCount + (Block->Attachment ?
        (Block->Attachment->Length * sizeof (Block->Attachment->Data[0])) : 0);
  if (len & 1) len++;

  Clone = (pAMSBlock) aalMalloc(len);
  if ( ! Clone)
  {
#ifdef abiDebug
    if (abiDebug > 0)
      printf("%s: Out of memory: Block size of %d\n", TaskName, len);
#endif

    return NULL;
  }

  *Clone = *Block;

  Clone->BufferSize = DataCount;
  Clone->DataCount = DataCount;
  Clone->Contents = (void *)&Clone->DataStart[0];

  if (Block->Attachment)
  {
    len = DataCount;
    if (len & 1) 
      len++;

    Clone->Attachment = (pabiAttachment) (abiDataPtr8(Clone) + len);
    memcpy(Clone->Attachment, Block->Attachment, Block->Attachment->Length);
  }

  return Clone;
}

//~============================================================================

//  abiPrint.c   Display an AMSBlock

//  Revision History
//    Jun 2004 by Peter Dennett
//      - Initial version at CERN
//    Jul 2004 by Peter Dennett
//      - Direct conversion from MDCSoftware

#define SHORTN 8

////////////////////////////////////////////////////////////////////////////
//-Extern: abiShow
bool abiShow(pAMSBlock pBlock, int NumberBytesToDump)
//-Synopsis:    Core of print an AMSBlock to stdout
//-Returns:     TRUE, there are no errors possible
//-ARG_I:       pBlock          Pointer to the AMSBlock to display
//-ARG_I:       NumberBytesToDump Number of bytes to dump
//-Description: Core of print an AMSBlock to stdout
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int w, i;
unsigned char *cp;

  w = pBlock->DataCount;

  if (w > (NumberBytesToDump-SHORTN)) 
    w = (NumberBytesToDump-SHORTN);
  printf("[%s-%s N:%3.3X T:%6.6X L:%4.4d]  ", 
         pBlock->BlockType&BT_REPLY?"RP":"RQ",
         pBlock->BlockType&BT_WRITE?"W ":"WR",
         pBlock->NodeAddress, pBlock->DataType, pBlock->DataCount);
  cp = abiDataPtr8(pBlock);
  for (i=0; i<w; i+=2) 
  {
    printf("%02X%02X ", *cp, *(cp+1)); 
    cp += 2;
  }

  if (pBlock->DataCount > (NumberBytesToDump-SHORTN))
  {
    printf(".. ");
    cp = abiDataPtr8(pBlock);
    cp += pBlock->DataCount - 6;
    for (i=0; i<3; i++) 
    {
      printf("%02X%02X ", *cp, *(cp+1)); 
      cp+=2;
    }
  }

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiPrint
bool abiPrint(char *Tag, pAMSBlock pBlock, int NumberBytesToDump)
//-Synopsis:    Print an AMSBlock to stdout
//-Returns:     TRUE, there are no errors possible
//-ARG_I:       Tag             Text to print before the AMSBlock
//-ARG_I:       pBlock          Pointer to the AMSBlock to display
//-ARG_I:       NumberBytesToDump Number of bytes to dump
//-Description: Print an AMSBlock to stdout
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  printf("%s: ", Tag);
  abiShow(pBlock, NumberBytesToDump);
  printf("\n");

  return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiPrint2
bool abiPrint2(char *Tag1, char *Tag2, pAMSBlock pBlock, int NumberBytesToDump)
//-Synopsis:    Print an AMSBlock to stdout
//-Returns:     TRUE, there are no errors possible
//-ARG_I:       Tag1            Text to print before the AMSBlock
//-ARG_I:       Tag2            Text to print before the AMSBlock
//-ARG_I:       pBlock          Pointer to the AMSBlock to display
//-ARG_I:       NumberBytesToDump Number of bytes to dump
//-Description: Print an AMSBlock to stdout
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  printf("%s-%s: ", Tag1, Tag2);
  abiShow(pBlock, NumberBytesToDump);
  printf("\n");

  return TRUE;
}

//~============================================================================

//  aallib.c   Defines global values

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Lake Howard Hotel, Taiwan

aalPDStats aalPDData = {0, 0};

//~============================================================================

//  apid.c     Lookup APID names

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version at CSIST

APIDNameEnt APIDNames[] =
{
  { Name: "AMSHK",         APID: APID_AMSHK},
  { Name: "AMSSCI",        APID: APID_AMSSCI},
  { Name: "AMSCMD",        APID: APID_AMSCMD},
  { Name: "AMSHKH",        APID: APID_AMSHKH},
  { Name: "PBCKSCI",       APID: APID_PBCKSCI},
  { Name: "PBCKHKH",       APID: APID_PBCKHKH},
  { Name: "PTOPCMD",       APID: APID_PTOPCMD},
  { Name: "PTOPREPLY",     APID: APID_PTOPREPLY},
  { Name: "ACOPCMD",       APID: APID_ACOPCMD},
  { Name: "ACOPHK",        APID: APID_ACOPHK},
  { Name: "ACOPQC",        APID: APID_ACOPQC},

  { Name: "APLS_C",        APID: APID_APLS_C},
  { Name: "APLS_D",        APID: APID_APLS_D},
  { Name: "ACOP_C",        APID: APID_ACOP_C},
  { Name: "ACOP_D",        APID: APID_ACOP_D},
  { Name: "DDRS2_C",       APID: APID_DDRS2_C},
  { Name: "DDRS2_D",       APID: APID_DDRS2_D},
  { Name: "FILL",          APID: APID_FILL},

  // Dummy and alias
  { Name: "CAN",           APID: APID_CAN},
  { Name: "AMSW",          APID: APID_AMSW},
  { Name: "RS422",         APID: APID_RS422},
  { Name: "HRDL",          APID: APID_HRDL},
  { Name: "1553",          APID: APID_1553},
};

#define APIDDim  ((sizeof APIDNames) / sizeof APIDNames[0])

////////////////////////////////////////////////////////////////////////////
//-Extern: apidLookupValue
int32 apidLookupValue(char *APID)
//-Synopsis:    Look up a APIDs value from a symbolic name
//-Returns:     Returns the APID's value or zero on error
//-Description: Look up a APIDs value from a symbolic name
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int i;

 for (i=0; i<APIDDim; i++)
   if (strcasecmp(APIDNames[i].Name, APID) == 0)
     return APIDNames[i].APID;

  return 0;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: apidLookupName
char *apidLookupName(int32 APID)
//-Synopsis:    Look up a APIDs value from a symbolic name
//-Returns:     Returns the APID's value or zero on error
//-Description: Look up a APIDs value from a symbolic name
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
int i;
static char NotFound[10];

 for (i=0; i<APIDDim; i++)
   if (APIDNames[i].APID == APID)
     return APIDNames[i].Name;

  sprintf(NotFound, "0x%X", APID);
  return NotFound;
}

//~============================================================================

//  aaltime.c   General time handling

//  Revision History
//    Mar 2003 by Peter Dennett
//      - Initial version at San Jose Del Cabo - pool side.
//    Jul 2004 by Peter Dennett
//      - Split general time code and DAQD timers

////////////////////////////////////////////////////////////////////////////
//-Extern: timeCmp
bool timeCmp(paalTIMEVAL a, paalTIMEVAL b, char CMP)
//-Synopsis:    Perform a logical compare of two time values
//-Returns:     The logical result of the compare
//-ARG_I:       a              First time value
//-ARG_I:       b              Second time value
//-ARG_I:       CMP            The c boolean operation ('<', '>' '=', )
//-Description: Perform a logical compare of two time values.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:       No >= or <= yet!
//-Bugs:
//-Revisions:
//-End:
{
  if (CMP == '=')
    return   (a->tv_sec == b->tv_sec) ? (a->tv_usec == b->tv_usec) :
                                        (a->tv_sec == b->tv_sec);
  else if (CMP == '>')
    return   (a->tv_sec >  b->tv_sec) ? (a->tv_usec > b->tv_usec) :
                                        (a->tv_sec > b->tv_sec);
  else if (CMP == '<')
    return   (a->tv_sec <  b->tv_sec) ? (a->tv_usec < b->tv_usec) :
                                        (a->tv_sec < b->tv_sec);
  else
    return 0;
}

////////////////////////////////////////////////////////////////////////////
//-Extern: timeAdd
void timeAdd(paalTIMEVAL a, paalTIMEVAL b, paalTIMEVAL result)
//-Synopsis:    Perform an addition of two time values
//-Returns:     N/A
//-ARG_I:       a              First time value
//-ARG_I:       b              Second time value
//-ARG_I:       result         Pointer to place to store results
//-Description: Adds two time values.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  result->tv_sec  = a->tv_sec + b->tv_sec;
  result->tv_usec = a->tv_usec + b->tv_usec;
  while (result->tv_usec >= 1000000)
  {
    ++result->tv_sec;
    result->tv_usec -= 1000000;
  }
}

////////////////////////////////////////////////////////////////////////////
//-Extern: timeSub
void timeSub(paalTIMEVAL a, paalTIMEVAL b, paalTIMEVAL result)
//-Synopsis:    Perform a subtraction of two time values
//-Returns:     N/A
//-ARG_I:       a              First time value
//-ARG_I:       b              Second time value
//-ARG_I:       result         Pointer to place to store results
//-Description: Subtracts two time values. Results may not be satisfactory
//-             unless a >= b.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  result->tv_sec = a->tv_sec - b->tv_sec;
  result->tv_usec = a->tv_usec - b->tv_usec;
  while (result->tv_usec < 0)
  {
    if (result->tv_sec > 0)
       --result->tv_sec;

    result->tv_usec += 1000000;
  }
}

////////////////////////////////////////////////////////////////////////////
//-Extern: timeGet
void timeGet(paalTIMEVAL result)
//-Synopsis:    Get the current time
//-Returns:     N/A
//-ARG_I:       result         Pointer to place to store results
//-Description: Gets the current time from the system
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
#ifdef OS_LINUX
  gettimeofday((struct timeval *)result, NULL);
#endif

#ifdef OS_ECOS
#if 0
static bool Init = TRUE;
static cyg_handle_t hRtClock;
static cyg_resolution_t RtRes;
cyg_tick_count_t Ticks;
long long nanoseconds;

  if (Init)
  {
    Init = FALSE;
    hRtClock = cyg_real_time_clock();
    RtRes = cyg_clock_get_resolution(hRtClock);
  }

  Ticks = cyg_current_time();
  nanoseconds = ((long long) Ticks * RtRes.dividend) / RtRes.divisor;

  result->tv_sec = (long) (nanoseconds / 1000000);
  result->tv_usec = (long) (nanoseconds - (result->tv_sec * 1000000));

#else // 0
  // From somewhere on the net...
  //gettimeofday(struct timeval *tv, void *tz)
  //{
  //    cyg_tick_count_t cur_time;
  //    cur_time = cyg_current_time();
  //    tv->tv_sec = cur_time / 100;
  //    tv->tv_usec = (cur_time % 100) * 10000;
  //	return 0;
  //}
#ifdef OS_ECOS_KAPI
cyg_tick_count_t cur_time = cyg_current_time();

  if ((cur_time % 100) == 0)
    printf("%s: ticks: %ld\n", "timeGet", cur_time);

  result->tv_sec = cur_time / 100;
  result->tv_usec = (cur_time % 100) * 10000;
#else  //  ! OS_ECOS_KAPI

//  This code uses the JMDC RTC.  It's only millisecs...

 struct jsbc_time jtime;

   dev_jsbc_rtc_get_time(&jtime);
   result->tv_sec = jtime.sec;
   result->tv_usec = jtime.msec * 1000;

#endif //    OS_ECOS_KAPI
#endif

#endif // OS_ECOS

  return;
}

//~============================================================================
