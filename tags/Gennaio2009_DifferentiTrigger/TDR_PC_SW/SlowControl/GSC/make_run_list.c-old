// file make_run_list.c
//
// read block files, decode blocks, build run ID list
//
// A.Lebedev - Jan 2008...
//

#include "nodedef.h"
#include "gsclib.h"

int P;

typedef struct {
  int    num;
  int    len;
  int16  sta;
  int32  msk;   // <<<=== bad name
  int16 *dat;
  int16  CRC;
  struct {
    int    len;
    int16  sta;
    int16 *dat;
  } fra[24];
} _event;

_event Event, *pEvent = &Event;

static AMSBlock Block, *pBlock = &Block;
static int32 run_tag;
static int32 run_id, old_run_id = 0xFFFFFFFF;
static int32 event_id, old_event_id = 0xFFFFFFFF;
static int file_number;
static long file_pos, old_file_pos = -1;
static int old_file_number = -1;
static char run_time[80];
static int nblk = 0;

static bool calibration_run;

static int nbad = 0, ngood = 0;

//~----------------------------------------------------------------------------

void print_run_bgn(void) {

  printf("%08X ", run_id);
  printf("%s ", calibration_run ? "C" : "D");
  printf("%08X ", run_tag);
  printf("%s : ", run_time);
//if (calibration_run) printf(" : ");
//else                 printf("%d: ", event_id);
  printf("%d: ", event_id);
  printf("%04d/%03d", file_number/1000, file_number%1000);
  printf("/%-8ld ", file_pos);
}

//~----------------------------------------------------------------------------

void print_run_end(void) {

  printf("-->");
//if (calibration_run) printf("        : ");
//else                 printf("%8d: ", old_event_id);
  printf("%8d: ", old_event_id);
  printf("%8d: ", nblk);
  printf("%04d/%03d", old_file_number/1000, old_file_number%1000);
  printf("/%-9ld * ", old_file_pos);
  if (!calibration_run) {
    printf("%7d %4d ", ngood+nbad, nbad);
    if (ngood + nbad) printf("%6.4f ", (float)nbad/(float)(ngood+nbad));
  }
  printf("\n");
}

//~----------------------------------------------------------------------------

/*
int16 calculate_CRC16(int16 *dat, int16 len) {

  int i;
  int16 CRC = 0xFFFF;
  int16 g = 0x1021;

  for (i=0; i<len; i++) {
    int j;
    int16 d = dat[i];
    for (j=0; j<16; j++) {
      if ((CRC ^ d) & 0x8000) CRC = (CRC << 1) ^ g;
      else                    CRC = (CRC << 1);
      d <<= 1;
    }
  }
  return CRC;
}
*/

//~----------------------------------------------------------------------------

void print_JINJ_event(_event *event) {

  int16 *p;
  int l = 1;
  bool debug = TRUE;
  char msg1[80], msg2[80];
  
  p = event->dat;
  event->CRC = calculate_CRC16(p, event->len);

  event->num = *p++;
  event->sta = event->dat[event->len-1];

  if (debug) printf("event->len=%d=%04X\n", event->len, event->len);
  if (debug) printf("event->num=%d=%04X\n", event->num, event->num);
  if (debug) printf("event->CRC=%04X\n", event->CRC);
  
  event->msk = 0x000000;

  while (1) {
    int16 lnk;
    int32 m;

    msg1[0] = msg2[0] = '\0';
    
    if (p + 2 >= event->dat + event->len) break;
    lnk = *(p + *p) & 0x001F;
    if (debug) printf("sta = %04X, lnk = %2d, ", *(p + *p), lnk);

    if (lnk > 23) {
      sprintf(msg1, "Error: lnk > 23 ");
    }

    m = 1 << lnk;
    if (debug) printf("event->msk = %06X, m = %06X, ", event->msk, m);
    if (m & event->msk) {
      sprintf(msg2, "Error: repeated fragment");
    }

    event->msk         |=  m;
    event->fra[lnk].dat =  p;
    event->fra[lnk].len = *p;
    event->fra[lnk].sta = event->fra[lnk].dat[event->fra[lnk].len];

    l = l + 1 + event->fra[lnk].len;
    if (debug) printf("event->fra[%2d].len = %4d %5d %5d, ", lnk, event->fra[lnk].len, l, event->len-l);
    if (debug) printf("sta = %04X", event->fra[lnk].sta);
    if (debug) {
      char b[80];
      sprintf_binary(b, event->fra[lnk].sta, -16);
      printf(" = %s ", b);
    }
    if (debug) printf("%s ", msg1);
    if (debug) printf("%s\n", msg2);

    p = p + *p + 1;
  }
}

//~----------------------------------------------------------------------------

int16 decode_JINJ_event(_event *event) {
  
  int16 *p;
  bool debug = FALSE;
  
  p = event->dat;

  event->CRC = calculate_CRC16(p, event->len);
  if (event->CRC) {
    return 0x0100;
  }

  event->num = *p++;
  event->sta = event->dat[event->len-1];

  if (debug) printf("event->len=%d=%04X\n", event->len, event->len);
  if (debug) printf("event->num=%d=%04X\n", event->num, event->num);
  if (debug) printf("event->CRC=%04X\n", event->CRC);
  
  event->msk = 0x000000;

  while (1) {
    int16 lnk;
    int32 m;
    if (p + 2 >= event->dat + event->len) break;
    lnk = *(p + *p) & 0x001F;
    if (debug) printf("lnk = %2d, ", lnk);

    if (lnk > 23) {
      return 0x0200;
    }

    m = 1 << lnk;
    if (debug) printf("event->msk = %06X, m = %06X, ", event->msk, m);
    if (m & event->msk) {
      return 0x0300;
    }

    event->msk         |=  m;
    event->fra[lnk].dat =  p;
    event->fra[lnk].len = *p;
    event->fra[lnk].sta = event->fra[lnk].dat[event->fra[lnk].len];

    if (debug) printf("event->fra[%2d].len = %4d, ", lnk, event->fra[lnk].len);
    if (debug) printf("sta = %04X", event->fra[lnk].sta);
    if (debug) {
      char b[80];
      sprintf_binary(b, event->fra[lnk].sta, -16);
      printf(" = %s\n", b);
    }

    p = p + *p + 1;
  }

  return 0;
}

//~----------------------------------------------------------------------------

void process_AMS_block_file(FILE *file) {

  int32 len;
  int16 dat[1000000];
  int16 *p, *end;

  while (1) {
    file_pos = ftell(file);
    if (!read_AMS_block(file, dat, &len)) break;
    decode_AMS_block(dat, len, TRUE, pBlock);
    if (pBlock->NodeAddress < 0x18 && 
        (pBlock->DataType == 0x05 || pBlock->DataType == 0x06)) {
      bool calibration = pBlock->DataType == 0x06;
      end = dat + (len + 1) / 2;
      p   = pBlock->Data.p16;
      asctime_r(localtime((time_t*)&pBlock->DataTime), run_time);
      run_time[19] = '\0';
      while (1) {
        int16 *pp;
        len = *p++;
        decode_AMS_block(p, len, FALSE, pBlock);
        pp = pBlock->Data.p16;

        if (pBlock->DataType == 0x07 || pBlock->DataType == 0x05) {
//        print_AMS_data_block("", pBlock, 16);
          run_tag = *pp++;
          run_tag = run_tag << 16 | *pp++;
          run_id = *pp++;
          run_id = run_id << 16 | *pp++;
          event_id = *pp++;
          event_id = event_id << 16 | *pp++;
          if (run_id != old_run_id) {
            if (old_run_id != 0xFFFFFFFF) {
              print_run_end();
              calibration_run = calibration;
              nblk = 0;
              nbad = 0;
              ngood = 0;
            }
            print_run_bgn();
          }
          nblk = nblk + 1;
          old_run_id = run_id;
          old_event_id = event_id;
          old_file_pos = file_pos;
          old_file_number = file_number;
        }
        
        if (pBlock->DataType == 0x01) {
          int16 err;
{
//static int c = 0;
//if (c++ >= 10) exit(1);
//printf("\n");
//print_AMS_data_block("", pBlock, 16);
}
          pEvent->dat = pp;
          pEvent->len = (pBlock->DataCount + 1) / 2;
          err = decode_JINJ_event(pEvent);
{
//int i;
//static int c = 0;
//if (c < 2) {
//printf("GOOD EVENT\n");
//for (i=pEvent->len-16; i<pEvent->len; i++) printf("%04X ", pBlock->Data.p16[i]);
//printf("\n");
//print_JINJ_event(pEvent);
//c++;
//}
}
          if (err) {
//          fprintf(stderr, "err = 0x%04X\n", err);
            nbad++;
{
//int i;
//static int c = 0;
//if (c < 10) {
//printf("BAD EVENT\n");
//for (i=pEvent->len-16; i<pEvent->len; i++) printf("%04X ", pBlock->Data.p16[i]);
//printf("\n");
//print_JINJ_event(pEvent);
//c++;
//}
}
          }
          else {
//          process_JINJ_event(pEvent);
            ngood++;
          }
        }
        p = p + (len + 1) / 2;
        if (p >= end) break;
      }
    }
  }
}

//~============================================================================

int main( int argc, char *argv[]) {

  int k;
  int current_file;
  char *block_directory;
  int first_block_file;
  int last_block_file;
  FILE *block_file;
    
//~--

  setbuf(stdout, NULL);
  fprintf(stderr, 
          "Usage: %s <Block Directory> [<First Block File> [P]]\n", argv[0]);

  P = 0;
  if (argc < 2) {
    fprintf(stderr, "Too few parameters\n");
    exit(1);
  }
  
  k = 1;
  block_directory = argv[k++];
  remove_trailing_slash(block_directory);
  first_block_file = 0;
  P = 0;
  if (argc > k) first_block_file = atoi(argv[k++]);
  if (argc > k) P                = atoi(argv[k++]);

  if (first_block_file < 0) first_block_file = 0;

  fprintf(stderr, "First Block File = %07d\n", first_block_file);
  fprintf(stderr, "P                = %d\n",   P);
  
  current_file = first_block_file; 

//~--

  while (1) {
    static bool first = TRUE;
    last_block_file = the_last_file_in(block_directory);
    for (; current_file <= last_block_file; current_file++) {
      if (P > 1) fprintf(stderr, "Process file %07d:\n", current_file);
      first = TRUE;
      block_file = open_file_for_reading(block_directory, current_file);
      if (!block_file) continue;
      file_number = current_file;
      process_AMS_block_file(block_file);
      fclose(block_file);
    }
    if (first) fprintf(stderr, "Waiting... push Q to stop.\n");
    first = FALSE;
    if (kbhit()) {
      int ch = toupper(fgetc(stdin));
      switch (ch) {
        case 'Q':
          print_run_end();
          exit(0);
        break;
      }
    }
    sleep(1);
  }

//~--

  return 0;
}
  
//~============================================================================
