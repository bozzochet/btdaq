// file recorder.c
//
// AMS-02 blocks recording
//
// Everything stolen from Jinghui Zhang and reworked
//
// A.Lebedev, Aug-2007...
//

#include "recorder.h"
#include <string.h>
#include <errno.h>

static pfrmListEnt pFL;
static frmListHead TxFrameList;
static FRAME Frame;

static char *TaskName = "Recording";

//~----------------------------------------------------------------------------

bool RecordTimer(MyFile * File, int Flag) {

  pthread_t thread;

  if (Flag == RECORD_TIMER_START) {   
    if (File->TimerOn == 0) {
      pthread_create(&thread, NULL, (void*)&Timer, File);
      File->TimerOn = 1;
//printf("Record Timer Start\n");
      return TRUE;
    }
    else {
      printf("Record Timer Already Started\n");
      return FALSE;
    }
  }

  if (Flag == RECORD_TIMER_STOP) {   
    if (File->TimerOn == 1) {
      pthread_exit(&thread);
      File->TimerOn = 0;
//printf("Record Timer Stop\n");
      return TRUE;
    }
    else {
      printf("Record Timer not run yet\n");
      return FALSE;
    }
  }

  return FALSE;
}

//~----------------------------------------------------------------------------

bool RecordAMSBlock(pMyFile File, pAMSBlock Lebedev, int16 APID, int FrameSize) {

/*
  pAMSBlock_P Peter = (pAMSBlock_P)NULL;
*/
  pAMSBlock Peter = (pAMSBlock)NULL;
     
  frmListHeadConstruct(&TxFrameList, TaskName);
 
  if (!frmConstruct(&Frame, APID, FrameSize, 0)) {
    printf("%s: Error on frmConstruct \n", TaskName);
    exit(1);
  }
  
  print_AMS_data_block("AMSBlock to Record", Lebedev);
  Peter = abiConstruct(Lebedev->NodeAddress, Lebedev->DataType, 
                       Lebedev->DataCount,   Lebedev->BlockType, 0);
  memcpy(abiDataPtr8(Peter), Lebedev->Data.p8, Lebedev->DataCount);
//abiPrint("Peter", Peter, 22);

  frmListBlock(&TxFrameList, &Frame, Peter);
  abiDestruct(Peter); 
  frmListBlock(&TxFrameList, &Frame, NULL);

  while ((pFL = frmListRemove(&TxFrameList)) != NULL) { 
    RecordFrame(File, &pFL->Buffer[0], FrameSize);
    frmListEntDestruct(&TxFrameList, pFL);   
  }
    
  frmListHeadDestruct(&TxFrameList);
  frmDestruct(&Frame);
  return TRUE;
}

//~----------------------------------------------------------------------------

bool RecordFrame(pMyFile File, int8 *Frame, int RecordSize) {
  
  if (File->TimerOn == 0) {
    printf("\nRecord Timer Off, Start Record Timer First\n");
    return FALSE;
  }

  while (File->FileFd == -1);

  if (Frame == NULL) return TRUE;

  printf("\nHave Written  Following Frame to file: %s%d/%d\n",
         File->GrandFatherDir, File->DirNo, File->FileNo);
  HexDump(Frame, RecordSize, TRUE);
  printf("\n");

  if (write(File->FileFd, Frame, RecordSize) != RecordSize) {
    close(File->FileFd);
    File->FileFd = -1;
    return FALSE;
  }

  return TRUE;  
}

//~----------------------------------------------------------------------------

void Timer(void *arg) {
   
  char FatherDir[100];
  char FileName[100];
  char Temp1[20];
  char Temp2[20];
  volatile int LastDirNo;
  volatile int LastFileNo;
  struct timeval timeout;
  int flag = 0;

  while (1) {
    if (flag != 0) {
      timeout.tv_sec = ((MyFile*)arg)->FileInterval;
      timeout.tv_usec = 0;
      select(0, NULL,NULL,NULL, &timeout);
    }
    else {
      flag = 1;
    }

    if (((MyFile*)arg)->FileFd != -1) close(((MyFile*)arg)->FileFd);

    ((MyFile*)arg)->FileFd = -1;
      
    LastDirNo = LastFileNoInDir(((MyFile*)arg)->GrandFatherDir, ((MyFile*)arg)->DirLen);

    if (LastDirNo == -1) {
      LastDirNo = 0;
      sprintf(Temp1, "%s%1d%s", "%0", ((MyFile*)arg)->DirLen, "d");
      sprintf(Temp2, "%s%s", "%s", Temp1);
      sprintf(FatherDir, Temp2, ((MyFile*)arg)->GrandFatherDir, LastDirNo);
      strcat(FatherDir, "/");
                  
      if (mkdir(FatherDir, 0777)== -1 && errno != EEXIST) {
        printf("%s%s%s\n", "mkdir", FatherDir, strerror(errno));
        exit(-1);
      }
      ((MyFile*)arg)->FileNo = 0;
      ((MyFile*)arg)->DirNo = LastDirNo;
      sprintf(Temp1, "%s%1d%s", "%0", ((MyFile*)arg)->FileLen, "d");
      sprintf(Temp2, "%s%s", "%s", Temp1);
      sprintf(FileName, Temp2, FatherDir, ((MyFile*)arg)->FileNo);
                
      ((MyFile*)arg)->FileFd = creat(FileName, 0666);
    }
    else {
      ((MyFile*)arg)->DirNo = LastDirNo;
      sprintf(Temp1, "%s%1d%s", "%0", ((MyFile*)arg)->DirLen, "d");
      sprintf(Temp2, "%s%s", "%s", Temp1);
      sprintf(FatherDir, Temp2, ((MyFile*)arg)->GrandFatherDir, ((MyFile*)arg)->DirNo);
      strcat(FatherDir, "/");
      LastFileNo = LastFileNoInDir(FatherDir, ((MyFile*)arg)->FileLen); 
     
      LastFileNo++;
      if (LastFileNo>999) {      
        LastDirNo = LastFileNoInDir(((MyFile*)arg)->GrandFatherDir, ((MyFile*)arg)->DirLen);
//printf("LastDirNo: %d\n",LastDirNo );
        LastDirNo++;
        sprintf(FatherDir, Temp2, ((MyFile*)arg)->GrandFatherDir, LastDirNo);
        strcat(FatherDir, "/");
        if (mkdir(FatherDir, 0777)== -1 && errno != EEXIST) {
          printf("%s%s\n", "mkdir", strerror(errno));
          exit(-1);
        }
        ((MyFile*)arg)->FileNo = 0;
        ((MyFile*)arg)->DirNo = LastDirNo;
        sprintf(Temp1, "%s%1d%s", "%0", ((MyFile*)arg)->FileLen, "d");
        sprintf(Temp2, "%s%s", "%s", Temp1);
        sprintf(FileName, Temp2, FatherDir, ((MyFile*)arg)->FileNo);
        ((MyFile*)arg)->FileFd = creat(FileName, 0666);
      }
      else {
        ((MyFile*)arg)->FileNo = LastFileNo;
        sprintf(Temp1, "%s%1d%s", "%0", ((MyFile*)arg)->FileLen, "d");
        sprintf(Temp2, "%s%s", "%s", Temp1);
        sprintf(FileName, Temp2, FatherDir, ((MyFile*)arg)->FileNo);
        ((MyFile*)arg)->FileFd = creat(FileName, 0666);
      }
    }
  }
}

//~----------------------------------------------------------------------------

int LastFileNoInDir(char *DirPath, int Length) {

  int FileNumber;
  int LastFileNumber;
  DIR *dir;
  struct dirent *d;
  char fname[50]; 
  int i;  
  int flag = 0;

  if (CheckDirIni(DirPath)==-1) {
    printf("Directory: %s   improper permission.\n", DirPath);
    exit(-1);
  }   
 
  if ((dir = opendir(DirPath)) == NULL) {
    printf("%s: opendir(%s) failed: %s\n", TaskName, DirPath, strerror(errno));
    exit(-1);
  }

  LastFileNumber = -1;

  for (i=0; i<5*Length; i=i+5) {
    fname[i]   = '[';
    fname[i+1] = '0';
    fname[i+2] = '-';
    fname[i+3] = '9';
    fname[i+4] = ']'; 
  }

  fname[5*Length] = '\0';

  while ((d = readdir(dir)) != NULL) {  
    if ((fnmatch(fname, d->d_name, 0) == 0)) {
      if (flag == 0) {
        LastFileNumber =0;
        flag = 1;
      }
      FileNumber = atol(d->d_name);
      LastFileNumber = MAX(LastFileNumber, FileNumber);
    }
  }

  if (closedir(dir)) {
    printf("%s: closedir(%s) failed: %s\n", TaskName, DirPath, strerror(errno));
    exit(-1);
  }

  return LastFileNumber;
}

//~----------------------------------------------------------------------------

int CheckDirIni(const char*Dir) {

  int depth = 0;
  char *temp;
  char *temp2;
  int i = 0;
  char dir1[200];
  char dir2[200];
  char buf[200];
  char buf2[200];

  strcpy(dir1, Dir);
  strcpy(dir2, Dir);
 
  if(mkdir( "/Data/" , 0777)== -1 && errno != EEXIST) {
    printf("%s%s%s\n", "mkdir", "/Data", strerror(errno));
    exit(-1);
  }

  while (1) {
    if ((temp=strrchr(dir1,'/'))==NULL) break;
    depth++;
    *temp='\0';
  }
 
  temp2 = dir2;
  for (i=0; i<depth; i++) {
    temp  = strchr(temp2,  '/');
    temp2 = strchr(temp+1, '/');
    if (temp2 != NULL) {
      strncpy(buf+i*20, temp+1, temp2-temp-1);
      buf[i*20+temp2-temp-1] = '\0';
    }
    else {
      strcpy(buf+i*20, temp+1);
    }
  }

  for (i=0; i<depth; i++) {
    sprintf(buf2, "./%s", buf+20*i);
    strcpy(buf+20*i, buf2);
  }               

  if (CheckDir(dir2, depth,buf, depth) == -1) return -1;            
  else                                        return 0;
}

//~----------------------------------------------------------------------------

int CheckDir(char* Dir, int Depth, char*DirEntries, int MaxDepth) {

  if (access(Dir,F_OK) != 0) {
    char *temp = strrchr(Dir,'/'); 
    *temp = '\0';
    if (CheckDir(Dir, Depth-1, DirEntries, MaxDepth) == -1) return -1;
    if (Depth<MaxDepth-1) {
      chdir(Dir);
      if (mkdir(DirEntries+20*Depth,0777) == -1) return -1;
      strcat(Dir, DirEntries+1+20*Depth);
    }
    return 0;
  }
  else {
    if (Depth != MaxDepth){
      chdir(Dir);
      if (mkdir(DirEntries+20*Depth, 0777) == -1) return -1;
      strcat(Dir, DirEntries+1+20*Depth);
    }
  }
  return 0;
}

//~============================================================================
