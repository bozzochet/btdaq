<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> AMS Software: Geometry Classes: CC/TrFit.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">CC</a></div>
<h1>TrFit.C</h1><a href="TrFit_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">//  $Id: TrFit.C,v 1.9 2008/09/11 16:56:02 zuccon Exp $</span>
00002 
00003 
00020 
00021 <span class="preprocessor">#include "<a class="code" href="TrFit_8h.html">TrFit.h</a>"</span>
00022 <span class="preprocessor">#include "TrField.h"</span>
00023 
00024 <span class="preprocessor">#include &lt;cmath&gt;</span>
00025 <span class="preprocessor">#include &lt;iostream&gt;</span>     <span class="comment">// for min and max</span>
00026 
<a name="l00027"></a><a class="code" href="classTrFit.html#s0">00027</a> <span class="keywordtype">int</span> <a class="code" href="classTrFit.html#s0">TrFit::_ims</a> = 1;
00028 
<a name="l00029"></a><a class="code" href="classTrFit.html#a0">00029</a> <a class="code" href="classTrFit.html#a0">TrFit::TrFit</a>(<span class="keywordtype">void</span>)
00030 {
00031   <a class="code" href="classTrFit.html#p20">_xmass</a> = 0.938272297;
00032   <a class="code" href="classTrFit.html#p21">_chrg</a>  = 1;
00033 
00034   <a class="code" href="classTrFit.html#a13">Clear</a>();
00035 }
00036 
<a name="l00037"></a><a class="code" href="classTrFit.html#a1">00037</a> <a class="code" href="classTrFit.html#a1">TrFit::~TrFit</a>()
00038 {
00039 }
00040 
<a name="l00041"></a><a class="code" href="classTrFit.html#a13">00041</a> <span class="keywordtype">void</span> <a class="code" href="classTrFit.html#a13">TrFit::Clear</a>(<span class="keywordtype">void</span>)
00042 {
00043   <a class="code" href="classTrFit.html#p0">_nhit</a> = 0;
00044   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; PMAX; i++) <a class="code" href="classTrFit.html#p13">_param</a>[i] = 0;
00045   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; LMAX; i++) <a class="code" href="classTrFit.html#p4">_xs</a>[i] = <a class="code" href="classTrFit.html#p5">_ys</a>[i] = <a class="code" href="classTrFit.html#p6">_zs</a>[i] = -1;
00046   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; LMAX; i++) <a class="code" href="classTrFit.html#p7">_xr</a>[i] = <a class="code" href="classTrFit.html#p8">_yr</a>[i] = <a class="code" href="classTrFit.html#p9">_zr</a>[i] =  0;
00047   <a class="code" href="classTrFit.html#p14">_chisqx</a> = <a class="code" href="classTrFit.html#p15">_chisqy</a> = -1;
00048   <a class="code" href="classTrFit.html#p16">_ndofx</a> = <a class="code" href="classTrFit.html#p17">_ndofy</a> = 0;
00049 }
00050 
<a name="l00051"></a><a class="code" href="classTrFit.html#a14">00051</a> <span class="keywordtype">int</span> <a class="code" href="classTrFit.html#a14">TrFit::Add</a>(<span class="keywordtype">double</span> x,  <span class="keywordtype">double</span> y,  <span class="keywordtype">double</span> z,
00052                <span class="keywordtype">double</span> ex, <span class="keywordtype">double</span> ey, <span class="keywordtype">double</span> ez, <span class="keywordtype">int</span> i)
00053 {
00054   <span class="keywordflow">if</span> (i &lt; 0) i = _nhit;
00055   <span class="keywordflow">if</span> (i &lt; 0 || <a class="code" href="classTrFit.html#w7w1">LMAX</a> &lt;= i) <span class="keywordflow">return</span> -1;
00056 
00057   <a class="code" href="classTrFit.html#p1">_xh</a>[i] = x; <a class="code" href="classTrFit.html#p4">_xs</a>[i] = ex;
00058   <a class="code" href="classTrFit.html#p2">_yh</a>[i] = y; <a class="code" href="classTrFit.html#p5">_ys</a>[i] = ey;
00059   <a class="code" href="classTrFit.html#p3">_zh</a>[i] = z; <a class="code" href="classTrFit.html#p6">_zs</a>[i] = ez;
00060 
00061   <a class="code" href="classTrFit.html#p10">_bx</a>[i] = <a class="code" href="classTrFit.html#p11">_by</a>[i] = <a class="code" href="classTrFit.html#p12">_bz</a>[i] = 0;
00062 
00063   <span class="keywordtype">float</span> pos[3] = { x, y, z }, bf[3];
00064   TrField::GetPtr()-&gt;GuFld(pos, bf);
00065   <a class="code" href="classTrFit.html#p10">_bx</a>[i] = bf[0];
00066   <a class="code" href="classTrFit.html#p11">_by</a>[i] = bf[1];
00067   <a class="code" href="classTrFit.html#p12">_bz</a>[i] = bf[2];
00068 
00069   <span class="keywordflow">if</span> (i &gt;= _nhit) <a class="code" href="classTrFit.html#p0">_nhit</a> = i+1;
00070   <span class="keywordflow">return</span> _nhit;
00071 }
00072 
<a name="l00073"></a><a class="code" href="classTrFit.html#a15">00073</a> <span class="keywordtype">int</span> <a class="code" href="classTrFit.html#a14">TrFit::Add</a>(<span class="keywordtype">double</span> x,  <span class="keywordtype">double</span> y,  <span class="keywordtype">double</span> z,
00074                <span class="keywordtype">double</span> ex, <span class="keywordtype">double</span> ey, <span class="keywordtype">double</span> ez, 
00075                <span class="keywordtype">double</span> bx, <span class="keywordtype">double</span> by, <span class="keywordtype">double</span> bz, <span class="keywordtype">int</span> i)
00076 {
00077   <span class="keywordflow">if</span> (i &lt; 0) i = _nhit;
00078   <span class="keywordflow">if</span> (i &lt; 0 || <a class="code" href="classTrFit.html#w7w1">LMAX</a> &lt;= i) <span class="keywordflow">return</span> -1;
00079 
00080   <a class="code" href="classTrFit.html#p1">_xh</a>[i] = x; <a class="code" href="classTrFit.html#p4">_xs</a>[i] = ex; <a class="code" href="classTrFit.html#p10">_bx</a>[i] = bx;
00081   <a class="code" href="classTrFit.html#p2">_yh</a>[i] = y; <a class="code" href="classTrFit.html#p5">_ys</a>[i] = ey; <a class="code" href="classTrFit.html#p11">_by</a>[i] = by;
00082   <a class="code" href="classTrFit.html#p3">_zh</a>[i] = z; <a class="code" href="classTrFit.html#p6">_zs</a>[i] = ez; <a class="code" href="classTrFit.html#p12">_bz</a>[i] = bz;
00083 
00084   <span class="keywordflow">if</span> (i &gt;= _nhit) <a class="code" href="classTrFit.html#p0">_nhit</a> = i+1;
00085   <span class="keywordflow">return</span> _nhit;
00086 }
00087 
<a name="l00088"></a><a class="code" href="classTrFit.html#a16">00088</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a16">TrFit::Fit</a>(<span class="keywordtype">int</span> method)
00089 {
00090   <span class="comment">// Check number of hits</span>
00091   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#p0">_nhit</a> &lt; 3) <span class="keywordflow">return</span> -1;
00092 
00093   <span class="keywordflow">if</span> (method == LINEAR) <span class="keywordflow">return</span> <a class="code" href="classTrFit.html#a17">LinearFit</a>();
00094   <span class="keywordflow">if</span> (method == CIRCLE) <span class="keywordflow">return</span> <a class="code" href="classTrFit.html#a18">CircleFit</a>();
00095   <span class="keywordflow">if</span> (method == SIMPLE) <span class="keywordflow">return</span> <a class="code" href="classTrFit.html#a19">SimpleFit</a>();
00096   <span class="keywordflow">if</span> (method == NORMAL) <span class="keywordflow">return</span> <a class="code" href="classTrFit.html#a20">NormalFit</a>();
00097 
00098   <span class="keywordflow">return</span> 0;
00099 }
00100 
<a name="l00101"></a><a class="code" href="classTrFit.html#a17">00101</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a17">TrFit::LinearFit</a>(<span class="keywordtype">void</span>)
00102 {
00104 
00105   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#a17">LinearFit</a>(1) &lt; 0) <span class="keywordflow">return</span> -1;
00106   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#a17">LinearFit</a>(2) &lt; 0) <span class="keywordflow">return</span> -1;
00107 
00108 <span class="comment">//_chisq = (_ndofx+_ndofy &gt; 0) ? (_chisqx+_chisqy)/(_ndofx+_ndofy) : -1;</span>
00109   <a class="code" href="classTrFit.html#p18">_chisq</a> = <a class="code" href="classTrFit.html#p14">_chisqx</a>+_chisqy;
00110   <span class="keywordflow">return</span> _chisq;
00111 }
00112 
<a name="l00113"></a><a class="code" href="classTrFit.html#a18">00113</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a18">TrFit::CircleFit</a>(<span class="keywordtype">void</span>)
00114 {
00116 
00117   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#a18">CircleFit</a>(2) &lt; 0) <span class="keywordflow">return</span> -1;
00118   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#a17">LinearFit</a>(3) &lt; 0) <span class="keywordflow">return</span> -1;
00119 
00120 <span class="comment">//_chisq = (_ndofx+_ndofy &gt; 0) ? (_chisqx+_chisqy)/(_ndofx+_ndofy) : -1;</span>
00121   <a class="code" href="classTrFit.html#p18">_chisq</a> = <a class="code" href="classTrFit.html#p14">_chisqx</a>+_chisqy;
00122   <span class="keywordflow">return</span> _chisq;
00123 }
00124 
<a name="l00125"></a><a class="code" href="classTrFit.html#a21">00125</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a17">TrFit::LinearFit</a>(<span class="keywordtype">int</span> side)
00126 {
00127   <span class="comment">// Analytic linear fitting method</span>
00128 
00129   <span class="keywordtype">double</span> sh[LMAX];
00130   <span class="keywordtype">double</span> *x   = (side == 2) ? <a class="code" href="classTrFit.html#p2">_yh</a> : _xh;
00131   <span class="keywordtype">double</span> *sig = (side == 2) ? <a class="code" href="classTrFit.html#p5">_ys</a> : _xs;
00132   <span class="keywordtype">double</span> *res = (side == 2) ? <a class="code" href="classTrFit.html#p8">_yr</a> : _xr;
00133   <span class="keywordtype">double</span> *par = (side == 2) ? <a class="code" href="classTrFit.html#p13">_param</a>+2 : _param;
00134   <span class="keywordtype">double</span> *y   = (side == 3) ? sh : _zh;
00135 
00136   <span class="comment">// Fill S coordinate</span>
00137   <span class="keywordflow">if</span> (side == 3) {
00138     <span class="keywordtype">double</span> kappa = <a class="code" href="classTrFit.html#p13">_param</a>[2];
00139     <span class="keywordtype">double</span> d0    = <a class="code" href="classTrFit.html#p13">_param</a>[3];
00140     <span class="keywordtype">double</span> phi0  = <a class="code" href="classTrFit.html#p13">_param</a>[4];
00141     <span class="keywordflow">if</span> (kappa &lt;= 0) <span class="keywordflow">return</span> -1;
00142 
00143     <span class="keywordtype">double</span> cx = -(0.5/kappa+d0)*std::sin(phi0);
00144     <span class="keywordtype">double</span> cy =  (0.5/kappa+d0)*std::cos(phi0);
00145     <span class="keywordtype">double</span> ra = std::fabs(0.5/kappa);
00146 
00147     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00148       <span class="keywordtype">double</span> phi = std::atan2(-(<a class="code" href="classTrFit.html#p1">_xh</a>[i]-cx), <a class="code" href="classTrFit.html#p2">_yh</a>[i]-cy);
00149       <span class="keywordtype">double</span> sgn = -1;
00150       <span class="keywordflow">if</span> (phi &lt; 0) { phi += M_PI; sgn = 1; }
00151       sh[i] = sgn*ra*(phi-(phi0-M_PI));
00152     }
00153   }
00154 
00155   <span class="comment">// Set 2x2-matrix and 2-vector</span>
00156   <span class="keywordtype">double</span> mtx[2][2] = { { 0, 0 }, { 0, 0 } }, minv[2][2];
00157   <span class="keywordtype">double</span> vec[2] = { 0, 0 };
00158    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00159       <span class="keywordtype">double</span> w = (sig[i] &gt; 0) ? 1/sig[i]/sig[i] : 1;
00160       mtx[0][0] += w;      mtx[0][1] += w*y[i];
00161       mtx[1][0] += w*y[i]; mtx[1][1] += w*y[i]*y[i];
00162       vec[0]    += w*x[i]; vec[1]    += w*x[i]*y[i];
00163    }
00164 
00165    <span class="comment">// Invert matrix</span>
00166    <span class="keywordtype">double</span> det = mtx[0][0]*mtx[1][1]-mtx[0][1]*mtx[1][0];
00167    <span class="keywordflow">if</span> (det == 0) <span class="keywordflow">return</span> -1;
00168    minv[0][0] = mtx[1][1]/det; minv[0][1] = -mtx[0][1]/det;
00169    minv[1][1] = mtx[0][0]/det; minv[1][0] = -mtx[1][0]/det;
00170 
00171    <span class="comment">// Solution parameters</span>
00172    par[0] = minv[0][0]*vec[0]+minv[0][1]*vec[1];
00173    par[1] = minv[1][0]*vec[0]+minv[1][1]*vec[1];
00174 
00175    <span class="comment">// Fitting chisquare</span>
00176    <span class="keywordtype">double</span> chisq = 0;
00177    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00178      res[i] = x[i]-(par[0]+par[1]*y[i]);
00179      chisq += (sig[i] &gt; 0) ? res[i]*res[i]/sig[i]/sig[i] : res[i]*res[i];
00180    }
00181 
00182    <span class="keywordtype">int</span> ndof = _nhit-2;
00183    <span class="keywordflow">if</span> (side == 1) {
00184      <a class="code" href="classTrFit.html#p16">_ndofx</a>  = ndof;
00185      <a class="code" href="classTrFit.html#p14">_chisqx</a> = chisq;
00186    } <span class="keywordflow">else</span> {
00187      <a class="code" href="classTrFit.html#p17">_ndofy</a>  = ndof;
00188      <a class="code" href="classTrFit.html#p15">_chisqy</a> = chisq;
00189    }
00190 
00191    <span class="keywordflow">return</span> chisq;
00192 }
00193 
<a name="l00194"></a><a class="code" href="classTrFit.html#a22">00194</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a18">TrFit::CircleFit</a>(<span class="keywordtype">int</span> side)
00195 {
00197 <span class="comment">//  Effective circle fit - Karimaki's method</span>
00198 <span class="comment">//  Nuclear Instruments and Methods</span>
00199 <span class="comment">//          A305(1991) 187-191 by V.Karimaki</span>
00200 <span class="comment">//</span>
00201 <span class="comment">//  Note : The output values might have large truncation errors </span>
00202 <span class="comment">//         when the center of the track is near( &lt;= 1% of R ) the origin.</span>
00204 <span class="comment"></span>
00205   <span class="keywordtype">double</span> *x   = (side == 1) ? <a class="code" href="classTrFit.html#p1">_xh</a> : _yh;
00206   <span class="keywordtype">double</span> *sig = (side == 1) ? <a class="code" href="classTrFit.html#p4">_xs</a> : _ys;
00207   <span class="keywordtype">double</span> *res = (side == 1) ? <a class="code" href="classTrFit.html#p7">_xr</a> : _yr;
00208   <span class="keywordtype">double</span> *par = (side == 1) ? <a class="code" href="classTrFit.html#p13">_param</a> : <a class="code" href="classTrFit.html#p13">_param</a>+2;
00209   <span class="keywordtype">double</span> *y   = _zh;
00210 
00211   <span class="keywordtype">double</span> r[LMAX], w[LMAX];
00212   <span class="keywordtype">double</span> sw = 0;
00213   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00214     r[i] = x[i]*x[i]+y[i]*y[i];
00215     w[i] = (sig[i] &gt; 0) ? 1/sig[i]/sig[i] : 1;
00216     sw += w[i];
00217   }
00218   <span class="keywordflow">if</span> (sw &lt;= 0) <span class="keywordflow">return</span> -1;
00219 
00220   <span class="comment">// Weighted average of x, y, r</span>
00221   <span class="keywordtype">double</span> xav  = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, x, 0, w);
00222   <span class="keywordtype">double</span> yav  = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, y, 0, w);
00223   <span class="keywordtype">double</span> rav  = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, r, 0, w);
00224   <span class="keywordtype">double</span> xxav = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, x, x, w);
00225   <span class="keywordtype">double</span> xyav = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, x, y, w);
00226   <span class="keywordtype">double</span> yyav = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, y, y, w);
00227   <span class="keywordtype">double</span> xrav = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, x, r, w);
00228   <span class="keywordtype">double</span> yrav = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, y, r, w);
00229   <span class="keywordtype">double</span> rrav = <a class="code" href="classTrFit.html#a23">VKAverage</a>(_nhit, r, r, w);
00230 
00231   <span class="comment">// Covariances</span>
00232   <span class="keywordtype">double</span> cxx = xxav-xav*xav;
00233   <span class="keywordtype">double</span> cxy = xyav-xav*yav;
00234   <span class="keywordtype">double</span> cyy = yyav-yav*yav;
00235   <span class="keywordtype">double</span> cxr = xrav-xav*rav;
00236   <span class="keywordtype">double</span> cyr = yrav-yav*rav;
00237   <span class="keywordtype">double</span> crr = rrav-rav*rav;
00238   <span class="keywordflow">if</span> (crr == 0) <span class="keywordflow">return</span> -1;
00239 
00240   <span class="comment">// Track parameters in the zero-th order</span>
00241   <span class="keywordtype">double</span> q1    = crr*cxy-cxr*cyr;
00242   <span class="keywordtype">double</span> q2    = crr*(cxx-cyy)-cxr*cxr+cyr*cyr;
00243   <span class="keywordtype">double</span> phi   = std::atan2(2*q1, q2)/2.;
00244   <span class="keywordtype">double</span> sphi  = std::sin(phi);
00245   <span class="keywordtype">double</span> cphi  = std::cos(phi);
00246   <span class="keywordtype">double</span> kappa = (sphi*cxr-cphi*cyr)/crr;
00247   <span class="keywordtype">double</span> delta = -kappa*rav+sphi*xav-cphi*yav;
00248   <span class="keywordflow">if</span> (1-4*delta*kappa &lt;= 0 || kappa == 0) <span class="keywordflow">return</span> -1;
00249 
00250   <span class="keywordtype">double</span> dksqr = std::sqrt(1-4*delta*kappa);
00251   <span class="keywordtype">double</span> rho   = 2.*kappa/dksqr;
00252   <span class="keywordtype">double</span> d     = 2.*delta/(1+dksqr);
00253   <span class="keywordtype">double</span> u     = 1+rho*d;
00254   <span class="keywordtype">double</span> chisq = sw*u*u*(sphi*sphi*cxx-2*sphi*cphi*cxy+
00255                          cphi*cphi*cyy-kappa*kappa*crr);
00256 
00257   <span class="comment">// Inversed covariance matrix Vinv</span>
00258   <span class="keywordtype">double</span> vinv[6];
00259   <span class="keywordtype">double</span> sa = sphi*xav-cphi*yav;
00260   <span class="keywordtype">double</span> sb = cphi*xav+sphi*yav;
00261   <span class="keywordtype">double</span> sc = (sphi*sphi-cphi*cphi)*xyav+sphi*cphi*(xxav-yyav);
00262   <span class="keywordtype">double</span> sd = sphi*xrav-cphi*yrav;
00263   <span class="keywordtype">double</span> se = sphi*sphi*xxav-2*sphi*cphi*xyav+cphi*cphi*yyav;
00264 
00265   vinv[0] = rrav/4.-d*(sd-d*(se+rav/2.-d*(sa-d/4.)));
00266   vinv[1] = -u*((cphi*xrav+sphi*yrav)/2.-d*(sc-d*sb/2.));
00267   vinv[2] = u*u*(cphi*cphi*xxav+2*sphi*cphi*xyav+sphi*sphi*yyav);
00268   vinv[3] = rho*(-sd/2.+d*se)+u*rav/2.-d*((2*u+rho*d)*sa-u*d)/2.;
00269   vinv[4] = u*(rho*sc-u*sb);
00270   vinv[5] = rho*(rho*se-2*u*sa)+u*u;
00271   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 6; i++) vinv[i] *= sw;
00272 
00273   <span class="comment">// Invert vinv</span>
00274   <span class="keywordtype">double</span> det = vinv[0]*vinv[2]*vinv[5]+vinv[1]*vinv[3]*vinv[4]
00275               +vinv[1]*vinv[3]*vinv[4]-vinv[0]*vinv[4]*vinv[4]
00276               -vinv[1]*vinv[1]*vinv[5]-vinv[2]*vinv[3]*vinv[3];
00277   <span class="keywordflow">if</span> (det == 0) <span class="keywordflow">return</span> -1;
00278 
00279   <span class="keywordtype">double</span> vmtx[6];
00280   vmtx[0] = (vinv[2]*vinv[5]-vinv[4]*vinv[4])/det;
00281   vmtx[1] = (vinv[3]*vinv[4]-vinv[1]*vinv[5])/det;
00282   vmtx[2] = (vinv[0]*vinv[5]-vinv[3]*vinv[3])/det;
00283   vmtx[3] = (vinv[1]*vinv[4]-vinv[2]*vinv[3])/det;
00284   vmtx[4] = (vinv[1]*vinv[3]-vinv[0]*vinv[4])/det;
00285   vmtx[5] = (vinv[0]*vinv[2]-vinv[1]*vinv[1])/det;
00286   <span class="keywordflow">if</span> (vmtx[0] &lt; 0) <span class="keywordflow">return</span> -1;
00287 
00288   <span class="comment">// First ordered corrections of parameters</span>
00289   <span class="keywordtype">double</span> sigma = -rho*sd+2*u*se-d*(1+u)*sa;
00290   rho -= (vmtx[0]*d*sigma+vmtx[3]*rho*sigma)/2.;
00291   phi -= (vmtx[1]*d*sigma+vmtx[4]*rho*sigma)/2.;
00292   d   -= (vmtx[3]*d*sigma+vmtx[5]*rho*sigma)/2.;
00293 
00294   <span class="keywordflow">if</span> (phi &gt; 0) {
00295     par[0] = rho/2;
00296     par[1] = d;
00297     par[2] = phi+M_PI;
00298   } <span class="keywordflow">else</span> {
00299     par[0] = -rho/2;
00300     par[1] = -d;
00301     par[2] = phi+2*M_PI;
00302   }
00303 
00304   <span class="comment">// Error of kappa</span>
00305   par[3] = std::sqrt(vmtx[0])/2;
00306 
00307   <span class="comment">// Fitting residual</span>
00308   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) res[i] = <a class="code" href="classTrFit.html#a24">VKResidual</a>(x[i], y[i], par);
00309 
00310   <span class="keywordtype">int</span> ndof = _nhit-3;
00311   <span class="keywordflow">if</span> (side == 1) {
00312     <a class="code" href="classTrFit.html#p16">_ndofx</a>  = ndof;
00313     <a class="code" href="classTrFit.html#p14">_chisqx</a> = chisq;
00314   } <span class="keywordflow">else</span> {
00315     <a class="code" href="classTrFit.html#p17">_ndofy</a>  = ndof;
00316     <a class="code" href="classTrFit.html#p15">_chisqy</a> = chisq;
00317   }
00318 
00319   <span class="keywordflow">return</span> chisq;
00320 }
00321 
<a name="l00322"></a><a class="code" href="classTrFit.html#a23">00322</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a23">TrFit::VKAverage</a>(<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">double</span> *w)
00323 {
00324    <span class="keywordtype">double</span> s = 0, sw = 0;
00325    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {
00326       s  += (y) ? x[i]*y[i]*w[i] : x[i]*w[i];
00327       sw += w[i];
00328    }
00329    <span class="keywordflow">return</span> (sw &lt;= 0) ? 0 : s/sw;
00330 }
00331 
<a name="l00332"></a><a class="code" href="classTrFit.html#a24">00332</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a24">TrFit::VKResidual</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> *par)
00333 {
00334    <span class="keywordflow">if</span> (par[0] == 0 || par[2] == 0) <span class="keywordflow">return</span> 0;
00335 
00336    <span class="keywordtype">double</span> cx = -(0.5/par[0]+par[1])*std::sin(par[2]);
00337    <span class="keywordtype">double</span> cy =  (0.5/par[0]+par[1])*std::cos(par[2]);
00338    <span class="keywordtype">double</span> dx = x-cx;
00339    <span class="keywordtype">double</span> dy = y-cy;
00340    <span class="keywordtype">double</span> gr = -dy/dx;
00341    <span class="keywordtype">double</span> a  = -1/gr;
00342 
00343    <span class="keywordtype">double</span> rr = std::fabs(0.5/par[0]);
00344    <span class="keywordtype">double</span> aa = a*a+1;
00345    <span class="keywordtype">double</span> bb = a*dx-a*a*y-cy;
00346    <span class="keywordtype">double</span> cc = (a*y-dx)*(a*y-dx)+cy*cy-rr*rr;
00347    <span class="keywordtype">double</span> dd = bb*bb-aa*cc;
00348    <span class="keywordflow">if</span> (dd &lt;= 0) <span class="keywordflow">return</span> 0;
00349 
00350    <span class="keywordtype">double</span> sg[2] = { 0, 0 }, rs[2] = { 0, 0 };
00351    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++) {
00352      <span class="keywordtype">double</span> yy = (-bb+(i*2-1)*std::sqrt(dd))/aa;
00353      <span class="keywordtype">double</span> xx = a*(yy-y)+x;
00354      sg[i] = (x &gt; xx) ? 1 : -1;
00355      rs[i] = std::sqrt((xx-x)*(xx-x)+(yy-y)*(yy-y));
00356    }
00357 
00358    <span class="keywordflow">return</span> (rs[0] &lt; rs[1]) ? rs[0]*sg[0] : rs[1]*sg[1];
00359 }
00360 
<a name="l00361"></a><a class="code" href="classTrFit.html#a19">00361</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a19">TrFit::SimpleFit</a>(<span class="keywordtype">void</span>)
00362 {
00363   <span class="keywordtype">double</span> len[LMAX];
00364 
00365   <span class="comment">// Length</span>
00366   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00367     len[i] = -1;
00368     <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#p4">_xs</a>[i] &lt;= 0 &amp;&amp; <a class="code" href="classTrFit.html#p5">_ys</a>[i] &lt;= 0 &amp;&amp; <a class="code" href="classTrFit.html#p6">_zs</a>[i] &lt;= 0) <span class="keywordflow">continue</span>;
00369 
00370     len[i] = (i == 0) ? 0 : std::sqrt((<a class="code" href="classTrFit.html#p1">_xh</a>[i]-<a class="code" href="classTrFit.html#p1">_xh</a>[i-1])*(<a class="code" href="classTrFit.html#p1">_xh</a>[i]-<a class="code" href="classTrFit.html#p1">_xh</a>[i-1])
00371                                      +(<a class="code" href="classTrFit.html#p2">_yh</a>[i]-<a class="code" href="classTrFit.html#p2">_yh</a>[i-1])*(<a class="code" href="classTrFit.html#p2">_yh</a>[i]-<a class="code" href="classTrFit.html#p2">_yh</a>[i-1])
00372                                      +(<a class="code" href="classTrFit.html#p3">_zh</a>[i]-<a class="code" href="classTrFit.html#p3">_zh</a>[i-1])*(<a class="code" href="classTrFit.html#p3">_zh</a>[i]-<a class="code" href="classTrFit.html#p3">_zh</a>[i-1]));
00373   }
00374 
00375   <span class="keywordtype">double</span> pintx[LMAX][3];
00376   <span class="keywordtype">double</span> pintu[LMAX][3];
00377 
00378   <span class="comment">// Calculate path integrals</span>
00379   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00380     <span class="keywordflow">if</span> (i == 0 || len[i] &lt;= 0) {
00381       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; j++) pintx[0][j] = pintu[0][j] = 0;
00382       <span class="keywordflow">continue</span>;
00383     }
00384      
00385     <span class="keywordtype">double</span> u[3];
00386     u[0] = (<a class="code" href="classTrFit.html#p1">_xh</a>[i]-<a class="code" href="classTrFit.html#p1">_xh</a>[i-1])/len[i];
00387     u[1] = (<a class="code" href="classTrFit.html#p2">_yh</a>[i]-<a class="code" href="classTrFit.html#p2">_yh</a>[i-1])/len[i];
00388     u[2] = (<a class="code" href="classTrFit.html#p3">_zh</a>[i]-<a class="code" href="classTrFit.html#p3">_zh</a>[i-1])/len[i];
00389 
00390     <span class="keywordtype">double</span> bax = (<a class="code" href="classTrFit.html#p10">_bx</a>[i-1]+<a class="code" href="classTrFit.html#p10">_bx</a>[i])/2;
00391     <span class="keywordtype">double</span> bay = (<a class="code" href="classTrFit.html#p11">_by</a>[i-1]+<a class="code" href="classTrFit.html#p11">_by</a>[i])/2;
00392     <span class="keywordtype">double</span> baz = (<a class="code" href="classTrFit.html#p12">_bz</a>[i-1]+<a class="code" href="classTrFit.html#p12">_bz</a>[i])/2;
00393 
00394     pintx[i][0] = (u[1]*<a class="code" href="classTrFit.html#p12">_bz</a>[i-1]-u[2]*<a class="code" href="classTrFit.html#p11">_by</a>[i-1])/2;
00395     pintx[i][1] = (u[2]*<a class="code" href="classTrFit.html#p10">_bx</a>[i-1]-u[0]*<a class="code" href="classTrFit.html#p12">_bz</a>[i-1])/2;
00396     pintx[i][2] = (u[0]*<a class="code" href="classTrFit.html#p11">_by</a>[i-1]-u[1]*<a class="code" href="classTrFit.html#p10">_bx</a>[i-1])/2;
00397 
00398     pintu[i][0] = u[1]*baz-u[2]*bay;
00399     pintu[i][1] = u[2]*bax-u[0]*baz;
00400     pintu[i][2] = u[0]*bay-u[1]*bax;
00401   }
00402 
00403   <span class="comment">// F and G matrices</span>
00404   <span class="keywordtype">double</span> d[2*LMAX][NDIM];
00405   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00406     <span class="keywordtype">int</span> ix = i, iy = i+_nhit;
00407 
00408     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; NDIM; j++) d[ix][j] = d[iy][j] = 0;
00409     d[ix][0] = d[iy][1] = 1;
00410     
00411     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt;= i; j++) {
00412       d[ix][2] += len[j];
00413       d[iy][3] += len[j];
00414 
00415       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt;= j; k++) {
00416         <span class="keywordflow">if</span> (k == j) {
00417           d[ix][4] += len[j]*len[j]*pintx[j][0];
00418           d[iy][4] += len[j]*len[j]*pintx[j][1];
00419         } <span class="keywordflow">else</span> {
00420           d[ix][4] += len[j]*len[k]*pintu[k][0];
00421           d[iy][4] += len[j]*len[k]*pintu[k][1];
00422         }
00423       }
00424     }
00425   }
00426 
00427   <span class="comment">// dx = F*S_x*x + G*S_y*y</span>
00428   <span class="keywordtype">double</span> dx[NDIM];
00429   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; NDIM; j++) {
00430     dx[j] = 0;
00431     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00432       <span class="keywordtype">int</span> ix = i, iy = i+_nhit;
00433       dx[j] += d[ix][j]/<a class="code" href="classTrFit.html#p4">_xs</a>[i]/<a class="code" href="classTrFit.html#p4">_xs</a>[i]*<a class="code" href="classTrFit.html#p1">_xh</a>[i]*1e-8;
00434       dx[j] += d[iy][j]/<a class="code" href="classTrFit.html#p5">_ys</a>[i]/<a class="code" href="classTrFit.html#p5">_ys</a>[i]*<a class="code" href="classTrFit.html#p2">_yh</a>[i]*1e-8;
00435     }
00436   }
00437 
00438   <span class="comment">// cov = F*S_x*F + G*S_y*G</span>
00439   <span class="keywordtype">double</span> cov[NDIM][NDIM];
00440   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; NDIM; j++) {
00441     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; NDIM; k++) {
00442       cov[j][k] = 0.;
00443       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00444         <span class="keywordtype">int</span> ix = i, iy = i+_nhit;
00445         cov[j][k] += d[ix][j]/<a class="code" href="classTrFit.html#p4">_xs</a>[i]/<a class="code" href="classTrFit.html#p4">_xs</a>[i]*d[ix][k]*1e-8;
00446         cov[j][k] += d[iy][j]/<a class="code" href="classTrFit.html#p5">_ys</a>[i]/<a class="code" href="classTrFit.html#p5">_ys</a>[i]*d[iy][k]*1e-8;
00447       } 
00448     }
00449   }
00450         
00451   <span class="comment">// cov^{-1}</span>
00452   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#e1">Inv55</a>(cov)) <span class="keywordflow">return</span> -1;
00453 
00454   <span class="comment">// Solution</span>
00455   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; NDIM; k++) {
00456     <a class="code" href="classTrFit.html#p13">_param</a>[k] = 0;
00457     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM; i++) <a class="code" href="classTrFit.html#p13">_param</a>[k] += cov[k][i]*dx[i];
00458   }
00459 
00460   <span class="comment">// Chisquare</span>
00461   <a class="code" href="classTrFit.html#p14">_chisqx</a> = <a class="code" href="classTrFit.html#p15">_chisqy</a> = 0;
00462   <a class="code" href="classTrFit.html#p16">_ndofx</a> = <a class="code" href="classTrFit.html#p17">_ndofy</a> = 0;
00463   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;_nhit; i++) {
00464     <a class="code" href="classTrFit.html#p7">_xr</a>[i] = <a class="code" href="classTrFit.html#p1">_xh</a>[i]*1.e4;
00465     <a class="code" href="classTrFit.html#p8">_yr</a>[i] = <a class="code" href="classTrFit.html#p2">_yh</a>[i]*1.e4;
00466 
00467     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; NDIM; k++) {
00468       <span class="keywordtype">int</span> ix = i, iy = i+_nhit;
00469       <a class="code" href="classTrFit.html#p7">_xr</a>[i] -= d[ix][k]*<a class="code" href="classTrFit.html#p13">_param</a>[k]*1e4;
00470       <a class="code" href="classTrFit.html#p8">_yr</a>[i] -= d[iy][k]*<a class="code" href="classTrFit.html#p13">_param</a>[k]*1e4;
00471     }
00472     <a class="code" href="classTrFit.html#p14">_chisqx</a> += <a class="code" href="classTrFit.html#p7">_xr</a>[i]*<a class="code" href="classTrFit.html#p7">_xr</a>[i]/<a class="code" href="classTrFit.html#p4">_xs</a>[i]/<a class="code" href="classTrFit.html#p4">_xs</a>[i]*1e-8; <a class="code" href="classTrFit.html#p16">_ndofx</a>++;
00473     <a class="code" href="classTrFit.html#p15">_chisqy</a> += <a class="code" href="classTrFit.html#p8">_yr</a>[i]*<a class="code" href="classTrFit.html#p8">_yr</a>[i]/<a class="code" href="classTrFit.html#p5">_ys</a>[i]/<a class="code" href="classTrFit.html#p5">_ys</a>[i]*1e-8; <a class="code" href="classTrFit.html#p17">_ndofy</a>++;
00474   }
00475 
00476   <a class="code" href="classTrFit.html#p16">_ndofx</a> -= 2;
00477   <a class="code" href="classTrFit.html#p17">_ndofy</a> -= 3;
00478 
00479   <span class="keywordflow">return</span> <a class="code" href="classTrFit.html#p14">_chisqx</a>+_chisqy;
00480 }
00481 
<a name="l00482"></a><a class="code" href="classTrFit.html#a20">00482</a> <span class="keywordtype">double</span> <a class="code" href="classTrFit.html#a20">TrFit::NormalFit</a>(<span class="keywordtype">void</span>)
00483 {
00484   <span class="keywordflow">if</span>(<a class="code" href="classTrFit.html#p0">_nhit</a> &gt; <a class="code" href="classTrFit.html#w7w1">LMAX</a> || 2*<a class="code" href="classTrFit.html#p0">_nhit</a> &lt;= 5 || <a class="code" href="classTrFit.html#p21">_chrg</a> == 0) <span class="keywordflow">return</span> -1;
00485 
00486   <span class="comment">// Set initial parameters</span>
00487   <span class="keywordtype">double</span> r = std::sqrt((<a class="code" href="classTrFit.html#p1">_xh</a>[1]-<a class="code" href="classTrFit.html#p1">_xh</a>[0])*(_xh[1]-_xh[0])+
00488                        (<a class="code" href="classTrFit.html#p2">_yh</a>[1]-<a class="code" href="classTrFit.html#p2">_yh</a>[0])*(_yh[1]-_yh[0])+
00489                        (<a class="code" href="classTrFit.html#p3">_zh</a>[1]-<a class="code" href="classTrFit.html#p3">_zh</a>[0])*(_zh[1]-_zh[0]));
00490   <span class="keywordtype">double</span> nx = (_xh[1]-_xh[0])/r;
00491   <span class="keywordtype">double</span> ny = (_yh[1]-_yh[0])/r;
00492   <span class="keywordtype">double</span> nz = (_zh[1]-_zh[0])/r;
00493   <span class="keywordtype">double</span> pi = 10000;
00494 
00495   <a class="code" href="classTrFit.html#p13">_param</a>[0] = _xh[0]; <a class="code" href="classTrFit.html#p13">_param</a>[1]=nx/nz;
00496   <a class="code" href="classTrFit.html#p13">_param</a>[2] = _yh[0]; <a class="code" href="classTrFit.html#p13">_param</a>[3]=ny/nz;
00497   <a class="code" href="classTrFit.html#p13">_param</a>[4] = <a class="code" href="classTrFit.html#p21">_chrg</a>/pi;
00498 
00499   <span class="keywordtype">int</span> maxcal = 8;
00500 
00501   <span class="keywordtype">double</span> tol = 1.e-2;
00502 
00503   <span class="comment">// Multiple scattering constant</span>
00504   <span class="keywordtype">double</span> xls = 300.e-4;
00505   <span class="keywordtype">double</span> rls = 9.36;
00506   <span class="keywordtype">double</span> sms = 13.6e-3*std::sqrt(xls/rls);
00507 
00508   <span class="keywordtype">double</span> chisqb = 0;
00509 
00510   <span class="keywordtype">int</span> ifail = 2;
00511 
00512   <span class="keywordtype">double</span> init[7], out[7];
00513 
00514   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kiter = 0; kiter &lt; maxcal; kiter++) {
00515     <span class="keywordtype">double</span> dnorm = 1./std::sqrt(1+<a class="code" href="classTrFit.html#p13">_param</a>[1]*<a class="code" href="classTrFit.html#p13">_param</a>[1]+<a class="code" href="classTrFit.html#p13">_param</a>[3]*<a class="code" href="classTrFit.html#p13">_param</a>[3]);
00516     init[0] =  _param[0];
00517     init[1] =  _param[2];
00518     init[2] =  _zh[0]+1e-4;
00519     init[3] = -_param[1]*dnorm;
00520     init[4] = -_param[3]*dnorm;
00521     init[5] = -dnorm;
00522     init[6] = (_param[4] != 0) ? <a class="code" href="classTrFit.html#p21">_chrg</a>/_param[4] : 1.e10;
00523 
00524     <span class="keywordtype">double</span> mm[NDIM][NDIM], gg[NDIM][NDIM], g[NDIM];
00525     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classTrFit.html#w7w0">NDIM</a>*NDIM; i++) mm[i/NDIM][i%NDIM] = 0;
00526     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM*NDIM; i++) gg[i/NDIM][i%NDIM] = 0;
00527     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM; i++) g[i] = 0;
00528     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM; i++) mm[i][i] = 1;
00529 
00530     <span class="keywordtype">double</span> fact[LMAX], xmsr[LMAX][LMAX], xms[LMAX], fckx[LMAX], fcky[LMAX];
00531 
00532     <span class="comment">// Loop for each point</span>
00533     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00534 
00535       <span class="comment">// Transportation</span>
00536       <span class="keywordflow">if</span> (i &gt; 0) <a class="code" href="classTrFit.html#a25">VCFitPar</a>(init, out, _zh[i], mm, (i &lt;= 1) ? 0 : 1);
00537       <span class="keywordflow">else</span> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 7; j++) out[j] = init[j];
00538 
00539       <span class="comment">// Multiple scattering factor</span>
00540       <span class="keywordtype">double</span> dnm = init[5];
00541       <span class="keywordtype">double</span> mmt = init[6];
00542       <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#s0">_ims</a> == 0 || i &lt;= 1) fact[i] = 0;
00543       <span class="keywordflow">else</span> {
00544         <span class="keywordtype">double</span> beta = std::max(fabs(mmt/sqrt(mmt*mmt+<a class="code" href="classTrFit.html#p20">_xmass</a>*<a class="code" href="classTrFit.html#p20">_xmass</a>)), 0.1);
00545         fact[i] = (sms*<a class="code" href="classTrFit.html#p21">_chrg</a>/mmt/beta)*(sms*<a class="code" href="classTrFit.html#p21">_chrg</a>/mmt/beta)/fabs(dnm);
00546       }
00547 
00548       <span class="comment">// Multiple scattering matrix</span>
00549       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = i; im &gt;= 0; im--) {
00550         xmsr[i][im] = 0;
00551         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> il = 1; il &lt;= std::min(i,im)-1; il++)
00552           xmsr[i][im] += (_zh[i]-_zh[il])*(_zh[im]-_zh[il])*fact[il+1];
00553 
00554         <span class="keywordflow">if</span> (im == i) xms[i] = xmsr[i][i];
00555         <span class="keywordflow">else</span> {
00556           <span class="keywordtype">double</span> tmp1 = 2*xms[i]+(<a class="code" href="classTrFit.html#p4">_xs</a>[i]*<a class="code" href="classTrFit.html#p4">_xs</a>[i]+
00557                                   <a class="code" href="classTrFit.html#p5">_ys</a>[i]*<a class="code" href="classTrFit.html#p5">_ys</a>[i])*dnm*dnm
00558                      +(1-dnm*dnm)*<a class="code" href="classTrFit.html#p6">_zs</a>[i]*<a class="code" href="classTrFit.html#p6">_zs</a>[i]+1.e-10;
00559           <span class="keywordtype">double</span> tmp2 = 2*xms[im]+(<a class="code" href="classTrFit.html#p4">_xs</a>[im]*<a class="code" href="classTrFit.html#p4">_xs</a>[im]+
00560                                    <a class="code" href="classTrFit.html#p5">_ys</a>[im]*<a class="code" href="classTrFit.html#p5">_ys</a>[im])*dnm*dnm
00561                       +(1-dnm*dnm)*<a class="code" href="classTrFit.html#p6">_zs</a>[im]*<a class="code" href="classTrFit.html#p6">_zs</a>[im]+1.e-10;
00562           xmsr[i][im] = 2*xmsr[i][im]/std::sqrt(tmp1*tmp2);
00563         }
00564       }
00565 
00566       <span class="comment">// Error matrix</span>
00567       <span class="keywordtype">double</span> aa[5];
00568       <a class="code" href="classTrFit.html#a27">VCErrMtx</a>(i, xms[i], out, aa, fckx[i], fcky[i]);
00569 
00570       <span class="comment">// Covariance matrix</span>
00571       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; NDIM; j++) {
00572         g[j] += 2*(mm[j][0]*(aa[0]*aa[3]+aa[1]*aa[4])+
00573                    mm[j][2]*(aa[2]*aa[4]+aa[1]*aa[3]));
00574 
00575         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; NDIM; k++)
00576           gg[j][k] += 2*(aa[0]* mm[k][0]*mm[j][0]+
00577                          aa[2]* mm[k][2]*mm[j][2]+
00578                          aa[1]*(mm[k][0]*mm[j][2]+mm[k][2]*mm[j][0]));
00579       }
00580 
00581       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 7; j++) init[j] = out[j];
00582     }
00583 
00584     <span class="comment">// Chisquare</span>
00585     <a class="code" href="classTrFit.html#p14">_chisqx</a> = <a class="code" href="classTrFit.html#p15">_chisqy</a> = <a class="code" href="classTrFit.html#p18">_chisq</a> = 0;
00586     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _nhit; i++) {
00587       <a class="code" href="classTrFit.html#p14">_chisqx</a> += fckx[i];
00588       <a class="code" href="classTrFit.html#p15">_chisqy</a> += fcky[i];
00589       <a class="code" href="classTrFit.html#p18">_chisq</a>  += fckx[i]+fcky[i];
00590       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = i+1; k &lt; _nhit; k++) {
00591         <a class="code" href="classTrFit.html#p14">_chisqx</a> += std::sqrt(fabs( fckx[i]*fckx[k]) )*xmsr[k][i];
00592         <a class="code" href="classTrFit.html#p15">_chisqy</a> += std::sqrt(fabs( fcky[i]*fcky[k]) )*xmsr[k][i];
00593         <a class="code" href="classTrFit.html#p18">_chisq</a>  += std::sqrt(fabs((fckx[i]+fcky[i])
00594                                  *(fckx[k]+fcky[k])))*xmsr[k][i];
00595 
00596       }
00597     }
00598 
00599     <span class="comment">// Check chisquare difference</span>
00600     <span class="keywordtype">double</span> dlt = (<a class="code" href="classTrFit.html#p18">_chisq</a>-chisqb)/(chisqb+2*_nhit-5+1.e-3);
00601     <span class="keywordflow">if</span> (fabs(dlt) &lt;= tol) {
00602       ifail = 0;
00603       <span class="keywordflow">break</span>;
00604     }
00605     chisqb = _chisq;
00606 
00607     <span class="comment">// Invert covariance matrix</span>
00608     <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#e1">TrFit::Inv55</a>(gg) &lt; 0) <span class="keywordflow">return</span> -1;
00609 
00610     <span class="comment">// Error of rigidity</span>
00611     <a class="code" href="classTrFit.html#p19">_erig</a> = std::sqrt(2*gg[4][4]);
00612 
00613     <span class="comment">// Solved parameters</span>
00614     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM; i++) {
00615       <span class="keywordtype">double</span> sol = (gg[0][i]*g[0]+gg[1][i]*g[1]+
00616                     gg[2][i]*g[2]+gg[3][i]*g[3]+gg[4][i]*g[4]);
00617       _param[i] += (i &lt;= 3) ? -sol : sol;
00618     }
00619 
00620     <span class="comment">// Check parameter range</span>
00621     <span class="keywordflow">if</span> (_param[4] &lt;= -10) _param[4] = -10;
00622     <span class="keywordflow">if</span> (_param[4] &gt;=  10) _param[4] =  10;
00623   }
00624 
00625   <span class="keywordflow">if</span> (ifail) <span class="keywordflow">return</span> -1;
00626 
00627   <a class="code" href="classTrFit.html#p16">_ndofx</a> = <a class="code" href="classTrFit.html#p0">_nhit</a>-2;
00628   <a class="code" href="classTrFit.html#p17">_ndofy</a> = <a class="code" href="classTrFit.html#p0">_nhit</a>-3;
00629 
00630   <a class="code" href="classTrFit.html#p13">_param</a>[4] = <a class="code" href="classTrFit.html#p13">_param</a>[4]*<a class="code" href="classTrFit.html#p21">_chrg</a>/std::fabs(<a class="code" href="classTrFit.html#p21">_chrg</a>);
00631   <span class="keywordflow">return</span> _chisq;
00632 }
00633 
00634 <span class="keywordtype">void</span> <a class="code" href="classTrFit.html#a25">TrFit::VCFitPar</a>(<span class="keywordtype">double</span> *init, <span class="keywordtype">double</span> *out, 
00635                      <span class="keywordtype">double</span> pz, <span class="keywordtype">double</span> m55[][NDIM], <span class="keywordtype">int</span> clear)
00636 {
00637   <span class="keywordtype">double</span> steps   = 0.03;
00638   <span class="keywordtype">double</span> smax    = 50;
00639   <span class="keywordtype">double</span> cconv   = 5.e-4;
00640   <span class="keywordtype">double</span> fieldmm = 20;
00641   <span class="keywordtype">double</span> tmaxf   = 0.2;
00642   <span class="keywordtype">double</span> pii     = 3.1415927;
00643   <span class="keywordtype">double</span> cfld    = 3333.*pii/180./(fieldmm+1.e-10)*tmaxf;
00644   <span class="keywordtype">double</span> sfield  = cfld*fabs(init[6]/_chrg);
00645 
00646   <span class="keywordtype">int</span> nitm = 1000;
00647 
00648   <span class="keywordtype">double</span> xmat[NDIM][NDIM];
00649 
00650   <span class="keywordtype">int</span> ich = 0;
00651   <span class="keywordtype">double</span> za = out[2];
00652   <span class="keywordtype">double</span> vin[7];
00653   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) vin[i] = out[i] = init[i];
00654 
00655   <span class="keywordtype">double</span> sdist = out[2]-pz;
00656 
00657   <span class="keywordflow">if</span> (sdist &lt; 0) {
00658     vin[3] = out[3] = -init[3];
00659     vin[4] = out[4] = -init[4];
00660     vin[5] = out[5] = -init[5];
00661   }
00662 
00663   <span class="keywordtype">double</span> pini = <a class="code" href="classTrFit.html#p21">_chrg</a>/init[6];
00664 
00665   <span class="keywordtype">int</span> nit = 0, imat = 0;
00666   <span class="keywordflow">while</span> (++nit &lt;= nitm &amp;&amp; imat == 0) {
00667     sdist = out[2]-pz;
00668 
00669     <span class="keywordtype">double</span> sd2 = -out[5];
00670     sdist = sdist/(sd2+1.e-10);
00671 
00672     <span class="keywordflow">if</span> (std::min(sfield, smax) &lt;= 0 || fabs(sdist) &lt; cconv) {
00673       <span class="keywordtype">double</span> h = out[2]-za;
00674 
00675       <span class="keywordflow">if</span> (fabs(h) &gt; steps &amp;&amp; imat++ == 0) {
00676         <span class="keywordtype">double</span> der[10];
00677         <a class="code" href="classTrFit.html#a26">VCFuncXY</a>(vin, out, der, clear);
00678 
00679         <span class="keywordtype">double</span> dfx  = der[0]*h*pini, dfy  = der[1]*h*pini;
00680         <span class="keywordtype">double</span> dfxp = der[2]*h*pini, dfyp = der[3]*h*pini;
00681         <span class="keywordtype">double</span> dgx  = der[4]*h*pini, dgy  = der[5]*h*pini;
00682         <span class="keywordtype">double</span> dgxp = der[6]*h*pini, dgyp = der[7]*h*pini;
00683         <span class="keywordtype">double</span> fm = der[8], gm = der[9];
00684 
00685         xmat[0][0] = 1+0.5*h*dfx;  xmat[2][0] = 0.5*h*dfy;
00686         xmat[1][0] = h+0.5*h*dfxp; xmat[3][0] = 0.5*h*dfyp;
00687         xmat[4][0] = fm*h*h/2.;
00688 
00689         xmat[0][1] = dfx;    xmat[2][1] = dfy;
00690         xmat[1][1] = 1+dfxp; xmat[3][1] = dfyp;
00691         xmat[4][1] = h*fm;
00692 
00693         xmat[0][2] = 0.5*h*dgx;  xmat[2][2] = 1+0.5*h*dgy;
00694         xmat[1][2] = 0.5*h*dgxp; xmat[3][2] = h+0.5*h*dgyp;
00695         xmat[4][2] = 0.5*h*h*gm;
00696 
00697         xmat[0][3] = dgx;  xmat[2][3] = dgy;
00698         xmat[1][3] = dfxp; xmat[3][3] = 1+dgyp;
00699         xmat[4][3] = h*gm;
00700 
00701         xmat[0][4] = xmat[1][4] = xmat[2][4] = xmat[3][4] = 0;
00702         xmat[4][4] = 1;
00703       }
00704       <span class="keywordflow">else</span> {
00705         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM*NDIM; i++) 
00706           xmat[i/NDIM][i%NDIM] = (i/NDIM == i%NDIM) ? 1 : 0;
00707       }
00708 
00709       za = out[2];
00710     }
00711 
00712     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) vin[i] = out[i];
00713 
00714     <span class="keywordflow">if</span> (fabs(sdist) &lt; cconv) <span class="keywordflow">break</span>;
00715     <span class="keywordflow">if</span> (sdist &lt; 0) {
00716       sdist = -sdist;
00717       ich++;
00718       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 3; k &lt; 6; k++) vin[k] =- vin[k];
00719     }
00720 
00721     <span class="keywordtype">double</span> step = std::min(std::min(smax, sfield), sdist);
00722 
00723     <span class="keywordflow">if</span> (step &gt; steps) <a class="code" href="classTrFit.html#e2">Rkuta</a>(_chrg, step, vin, out);
00724     <span class="keywordflow">else</span> {
00725       out[0] = vin[0]+step*vin[3];
00726       out[1] = vin[1]+step*vin[4];
00727       out[2] = vin[2]+step*vin[5];
00728       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) out[3+i] = vin[3+i];
00729     }
00730   }
00731 
00732   <span class="keywordflow">if</span> (ich%2 != 0) <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 3; k &lt; 6; k++) out[k] =- out[k];
00733 
00734   <span class="keywordtype">double</span> dum[NDIM][NDIM];
00735   <a class="code" href="classTrFit.html#e0">Dmm55</a>(xmat, m55, dum);
00736 
00737   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NDIM*NDIM; i++) 
00738     m55[i/NDIM][i%NDIM] = dum[i/NDIM][i%NDIM];
00739 }
00740 
<a name="l00741"></a><a class="code" href="classTrFit.html#a26">00741</a> <span class="keywordtype">void</span> <a class="code" href="classTrFit.html#a26">TrFit::VCFuncXY</a>(<span class="keywordtype">double</span> *in, <span class="keywordtype">double</span> *out, <span class="keywordtype">double</span> *derl, <span class="keywordtype">int</span> clear)
00742 {
00743   <span class="keyword">static</span> <span class="keywordtype">double</span> der[2][10];
00744 
00745   <span class="keywordflow">if</span> (clear == 1) {
00746     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) der[0][i] = der[1][i];
00747   }
00748 
00749   <span class="keywordtype">float</span> xx[3], h[3], hxy[3][3], dx, dy;
00750 
00751   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = clear; k &lt; 2; k++) {
00752     <span class="keywordflow">if</span> (k == 0){
00753       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) xx[i] = in[i];
00754       dx = in[3]/in[5];
00755       dy = in[4]/in[5];
00756     }
00757     <span class="keywordflow">else</span> {
00758       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) xx[i] = out[i];
00759       dx = out[3]/out[5];
00760       dy = out[4]/out[5];
00761     }
00762 
00763     <span class="keywordtype">double</span> s = std::sqrt(1+dx*dx+dy*dy);
00764     TrField::GetPtr()-&gt;GuFld(xx, h);
00765     TrField::GetPtr()-&gt;TkFld(xx, hxy);
00766     
00767     der[k][0] = s*(dx*dy*hxy[0][0]-(1+dx*dx)*hxy[0][1]+dy*hxy[0][2]);
00768     der[k][1] = s*(dx*dy*hxy[1][0]-(1+dx*dx)*hxy[1][1]+dy*hxy[1][2]);
00769 
00770     der[k][2] = dx/s*(dx*dy*h[0]-(1+dx*dx)*h[1]+dy*h[2])+s*(dy*h[0]-2*dx*h[1]);
00771     der[k][3] = dy/s*(dx*dy*h[0]-(1+dx*dx)*h[1]+dy*h[2])+s*(dx*h[0]+h[2]);
00772 
00773     der[k][4] = s*((1+dy*dy)*hxy[0][0]-dx*dy*hxy[0][1]-dx*hxy[0][2]);
00774     der[k][5] = s*((1+dy*dy)*hxy[1][0]-dx*dy*hxy[1][1]-dx*hxy[1][2]);
00775 
00776     der[k][6] = dx/s*((1+dy*dy)*h[0]-dx*dy*h[1]-dx*h[2])-s*(dy*h[1]+h[2]);
00777     der[k][7] = dy/s*((1+dy*dy)*h[0]-dx*dy*h[1]-dx*h[2])+s*(2*dy*h[0]-dx*h[1]);
00778 
00779     der[k][8] = s*( dx*dy*h[0]-(1+dx*dx)*h[1]+dy*h[2]);
00780     der[k][9] = s*(-dx*dy*h[1]+(1+dy*dy)*h[0]-dx*h[2]);
00781   }
00782 
00783   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++)
00784     derl[i] = 2.997e-4*(der[0][i]+der[1][i])/2;
00785 }
00786 
<a name="l00787"></a><a class="code" href="classTrFit.html#a27">00787</a> <span class="keywordtype">void</span> <a class="code" href="classTrFit.html#a27">TrFit::VCErrMtx</a>(<span class="keywordtype">int</span> ih, <span class="keywordtype">double</span> xms, <span class="keywordtype">double</span> *out, <span class="keywordtype">double</span> *aa,
00788                      <span class="keywordtype">double</span> &amp;fckx, <span class="keywordtype">double</span> &amp;fcky)
00789 {
00790   <span class="keywordtype">double</span> mtmp[3];
00791   mtmp[0] = <a class="code" href="classTrFit.html#p4">_xs</a>[ih]*<a class="code" href="classTrFit.html#p4">_xs</a>[ih]+out[3]*out[3]*<a class="code" href="classTrFit.html#p6">_zs</a>[ih]*<a class="code" href="classTrFit.html#p6">_zs</a>[ih]/out[5]/out[5];
00792   mtmp[2] = <a class="code" href="classTrFit.html#p5">_ys</a>[ih]*<a class="code" href="classTrFit.html#p5">_ys</a>[ih]+out[4]*out[4]*<a class="code" href="classTrFit.html#p6">_zs</a>[ih]*<a class="code" href="classTrFit.html#p6">_zs</a>[ih]/out[5]/out[5];
00793   mtmp[1] = 0;
00794 
00795   <span class="keywordflow">if</span> (<a class="code" href="classTrFit.html#s0">_ims</a> != 0) {
00796     <span class="keywordtype">double</span> vv = xms/out[5]/out[5]/out[5]/out[5];
00797     mtmp[0] += vv*(1-out[4]*out[4]);
00798     mtmp[2] += vv*(1-out[3]*out[3]);
00799     mtmp[1] += vv*out[3]*out[4];
00800   }
00801 
00802   <span class="keywordtype">double</span> det = mtmp[0]*mtmp[2]-mtmp[1]*mtmp[1];
00803   <span class="keywordflow">if</span> (det != 0) {
00804     aa[0] =  mtmp[2]/det; 
00805     aa[1] = -mtmp[1]/det;
00806     aa[2] =  mtmp[0]/det; 
00807   }
00808   <span class="keywordflow">else</span> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) aa[i] = 0;
00809 
00810   <span class="keywordtype">double</span> xperp[4];
00811   xperp[0] = out[0]-out[3]/out[5]*out[2];
00812   xperp[1] = out[1]-out[4]/out[5]*out[2];
00813   xperp[2] = <a class="code" href="classTrFit.html#p1">_xh</a>[ih]-out[3]/out[5]*<a class="code" href="classTrFit.html#p3">_zh</a>[ih];
00814   xperp[3] = <a class="code" href="classTrFit.html#p2">_yh</a>[ih]-out[4]/out[5]*_zh[ih];
00815 
00816   aa[3] = xperp[0]-xperp[2];
00817   aa[4] = xperp[1]-xperp[3];
00818 
00819   fckx = fcky = 0;
00820   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++)
00821     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00822       <span class="keywordtype">double</span> fck = (xperp[i]-xperp[i+2])*aa[i+j]*(xperp[j]-xperp[j+2]);
00823       <span class="keywordflow">if</span> (i == 0) fckx += fck;
00824       <span class="keywordflow">else</span>        fcky += fck;
00825     }
00826 }
00827 
<a name="l00828"></a><a class="code" href="classTrFit.html#e0">00828</a> <span class="keywordtype">void</span> <a class="code" href="classTrFit.html#e0">TrFit::Dmm55</a>(<span class="keywordtype">double</span> AA[][5], <span class="keywordtype">double</span> BB[][5], <span class="keywordtype">double</span> CC[][5])
00829 {
00830 <span class="comment">/*</span>
00831 <span class="comment">*** ---------------------------------------------                     05/07/81</span>
00832 <span class="comment">*** MULTIPLICATION OF 5X5 MATRICES: A*B -&gt; C.</span>
00833 <span class="comment">*** FOR:I,J=1,5   C(I,J)=SUM:K=1,5(A(I,K)B(K,J))</span>
00834 <span class="comment">*** NB: B AND C MAY WELL BE THE SAME MATRIX</span>
00835 <span class="comment"></span>
00836 <span class="comment">        Author: A. Haas (Freiburg University)</span>
00837 <span class="comment"></span>
00838 <span class="comment">C *** ---------------------------------------------</span>
00839 <span class="comment"></span>
00840 <span class="comment">   Imported to C++ by SH</span>
00841 <span class="comment">*/</span>
00842 
00843   <span class="keywordtype">double</span> A[25], B[25], C[25];
00844   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 25; i++) {
00845     A[i] = AA[i/5][i%5];
00846     B[i] = BB[i/5][i%5];
00847   }
00848 
00849   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> J5 = 4; J5 &lt; 25; J5 += 5) {
00850     <span class="keywordtype">double</span> B5J = B[J5]; <span class="keywordtype">int</span> J4 = J5-1;
00851     <span class="keywordtype">double</span> B4J = B[J4]; <span class="keywordtype">int</span> J3 = J4-1;
00852     <span class="keywordtype">double</span> B3J = B[J3]; <span class="keywordtype">int</span> J2 = J3-1;
00853     <span class="keywordtype">double</span> B2J = B[J2]; <span class="keywordtype">int</span> J1 = J2-1;
00854     <span class="keywordtype">double</span> B1J = B[J1];
00855 
00856     C[J1] = A[0]*B1J+A[5]*B2J+A[10]*B3J+A[15]*B4J+A[20]*B5J;
00857     C[J2] = A[1]*B1J+A[6]*B2J+A[11]*B3J+A[16]*B4J+A[21]*B5J;
00858     C[J3] = A[2]*B1J+A[7]*B2J+A[12]*B3J+A[17]*B4J+A[22]*B5J;
00859     C[J4] = A[3]*B1J+A[8]*B2J+A[13]*B3J+A[18]*B4J+A[23]*B5J;
00860     C[J5] = A[4]*B1J+A[9]*B2J+A[14]*B3J+A[19]*B4J+A[24]*B5J;
00861   }
00862 
00863   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 25; i++) CC[i/5][i%5] = C[i];
00864 }
00865 
<a name="l00866"></a><a class="code" href="classTrFit.html#e1">00866</a> <span class="keywordtype">int</span> <a class="code" href="classTrFit.html#e1">TrFit::Inv55</a>(<span class="keywordtype">double</span> M[5][5])
00867 {
00869 <span class="comment">//                                                                      //</span>
00870 <span class="comment">// TMatrixTCramerInv                                                    //</span>
00871 <span class="comment">//                                                                      //</span>
00872 <span class="comment">// Authors: Fons Rademakers, Eddy Offermann  Jan 2004                   //</span>
00873 <span class="comment">//                                                                      //</span>
00874 <span class="comment">// Encapsulate templates of Cramer Inversion routines.                  //</span>
00875 <span class="comment">//                                                                      //</span>
00876 <span class="comment">// Adapted from routines written by                                     //</span>
00877 <span class="comment">// Mark Fischler and Steven Haywood as part of the CLHEP package        //</span>
00878 <span class="comment">//                                                                      //</span>
00879 <span class="comment">// Although for sizes &lt;= 6x6 the Cramer Inversion has a gain in speed   //</span>
00880 <span class="comment">// compared to factorization schemes (like LU) , one pays a price in    //</span>
00881 <span class="comment">// accuracy                                                             //</span>
00882 <span class="comment">//                                                                      //</span>
00883 <span class="comment">// For Example:                                                         //</span>
00884 <span class="comment">//  H * H^-1 = U, where H is a 5x5 Hilbert matrix                       //</span>
00885 <span class="comment">//                      U is a 5x5 Unity matrix                         //</span>
00886 <span class="comment">//                                                                      //</span>
00887 <span class="comment">// LU    : |U_jk| &lt; 10e-13 for  j!=k                                    //</span>
00888 <span class="comment">// Cramer: |U_jk| &lt; 10e-7  for  j!=k                                    //</span>
00889 <span class="comment">//                                                                      //</span>
00890 <span class="comment">//  however Cramer algorithm is about 10 (!) times faster               //</span>
00892 <span class="comment"></span><span class="comment">//</span>
00893 <span class="comment">// Imported by SH</span>
00894 
00895   <span class="comment">// Find all NECESSARY 2x2 dets:  (30 of them)</span>
00896   <span class="keywordtype">double</span> d2_23_01 = M[2][0]*M[3][1] - M[2][1]*M[3][0];
00897   <span class="keywordtype">double</span> d2_23_02 = M[2][0]*M[3][2] - M[2][2]*M[3][0];
00898   <span class="keywordtype">double</span> d2_23_03 = M[2][0]*M[3][3] - M[2][3]*M[3][0];
00899   <span class="keywordtype">double</span> d2_23_04 = M[2][0]*M[3][4] - M[2][4]*M[3][0];
00900   <span class="keywordtype">double</span> d2_23_12 = M[2][1]*M[3][2] - M[2][2]*M[3][1];
00901   <span class="keywordtype">double</span> d2_23_13 = M[2][1]*M[3][3] - M[2][3]*M[3][1];
00902   <span class="keywordtype">double</span> d2_23_14 = M[2][1]*M[3][4] - M[2][4]*M[3][1];
00903   <span class="keywordtype">double</span> d2_23_23 = M[2][2]*M[3][3] - M[2][3]*M[3][2];
00904   <span class="keywordtype">double</span> d2_23_24 = M[2][2]*M[3][4] - M[2][4]*M[3][2];
00905   <span class="keywordtype">double</span> d2_23_34 = M[2][3]*M[3][4] - M[2][4]*M[3][3];
00906   <span class="keywordtype">double</span> d2_24_01 = M[2][0]*M[4][1] - M[2][1]*M[4][0];
00907   <span class="keywordtype">double</span> d2_24_02 = M[2][0]*M[4][2] - M[2][2]*M[4][0];
00908   <span class="keywordtype">double</span> d2_24_03 = M[2][0]*M[4][3] - M[2][3]*M[4][0];
00909   <span class="keywordtype">double</span> d2_24_04 = M[2][0]*M[4][4] - M[2][4]*M[4][0];
00910   <span class="keywordtype">double</span> d2_24_12 = M[2][1]*M[4][2] - M[2][2]*M[4][1];
00911   <span class="keywordtype">double</span> d2_24_13 = M[2][1]*M[4][3] - M[2][3]*M[4][1];
00912   <span class="keywordtype">double</span> d2_24_14 = M[2][1]*M[4][4] - M[2][4]*M[4][1];
00913   <span class="keywordtype">double</span> d2_24_23 = M[2][2]*M[4][3] - M[2][3]*M[4][2];
00914   <span class="keywordtype">double</span> d2_24_24 = M[2][2]*M[4][4] - M[2][4]*M[4][2];
00915   <span class="keywordtype">double</span> d2_24_34 = M[2][3]*M[4][4] - M[2][4]*M[4][3];
00916   <span class="keywordtype">double</span> d2_34_01 = M[3][0]*M[4][1] - M[3][1]*M[4][0];
00917   <span class="keywordtype">double</span> d2_34_02 = M[3][0]*M[4][2] - M[3][2]*M[4][0];
00918   <span class="keywordtype">double</span> d2_34_03 = M[3][0]*M[4][3] - M[3][3]*M[4][0];
00919   <span class="keywordtype">double</span> d2_34_04 = M[3][0]*M[4][4] - M[3][4]*M[4][0];
00920   <span class="keywordtype">double</span> d2_34_12 = M[3][1]*M[4][2] - M[3][2]*M[4][1];
00921   <span class="keywordtype">double</span> d2_34_13 = M[3][1]*M[4][3] - M[3][3]*M[4][1];
00922   <span class="keywordtype">double</span> d2_34_14 = M[3][1]*M[4][4] - M[3][4]*M[4][1];
00923   <span class="keywordtype">double</span> d2_34_23 = M[3][2]*M[4][3] - M[3][3]*M[4][2];
00924   <span class="keywordtype">double</span> d2_34_24 = M[3][2]*M[4][4] - M[3][4]*M[4][2];
00925   <span class="keywordtype">double</span> d2_34_34 = M[3][3]*M[4][4] - M[3][4]*M[4][3];
00926 
00927   <span class="comment">// Find all NECESSARY 3x3 dets:   (40 of them)</span>
00928   <span class="keywordtype">double</span> d3_123_012 = M[1][0]*d2_23_12 - M[1][1]*d2_23_02 + M[1][2]*d2_23_01;
00929   <span class="keywordtype">double</span> d3_123_013 = M[1][0]*d2_23_13 - M[1][1]*d2_23_03 + M[1][3]*d2_23_01;
00930   <span class="keywordtype">double</span> d3_123_014 = M[1][0]*d2_23_14 - M[1][1]*d2_23_04 + M[1][4]*d2_23_01;
00931   <span class="keywordtype">double</span> d3_123_023 = M[1][0]*d2_23_23 - M[1][2]*d2_23_03 + M[1][3]*d2_23_02;
00932   <span class="keywordtype">double</span> d3_123_024 = M[1][0]*d2_23_24 - M[1][2]*d2_23_04 + M[1][4]*d2_23_02;
00933   <span class="keywordtype">double</span> d3_123_034 = M[1][0]*d2_23_34 - M[1][3]*d2_23_04 + M[1][4]*d2_23_03;
00934   <span class="keywordtype">double</span> d3_123_123 = M[1][1]*d2_23_23 - M[1][2]*d2_23_13 + M[1][3]*d2_23_12;
00935   <span class="keywordtype">double</span> d3_123_124 = M[1][1]*d2_23_24 - M[1][2]*d2_23_14 + M[1][4]*d2_23_12;
00936   <span class="keywordtype">double</span> d3_123_134 = M[1][1]*d2_23_34 - M[1][3]*d2_23_14 + M[1][4]*d2_23_13;
00937   <span class="keywordtype">double</span> d3_123_234 = M[1][2]*d2_23_34 - M[1][3]*d2_23_24 + M[1][4]*d2_23_23;
00938   <span class="keywordtype">double</span> d3_124_012 = M[1][0]*d2_24_12 - M[1][1]*d2_24_02 + M[1][2]*d2_24_01;
00939   <span class="keywordtype">double</span> d3_124_013 = M[1][0]*d2_24_13 - M[1][1]*d2_24_03 + M[1][3]*d2_24_01;
00940   <span class="keywordtype">double</span> d3_124_014 = M[1][0]*d2_24_14 - M[1][1]*d2_24_04 + M[1][4]*d2_24_01;
00941   <span class="keywordtype">double</span> d3_124_023 = M[1][0]*d2_24_23 - M[1][2]*d2_24_03 + M[1][3]*d2_24_02;
00942   <span class="keywordtype">double</span> d3_124_024 = M[1][0]*d2_24_24 - M[1][2]*d2_24_04 + M[1][4]*d2_24_02;
00943   <span class="keywordtype">double</span> d3_124_034 = M[1][0]*d2_24_34 - M[1][3]*d2_24_04 + M[1][4]*d2_24_03;
00944   <span class="keywordtype">double</span> d3_124_123 = M[1][1]*d2_24_23 - M[1][2]*d2_24_13 + M[1][3]*d2_24_12;
00945   <span class="keywordtype">double</span> d3_124_124 = M[1][1]*d2_24_24 - M[1][2]*d2_24_14 + M[1][4]*d2_24_12;
00946   <span class="keywordtype">double</span> d3_124_134 = M[1][1]*d2_24_34 - M[1][3]*d2_24_14 + M[1][4]*d2_24_13;
00947   <span class="keywordtype">double</span> d3_124_234 = M[1][2]*d2_24_34 - M[1][3]*d2_24_24 + M[1][4]*d2_24_23;
00948   <span class="keywordtype">double</span> d3_134_012 = M[1][0]*d2_34_12 - M[1][1]*d2_34_02 + M[1][2]*d2_34_01;
00949   <span class="keywordtype">double</span> d3_134_013 = M[1][0]*d2_34_13 - M[1][1]*d2_34_03 + M[1][3]*d2_34_01;
00950   <span class="keywordtype">double</span> d3_134_014 = M[1][0]*d2_34_14 - M[1][1]*d2_34_04 + M[1][4]*d2_34_01;
00951   <span class="keywordtype">double</span> d3_134_023 = M[1][0]*d2_34_23 - M[1][2]*d2_34_03 + M[1][3]*d2_34_02;
00952   <span class="keywordtype">double</span> d3_134_024 = M[1][0]*d2_34_24 - M[1][2]*d2_34_04 + M[1][4]*d2_34_02;
00953   <span class="keywordtype">double</span> d3_134_034 = M[1][0]*d2_34_34 - M[1][3]*d2_34_04 + M[1][4]*d2_34_03;
00954   <span class="keywordtype">double</span> d3_134_123 = M[1][1]*d2_34_23 - M[1][2]*d2_34_13 + M[1][3]*d2_34_12;
00955   <span class="keywordtype">double</span> d3_134_124 = M[1][1]*d2_34_24 - M[1][2]*d2_34_14 + M[1][4]*d2_34_12;
00956   <span class="keywordtype">double</span> d3_134_134 = M[1][1]*d2_34_34 - M[1][3]*d2_34_14 + M[1][4]*d2_34_13;
00957   <span class="keywordtype">double</span> d3_134_234 = M[1][2]*d2_34_34 - M[1][3]*d2_34_24 + M[1][4]*d2_34_23;
00958   <span class="keywordtype">double</span> d3_234_012 = M[2][0]*d2_34_12 - M[2][1]*d2_34_02 + M[2][2]*d2_34_01;
00959   <span class="keywordtype">double</span> d3_234_013 = M[2][0]*d2_34_13 - M[2][1]*d2_34_03 + M[2][3]*d2_34_01;
00960   <span class="keywordtype">double</span> d3_234_014 = M[2][0]*d2_34_14 - M[2][1]*d2_34_04 + M[2][4]*d2_34_01;
00961   <span class="keywordtype">double</span> d3_234_023 = M[2][0]*d2_34_23 - M[2][2]*d2_34_03 + M[2][3]*d2_34_02;
00962   <span class="keywordtype">double</span> d3_234_024 = M[2][0]*d2_34_24 - M[2][2]*d2_34_04 + M[2][4]*d2_34_02;
00963   <span class="keywordtype">double</span> d3_234_034 = M[2][0]*d2_34_34 - M[2][3]*d2_34_04 + M[2][4]*d2_34_03;
00964   <span class="keywordtype">double</span> d3_234_123 = M[2][1]*d2_34_23 - M[2][2]*d2_34_13 + M[2][3]*d2_34_12;
00965   <span class="keywordtype">double</span> d3_234_124 = M[2][1]*d2_34_24 - M[2][2]*d2_34_14 + M[2][4]*d2_34_12;
00966   <span class="keywordtype">double</span> d3_234_134 = M[2][1]*d2_34_34 - M[2][3]*d2_34_14 + M[2][4]*d2_34_13;
00967   <span class="keywordtype">double</span> d3_234_234 = M[2][2]*d2_34_34 - M[2][3]*d2_34_24 + M[2][4]*d2_34_23;
00968 
00969   <span class="comment">// Find all NECESSARY 4x4 dets:   (25 of them)</span>
00970   <span class="keywordtype">double</span> d4_0123_0123 = M[0][0]*d3_123_123 - M[0][1]*d3_123_023 
00971                       + M[0][2]*d3_123_013 - M[0][3]*d3_123_012;
00972   <span class="keywordtype">double</span> d4_0123_0124 = M[0][0]*d3_123_124 - M[0][1]*d3_123_024 
00973                       + M[0][2]*d3_123_014 - M[0][4]*d3_123_012;
00974   <span class="keywordtype">double</span> d4_0123_0134 = M[0][0]*d3_123_134 - M[0][1]*d3_123_034 
00975                       + M[0][3]*d3_123_014 - M[0][4]*d3_123_013;
00976   <span class="keywordtype">double</span> d4_0123_0234 = M[0][0]*d3_123_234 - M[0][2]*d3_123_034 
00977                       + M[0][3]*d3_123_024 - M[0][4]*d3_123_023;
00978   <span class="keywordtype">double</span> d4_0123_1234 = M[0][1]*d3_123_234 - M[0][2]*d3_123_134 
00979                       + M[0][3]*d3_123_124 - M[0][4]*d3_123_123;
00980   <span class="keywordtype">double</span> d4_0124_0123 = M[0][0]*d3_124_123 - M[0][1]*d3_124_023 
00981                       + M[0][2]*d3_124_013 - M[0][3]*d3_124_012;
00982   <span class="keywordtype">double</span> d4_0124_0124 = M[0][0]*d3_124_124 - M[0][1]*d3_124_024 
00983                       + M[0][2]*d3_124_014 - M[0][4]*d3_124_012;
00984   <span class="keywordtype">double</span> d4_0124_0134 = M[0][0]*d3_124_134 - M[0][1]*d3_124_034 
00985                       + M[0][3]*d3_124_014 - M[0][4]*d3_124_013;
00986   <span class="keywordtype">double</span> d4_0124_0234 = M[0][0]*d3_124_234 - M[0][2]*d3_124_034 
00987                       + M[0][3]*d3_124_024 - M[0][4]*d3_124_023;
00988   <span class="keywordtype">double</span> d4_0124_1234 = M[0][1]*d3_124_234 - M[0][2]*d3_124_134 
00989                       + M[0][3]*d3_124_124 - M[0][4]*d3_124_123;
00990   <span class="keywordtype">double</span> d4_0134_0123 = M[0][0]*d3_134_123 - M[0][1]*d3_134_023 
00991                       + M[0][2]*d3_134_013 - M[0][3]*d3_134_012;
00992   <span class="keywordtype">double</span> d4_0134_0124 = M[0][0]*d3_134_124 - M[0][1]*d3_134_024 
00993                       + M[0][2]*d3_134_014 - M[0][4]*d3_134_012;
00994   <span class="keywordtype">double</span> d4_0134_0134 = M[0][0]*d3_134_134 - M[0][1]*d3_134_034 
00995                       + M[0][3]*d3_134_014 - M[0][4]*d3_134_013;
00996   <span class="keywordtype">double</span> d4_0134_0234 = M[0][0]*d3_134_234 - M[0][2]*d3_134_034 
00997                       + M[0][3]*d3_134_024 - M[0][4]*d3_134_023;
00998   <span class="keywordtype">double</span> d4_0134_1234 = M[0][1]*d3_134_234 - M[0][2]*d3_134_134 
00999                       + M[0][3]*d3_134_124 - M[0][4]*d3_134_123;
01000   <span class="keywordtype">double</span> d4_0234_0123 = M[0][0]*d3_234_123 - M[0][1]*d3_234_023 
01001                       + M[0][2]*d3_234_013 - M[0][3]*d3_234_012;
01002   <span class="keywordtype">double</span> d4_0234_0124 = M[0][0]*d3_234_124 - M[0][1]*d3_234_024 
01003                       + M[0][2]*d3_234_014 - M[0][4]*d3_234_012;
01004   <span class="keywordtype">double</span> d4_0234_0134 = M[0][0]*d3_234_134 - M[0][1]*d3_234_034 
01005                       + M[0][3]*d3_234_014 - M[0][4]*d3_234_013;
01006   <span class="keywordtype">double</span> d4_0234_0234 = M[0][0]*d3_234_234 - M[0][2]*d3_234_034 
01007                       + M[0][3]*d3_234_024 - M[0][4]*d3_234_023;
01008   <span class="keywordtype">double</span> d4_0234_1234 = M[0][1]*d3_234_234 - M[0][2]*d3_234_134 
01009                       + M[0][3]*d3_234_124 - M[0][4]*d3_234_123;
01010   <span class="keywordtype">double</span> d4_1234_0123 = M[1][0]*d3_234_123 - M[1][1]*d3_234_023 
01011                       + M[1][2]*d3_234_013 - M[1][3]*d3_234_012;
01012   <span class="keywordtype">double</span> d4_1234_0124 = M[1][0]*d3_234_124 - M[1][1]*d3_234_024 
01013                       + M[1][2]*d3_234_014 - M[1][4]*d3_234_012;
01014   <span class="keywordtype">double</span> d4_1234_0134 = M[1][0]*d3_234_134 - M[1][1]*d3_234_034 
01015                       + M[1][3]*d3_234_014 - M[1][4]*d3_234_013;
01016   <span class="keywordtype">double</span> d4_1234_0234 = M[1][0]*d3_234_234 - M[1][2]*d3_234_034 
01017                       + M[1][3]*d3_234_024 - M[1][4]*d3_234_023;
01018   <span class="keywordtype">double</span> d4_1234_1234 = M[1][1]*d3_234_234 - M[1][2]*d3_234_134 
01019                       + M[1][3]*d3_234_124 - M[1][4]*d3_234_123;
01020 
01021   <span class="comment">// Find the 5x5 det:</span>
01022 
01023   <span class="keywordtype">double</span> det = M[0][0]*d4_1234_1234
01024              - M[0][1]*d4_1234_0234
01025              + M[0][2]*d4_1234_0134
01026              - M[0][3]*d4_1234_0124
01027              + M[0][4]*d4_1234_0123;
01028   <span class="keywordflow">if</span> (det == 0) <span class="keywordflow">return</span> -1;
01029 
01030   M[0][0] =  d4_1234_1234/det;
01031   M[0][1] = -d4_0234_1234/det;
01032   M[0][2] =  d4_0134_1234/det;
01033   M[0][3] = -d4_0124_1234/det;
01034   M[0][4] =  d4_0123_1234/det;
01035 
01036   M[1][0] = -d4_1234_0234/det;
01037   M[1][1] =  d4_0234_0234/det;
01038   M[1][2] = -d4_0134_0234/det;
01039   M[1][3] =  d4_0124_0234/det;
01040   M[1][4] = -d4_0123_0234/det;
01041 
01042   M[2][0] =  d4_1234_0134/det;
01043   M[2][1] = -d4_0234_0134/det;
01044   M[2][2] =  d4_0134_0134/det;
01045   M[2][3] = -d4_0124_0134/det;
01046   M[2][4] =  d4_0123_0134/det;
01047 
01048   M[3][0] = -d4_1234_0124/det;
01049   M[3][1] =  d4_0234_0124/det;
01050   M[3][2] = -d4_0134_0124/det;
01051   M[3][3] =  d4_0124_0124/det;
01052   M[3][4] = -d4_0123_0124/det;
01053 
01054   M[4][0] =  d4_1234_0123/det;
01055   M[4][1] = -d4_0234_0123/det;
01056   M[4][2] =  d4_0134_0123/det;
01057   M[4][3] = -d4_0124_0123/det;
01058   M[4][4] =  d4_0123_0123/det;
01059 
01060   <span class="keywordflow">return</span> 0;
01061 }
01062 
<a name="l01063"></a><a class="code" href="classTrFit.html#e2">01063</a> <span class="keywordtype">void</span> <a class="code" href="classTrFit.html#e2">TrFit::Rkuta</a>(<span class="keywordtype">double</span> charge, <span class="keywordtype">double</span> step, <span class="keywordtype">double</span> *vect, <span class="keywordtype">double</span> *vout)
01064 {
01065 <span class="comment">/*</span>
01066 <span class="comment">C.</span>
01067 <span class="comment">C.    ******************************************************************</span>
01068 <span class="comment">C.    *                                                                *</span>
01069 <span class="comment">C.    *  Runge-Kutta method for tracking a particle through a magnetic *</span>
01070 <span class="comment">C.    *  field. Uses Nystroem algorithm (See Handbook Nat. Bur. of     *</span>
01071 <span class="comment">C.    *  Standards, procedure 25.5.20)                                 *</span>
01072 <span class="comment">C.    *                                                                *</span>
01073 <span class="comment">C.    *  Input parameters                                              *</span>
01074 <span class="comment">C.    *       CHARGE    Particle charge                                *</span>
01075 <span class="comment">C.    *       STEP      Step size                                      *</span>
01076 <span class="comment">C.    *       VECT      Initial co-ords,direction cosines,momentum     *</span>
01077 <span class="comment">C.    *  Output parameters                                             *</span>
01078 <span class="comment">C.    *       VOUT      Output co-ords,direction cosines,momentum      *</span>
01079 <span class="comment">C.    *  User routine called                                           *</span>
01080 <span class="comment">C.    *       CALL GUFLD(X,F)                                          *</span>
01081 <span class="comment">C.    *                                                                *</span>
01082 <span class="comment">C.    *    ==&gt;Called by : &lt;USER&gt;, GUSWIM                               *</span>
01083 <span class="comment">C.    *       Authors    R.Brun, M.Hansroul  *********                 *</span>
01084 <span class="comment">C.    *                  V.Perevoztchikov (CUT STEP implementation)    *</span>
01085 <span class="comment">C.    *                                                                *</span>
01086 <span class="comment">C.    *                                                                *</span>
01087 <span class="comment">C.    ******************************************************************</span>
01088 <span class="comment">C.</span>
01089 <span class="comment"></span>
01090 <span class="comment">   Imported to C++ by SH</span>
01091 <span class="comment">*/</span>
01092   <span class="keywordtype">float</span> F[4], X, Y, Z, XYZT[3];
01093   <span class="keywordtype">double</span> SECXS[4], SECYS[4], SECZS[4], HXP[3];
01094 
01095   <span class="keywordtype">int</span> MAXIT = 1992, MAXCUT = 11;
01096   <span class="keywordtype">double</span> EC  = 2.9979251e-4;
01097   <span class="keywordtype">double</span> DLT = 1e-4, DLT32 = DLT/32;
01098   <span class="keywordtype">double</span> PISQUA = .986960440109e+01;
01099 
01100   <span class="keywordtype">int</span> ITER = 0, NCUT = 0;
01101 
01102   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 7; j++) vout[j] = vect[j];
01103 
01104   <span class="keywordtype">double</span> PINV = EC*charge/vect[6], TL = 0, H = step;
01105 
01106   <span class="keywordflow">do</span> {
01107     <span class="keywordtype">double</span> REST = step-TL;
01108     <span class="keywordflow">if</span> (std::fabs(H) &gt; std::fabs(REST)) H = REST;
01109     <span class="keywordtype">float</span> vvout[3];
01110     vvout[0]=vout[0];
01111     vvout[1]=vout[1];
01112     vvout[2]=vout[2];
01113     TrField::GetPtr()-&gt;GuFld(vvout, F);
01114 <span class="comment">//</span>
01115 <span class="comment">//             Start of integration</span>
01116 <span class="comment">//</span>
01117     X = vout[0];
01118     Y = vout[1];
01119     Z = vout[2];
01120 
01121     <span class="keywordtype">double</span> A = vout[3];
01122     <span class="keywordtype">double</span> B = vout[4];
01123     <span class="keywordtype">double</span> C = vout[5];
01124 
01125     <span class="keywordtype">double</span> H2  = H/2;
01126     <span class="keywordtype">double</span> H4  = H2/2;
01127     <span class="keywordtype">double</span> PH  = PINV*H;
01128     <span class="keywordtype">double</span> PH2 = PH/2;
01129 
01130     SECXS[0] = (B*F[2]-C*F[1])*PH2;
01131     SECYS[0] = (C*F[0]-A*F[2])*PH2;
01132     SECZS[0] = (A*F[1]-B*F[0])*PH2;
01133 
01134     <span class="keywordtype">double</span> ANG2 = (SECXS[0]*SECXS[0]+SECYS[0]*SECYS[0]+SECZS[0]*SECZS[0]);
01135     <span class="keywordflow">if</span> (ANG2 &gt; PISQUA) <span class="keywordflow">break</span>;
01136 
01137     <span class="keywordtype">double</span> DXT = H2*A+H4*SECXS[0];
01138     <span class="keywordtype">double</span> DYT = H2*B+H4*SECYS[0];
01139     <span class="keywordtype">double</span> DZT = H2*C+H4*SECZS[0];
01140 
01141     XYZT[0] = X+DXT;
01142     XYZT[1] = Y+DYT;
01143     XYZT[2] = Z+DZT;
01144 <span class="comment">//</span>
01145 <span class="comment">//              Second intermediate point</span>
01146 <span class="comment">//</span>
01147     <span class="keywordtype">double</span> EST = std::fabs(DXT)+std::fabs(DYT)+std::fabs(DZT);
01148     <span class="keywordflow">if</span> (EST &lt;= H) {
01149     TrField::GetPtr()-&gt;GuFld(XYZT, F);
01150 
01151 
01152       <span class="keywordtype">double</span> AT = A+SECXS[0];
01153       <span class="keywordtype">double</span> BT = B+SECYS[0];
01154       <span class="keywordtype">double</span> CT = C+SECZS[0];
01155 
01156       SECXS[1] = (BT*F[2]-CT*F[1])*PH2;
01157       SECYS[1] = (CT*F[0]-AT*F[2])*PH2;
01158       SECZS[1] = (AT*F[1]-BT*F[0])*PH2;
01159 
01160       AT = A+SECXS[1];
01161       BT = B+SECYS[1];
01162       CT = C+SECZS[1];
01163 
01164       SECXS[2] = (BT*F[2]-CT*F[1])*PH2;
01165       SECYS[2] = (CT*F[0]-AT*F[2])*PH2;
01166       SECZS[2] = (AT*F[1]-BT*F[0])*PH2;
01167 
01168       DXT = H*(A+SECXS[2]);
01169       DYT = H*(B+SECYS[2]);
01170       DZT = H*(C+SECZS[2]);
01171 
01172       XYZT[0] = X+DXT;
01173       XYZT[1] = Y+DYT;
01174       XYZT[2] = Z+DZT;
01175 
01176       AT = A+2*SECXS[2];
01177       BT = B+2*SECYS[2];
01178       CT = C+2*SECZS[2];
01179 
01180       EST = std::fabs(DXT)+std::fabs(DYT)+std::fabs(DZT);
01181 
01182       <span class="keywordflow">if</span> (EST &lt;= 2.*std::fabs(H)) {
01183         TrField::GetPtr()-&gt;GuFld(XYZT, F);
01184 
01185         Z += (C+(SECZS[0]+SECZS[1]+SECZS[2])/3)*H;
01186         Y += (B+(SECYS[0]+SECYS[1]+SECYS[2])/3)*H;
01187         X += (A+(SECXS[0]+SECXS[1]+SECXS[2])/3)*H;
01188 
01189         SECXS[3] = (BT*F[2]-CT*F[1])* PH2;
01190         SECYS[3] = (CT*F[0]-AT*F[2])* PH2;
01191         SECZS[3] = (AT*F[1]-BT*F[0])* PH2;
01192 
01193         A += (SECXS[0]+SECXS[3]+2*(SECXS[1]+SECXS[2]))/3;
01194         B += (SECYS[0]+SECYS[3]+2*(SECYS[1]+SECYS[2]))/3;
01195         C += (SECZS[0]+SECZS[3]+2*(SECZS[1]+SECZS[2]))/3;
01196 
01197         EST = (std::fabs(SECXS[0]+SECXS[3]-(SECXS[1]+SECXS[2])))+
01198               (std::fabs(SECYS[0]+SECYS[3]-(SECYS[1]+SECYS[2])))+
01199               (std::fabs(SECZS[0]+SECZS[3]-(SECZS[1]+SECZS[2])));
01200 
01201         <span class="keywordflow">if</span> (EST &lt;= DLT &amp;&amp; std::fabs(H) &gt; 1.E-4) {
01202           NCUT = 0;
01203 
01204 <span class="comment">//               If too many iterations, go to HELIX</span>
01205           <span class="keywordflow">if</span> (++ITER &gt; MAXIT) <span class="keywordflow">break</span>;
01206 
01207           TL = TL+H;
01208           <span class="keywordflow">if</span> (EST &lt; (DLT32)) H *= 2;
01209 
01210           <span class="keywordtype">double</span> CBA = 1/std::sqrt(A*A+B*B+C*C);
01211           vout[0] = X;
01212           vout[1] = Y;
01213           vout[2] = Z;
01214           vout[3] = CBA*A;
01215           vout[4] = CBA*B;
01216           vout[5] = CBA*C;
01217 
01218           REST = step-TL;
01219           <span class="keywordflow">if</span> (step &lt; 0.) REST = -REST;
01220           <span class="keywordflow">if</span> (REST &gt; 1.E-5*std::fabs(step)) <span class="keywordflow">continue</span>;
01221 
01222           <span class="keywordflow">return</span>;
01223         }
01224       }
01225     }
01226 <span class="comment">//              CUT step</span>
01227 <span class="comment">//               If too many cuts , go to HELIX</span>
01228     H /= 2;
01229     NCUT++;
01230   } <span class="keywordflow">while</span> (NCUT &lt;= MAXCUT);
01231 
01232 
01233 <span class="comment">//              ANGLE TOO BIG, USE HELIX</span>
01234   <span class="keywordtype">double</span> F1  = F[0];
01235   <span class="keywordtype">double</span> F2  = F[1];
01236   <span class="keywordtype">double</span> F3  = F[2];
01237   <span class="keywordtype">double</span> F4  = std::sqrt(F1*F1+F2*F2+F3*F3);
01238   <span class="keywordtype">double</span> RHO = -F4*PINV;
01239   <span class="keywordtype">double</span> TET = RHO*step;
01240 
01241   <span class="keywordflow">if</span> (TET != 0.) {
01242     <span class="keywordtype">double</span> HNORM = 1/F4;
01243     F1 = F1*HNORM;
01244     F2 = F2*HNORM;
01245     F3 = F3*HNORM;
01246 
01247     HXP[0] = F2*vect[2]-F3*vect[1];
01248     HXP[1] = F3*vect[0]-F1*vect[2];
01249     HXP[2] = F1*vect[1]-F2*vect[0];
01250 
01251     <span class="keywordtype">double</span> HP = F1*vect[0]+F2*vect[1]+F3*vect[2];
01252 
01253     <span class="keywordtype">double</span> RHO1 = 1/RHO;
01254     <span class="keywordtype">double</span> SINT = std::sin(TET);
01255     <span class="keywordtype">double</span> COST = 2*std::sin(TET/2)*std::sin(TET/2);
01256 
01257     <span class="keywordtype">double</span> G1 = SINT*RHO1;
01258     <span class="keywordtype">double</span> G2 = COST*RHO1;
01259     <span class="keywordtype">double</span> G3 = (TET-SINT)*HP*RHO1;
01260     <span class="keywordtype">double</span> G4 = -COST;
01261     <span class="keywordtype">double</span> G5 = SINT;
01262     <span class="keywordtype">double</span> G6 = COST*HP;
01263  
01264     vout[0] = vect[0]+(G1*vect[0]+G2*HXP[0]+G3*F1);
01265     vout[1] = vect[1]+(G1*vect[1]+G2*HXP[1]+G3*F2);
01266     vout[2] = vect[2]+(G1*vect[2]+G2*HXP[2]+G3*F3);
01267  
01268     vout[0] = vect[0]+(G4*vect[0]+G5*HXP[0]+G6*F1);
01269     vout[1] = vect[1]+(G4*vect[1]+G5*HXP[1]+G6*F2);
01270     vout[2] = vect[2]+(G4*vect[2]+G5*HXP[2]+G6*F3);
01271   }
01272   <span class="keywordflow">else</span> {
01273     vout[0] = vect[0]+step*vect[0];
01274     vout[1] = vect[1]+step*vect[1];
01275     vout[2] = vect[2]+step*vect[2];
01276   }
01277 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Nov 18 18:21:03 2008 for  AMS Software: Geometry Classes by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
