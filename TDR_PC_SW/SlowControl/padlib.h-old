// file padlib.h
//
// Collection of Peter's aal software in one (well, in two) file(s).
//
// see file padlib.c
//
// A.Lebedev - Oct-2007...

//~----------------------------------------------------------------------------

#ifndef _PADLIB_H
#define _PADLIB_H

#include "tcplib.h"

//~============================================================================

#define PRINT_NEW_LINE_IF_NEEDED {if (new_line) {new_line = 0; printf("\n");}}

//~============================================================================

//  aalMutex.h   Wedge to support transportable mutex

//  Revision History
//    Aug 2004 by Peter Dennett
//      - Initial version 

#ifdef OS_LINUX

# define aalMutex_t          pthread_mutex_t
# define aalMutexInitializer PTHREAD_MUTEX_INITIALIZER
# define aalMutexInit(m, i)  pthread_mutex_init(m, i)
# define aalMutexDestroy(m)  pthread_mutex_destroy(m)
# define aalMutexLock(m)     pthread_mutex_lock(m)
# define aalMutexUnlock(m)   pthread_mutex_unlock(m)
#endif // OS_LINUX

#ifdef OS_ECOS
#ifndef OS_ECOS_KAPI
# define aalMutex_t          int
# define aalMutexInit(m, i)  
# define aalMutexDestroy(m)  
# define aalMutexLock(m)     
# define aalMutexUnlock(m)   
#else
# include <cyg/kernel/kapi.h>

# define aalMutex_t          cyg_mutex_t
# define aalMutexInit(m, i)  cyg_mutex_init(m)
# define aalMutexDestroy(m)  cyg_mutex_destroy(m)
# define aalMutexLock(m)     cyg_mutex_lock(m)
# define aalMutexUnlock(m)   cyg_mutex_unlock(m)
#endif
#endif

//~============================================================================

//  cmdopt.h   getopt_long replacement

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Lake Howard Hotel, Taiwan

#ifdef __cplusplus
extern "C" {
#endif


extern char *optarg;
extern int   optind;
extern int   opterr;
extern int   optopt;

#ifdef no_argument
# undef no_argument
#endif
#define no_argument 0

#ifdef required_argument
# undef required_argument
#endif
#define required_argument 1

#ifdef optional_argument
# undef optional_argument
#endif
#define optional_argument 2

struct _CmdOpt
{
  const char *name;
  int has_arg;
  int *flag;
  int val;
  const char *Description;
  const char *ArgName;
};

int CmdOptGet (int argc, char *const argv[], const char *optstring,
               const struct _CmdOpt *longopts, int *longindex);

void CmdOptUsage (const char *optstring, const struct _CmdOpt *longopts);

#ifdef __cplusplus
}
#endif

//~============================================================================

//  apid.h   Information about our APIDS

//  Revision History
//    Nov 2003 by Peter Dennett
//      - Initial version
//    Jul 2004 by Peter Dennett
//      - Changed from table to callable

//  Define our APID values

typedef struct _APIDNameEnt
{
  char Name[20];  // Name of the APID
  int16 APID;      // The assigned value
} APIDNameEnt;

#define APID_AMSCMD       24
#define APID_AMSHK        876
#define APID_AMSSCI       976
#define APID_AMSHKH       977
#define APID_PBCKSCI      978
#define APID_PBCKHKH      979
#define APID_PTOPCMD      980
#define APID_PTOPREPLY    981
#define APID_ACOPCMD      982
#define APID_ACOPHK       876
#define APID_ACOPQC       975
#define APID_SPARE1       983


#define APID_APLS_C       001
#define APID_APLS_D       002
#define APID_ACOP_C       003
#define APID_ACOP_D       004
#define APID_DDRS2_C      005
#define APID_DDRS2_D      007

// Dummy and alias
#define APID_CAN          010
#define APID_AMSW         011
#define APID_RS422        005
#define APID_HRDL         982
#define APID_1553         24

#define APID_FILL         0x7FF

int32 apidLookupValue(char *APID);
char *apidLookupName(int32 APID);

//~============================================================================

//  network.h

typedef struct _PortNameEnt
{
  char Name[20];    // Name of the APID
  int16 Port;       // The assigned value
} PortNameEnt;

// Modified for FC6 TCPIP communication problem, reason unknown
#define AAL_UDP_BASE_PORT 61000
#define AAL_TCP_BASE_PORT 61000

#define AAL_TCP_HRDL_PORT	(AAL_TCP_BASE_PORT + 1)
#define AAL_UCP_HRDL_PORT	(AAL_UCP_BASE_PORT + 1)

#define AAL_TCP_1553_PORT	(AAL_TCP_BASE_PORT + 2)
#define AAL_UCP_1553_PORT	(AAL_UCP_BASE_PORT + 2)

#define AAL_TCP_RS422_PORT	(AAL_TCP_BASE_PORT + 3)
#define AAL_UCP_RS422_PORT	(AAL_UCP_BASE_PORT + 3)

#define AAL_TCP_CAN_PORT	(AAL_TCP_BASE_PORT + 4)
#define AAL_UCP_CAN_PORT	(AAL_UCP_BASE_PORT + 4)

#define AAL_TCP_AMSW_PORT	(AAL_TCP_BASE_PORT + 5)
#define AAL_UCP_AMSW_PORT	(AAL_UCP_BASE_PORT + 5)


int portLookupValue(char *Port);
char *portLookupName(int port);

//~============================================================================

//  frm.h   Data framing routines

//  Revision History
//    Apr 2002 by Peter Dennett
//      - Initial version (AALFRM)
//    Sep 2003 by Peter Dennett
//      - Modications for use in payload simulator
//    Jul 2004 by Peter Dennett
//      - Migration from MDCSoftware
//    Jan 2005 by Alexei Lebedev
//      - NASA commands handling added

#define FRM_DEBUG 1           //?? Debug

//  Define our working area for a framing operation

#define END_OF_FRAME  0
#define FRAME_CHD_BYTES 10

typedef struct _FRAME
{
//  Open time parameters

  int32 APID;
  int32 FrameSize;
  int32 Options;      // Use the FO_ values below

  int8 CHDFrame;     // CHD frame number
  int8 CHDCmdCount;  // CHD command frame count

//  These are working values

  int32 NASAHdrSize;  // All ISS/STS headers
  int32 AMSHdrSize;   // All AMS headers (1st block ptr & CHD)
  int32 DataSize;     // Data field size

  int32 Index;        // Index into frame
  int32 Done;         // Index into block
  int32 Sequence;     // Next block sequence number
  bool DeBlocking;    // Honest check
  int32 Doing;        // Deblock block len
  bool InSync;        // Not the band
  pAMSBlock Block;    // Area to de-block into

//  DeBlocking counts

  int32 ErrorsCRC;
  int32 ErrorsCheckWord;
  int32 ErrorsSeqGap;
  int32 ErrorsBlockSync;
  int32 ErrorsData;
  int32 FrameCount;
  int32 FillCount;
} FRAME, *pFRAME;

#define FO_CRC        (1<<0)  // Frames must have CRC
#define FO_CHECKWORD  (1<<1)  // Frames must have NASA CheckWord
#define FO_FILLFRAMES (1<<2)  // Fill frames required
#define FO_CHD        (1<<3)  // Critical health data required
#define FO_PLMDM      (1<<4)  // PLMDM HK format required 
#define FO_OIU        (1<<5)  // OIU HK format required
#define FO_ACOP       (1<<6)  // ACOP format required
#define FO_RANDOMIZE  (1<<7)  // Perform psuedo randomize
#define FO_INPUT      (1<<8)  // This stream is input (commands in)
#define FO_TQMHEADER  (1<<9)  // Add the TQM header to each AMSBlock
                              // Note: Set value to 0 to turn off feature
#define FO_PLMDMCMD   (1<<10) // The PLMDM inserts 2 words in our command
#define FO_BYTESWAP   (1<<11) // Byte swap the AMSFrame.  For 1553 interfaces that
                              // preform byte swapping in hardware we need to
                              // have 16-bit values 
#define FO_EXTCMD     (1<<12) // External command

#define FO_DEBUG      (1<<30) // Debug code enable

#define FS_RANDOMIZE  (1<<3)  // Frame status randomize
#define FS_CRC        (1<<2)  // Frame status CRC
#define FS_EXTCMD     (1<<1)  // Frame status external command
#define FS_CHD        (1<<0)  // Frame status AMS secondary header (aka CHD)

#define FRAME_BLOCK_START 16

typedef struct _frmListEnt
{
  struct _frmListEnt *Next;
  int FrameSize;
  int8 Buffer[4096];
  int32 Marker;
} frmListEnt, *pfrmListEnt;

typedef struct _frmListHead
{
  char *TaskName;
  aalMutex_t  BufferMutex;
  pfrmListEnt Next;          // The actual list pointer
  pfrmListEnt Block;         // An entry we are blocking into
  pfrmListEnt Deblock;       // An entry we are deblocking from
  int32 Debug;               // Larger is more
  int32 Marker;
  int32 PDFramesInList;      // Should be diff of below...
  int32 PDFramesAdded;
  int32 PDFramesRemoved;
  int32 PDEntConstructed;
  int32 PDEntDestructed;
} frmListHead, *pfrmListHead;

#define ASSERT_FRMLIST 1

#define frmListEntMarker  0x4567
#define frmListHeadMarker 0x4321

#ifdef  ASSERT_FRMLIST
//static void __inline ASSERT_frmListEnt(pfrmListEnt pENT)
#define ASSERT_frmListEnt(pENT) \
{                                           \
  if (pENT->Marker != frmListEntMarker)     \
    printf("ASSERT_frmListEnt failed in %s at line %d func %s\n", \
          __FILE__, __LINE__, __func__); \
}
//static void __inline ASSERT_frmListHeader(pfrmListHead pFLH)
#define ASSERT_frmListHeader(pFLH) \
{                                               \
  if (pFLH->Marker != frmListHeadMarker)        \
    printf("ASSERT_frmListHeader failed in %s at line %d func %s\n", \
            __FILE__, __LINE__, __func__); \
}
#else
#  define  ASSERT_frmListEnt(pENT)
#  define  ASSERT_frmListHead(pFLH)
#endif

bool frmConstruct(pFRAME pFRM, int32 APID, int32 FrameSize, int32 Options);
bool frmDestruct(pFRAME pFRM);

bool frmBlock(pFRAME pFRM, int8 *Frame, pAMSBlock Block);
bool frmDeblock(pFRAME pFRM, int8 *Frame, pAMSBlock *Block);

void frmRandomize(int8 *Frame, int32 Bytes);

int16 frmCRC16(int8 *msg, int16 len);
int16 frmCRCCheck(int8 *msg, int16 len);
int16 frmCRCAttach(int8 *msg, int16 len);

int16 frmCheckWord(int8 *Frame, int FrameSize, bool ByteSwap, bool Apply);

bool frmListHeadConstruct(pfrmListHead pFLH, char *TaskName);
bool frmListHeadDestruct(pfrmListHead pFLH);
pfrmListEnt frmListEntConstruct(pfrmListHead pFLH, int FrameSize);
bool frmListEntDestruct(pfrmListHead pFLH, pfrmListEnt pFLE);
bool frmListAdd(pfrmListHead pFLH, pfrmListEnt pFLE);
pfrmListEnt frmListRemove(pfrmListHead pFLH);
bool frmListEmpty(pfrmListHead pFLH);
bool frmListBlock(pfrmListHead pFLH, pFRAME pFrm, pAMSBlock pRequest);
bool frmListDeblock(pfrmListHead pFLH, pFRAME pFrm, pAMSBlock *pRequest);

extern int16 frmFixedCHD[3];// The fixed part of CHD
extern int16 frmTDMCHD[256];// The time multiplexed part
// Does not need anywhere	extern aalTIMEVAL frmTIME;

//~============================================================================

//  rcb.h   Regisgtered call back routines

//  Revision History
//    May 1994 by Peter Dennett
//      - Initial version developed for the EPS project
//    Jul 2004 by Peter Dennett
//      - Munged for AMS-02 in Taiwan

typedef bool rcbRoutine(void *reg_data, void *call_data);

typedef struct _rcbCallback
{
  rcbRoutine *callback_func;     // Function registered for call back 
  char *reg_data;                // User data from register
  int cbnest;                    // Control for recursive callbacks 
  struct _rcbCallback *next;     // Next function on list 
} rcbCallback, *prcbCallback;

bool rcbRegister(prcbCallback *list, rcbRoutine routine, void *reg_data);
bool rcbDo(prcbCallback *list, void *call_data);
bool rcbDelete(prcbCallback *list, prcbCallback callback);
bool rcbDeregister(prcbCallback *list, rcbRoutine routine, void *reg_data);

//~============================================================================

//  fep.h   Front end processor interface

//  Revision History
//    June 2004 by Peter Dennett
//      - Initial version at CERN

typedef struct _FEP
{
  int Debug;                        // Zero: no debug, bigger is more
  int Port;                         // The server port
  char *TaskName;                   // Used to mark debug displays
  prcbCallback ClientConnect;
  prcbCallback ClientDisconnect;
  prcbCallback ClientRecv;

#define fepClientConnect    1
#define fepClientDisconnect 2
#define fepClientRecv       3

  void (*Callback)(struct _FEP *pFep, int Function, int ClientHandle);

  int TCPSock;                      // Socket descriptor for server 

  int32      ThreadInstalled;
  pthread_t  hThread;
  void       *ThreadResult;

/*
#define FEP_MAX_CLIENTS 15
*/
#define FEP_MAX_CLIENTS 1

  struct _Client
  {
    bool Accepted;                  // If accepted this socket is active
    bool WriteReady;                // Socket is ready for write
    int  ClntSock;                  // Socket descriptor for client 
    struct sockaddr_in ClntAddr;    // Client address
    frmListHead FramesIn;           // List of command frames in
    frmListHead FramesOut;          // List of frames for out

    int16 APID;                     // Client framing/ de-framing stuff
    int FrameSize;
    int FRMOpened;                  // 
    FRAME FRM;                      // Commands in frame
    FRAME FRMReply;                 // Framing for replies
    pfrmListEnt pFLE;               // Input frame we are already working
  } Client[FEP_MAX_CLIENTS];
} FEP, *pFEP;

typedef void fepCallback(pFEP pFep, int Function, int ClientHandle);

bool fepConstruct(pFEP pFep, int Port, fepCallback Callback, char *TaskName,
                  int Debug);
bool fepDestruct(pFEP pFep);
bool fepRecv(pFEP pFep, pAMSBlock *pRequest, int32 Client);
bool fepSend(pFEP pFep, pAMSBlock pRequest, int32 Client);
bool fepShow(pFEP pFep);

//~============================================================================

//  aalAlloc.h   Wedge to support transportable memory allocation (malloc/free)

//  Revision History
//    Aug 2004 by Peter Dennett
//      - Initial version 

typedef struct _aalPDStats
{
  int32 Allocated;
  int32 Freed;
} aalPDStats;

extern aalPDStats aalPDData;

#ifdef OS_LINUX

static __inline char * aalMalloc(int size)
{
  char *p = (char *)malloc(size);
  if (p)
    aalPDData.Allocated++;

  //  memset(p, 0xaa, size);

  return p;
}

static __inline void aalFree(char *ptr)
{
  free(ptr);
  aalPDData.Freed++;
  return;
}

static __inline char * aalReAlloc(char *pin, int size)
{
  char *p = (char *)realloc(pin, size);

  return p;
}
#endif // OS_LINUX

#ifdef OS_ECOS

static __inline char * aalMalloc(int size)
{
  char *p = malloc(size);
  if (p)
    aalPDData.Allocated++;

  //  memset(p, 0xaa, size);

  return p;
}

static __inline void aalFree(char *ptr)
{
  free(ptr);
  aalPDData.Freed++;
  return;
}

static __inline char * aalReAlloc(char *pin, int size)
{
  char *p = realloc(pin, size);

  return p;
}
#endif

//~============================================================================

//  abi.h   Defines for the AMS Block Interface

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Lake Howard Hotel, Taiwan
//        based on MDCSoftware coding

//-Code: typedef AMSBlock
//-  Defines an AMSBlock
#define BT_REQUEST       0x00
#define BT_REPLY         0x02
#define BT_WRITEREAD     0x00
#define BT_WRITE         0x01    // Better read as write but inhibit read

//  Special bit to trace an AMSBlock in the system
//  Turn off this feature by defining as zero

#define BT_TRACE         0x80

//  AMSBlock errors

#define ABE_OK           0x00   // Everything went well
#define ABE_LBERR        0x01   // DAQDLocalBlock returned error 
#define ABE_ABRFFULL     0x02   // DAQDSubmit AMSBlock Request FIFO Full
#define ABE_DCERR        0x03   // DataCount error - missing parameters
#define ABE_PARM         0x04   // Parameter within the AMSBlock is bad
#define ABE_TIMEOUT      0x05   // Timeout
#define ABE_TASK         0x06   // Task failed request
#define ABE_LBDIM        0x07   // DAQDLocalBlock declares DataType in error
#define ABE_FAIL         0x08   // Block is not supportted
#define ABE_DOWN         0x10   // The node is marked not available for use
#define ABE_ABORT        0x11   // AMS abort (may recover) 
#define ABE_ERROR        0x12   // AMS error (hard error)
#define ABE_PROTOCOL     0x13   // AMS protocol error
#define ABE_EPP          0x14   // Error with EPP port
#define ABE_CAN          0x15   // Error from CAN chip
#define ABE_DATATYPE     0x16   // Data type conversion error
#define ABE_BUFFSIZE     0x17   // Buffer size limits caused failure

enum _abiAttachmentTypes
{
  ATTACHMENT_COMMAND      = 1,
  ATTACHMENT_EVENT        = 2,
  ATTACHMENT_HOUSEKEEPING = 3,
} ;

#define abiStatusFreeData       0x01  // Data should be abiFree'd on Destruction
#define abiStatusFreeAttachment 0x02  // Attachment should be abiFree'd on Destruction

//-Code_End:

////////////////////////////////////////////////////////////////////////////
//-Extern: abiBlockIsRequest
static __inline int abiBlockIsRequest(pAMSBlock b) 
//-Synopsis:    Test to see if an AMSBlock is a request
//-Returns:     The logical result of the test
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Test to see if an AMSBlock is a request.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return !(b->BlockType & BT_REPLY);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiMakeRequest
static __inline int abiMakeRequest(pAMSBlock b)
//-Synopsis:    Mark an AMSBlock as a request
//-Returns:     BlockType
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Mark an AMSBlock as a request
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions: {return (b->BlockType |= BT_WRITE);}
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return (b->BlockType &= ~BT_REPLY);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiIsReply
static __inline int abiIsReply(pAMSBlock b)
//-Synopsis:    Test to see if an AMSBlock is a reply
//-Returns:     The logical result of the test
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Test to see if an AMSBlock is a reply.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return (b->BlockType & BT_REPLY);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiMakeReply
static __inline int abiMakeReply(pAMSBlock b)
//-Synopsis:    Mark an AMSBlock as a reply
//-Returns:     BlockType
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Mark an AMSBlock as a reply
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return (b->BlockType |= BT_REPLY);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiReplyError
static __inline pAMSBlock abiReplyError(pAMSBlock b, int16 Error)
//-Synopsis:    Mark an AMSBlock as a request
//-Returns:     BlockType
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Mark an AMSBlock as a request
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  b->Error = Error;
  b->DataCount = 0;
  abiMakeReply(b);
  return (b);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiIsWriteRead
static __inline int abiIsWriteRead(pAMSBlock b)
//-Synopsis:    Test to see if an AMSBlock is a write then read
//-Returns:     The logical result of the test
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Test to see if an AMSBlock is a put.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return  !(b->BlockType & BT_WRITE);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiMakeWriteRead
static __inline int abiMakeWriteRead(pAMSBlock b)
//-Synopsis:    Make an AMSBlock a write then read
//-Returns:     The logical result of the test
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Make an AMSBlock a write then read
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return (b->BlockType &= ~BT_WRITE);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiIsWrite
static __inline int abiIsWrite(pAMSBlock b)
//-Synopsis:    Test to see if an AMSBlock is a write
//-Returns:     The logical result of the test
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Test to see if an AMSBlock is a write.
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return (b->BlockType & BT_WRITE);
}

////////////////////////////////////////////////////////////////////////////
//-Extern: abiMakeWrite
static __inline int abiMakeWrite(pAMSBlock b)
//-Synopsis:    Make an AMSBlock a write
//-Returns:     New BlockType
//-ARG_I:       b              Pointer to the AMSBlock
//-Description: Make an AMSBlock a write
//-SeeAlso:
//-Includes:
//-Method:
//-Restrictions:
//-Notes:
//-Bugs:
//-Revisions:
//-End:
{
  return (b->BlockType |= BT_WRITE);
}

static __inline int8  *abiDataPtr8 (pAMSBlock b) {return (int8  *)b->Contents;}
static __inline int16 *abiDataPtr16(pAMSBlock b) {return (int16 *)b->Contents;}
static __inline int32 *abiDataPtr32(pAMSBlock b) {return (int32 *)b->Contents;}

pAMSBlock abiConstruct(int32 NodeAddress, int32 DataType, int32 DataCount, 
                       int32 BlockType, int32 AttachSize);
void abiDestruct(pAMSBlock Block);
pAMSBlock abiClone(pAMSBlock Block, int32 DataCount);

bool abiShow(pAMSBlock pBlock, int NumberBytesToDump);
bool abiPrint(char *Tag, pAMSBlock pBlock, int NumberBytesToDump);
bool abiPrint2(char *Tag1, char *Tag2, pAMSBlock pBlock, int NumberBytesToDump);

bool abiLog(FILE *fh, pAMSBlock pBlock);

//~============================================================================

//  aallib.h   Defines for the general aallib routines

//  Revision History
//    Jul 2004 by Peter Dennett
//      - Initial version in Lake Howard Hotel, Taiwan
//        based on MDCSoftware coding

void HexDump(void *Buffer, int32 Bytes, bool ByteSwap);
bool Panic(char *Format, ...);
void ByteSwap16memcpy(void *out, void *in, int count);
char *ExpandTilde(char *filename);

//~============================================================================

//  chd.h   Display CHD data

//  Revision History
//    Dec 2003 by Alexei Lebedev
//      - Initial version

void display_CHD(int16 Status, int8 *Frame);

//~============================================================================

//  acop6tlib.h   Defines for acop6tlib.c

//  Revision History
//    May 2003 by Peter Dennett
//      - Initial version at PADSOFT
//    Dec 2003 by Peter Dennett
//      - Conversion of PIT work to APLS

#define ACOP6T_INTA         0
#define ACOP6T_INTB         1

#define ACOP6T_TxA          0x01
#define ACOP6T_RxA          0x02
#define ACOP6T_TxB          0x04
#define ACOP6T_RxB          0x08
#define ACOP6T_LoopBackA    0x10
#define ACOP6T_LoopBackB    0x20
#define ACOP6T_JitterTestA  0x40
#define ACOP6T_JitterTestB  0x80

// Performance data

typedef struct _ACOP6TPDintf
{
  int32 SyncLost;
  int32 SymbolErrors;
  int32 OverRuns;
  int32 PacketSizeErr;
  int32 FifoMax;
} ACOP6TPDintf;

typedef struct _ACOP6TPDall
{
  ACOP6TPDintf PD_A;
  ACOP6TPDintf PD_B;
} ACOP6TPDall;

typedef int ACOP6TISR(int32 ISRStatus);

int ACOP6TReadReg(int Reg, int32 *pVal);
int ACOP6TWriteReg(int Reg, int32 Val);
int ACOP6TRead(int32 Offset, int8 *Buff, int Cnt);
int ACOP6TWrite(int32 Offset, int8 *Buff, int Cnt);

int ACOP6TOpen(void);
int ACOP6TClose(void);
int ACOP6TConfig(int EnableMask, int FrameSize, int FifoSizeTxA, 
                 int FifoSizeRxA, int FifoSizeTxB, int FifoSizeRxB,
                 int DataA, int SyncA, int PadA,
                 int DataB, int SyncB, int PadB);

int   ACOP6TChkRx(int Interface);
int32 ACOP6TGetRx(int Interface);
int   ACOP6TIncRx(int Interface);

int   ACOP6TChkTx(int Interface);
int32 ACOP6TGetTx(int Interface);
int   ACOP6TIncTx(int Interface);

int ACOP6TShowCondition(void);

int ACOP6TInstallISR(ACOP6TISR *pUserISR);
int ACOP6TUnInstallISR(void);

//~============================================================================
/* -*-C-*-
 * acop6t.h - header file for ACOP6T device driver
 *
 *-----------------------------------------------------------------------
 *
 *
 *-----------------------------------------------------------------------
 */

#ifdef __cplusplus
extern "C" {
#endif

//  Defines for the device driver

/****************************************************
  IOCTL Operations
 ****************************************************/

#define ACOP6T_RW_MASK      3 << 24
#define ACOP6T_IOCTL_RD     1 << 24
#define ACOP6T_IOCTL_WR     1 << 25

#define ACOP6T_SPACE_MASK   15 << 28
#define ACOP6T_CSR_SPACE    1 << 28
#define ACOP6T_DMA_SPACE    1 << 29
#define ACOP6T_CMD_SPACE    1 << 30

/****************************************************
  IOCTL Commands
 ****************************************************/

#define ACOP6T_IOC_GET_REG  0x00000000    // Get HRDL-PCI register value
#define ACOP6T_IOC_SET_REG  0x01000000    // Set HRDL-PCI register value

#if 0
#define ACOP6T_IOC_GET_DMA  0x02000000    // GET HRDL-PCI DMA register value
#define ACOP6T_IOC_SET_DMA  0x03000000    // SET HRDL-PCI DMA register value
#endif

#define ACOP6T_IOC_BLOCK    0x0C000000    // Block in driver for ISR
#define ACOP6T_IOC_INSTALL  0x0D000000    // Install ISR
#define ACOP6T_IOC_REMOVE   0x0E000000    // Remove ISR

typedef struct {
  int           chan;       // TX and RX channel number
  unsigned long csr;        // CSR for TX and RX
  int           size;       // size in bytes
  unsigned long data;       // Buffer address
  unsigned long status;     // Status for RX
  unsigned long pci_off;    // PCI offset (memory access only)
} ACOP6T_DATA;

//  Defines for the hardware

#define ACOP6T_BAR0_SIZE     (1024*1024)
#define ACOP6T_BAR1_SIZE     256
#define ACOP6T_BAR2_SIZE     256

//  BAR0 is the Tx and Rx buffers.  Each TX or RX channel has its own buffers.
//  The buffer size is configurable in block (4096Bytes), but the order of buffers
//  in memory is always TX0-RX0-TX1-RX1 (if there are TX1 and RX1). If RS422 is
//  implemented, the first block in TX buffer is reserved for RS422 fill frame

//  ----------------------------------------------------------------------------
//  BAR1 Registers

#define ACOP6T_INT_STATUS    (0x00>>2) //  RC  Interrupt status register                   ABJ
#define ACOP6T_INT_MASK      (0x04>>2) //  RW  Interrupt mask register                     ABJ
#define ACOP6T_BCFG          (0x08>>2) //  RW  Board Configuration register                ABJ
#define ACOP6T_BUF_FLUSH     (0x0C>>2) //  WO  TX and RX buffer flush                      ABJ
#define ACOP6T_BSTT          (0x10>>2) //  RO  Board status                                ABJ
#define ACOP6T_TXA_EN        (0x20>>2) //  RW  TXA enable register                         ABJ
#define ACOP6T_TXA_PCKT_SIZE (0x24>>2) //  RW  TXA packet size register                    ABJ
#define ACOP6T_TXA_5B_SIZE   (0x28>>2) //  RW  TXA 5B buffer size register                 ABJ
#define ACOP6T_TXA_DATA_RATE (0x2C>>2) //  RW  Logical data rate control register for TXA  ABJ
#define ACOP6T_TXA_GAP       (0x30>>2) //  RW  Inter-frame gap register for TXA            ABJ
#define ACOP6T_TXA_ASM       (0x34>>2) //  RW  ASM format register for 422 TXA and RXA     J
#define ACOP6T_TXA_CLK_DIV   (0x38>>2) //  RW  Clock divider register for 422 TXA          J
#define ACOP6T_TXA_ALE_TH    (0x3C>>2) //  RW  TXA buffer almost-empty threshold register  ABJ
#define ACOP6T_TXA_STATUS    (0x40>>2) //  RO  TXA status register                         ABJ
#define ACOP6T_TXA_WR        (0x44>>2) //  WO  TXA buffer block write finished             ABJ
#define ACOP6T_TXA_SYNC_SENT (0x48>>2) //  RO  Number of SYNC has been sent register for TXA ABJ
#define ACOP6T_RXA_PCKT_SIZE (0x50>>2) //  RW  RXA packet size register                    J
#define ACOP6T_RXA_ALF_TH    (0x54>>2) //  RW  RXA buffer almost-full threshold register   ABJ
#define ACOP6T_RXA_STATUS    (0x58>>2) //  RO  RXA status                                  ABJ
#define ACOP6T_RXA_RD        (0x5C>>2) //  WO  RXA buffer block read finished              ABJ
#define ACOP6T_TXB_EN        (0x60>>2) //  RW  TXB enable register                         A
#define ACOP6T_TXB_PCKT_SIZE (0x64>>2) //  RW  TXB packet size register                    A
#define ACOP6T_TXB_5B_SIZE   (0x68>>2) //  RW  TXB 5B buffer size register                 A
#define ACOP6T_TXB_DATA_RATE (0x6C>>2) //  RW  Logical data rate control register for TXB  A
#define ACOP6T_TXB_GAP       (0x70>>2) //  RW  Inter-frame gap register for TXB            A
#define ACOP6T_TXB_ASM       (0x74>>2) //  RW  ASM format register for 422 TXB and RXB
#define ACOP6T_TXB_CLK_DIV   (0x78>>2) //  RW  Clock divider register for 422 TXB
#define ACOP6T_TXB_ALE_TH    (0x7C>>2) //  RW  TXB buffer almost-empty threshold register  A
#define ACOP6T_TXB_STATUS    (0x80>>2) //  RO  TXB status register                         A
#define ACOP6T_TXB_WR        (0x84>>2) //  WO  TXB buffer block write finished             A
#define ACOP6T_TXB_SYNC_SENT (0x88>>2) //  RO  Number of SYNC has been sent register for TXB A
#define ACOP6T_RXB_PCKT_SIZE (0x90>>2) //  RW  RXB packet size register
#define ACOP6T_RXB_ALF_TH    (0x94>>2) //  RW  RXB buffer almost-full threshold register   A
#define ACOP6T_RXB_STATUS    (0x98>>2) //  RO  RXB status                                  A
#define ACOP6T_RXB_RD        (0x9C>>2) //  WO  RXB buffer block read finished              A
#define ACOP6T_DMA_PALR      (0xE0>>2) //  RW  PCI start address register (low dword)      B
#define ACOP6T_DMA_PAHR      (0xE4>>2) //  RW  PCI start address register(high dword)      B
#define ACOP6T_DMA_SIZE      (0xE8>>2) //  RW  DMA size register                           B
#define ACOP6T_DMA_CTRL      (0xEC>>2) //  RW  DMA control and status register             B
#define ACOP6T_DMA_LADDR     (0xF0>>2) //  RW  RAM start address register                  B
#define ACOP6T_JTAG_WR       (0xF8>>2) //  WO  JTAG port write                             A
#define ACOP6T_JTAG_RD       (0xFC>>2) //  RO  JTAG port read                              A

//  ----------------------------------------------------------------------------
//  BAR2 Registers

#define ACOP6T_DMA_PAR       (0x40>>2) //  RW  PCI start address register                  AJ
#define ACOP6T_DMA_RAR       (0x44>>2) //  RW  RAM start address register                  AJ
#define ACOP6T_DMA_CTRL2     (0x48>>2) //  RW  DMA control register register               AJ

//  ----------------------------------------------------------------------------
//  ACOP6T_INT_STATUS - Interrupt status register

#define INT_DMA_DONE  (1<<16) // Interrupt from DMA Done.  This bit indicates that
                              // the PCI core completes a DMA operation. It is cleared
                              // at the same time of CPU read. This bit appears even
                              // when INT_DMA_DONE_MASK asserted, but the event won't
                              // cause the interrupt signal asserted. High active.
#define INT_TXA_NF    (1<<15) // Interrupt from TXA buffer not full.This bit indicates
                              // that the condition of TXA buffer not full changing from
                              // false to true. It is cleared at the same time of CPU read.
                              // This bit appears even when INT_TXA_NF_MASK asserted, but
                              // the event won't cause the interrupt signal asserted.
                              // High active.
#define INT_TXA_ALE   (1<<14) // Interrupt from TXA buffer almost empty.This bit
                              // indicates that the condition of TXA buffer almost
                              // empty changing from false to true. It is cleared at
                              // the same time of CPU read. This bit appears even when
                              // INT_TXA_ALE_MASK asserted, but the event won't cause
                              // the interrupt signal asserted. High active.
#define INT_TXA_E     (1<<13) // Interrupt from TXA buffer empty. This bit indicates
                              // that the condition of TXA buffer empty changing from
                              // false to true. It is cleared at the same time of CPU
                              // read. This bit appears even when INT_TXA_E_MASK asserted,
                              // but the event won't cause the interrupt signal asserted.
                              // High active.
#define INT_RXA_NE    (1<<11) // Interrupt from RXA buffer nonempty. This bit indicates
                              // that the condition of RXA buffer nonempty changing from
                              // false to true. It is cleared at the same time of CPU read.
                              // This bit appears even when INT_RXA_NE_MASK asserted, but
                              // the event won't cause the interrupt signal asserted. High
                              // active.
#define INT_RXA_ALF   (1<<10) // Interrupt from RXA buffer almost full. This bit indicates
                              // that the condition of RX buffer almost full changing from
                              // false to true. It is cleared at the same time of CPU read.
                              // This bit appears even when INT_RXA_ALE_MASK asserted, but
                              // the event won't cause the interrupt signal asserted. High
                              // active.
#define INT_RXA_F      (1<<9) // Interrupt from RXA buffer full.This bit indicates that the
                              // condition of RX buffer full changing from false to true. It
                              // is cleared at the same time of CPU read. This bit appears
                              // even when INT_RXA_F_MASK asserted, but the event won't
                              // cause the interrupt signal asserted. High active.
#define INT_RXA_NFRM   (1<<8) // Interrupt from new frame of RXA.This bit indicates that a
                              // new frame has arrived from RXA. It is cleared at the same
                              // time of CPU read. This bit appears even when
                              // INT_RXA_NFRM_MASK asserted, but the event won't cause the
                              // interrupt signal asserted. High active.
#define INT_TXB_NF     (1<<7) // Interrupt from TXB buffer not full. This bit indicates that
                              // the condition of TXB buffer not full changing from false to
                              // true. It is cleared at the same time of CPU read. This bit
                              // appears even when INT_TXB_NF_MASK asserted, but the event
                              // won't cause the interrupt signal asserted. High active.
                              // Available only when TXB implemented, otherwise 0.
#define INT_TXB_ALE    (1<<6) // Interrupt from TXB buffer almost empty. This bit indicates
                              // that the condition of TXB buffer almost empty changing from
                              // false to true. It is cleared at the same time of CPU read.
                              // This bit appears even when INT_TXB_ALE_MASK asserted, but the
                              // event won't cause the interrupt signal asserted. High active.
                              // Available only when TXB implemented, otherwise 0.
#define INT_TXB_E      (1<<5) // Interrupt from TXB buffer empty. This bit indicates that
                              // the condition of TXB buffer empty changing from false to true.
                              // It is cleared at the same time of CPU read. This bit appears
                              // even when INT_TXB_E_MASK asserted, but the event won't cause
                              // the interrupt signal asserted. High active. Available only
                              // when TXB implemented, otherwise 0.
#define INT_RXB_NE     (1<<4) // Interrupt from RXB buffer nonempty.This bit indicates that
                              // the condition of RX buffer nonempty changing from false to
                              // true. It is cleared at the same time of CPU read. This bit
                              // appears even when INT_RX_NE_MASK asserted, but the event
                              // won't cause the interrupt signal asserted. High active.
                              // Available only when RXB implemented, otherwise 0.
#define INT_RXB_ALF    (1<<2) // Interrupt from RXB buffer almost full.  This bit indicates
                              // that the condition of RX buffer almost full changing from
                              // false to true. It is cleared at the same time of CPU read.
                              // This bit appears even when INT_RXB_ALE_MASK asserted, but
                              // the event won't cause the interrupt signal asserted. High
                              // active.  Available only when RXB implemented, otherwise 0.
#define INT_RXB_F      (1<<1) // Interrupt from RXB buffer full.  This bit indicates that
                              // the condition of RXB buffer full changing from false to true.
                              // It is cleared at the same time of CPU read. This bit appears
                              // even when INT_RXB_F_MASK asserted, but the event won't cause
                              // the interrupt signal asserted. High active.  Available only
                              // when RXB implemented, otherwise 0.
#define INT_RXB_NFRM   (1<<0) // Interrupt from new frame of RXB.This bit indicates that
                              // a new frame has arrived from RXB. It is cleared at the
                              // same time of CPU read. This bit appears even when
                              // INT_RXB_NFRM_MASK asserted, but the event won't cause the
                              // interrupt signal asserted. High active. Available only
                              // when RXB implemented, otherwise 0.

//  ----------------------------------------------------------------------------
//  ACOP6T_INT_MASK - Interrupt mask register

#define INT_DISABLE        (1<<31) // Interrupt disable (1=disable, 0=enable)
#define INT_DMA_DONE_MASK  (1<<16) // See INT_* above 0=Masked. 1=Unmasked
#define INT_TXA_NF_MASK    (1<<15)
#define INT_TXA_ALE_MASK   (1<<14)
#define INT_TXA_E_MASK     (1<<13)
#define INT_RXA_NE_MASK    (1<<12)
#define INT_RXA_ALF_MASK   (1<<10)
#define INT_RXA_F_MASK     (1<<9)
#define INT_RXA_NFRM_MASK  (1<<8)
#define INT_TXB_NF_MASK    (1<<7)
#define INT_TXB_ALE_MASK   (1<<6)
#define INT_TXB_E_MASK     (1<<5)
#define INT_RXB_NE_MASK    (1<<4)
#define INT_RXB_ALF_MASK   (1<<2)
#define INT_RXB_F_MASK     (1<<1)
#define INT_RXB_NFRM_MASK  (1<<0)

#define INT_MASK_ALL        0x1F7F7

//  ----------------------------------------------------------------------------
//  ACOP6T_BCFG - Board configuration register

#define BCFG_LITTLE_ENDIAN  (1<<31) // 1=Little endian format
                                    // 0=Data in buffer is organized in big endian format.
#define BCFG_Reserved	      (1<<30)
#define BCFG_TXA_RS422_ON   (1<<29) // 1=TX runs in RS422 mode.
                                    // 0=TX runs in HRDL mode.
#define BCFG_TXA_HRDL_TEST  (1<<28) // HRDL test mode.  1=Sends 5B symbol.
                                    // 0=HRDL TX runs in normal mode to sent packet
#define BCFG_TXA_HLPBCK     (1<<27) // HRDL self loop back 1=AMD physical link chips under
                                    // loop-back mode. 0=Normal mode.
#define BCFG_TXB_RS422_ON   (1<<26) // 1=TX runs in RS422 mode. 0 - TX runs in HRDL mode.
#define BCFG_TXB_HRDL_TEST  (1<<25) // 1=HRDL TX runs in test mode to send 5B symbol.
                                    // 0=HRDL TX runs in normal mode to sent packet.
#define BCFG_TXB_HLPBCK     (1<<24) // HRDL self loop back 1=AMD physical link chips under
                                    // loop-back mode. 0=Normal mode.
#define BCFG_RXA_BUFFER_START (0xFF<<16) // Start block index of RXA buffer
#define BCFG_TXB_BUFFER_START (0xFF<< 8) // Start block index of TXB buffer.
#define BCFG_RXB_BUFFER_START (0xFF<< 0) // Start block index of RXB buffer.

//  ----------------------------------------------------------------------------
//  ACOP6T_BUF_FLUSH - Flush control

#define TXA_BUF_FLUSH   (1<<31) // TXA buffer flush. Software writes 1 to this bit
                                // to flush the TXA buffer. Read operation does not
                                // harm but the return value is meaningless.
#define RXA_BUF_FLUSH   (1<<30) // RXA buffer flush.  Software writes 1 to this bit
                                // to flush the RXA buffer. Read operation does not
                                // harm but the return value is meaningless.
#define TXB_BUF_FLUSH   (1<<29) // TXB buffer flush.  Software writes 1 to this bit
                                // to flush the TXB buffer. Read operation does not
                                // harm but the return value is meaningless.
#define RXB_BUF_FLUSH   (1<<28) // RXB buffer flush. Software writes 1 to this bit to
                                // flush the RXB buffer. Read operation does not harm
                                // but the return value is meaningless.

//  ----------------------------------------------------------------------------
//  ACOP6T_BSTT - Board status register

#define BSTT_VERSION   (0xF<<28) //	Firmware version number
#define BSTT_REVISION  (0xF<<24) // Firmware reversion number
#define BSTT_DUAL      (1<<23)   //	1 - TXB/RXB on board, 0 - No TXB/RXB on board
#define BSTT_RS422     (1<<22)   // 1 - RS422 implemented, 0 - No RS422 on board
#define BSTT_BOOTA     (1<<19)   // Boot command bit for RXA.  This bit is '1' to
                                 // indicate a boot command received before last
                                 // PCI reset
#define BSTT_BOOTB     (1<<18)   // Boot command bit for RXB. This bit is '1' to
                                 // indicate a boot command received before last
                                 // PCI reset.
#define BSTT_NODEADDR  (0x3FF<<0) //Node Address

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_EN - Transmit A Enables
//  ACOP6T_TXB_EN - Transmit B Enables

#define TXx_OUT_EN     (1<<1)    // OUT_EN - TXx output enable
                                 // 1 - TXx output enabled.
                                 // 0 - TXx output keeps dark
#define TXx_DATA_EN    (1<<0)    // DATA_EN - TXA data enable
                                 // 1 - Packets in TXA buffer are transferred.
                                 // 0 - If there is packet in transfer, it will
                                 //     continue until finished. New packet will
                                 //     not start, SYNC will be sent instead

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_PCKT_SIZE - Transmit A packet size
//  ACOP6T_TXB_PCKT_SIZE - Transmit B packet size

#define TXx_PCKT_SIZE  (0xFFF<<0) // This value is the TXA packet size - 1 (in bytes).
                                  // According to SSP50184, the TXA packet size in byte
                                  // must be an even number, and equal to or larger
                                  // than 100

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_5B_SIZE - Transmit A size of 5B message
//  ACOP6T_TXB_5B_SIZE - Transmit B size of 5B message

#define TXx_5B_SIZE   (0x3FFF<<0) // The number of 5B symbols saved in TXA buffer
                                  // for transfer (test mode only). Register value
                                  // should be set to the real number - 1

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_DATA_RATE - Transmit A data rate
//  ACOP6T_TXB_DATA_RATE - Transmit A data rate

#define TXx_SYNC_NUM   (0xFF<<8)  // Intra-frame sync ratio
#define TXx_DATA_NUM   (0xFF<<0)  // Intra-frame symbol ratio

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_GAP - Sync gap between frames
//  ACOP6T_TXB_GAP - Sync gap between frames

#define TXx_GAP      (0xFFFFFFFF) // Min number of syncs between frames

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_ASM - TX A attached sync marker
//  ACOP6T_TXB_ASM - TX B attached sync marker

#define  TXx_ASM  (0xFFFFFF<<8)   // ASM

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_CLK_DIV - TX A clock divider for RS422
//  ACOP6T_TXB_CLK_DIV - TX B clock divider for RS422

#define TXx_CLK_DIV   (0x1F<<0)   // The divider used for RS422 clock generation
                                  // from the 50MHz OSC. The frequency of RS422
                                  // clock is (25/CLK_DIV) MHz

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_ALE_TH - TXA buffer almost empty threshold
//  ACOP6T_TXB_ALE_TH - TXB buffer almost empty threshold

#define TXx_ALE_TH     (0xFF<<0) // The condition that TXA buffer is almost empty
                                 // is satisfied when the number of packets (including
                                 // the packet in transfer) in TXA buffer is equal to
                                 // or less than TXA_ALE_TH.

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_STATUS - TXA status
//  ACOP6T_TXB_STATUS - TXB status

#define TXx_TX_INDEX  (0xFF<<24) // This value gives the block index for software to
                                 // write to TX buffer.  The start address of the block
                                 // is BAR0 + (TX_INDEX << 12)
#define TXx_OUT_INDEX (0xFF<<16) // Current TX block index for the controller FPGA.  This
                                 // value is provided for debug purpose and is not
                                 // necessary for normal operation.
#define TXx_TX_IN_CFG  (1<<15)   // TX state machine in configuration state.
                                 // 1 - Indicates that the TX state machine has entered
                                 //     the configuration state. In this state the
                                 //     controller FPGA will not fetch more packet from
                                 //     buffer and send SYNC symbols only. It is ready
                                 //     for software to reconfigure the TX parameters
                                 //     like TX_PCKT_SIZE, DATA_RATE and GAP.
                                 // 0 - TX state machine come back to normal state to
                                 //     send packet (if available in buffer).
                                 // Write '0' to DATA_EN bit in TX_EN register to make
                                 // TX_IN_CFG asserted, and '1' to make it disasserted.
#define TXx_TX_NF      (1<<2)    // TX buffer not full
#define TXx_TX_ALE     (1<<1)    // TX buffer almost empty
#define TXx_TX_E       (1<<0)    // TX buffer empty

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_WR - TXA buffer write finished
//  ACOP6T_TXB_WR - TXB buffer write finished

//  Write any value to this register to inicate that the block TXx_TX_INDEX has
//  been filled with data to be transmitted.  This increments TXx_TX_INDEX,
//  the FIFO pointer.

//  ----------------------------------------------------------------------------
//  ACOP6T_TXA_SYNC_SENT - TXA syncs sent
//  ACOP6T_TXB_SYNC_SENT - TXB syncs sent

#define TXx_SYNC_SENT (0xFFFF<<0)// The value gives the number of SYNCs
                                 // sent after last frame in HRDL TX

//  ----------------------------------------------------------------------------
//  ACOP6T_RXA_PCKT_SIZE - RXA packet size
//  ACOP6T_RXB_PCKT_SIZE - RXB packet size

#define RXx_PCKT_SIZE  (0xFFFFF<<0) // This value is the real RX packet size - 1
                                    // (in byte). It is only effective for RS422
                                    // receiver. HRDL receiver does not have predefined
                                    // packet size

//  ----------------------------------------------------------------------------
//  ACOP6T_RXA_ALF_TH - RXA almost-full threshold
//  ACOP6T_RXB_ALF_TH - RXB almost-full threshold

#define RXx_ALF_TH  (0xFF<<0)    // The condition that RXA buffer is almost empty is
                                 // satisfied when the number of available packet
                                 // buffers (including the packet in transfer) in
                                 // RXA buffer is equal to or less than RXA_ALF_TH.

//  ----------------------------------------------------------------------------
//  ACOP6T_RXA_STATUS - RXA Status
//  ACOP6T_RXB_STATUS - RXB Status

#define RXx_INDEX    (0xFF<<24) // Current RX block index. This value gives the block
                                // index for software to read from RX buffer.  The
                                // start address of the block is BAR0 + (RX_INDEX << 12)
#define RXx_IN_INDEX (0xFF<<16) // Current RX block index for the controller FPGA.  This
                                // value is provided for debug purpose and is not
                                // necessary for normal operation
#define RXx_HRDL_DEC    (1<<15) // HRDL input detected.
#define RXx_RS422_DEC   (1<<14) // RS422 input detected.
#define RXx_HRDL_SYNC   (1<<13) // HRDL SYNC symbol found.
#define RXx_RS422_SYNC  (1<<12) // RS422 ASM found.
#define RXx_ILLSYNBOL   (1<<11) // Illegal symbol found in HRDL channel
#define RXx_RX_NE       (1<<2)  // RX buffer not empty
#define RXx_RX_ALF      (1<<1)  // RX buffer almost full
#define RXx_RX_F        (1<<0)  // RX buffer full

//  ----------------------------------------------------------------------------
//  ACOP6T_RXA_RD - RXA buffer complete
//  ACOP6T_RXB_RD - RXB buffer complete

//  Software writes any value to this register to indicate the read operation to
//  current RXA buffer block finished. This increments RXx_INDEX.

//  ----------------------------------------------------------------------------
//  ACOP6T_JTAG_WR - JTAG write
//  ACOP6T_JTAG_RD - JTAG write

#define JTAG_TOE       (1<<4)
#define JTAG_TDI       (1<<3)
#define JTAG_TMS       (1<<2)
#define JTAG_TCK       (1<<1)
#define JTAG_TDO       (1<<0)

/****************************************************
  HRDL Received block header
 ****************************************************/
#define ACOP6T_RX_HRDL      1 << 31     // 1: HRDL 0: RS422
// Bits 24 - 29 ACOP6T_RX_OVRRUN        //?? Count of packets over written
// Bits 20 - 23 ACOP6T_RX_XSD           //?? Count of extra SD symbols before this packet
// Bits 16 - 19 ACOP6T_RX_XED           //?? Count of extra HD symbols before this packet
#define ACOP6T_RX_SYMERR    1 << 13     // Invalid symbol in this packet
#define ACOP6T_RX_OVRSIZE   1 << 12     // This packet is larger the 4096 - 4 bytes
// Bits 0 - 11  ACOP6T_RX_SIZE          // Size of packet in bytes

#ifdef __cplusplus
}
#endif

//~============================================================================

/* -*-C-*-
 *  crc.h - Header file for CRC utilities
 *
 *-----------------------------------------------------------------------
 *  Created by X.Cai, on 23.04.2003
 *
 *-----------------------------------------------------------------------
 */

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************
  Includes
 ****************************************************/

//??#include "types.h"
typedef unsigned short UINT16;
typedef int INT;
typedef unsigned char UINT8;


/****************************************************
  Definitions
 ****************************************************/

#define CRC16_POLYNOMIAL	0x1021

/****************************************************
  typedef and struct
 ****************************************************/

/****************************************************
  function declarations
 ****************************************************/

void CRC16_TableInit(void);
UINT16 CRC16_Calc(UINT8 *msg, INT len);
INT CRC16_Check(UINT8 *msg, INT len);
UINT16 CRC16_Attach(UINT8 *msg, INT len);
UINT16 CRC16_Continue(UINT8 *msg, INT len, UINT16 crc);

/****************************************************
  End
 ****************************************************/

#ifdef __cplusplus
}
#endif

//~============================================================================

//  aaltime.h   General time handling

//  Revision History
//    Mar 2003 by Peter Dennett
//      - Initial version at San Jose Del Cabo - pool side.
//    Jul 2004 by Peter Dennett
//      - Split general time code and DAQD timers

//-Code: typedef TIMEVAL
//-  Defines a the basic time data type 
//-
//-  Time within DAQD is expressed as microseconds
//-  <pre>
//-  1 second = 1,000             milliseconds (ms) 
//-           = 1,000,000         microseconds (us)
//-           = 1,000,000,000     nanoseconds  (ns)
//-           = 1,000,000,000,000 picoseconds  (ps)
//-  </pre>
typedef struct _aaltimeval
{
  long tv_sec;          // seconds
  long tv_usec;         // microseconds
} aalTIMEVAL, *paalTIMEVAL;
//-Code_End:

bool timeCmp(paalTIMEVAL a, paalTIMEVAL b, char CMP);
void timeAdd(paalTIMEVAL a, paalTIMEVAL b, paalTIMEVAL result);
void timeSub(paalTIMEVAL a, paalTIMEVAL b, paalTIMEVAL result);
void timeGet(paalTIMEVAL result);

//~============================================================================

#endif // _PADLIB_H
