CPAT,ANGEL    .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine angel(sig,emm,s,pr,icltyp,t1,c1)
        include 'scatter7'
#include "amsrqmd.h"
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'ver rqmd 1.07 ---- 29-apr-91'/
      data pronam/'module: a n g e l'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      if(ida(37).eq.1) then
         go to 10
      end if
      if(icltyp.le.66) then
        goto (
     >   1,  3,  1,  2,  2,
     >   1,  2,  2,  2,  1,
     >   2,  2,  2,  2,  1,
     >   2,  2,  2,  2,  2,
     >   1,  2,  2,  2,  2,
     >   2,  2,  1,  2,  2,
     >   2,  2,  2,  2,  2,
     >   1,  2,  2,  2,  2,
     >   2,  2,  2,  2,  1,
     >   2,  2,  2,  2,  2,
     >   2,  2,  2,  2,  2,
     >   2,  2,  2,  2,  2,
     >   2,  2,  2,  2,  2,
     >   1
     & ) , icltyp
       end if
       if((icltyp.ge.67).and.(icltyp.le.78)) then
            if(icltyp.eq.78) go to 1
            go to 2
       end if
       if((icltyp.ge.79).and.(icltyp.le.120)) then
            go to 2
       end if
       if((icltyp.ge.4754).and.(icltyp.le.4950)) then
            go to 2
       end if
      write(lun8,*)' icltyp invalid in  angel   ',icltyp
      call errex( 'fatal error')
    1 factor=1.
      goto 101
    3 continue
      call angnp(iang,s,c1,t1)
      if(iang.eq.1) return
    2 factor=2.
  101 continue
      a=slopet(icltyp,pr,s,emm,sig)
      ta=2.*pr*pr
      ata=ta*a
      if(ata.gt.35.) then
           iloop=0
   13      zrand=ranf(0)
           c1=1.+ 2./(ata) * log(max(cvalu2,zrand))
           if(c1.lt.0.) then
              iloop=iloop+1
              if(iloop.lt.100) then
                 go to 13
              else
                 call errex('no cosine theta found in angel')
              end if
           else
              c1= sqrt(c1)
           end if
      else if(ata.lt.1.e-7) then
           c1=1.
      else
           y3=ranf(0)
           pt=log((1.-y3)*exp(-factor*ata)+y3)
           c1=1.+pt/ata
      end if
      if (abs(c1) .gt. 1.0) c1=sign(cvalu1,c1)
      t1=pi2*ranf(0)
      return
   10 c1=1.-2.*ranf(0)
      t1=pi2*ranf(0)
      return
      end
      subroutine angnp(iang,srt,c1,t1)
      include 'scatter7'
#include "amsrqmd.h"
      data  npotnp,paranp,parcnp,tkmin / 4, 0.02, 0.04, 1.0/
       iang=0
       tkin=(srt**2-4.*emnuc**2)/(2.*emnuc)
       slimit=(tkmin/max(tkin,tkmin))**2
       if(ranf(0).gt.slimit) return
       iang=1
       if(tkin.le.paranp) then
         c1=1.-2.*ranf(0)
         t1=pi2*ranf(0)
         return
       end if
       vf=1./((parcnp/max(tkin,parcnp)+
     a                   (1.-paranp/max(tkin,paranp))/(npotnp+1.)))
       apr=(1.-paranp/max(tkin,paranp))/(npotnp+1.)
       bpr=parcnp/max(tkin,parcnp)/apr
       zrand=1.-2.*ranf(0)
       vrand=sign(cvalu1,zrand)
       zrand=abs(zrand)
       sl=zrand/vf/apr
       xstor=0.
       sg=1.
       do 20 ilop=1,25
         dekr=1./(2)**ilop
         xstor=xstor+sg*dekr
         sg=sign(cvalu1,sl-(xstor**5+bpr*xstor))
   20  continue
       slpr=xstor**5+bpr*xstor
       dlt=(sl-slpr)/(bpr+(npotnp+1.)*xstor**npotnp)
       xstor=xstor+dlt
       if(xstor.lt.0.or.xstor.gt.1.) then
          write(lun8,*) 'warning: wrong xstor in angnp', xstor,zrand
          xstor=max(cvalu0,min(cvalu1,xstor))
       end if
       c1=xstor*vrand
       t1=pi2*ranf(0)
      return
      end
      function slopet(icltyp,pr,s,emm,sig)
      include 'scatter7'
#include "amsrqmd.h"
      if(icltyp.le.3) then
         rshhpp=1.
      else
         rshhpp=sig/40.
      end if
      if(pr.lt.0.95) then
        as=(3.65*(s- emm))**6
        a=6.*as/(1.+as)
      else
        ssq=4.*(emnuc**2+pr**2)
        plab=sqrt(ssq*(ssq-4.*emnuc**2))/(2.*emnuc)
        a=9.2+0.27*log(plab)-5.7/sqrt(plab)
      end if
      slopet=a*rshhpp
      return
      end
CPAT,ANGIN    .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine angin(s,pr,prold,icltyp,t1,c1)
        include 'scatter7'
#include "amsrqmd.h"
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'ver rqmd 1.07 ---- 09-mar-91'/
      data pronam/'module: a n g i n'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      if(ida(37).eq.1) then
          go to 10
      end if
      ta= 2.*pr*prold
      a1=6.
      a=a1+max(cvalu0,0.23*(log(s*s)-log(100.)))
      y3=ranf(0)
      ata=ta *a
      if(ata.gt.35.) then
           iloop=0
   13      zrand=ranf(0)
           c1=1.+ 2./(ata) * log(max(cvalu2,zrand))
           if(c1.lt.0.) then
              iloop=iloop+1
              if(iloop.lt.100) then
                 go to 13
              else
                 call errex('no cosine theta found in angin')
              end if
           else
              c1= sqrt(c1)
           end if
      else
         arg=   exp(-2.*ata)
         pt=log( (1.-y3)*arg+y3 )
         c1=1.+pt/ata
      end if
      if (abs(c1) .gt. 1.0) c1=sign(cvalu1,c1)
      t1=pi2*ranf(0)
      return
   10 c1=1.-2.*ranf(0)
      t1=pi2*ranf(0)
      return
      end
CPAT,BLKDAT   .
      block data rqmdat
        include 'scatter7'
        include  'sigmasx'
      data cvalu1,cvalu2,cvalu3,cvalu0,cvalu4,cvalu5,cvalu6,cvalu7/
     a      1.0,  1.e-35, 0.1,   0.0, 1.e-20, 0.0 , 0.0001, 0.000001/
      data  emnuc,emdelt,empion,emrho,emeta,widdlt,emstrm,emctst,
     a      emkap,emka0,emlamb,emsigp,emsig0,emsigm,
     b      emkdec,emydec,emrhdc,dltmas,tprd,tpar1,tpar2,tpar3,ekelmi,
     c      widn1,widn2,widrho,emmnn2,emmnd2,gmprop,rho0,
     d      cst,cst1,cst2,emnres,wdnres , ekinmi, r0cor,
     e      hc,pi,pi2, pscal1,pscal2,p0ref/
     f      0.938,1.232,.138,0.770,0.550,0.120, 2., 2.5,
     g      0.494,0.498,1.116,1.189,1.192,1.197,
     h      1.15,1.5,1.0,0.3, 1.0,0.650,0.000,0.000,0.05,
     i      0.1,0.1,0.154,1.3,1.5,0.1,0.16,
     j      -2.26,-1.154215,2.725011,1.44,0.2,0.001, 0.88,
     k      1.2398,  3.1415927, 6.2831854,
     l      .238,.318,.227/
      data  enhcnd,snnlim,snpilm/1.5,4.1,1.9/
      data kspin /
     > -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0,
     >  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,-1,-1,
     >  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
     >  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
     > -1,-1, 0, 0, 0, 0, 1, 1, 1, 1 /
c 
c nucleus surface parameter a: rho(r)=rho0/(exp((r-r0)/a)+1)
c     da(2) = 0.52
c 
c 
c da(3)
c radius parameter, corresponds to 0.17 part/fm**3
c (only  needed for  fermi momentum at  rho0).
c     da(3) = 1.12
c 
c 
c da(4)
c parameter multiplying the life time of all resonances
c and the formation time of all new hadrons.
c    (input:sepfp)
c    default:da(4) = 1.
c 
c 
c da(5)
c parameter multiplying the total reaction time for switch(23)=t
c     default:da(5)=1.
c 
c 
c 
c da(7)
c parameter giving the decrease of m-b annihilation x section
c  sig-annihilation=sig0*(4.0/s)**da(7)
c     default:da(7)=0.5
c 
c da(8)
c use as a scale factor for squared distances which enter
c calculation of cross sections
c 
c da(9)
c  nonideal  mixing angle for  phi/omega.
c 
c da(10)
c  effective nonideal  mixing angle for  phi/omega to  be used in
c  diffractive  excitation in bb  collisions.
c 
c da(11)
c input impact parameter is stored in  da(11)
c 
c 
c da(12)
c parameter multiplying/suppressing  d n ==> d d cross section
c (changing the ddpi-coupling constant**2.)
c     default:da(12)= 0.25
c 
c 
c da(13)
c     for ida(12)=1: parameter giving the relation between
c                v12/vnn in the term linear in rho (12=dd,nb,bb).
c                 (above pr2max)
c 
c 
c da(14)
c     for ida(12)=1: parameter giving the relation between
c                    vnd/vnn (in the term linear in rho).
c                 (above pr2max)
c 
c da(15)
c     parameter multiplying the r.h.s of 'uncertainty relation'
c     delta (p +) * delta (x +) = da(15)
c     which defines minimum delta(x +) between 2 subsequent collisions.
c 
c 
c da(16)
c     parameter multiplying rho_ij in the repulsive piece of
c     quasi-potential for B_1-B_2 combinations for which
c     attractive piece is modified (see above for da(13) explanation).
c                 (above pr2max)
c 
c     da(17)= 0.8
c...transverse radius of rope
c 
c 
c     da(18)= 0.8
c...splitting probability of spin1 diquarks in string fragmentation.
c 
c     da(19)= 0.2
c...splitting probability of spin0 diquarks in string fragmentation.
c 
c     da(20)= 1.0
c... giving the  probability that in diffractive interaction
c    the interacting quark ends up in leading hadron
c    (=sea  string  excitation).
c 
csuny011195
c     da(21)= 1.0
c     width parameter multiplying n nbar molecule decay width (=50mev)
c     (for ida(49)=3 option)
c 
c     da(22)
c             factor to increase the fireball zone in the switch(17)=f
c             option
c             fireball radius= da(22)*1.5 + radius(proj.)
c 
c 
c 
c 
c              1  no particle decay, but decay of jet systems
c                 and resonances (except delta and rho)
c    ida(1)=
c              0  no restriction
c 
c 
c 
c 
c              1  neglect all collisions with cms energy below 4gev.
c    ida(2)=
c              0  no restriction
c 
c 
c 
c              1  nucleons get free masses after elastic scattering.
c    ida(3)=
c              0  nucleons get effctv. masses after elastic scattering.
c 
c 
c 
c 
c              2  pion absorption according to delta hole
c                 local density approximation.
c    ida(4)=
c              1  pi n ==> delta, n n ==> n delta: matter modification;
c                 delta n ==> n n (dlt.-massdependent ope x section)
c 
c              0  delta n ==> n n (detailed balance, pp x section)
c 
c 
c              1  print of vector meson decays on unit 10
c    ida(5)=
c              0  no
c 
c 
c 
c              0  global fermi-momentum
c    ida(6)=
c              1    local density-dependent fermi-momentum
c              2    dito (with the help of ws distribution)
c 
c 
c              1  retardation in gain of pt for hadron daughter
c                 carrying cquark is taken into account.
c    ida(7)=
c              0    no
c 
c 
c            0  mixed computation of the hamiltonian (4/5 of all time
c               steps simplified(itrig=1) and 1/5 of all time steps full
c               computation)
c     ida(8)=1  simplified computation of the hamiltonian
c               (no chi(pion)-components therein).itrig is chosen like
c               in the case before.
c            2  fully correct computation of the hamiltonian
c            3  simplified computation of the hamiltonian (itrig=1)
c 
c 
c              1
c    ida(9) =  0  no
c 
c 
c              1  leading hadron interacts without time delay
c                 (full x section)
c    ida(10)=  0  no
c 
c 
c              1  only b b collisions
c    ida(11)=  0  no restriction
c 
c 
c031096
c              1   relative momentum dependence
c    ida(12)=
c              2  no relative momentum dependence
c 
c 
c 
c             1 only nucleons and delta feel potential forces
c    ida(13)=
c             2 all non-strange baryons  feel potential forces
c             3 all baryons  feel potential forces
c 
c 
c 
c             1  chi(i)= sum(j,j.ne.i) exp(qij***2/2l)*(-)2l/qij**2 *
c                             em(i)**2*em(j)**2 *qij*pij/sqrt(pij**2)
c                                                        i=1, ....n-1
c    ida(14)=
c             0  chi(i)= sum(j,j.ne.i) exp(qij***2/2l)*(-)2l/qij**2 *
c                                            qij *pij    i=1, ....nt-1
c 
c 
c 
c             1 only hadrons containing the original constituent quarks
c               can interact.
c    ida(15)=
c             0 default
c 
c 
c 
c             2/3 string in position space corrected for cnst. quark
c                 propagation.
c                 (difference between 2 and 3 the same as 0 and 1).
c    ida(16)=
c             1 earliest hadron formation point = the first (fictive)
c               formation point of the yo-yo
c             0 arithmetic mean of the two production points
c 
c 
c             1 nucleons are woods-saxon distributed initially
c    ida(17)=
c             0 nucleons are uniformly   distributed initially
c 
c 
c             2 finite life time for jet systems with exponentially
c               decreasing probability.
c             1 finite life time for jet systems below cutoff mass
c    ida(18)=
c             0 else
c 
c 
c 
c            0 b-antib annihilation x sct.= sigma(nnbar)at equal s.
c    ida(19)=
c            1 b-antib annihilation x sct.= sigma(nnbar)at equal pr.
c            2 a la m^* formation,  with vector coefficient coupling.
c 
c 
c              1 leading baryon always contains constituent diquark
c    ida(20)=  0 constituent diquark can be split up.
c 
c 
c             1 no finite lifetime (with exceptions given by ida(18)
c    ida(21)=
c             0 finite interaction- and lifetime of strings
c               which are treated like resonances
c 
c 
c             0 none
c    ida(22)=
c             3 triple pomeron diffraction
c 
c 
c             1 equal time propagation in the ess or ts or ls
c    ida(23)=
c             0 switched off
c 
c 
c             1 check on available cpu time
c    ida(24)=
c             0 no check on available cpu time
c 
c 
c             1 collisions/decay information is written on unit 15
c    ida(25)=
c             0 no collisions/decay information is written on unit 15
c 
c 
c             2 the same as for 1, but no exception.
c             1 h h low and medium energy strangeness production
c               with general resonance formation and production
c               scheme (exception: nn). (default)
c    ida(26)=
c             0 h h low and medium energy strangeness production
c               according to parametrized pp x sections.
c 
c 
c             1 fast initialization (initfa) is switched on
c    ida(27)=
c             0 fast initialization (initfa) is switched off
c 
c 
c             0 mass shell correction in relham
c    ida(28)=
c             1 none
c 
c 
c             3 full comp. of hadron positions according to  yoyo model
c             2 mass dependent formation time based on yoyo model
c    ida(29)= 1 mass dependent formation time
c             0 mass independent formation time
c 
c 
c             1 variable tau step width
c    ida(30)=
c             0 old version
c 
c 
c             1 minimum (hard core) distance between nclns. in nucleus
c    ida(31)=
c             0 none
c 
c 
c             2 gaussian nucleon width= 1.100 fm  (for quasipotential)
c               + interaction strength takes difference between
c                 correlated interaction and true baryon density into
c                 account.
c    ida(32)=
c             1 gaussian nucleon width= 1.100 fm  (for quasipotential)
c             0 gaussian nucleon width= 2.165 fm
c 
c 
c 
c             1 switched off
c    ida(33)=
c             0 particles are removed from the interaction region
c               if no collisions are expected any more (relham).
c 
c 
c 
c             2 potential forces act only on projectile, secondaries
c               or nucleons which have already collided in a
c               woods saxon type mean field of a nucleus.
c               collision frequency= sigma*v*rho(woods-saxon)
c             1 potential forces act only on projectile, secondaries
c               or nucleons which have already collided.
c               (only in connection with ida(23).ne.0).
c    ida(34)=
c             0 switched off (default)
c 
c 
c 
c            1  resonance potential the same as for nucleons.
c    ida(35)=
c            2  for pr2>pr2max: allow for different values
c               (with ratios given by da(13) and da(14))
c 
c 
c            1  density is computed and printed after every collision
c               and decay.
c    ida(36)=
c            0  no
c 
c 
c            1  isotropic scattering in collisions
c    ida(37)=
c            0  no
c 
c 
c            7  output of sources of  cascade on unit 13
c            5  output of sources of phi on unit 13
c    ida(38)=
c            4  the same as 3,
c               but with excitation point of 'mother particle'.
c            3  freeze-out point together with source written on unit 9
c               (code:1 coll, 2 string, 3 b*, 4 rope, 0 nothing,
c                .ne.0 lund code for mother particle).
c            2  output of sources of  lambda on unit 13
c            1  output of sources of kaons on unit 13
c            0  none
c 
c 
c             1  medium correction for delta propagator in pi n/nn==>nd
c    ida(39)=
c             0 none
c 
c 
c 
c             3  1+2
c             2  estimate cross section in hit.
c    ida(40)=
c             1  calculate collision possibility with help of z-y
c                correlation (in hit).
c             0 no
c 
c 
c             1  strange hadrons (k,phi,lambda,sigma,xi,omega) stable.
c    ida(41)=
c             0  no
c 
c 
c             1  print phase space info on unit 7(unformatted)
c    ida(42)=
c             0  no
c 
c 
c             1  for errex-call: print on unit 14 and stop
c    ida(43)=
c             0  no
c 
c 
c             1  sea chain excitation in elementary collisions
c    ida(44)=
c             0  no
c 
c 
c             1  modified  lusysj
c    ida(45)=
c             0  old lund-lusysj
c 
c 
c             1  no single diffractive events in hh
c    ida(46)=
c             0  default
c 
c 
c             1  string fusion to ropes
c    ida(47)=
c             0  switched off.
c 
c 
c             1  meson-meson interaction via ps-ps-v coupling
c    ida(48)=
c             0  switched off.
c 
c 
csuny011195
c             3  molecule formation in l.e. anti-b b annihilation.
c             2  no anti-b b annihilation.
c    ida(49)=
c             1  diquark formation time = yoyo time  (for ida(16)=0).
c             0  no
c 
c 
c                high  mass baryon resonances decay  generating
c             1  an  average pt**2.le.(400mev)**2,
c                the standard value of string decay.
c    ida(50)=
c             0  isotropic  decay  of high  mass baryon resonances
c 
c 
c             2  the  same  as 1 and additional effective angle
c                 for  bb collisions simulating the
c                 strange nucleon sea (da(10)).
c    ida(51)=
c             1  nonideal mixing for phi/omega meson given
c                 by parameter da(9).
c             0  ideal mixing for phi/omega meson.
c 
c 
c             0  no restriction
c    ida(52)=
c             1  target nucleons without collisions are not written
c                for ha collisions on unit 9.
c             2  ta/pr nucleons without collisions,pi0's, neutrons
c                are not written
c                on unit 9.
c 
c 
c             0  hh coupling, ssbar suppression,phase space given
c                by maximum pt.
c    ida(53)=
c             1  Vandermeulen model of hh coupling.
c             2  Munigl model of hh coupling. (not implemented yet)
c 
c 
c             1 xs correction for shortliving resonances
c               in mb==> n*,delta*
c    ida(54)=
c             0  no correction
c 
c 
c             2 s quark motion in mb==>y,xi,om ==>mb
c               is reggeized.
c    ida(55)=
c             1
c             0
c 
c 
c 
c300198
c             1
c    ida(56)=      disabled
c             0
c 
c 
c             1 check whether time according to uncertainty
c               relation is available before next 'hard'
c               collision, else forbidden.
c    ida(57)=
c             0 none
c 
c 
c    ida(58)  different parametrizations for kbar lambda
c 
      data da/ 0.0,0.52,1.12,1.0,1.0,1.0,0.5,1.0,41.0,35.3,
     a               0.0,0.25,-0.1,1.0,1.0,1.00,0.8,0.8,0.2,1.0,
     b                  1.0,1.0/
      data ida/  0,0,1,1,3,2,1,3,1,0,
     a             0,1,3,0,0,2,1,2,2,0,
     b               1,3,1,2,1,2,1,0,3,1,
     c                 1,2,0,0,2,2,0,3,1,1,
     d                   1,0,1,1,1,0,0,1,3,1,
     e                     1,1,0,1,2,0,1,0,2*0 /
      data spntot/
     @248.20, 93.38, 55.26, 44.50, 41.33, 38.48, 37.20, 35.98,
     @ 35.02, 34.47, 34.37, 34.67, 35.23, 35.97, 36.75, 37.37,
     @ 37.77, 38.03, 38.40, 38.83, 39.26, 39.67, 40.06, 40.45,
     @ 40.79, 41.06, 41.31, 41.52, 41.70, 41.81, 41.87, 41.98,
     @ 42.12, 42.29, 42.55, 42.82, 43.01, 43.12, 43.16, 43.14,
     @ 43.06, 42.95, 42.81, 42.67, 42.54, 42.45, 42.38, 42.33,
     @ 42.30, 42.29, 42.28, 42.26, 42.24, 42.21, 42.17, 42.14,
     @ 42.10, 42.07, 42.06, 42.05, 42.04, 42.03, 42.02, 42.00,
     @ 41.97, 41.94, 41.89, 41.84, 41.79, 41.73, 41.67, 41.61,
     @ 41.55, 41.49, 41.44, 41.38, 41.34, 41.31, 41.29, 41.28,
     @ 41.27, 41.28, 41.30, 41.33, 41.36, 41.40, 41.44, 41.49,
     @ 41.50, 41.51, 41.51, 41.51, 41.52, 41.51, 41.51, 41.50,
     @ 41.50, 41.49, 41.47, 41.46
     @/
      data spnel /
     @248.20, 93.38, 55.26, 44.50, 41.33, 38.48, 37.20, 35.80,
     @ 34.71, 33.43, 32.52, 31.54, 30.65, 30.34, 29.14, 27.22,
     @ 26.93, 26.18, 25.64, 25.16, 24.89, 24.49, 24.08, 23.86,
     @ 23.17, 22.70, 21.88, 21.48, 20.22, 19.75, 18.97, 18.39,
     @ 17.98, 17.63, 17.21, 16.72, 16.68, 16.58, 16.42, 16.22,
     @ 15.98, 15.71, 15.42, 15.14, 14.87, 14.65, 14.44, 14.26,
     @ 14.10, 13.95, 13.80, 13.64, 13.47, 13.29, 13.09, 12.89,
     @ 12.68, 12.47, 12.27, 12.06, 11.84, 11.76, 11.69, 11.60,
     @ 11.50, 11.41, 11.29, 11.17, 11.06, 10.93, 10.81, 10.68,
     @ 10.56, 10.44, 10.33, 10.21, 10.12, 10.03,  9.96,  9.89,
     @  9.83,  9.80,  9.77,  9.75,  9.74,  9.74,  9.74,  9.76,
     @  9.73,  9.70,  9.68,  9.65,  9.63,  9.60,  9.57,  9.55,
     @  9.52,  9.49,  9.46,  9.43
     @/
      data spptot/
     @ 39.48, 31.76, 26.26, 24.05, 23.94, 23.77, 23.74, 24.13,
     @ 25.09, 26.23, 28.04, 32.30, 34.93, 37.85, 41.47, 44.73,
     @ 46.73, 47.33, 47.29, 47.49, 47.50, 47.37, 47.54, 47.39,
     @ 47.38, 47.38, 47.22, 47.14, 46.91, 46.60, 46.39, 45.80,
     @ 45.47, 45.54, 45.28, 45.00, 44.95, 44.74, 44.32, 44.21,
     @ 43.86, 43.63, 43.50, 43.04, 43.01, 42.79, 42.65, 42.44,
     @ 42.20, 42.02, 41.87, 41.75, 41.64, 41.53, 41.43, 41.33,
     @ 41.24, 41.16, 41.09, 41.03, 40.97, 40.90, 40.83, 40.75,
     @ 40.67, 40.59, 40.51, 40.45, 40.39, 40.34, 40.29, 40.25,
     @ 40.22, 40.19, 40.17, 40.15, 40.13, 40.11, 40.10, 40.08,
     @ 40.06, 40.04, 40.02, 40.00, 39.98, 39.95, 39.93, 39.91,
     @ 39.92, 39.92, 39.92, 39.92, 39.92, 39.92, 39.91, 39.90,
     @ 39.89, 39.88, 39.86, 39.84
     @/
      data sppel /
     @ 39.48, 31.76, 26.26, 24.05, 23.94, 23.77, 23.72, 23.98,
     @ 24.48, 24.52, 24.48, 26.24, 26.01, 26.01, 26.90, 27.78,
     @ 27.80, 26.82, 25.50, 24.64, 23.66, 22.46, 22.04, 21.42,
     @ 21.05, 20.76, 20.39, 20.14, 19.79, 19.39, 19.12, 18.49,
     @ 18.13, 18.19, 17.92, 17.63, 17.58, 17.37, 16.95, 16.83,
     @ 16.48, 16.24, 16.09, 15.62, 15.57, 15.32, 15.15, 14.91,
     @ 14.64, 14.42, 14.22, 14.06, 13.90, 13.73, 13.58, 13.42,
     @ 13.27, 13.13, 13.00, 12.88, 12.75, 12.62, 12.48, 12.34,
     @ 12.19, 12.04, 11.90, 11.77, 11.64, 11.53, 11.41, 11.31,
     @ 11.22, 11.13, 11.05, 10.97, 10.89, 10.82, 10.75, 10.68,
     @ 10.61, 10.54, 10.48, 10.41, 10.35, 10.28, 10.22, 10.16,
     @ 10.13, 10.10, 10.08, 10.05, 10.02,  9.99,  9.96,  9.93,
     @  9.90,  9.87,  9.84,  9.80
     @/
       data spbrpt/
     @ 253.118,223.598,195.010,174.600,158.832,147.941,139.813,137.000,
     @ 134.904,133.381,131.843,130.142,128.223,126.285,124.389,122.569,
     @ 120.731,119.171,117.910,116.637,115.350,113.752,112.018,110.266,
     @ 109.063,107.875,106.675,105.461,104.232,102.991,101.737,100.189,
     @  98.600, 96.996, 95.562, 94.249, 92.922, 91.630, 90.413, 89.184,
     @  87.942, 86.383, 84.423, 82.444, 81.044, 80.322, 79.593, 77.903,
     @  75.395, 74.128, 72.849, 70.948, 69.467, 68.426, 67.832, 67.233,
     @  66.513, 65.691, 64.860, 64.147, 63.722, 63.293, 62.860, 62.422,
     @  62.000, 61.627, 61.250, 60.869, 60.485, 60.097, 59.705, 59.371,
     @  59.034, 58.703, 58.378, 58.059, 57.746, 57.439, 57.138, 56.842,
     @  56.552, 56.266, 55.987, 55.712, 55.442, 55.177, 54.916, 54.660,
     @  54.409, 54.162, 53.919, 53.681, 53.447, 53.217, 52.991, 52.768,
     @  52.550, 52.335, 52.124, 51.917
     @  /
       data spbrpe/
     @  72.937, 64.944, 58.213, 55.509, 52.919, 51.639, 50.346, 49.040,
     @  47.820, 46.613, 45.394, 44.314, 43.285, 42.245, 41.293, 40.391,
     @  39.480, 38.629, 37.803, 36.970, 36.128, 35.192, 34.225, 33.252,
     @  32.370, 31.479, 30.579, 29.879, 29.422, 28.960, 28.493, 27.870,
     @  27.236, 26.594, 25.947, 25.288, 24.621, 23.947, 23.270, 22.589,
     @  21.901, 21.206, 20.769, 20.479, 20.186, 19.889, 19.636, 19.386,
     @  19.133, 18.879, 18.511, 18.044, 17.572, 17.656, 17.371, 17.095,
     @  16.828, 16.570, 16.319, 16.077, 15.843, 15.615, 15.395, 15.181,
     @  14.974, 14.773, 14.578, 14.388, 14.205, 14.026, 13.852, 13.684,
     @  13.520, 13.361, 13.206, 13.055, 12.909, 12.766, 12.627, 12.492,
     @  12.361, 12.233, 12.108, 11.987, 11.869, 11.754, 11.641, 11.532,
     @  11.425, 11.321, 11.220, 11.121, 11.024, 10.930, 10.839, 10.749,
     @  10.662, 10.576, 10.493, 10.412
     @  /
      data sdnel1/
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000, 70.000, 55.067, 42.486,
     @  35.025, 29.261, 26.552, 23.592, 21.345, 19.601, 19.213, 18.832,
     @  18.460, 18.094, 17.736, 17.384, 17.040, 16.703, 16.372, 16.048,
     @  15.730, 15.419, 15.113, 14.814, 14.521, 14.233, 13.951, 13.675,
     @  13.404, 13.139, 12.879, 12.624, 12.374, 12.129, 11.889, 11.653,
     @  11.422, 11.196, 10.975, 10.757, 10.544, 10.335, 10.131,  9.930,
     @   9.734,  9.541,  9.352,  9.167,  8.985,  8.807,  8.633,  8.462,
     @   8.294,  8.130,  7.969,  7.811,  7.657,  7.505,  7.356,  7.211,
     @   7.068,  6.928,  6.791,  6.656,  6.525,  6.395,  6.269,  6.145,
     @   6.023,  5.904,  5.787,  5.672,  5.560,  5.450,  5.342,  5.236,
     @   5.132,  5.031,  4.931,  4.834,  4.738,  4.644,  4.552,  4.462,
     @   4.374,  4.287,  4.202,  4.119
     @ /
      data sdnel2/
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,230.000,180.070,141.345,
     @ 110.116, 88.757, 62.962, 54.483, 52.379, 52.134, 51.103, 50.090,
     @  49.098, 48.126, 47.173, 46.240, 45.323, 44.426, 43.546, 42.683,
     @  41.839, 41.009, 40.198, 39.403, 38.622, 37.857, 37.108, 36.373,
     @  35.654, 34.947, 34.255, 33.576, 32.912, 32.260, 31.620, 30.995,
     @  30.382, 29.780, 29.189, 28.611, 28.045, 27.490, 26.945, 26.412,
     @  25.889, 25.376, 24.874, 24.381, 23.899, 23.426, 22.961, 22.507,
     @  22.062, 21.624, 21.196, 20.777, 20.364, 19.963, 19.567, 19.179,
     @  18.799, 18.427, 18.061, 17.706, 17.354, 17.011, 16.674, 16.343,
     @  16.020, 15.702, 15.392, 15.086, 14.789, 14.495, 14.208, 13.927,
     @  13.652, 13.381, 13.117, 12.856, 12.602, 12.353, 12.107, 11.868,
     @  11.633, 11.402, 11.176, 10.956
     @  /
      data sdnav/
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,177.900,133.194,104.273,
     @  81.957, 66.446, 49.308, 42.899, 40.741, 39.934, 39.144, 38.368,
     @  37.609, 36.864, 36.134, 35.419, 34.717, 34.030, 33.356, 32.695,
     @  32.048, 31.413, 30.791, 30.182, 29.584, 28.998, 28.424, 27.861,
     @  27.310, 26.769, 26.239, 25.719, 25.210, 24.711, 24.221, 23.742,
     @  23.272, 22.811, 22.359, 21.916, 21.482, 21.057, 20.640, 20.231,
     @  19.831, 19.438, 19.053, 18.676, 18.306, 17.944, 17.588, 17.240,
     @  16.899, 16.564, 16.236, 15.915, 15.599, 15.291, 14.988, 14.691,
     @  14.400, 14.115, 13.835, 13.562, 13.293, 13.030, 12.772, 12.519,
     @  12.271, 12.028, 11.790, 11.556, 11.328, 11.103, 10.883, 10.668,
     @  10.457, 10.250, 10.047,  9.848,  9.653,  9.462,  9.274,  9.091,
     @   8.911,  8.734,  8.561,  8.392
     @   /
      data snnnd /
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.15,
     @  0.61,  1.71,  3.56,  6.06,  8.92, 11.01, 12.76, 14.40,
     @ 16.06, 17.74, 19.35, 20.82, 22.10, 23.14, 23.95, 24.53,
     @ 24.89, 25.06, 25.06, 24.92, 24.66, 24.31, 23.87, 23.37,
     @ 22.82, 22.23, 21.92, 21.00, 19.53, 18.99, 18.40, 17.87,
     @ 17.27, 16.98, 17.02, 16.29, 16.54, 17.25, 16.96, 16.97,
     @ 15.10, 14.66, 13.70, 11.74, 10.94, 10.56,  9.90,  9.41,
     @  8.93,  8.46,  7.99,  7.53,  7.08,  6.64,  6.20,  5.77,
     @  5.36,  4.95,  4.55,  4.16,  3.79,  3.43,  3.08,  2.74,
     @  8.10,  7.83,  6.96,  5.70,  4.59,  3.53,  2.60,  1.75,
     @  1.19,  0.64,  0.19,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00
     @/
      data sdndd /
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000, 33.013, 45.444, 51.728, 54.743, 55.804,
     @  55.647, 54.719, 53.305, 51.587, 49.691, 47.699, 45.670, 43.643,
     @  41.644, 39.692, 37.799, 35.973, 34.217, 32.535, 30.928, 29.394,
     @  27.933, 26.542, 25.218, 23.963, 22.770, 21.639, 20.564, 19.543,
     @  18.576, 17.657, 16.786, 15.960, 15.176, 14.432, 13.728, 13.059,
     @  12.425, 11.823, 11.251, 10.709, 10.194,  9.704,  9.240,  8.799,
     @   8.379,  7.981,  7.603,  7.243,  6.901,  6.576,  6.266,  5.972,
     @   5.692,  5.426,  5.173,  4.931,  4.702,  4.484,  4.276,  4.078,
     @   3.890,  3.710,  3.539,  3.376,  3.221,  3.072,  2.932,  2.797,
     @   2.669,  2.547,  2.431,  2.320
     @/
      data snpid /
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  2.647,
     @  10.881, 21.678, 52.692, 97.428,163.619,196.966,165.886,118.453,
     @  82.930, 59.727, 53.996, 44.465, 38.289, 31.868, 28.052, 24.537,
     @  21.569, 19.602, 18.549, 18.329, 19.177, 20.592, 22.994, 25.367,
     @  26.443, 26.995, 28.052, 29.497, 31.558, 33.698, 36.171, 39.101,
     @  40.857, 41.363, 39.794, 37.616, 34.792, 31.917, 30.886, 30.223,
     @  29.791, 29.522, 29.501, 29.480, 29.459, 29.656, 29.725, 30.517,
     @  30.036, 29.633, 29.232, 31.200, 30.571, 29.948, 29.553, 29.450,
     @  29.347, 29.243, 29.138, 29.031, 28.924, 28.815, 28.706, 28.595,
     @  28.483, 28.370, 28.256, 28.141, 28.025, 27.907, 27.788, 27.669,
     @  27.547, 27.425, 27.302, 27.177, 27.051, 26.923, 26.795, 26.665,
     @  26.534, 26.401, 26.267, 26.132, 25.995, 25.858, 25.718, 25.578,
     @  25.435, 25.292, 25.147, 25.000
     @/
      data sppipe /
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  2.647,
     @  10.881, 21.678, 52.692, 97.428,163.619,196.966,165.886,118.453,
     @  82.930, 59.727, 53.996, 44.465, 38.289, 31.868, 28.052, 24.537,
     @  21.569, 19.602, 16.549, 13.763, 11.959,  9.773,  8.932,  8.928,
     @   9.178, 10.576, 10.799, 11.626, 12.359, 13.100, 13.876, 14.811,
     @  15.756, 16.922, 18.900, 17.130, 15.074, 13.172, 11.573, 10.787,
     @  10.059,  9.594,  9.230,  8.862,  8.511,  8.311,  8.126,  7.939,
     @   7.750,  7.470,  7.231,  7.062,  6.890,  6.717,  6.542,  6.332,
     @   6.209,  6.120,  6.030,  5.940,  5.817,  5.678,  5.537,  5.394,
     @   5.250,  5.105,  5.081,  5.081,  5.081,  5.081,  5.081,  5.017,
     @   4.916,  4.815,  4.712,  4.624,  4.563,  4.501,  4.439,  4.377,
     @   4.328,  4.279,  4.244,  4.244,  4.244,  4.216,  4.170,  4.123,
     @   4.076,  4.028,  3.979,  3.931
     @/
      data spimp /
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.741,
     @   3.658,  7.251, 17.543, 32.820, 54.558, 65.232, 55.765, 44.780,
     @  35.167, 31.693, 30.300, 29.634, 29.891, 30.327, 31.131, 34.146,
     @  38.955, 46.808, 49.792, 44.286, 38.373, 37.016, 39.269, 51.126,
     @  61.069, 57.527, 48.820, 41.953, 37.497, 35.609, 35.141, 35.207,
     @  35.054, 35.031, 34.753, 34.841, 35.126, 35.405, 35.619, 35.906,
     @  36.275, 36.311, 36.250, 36.173, 35.921, 35.741, 35.654, 35.317,
     @  34.904, 34.665, 34.176, 33.631, 33.273, 32.843, 32.355, 32.235,
     @  32.114, 31.991, 31.867, 31.742, 31.616, 31.488, 31.359, 31.229,
     @  31.097, 30.965, 30.830, 30.695, 30.558, 30.420, 30.280, 30.139,
     @  29.997, 29.853, 29.707, 29.560, 29.412, 29.262, 29.111, 28.958,
     @  28.804, 28.648, 28.491, 28.332, 28.171, 28.009, 27.845, 27.679,
     @  27.512, 27.343, 27.173, 27.000
     @/
      data sppime /
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.247,
     @   1.219,  2.417,  5.848, 10.940, 18.186, 21.744, 21.862, 16.804,
     @  12.325, 10.551, 10.024, 10.371, 11.443, 12.667, 13.828, 15.032,
     @  16.914, 18.080, 19.002, 17.334, 15.318, 14.823, 17.115, 23.610,
     @  27.137, 26.694, 21.230, 17.699, 15.131, 13.094, 11.221, 10.181,
     @  10.162,  9.477,  9.604,  9.589,  9.449,  9.391,  9.363,  9.207,
     @   8.822,  8.245,  8.106,  7.985,  7.880,  7.774,  7.667,  7.456,
     @   7.248,  7.171,  7.093,  7.015,  6.936,  6.902,  6.736,  6.526,
     @   6.314,  6.140,  5.987,  5.832,  5.676,  5.519,  5.630,  5.544,
     @   5.458,  5.370,  5.254,  5.130,  5.004,  4.877,  4.834,  4.834,
     @   4.834,  4.834,  4.834,  4.799,  4.776,  4.752,  4.728,  4.688,
     @   4.631,  4.573,  4.515,  4.456,  4.397,  4.336,  4.275,  4.222,
     @   4.171,  4.120,  4.068,  4.016
     @/
      data sppnn2/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.39,  0.40,  0.44,
     @  0.51,  0.61,  0.74,  0.89,  1.06,  1.26,  1.47,  1.70,
     @  1.94,  2.20,  2.47,  2.75,  3.04,  3.34,  3.64,  3.95,
     @  4.26,  4.58,  4.89,  5.20,  5.51,  5.82,  6.12,  6.41,
     @  6.69,  6.96,  7.23,  7.47,  7.71,  7.93,  8.13,  8.31,
     @  8.48,  8.63,  8.76,  8.86,  8.95,  9.02,  9.06,  9.09,
     @  9.09,  9.07,  9.03,  8.97,  8.89,  8.80,  8.68,  8.55,
     @  8.40,  8.23,  8.05,  7.86,  7.66,  7.45,  7.23,  7.00,
     @  6.77,  6.53,  6.29,  6.05
     @/
      data snpnn2/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.04,  0.07,  0.11,  0.16,  0.24,  0.86,
     @  1.46,  2.19,  2.95,  3.29,  3.60,  3.91,  4.22,  4.53,
     @  4.84,  5.14,  5.43,  5.71,  5.98,  6.23,  6.46,  6.66,
     @  6.85,  7.01,  7.15,  7.27,  7.65,  7.70,  7.73,  7.74,
     @  7.73,  7.71,  7.68,  7.64,  7.59,  7.53,  7.46,  7.39,
     @  7.31,  7.23,  7.15,  7.06,  6.97,  6.89,  6.80,  6.71,
     @  6.63,  6.55,  6.46,  6.38,  6.30,  6.22,  6.15,  6.07,
     @  6.00,  5.93,  5.86,  5.79,  5.73,  5.66,  5.59,  5.53,
     @  5.46,  5.40,  5.33,  5.27,  5.20,  5.14,  5.07,  5.00,
     @  4.93,  4.86,  4.79,  4.71,  4.64,  4.56,  4.48,  4.41,
     @  4.33,  4.25,  4.16,  4.08,  4.00,  3.92,  3.83,  3.75,
     @  3.67,  3.59,  3.51,  3.43
     @/
      data sppdd/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.10,  0.24,  0.45,  0.73,  0.97,  1.24,
     @  1.45,  1.71,  1.97,  2.31,  2.72,  0.38,  0.82,  1.43,
     @  2.10,  2.91,  3.39,  4.40,  5.25,  5.32,  5.76,  6.06,
     @  6.37,  6.34,  5.94,  6.25,  5.57,  4.70,  4.66,  4.10,
     @  5.30,  5.30,  5.70,  6.90,  7.23,  6.98,  6.98,  6.83,
     @  6.64,  6.47,  6.29,  6.11,  5.94,  5.79,  5.64,  5.49,
     @  5.37,  5.26,  5.17,  5.08,  5.00,  4.96,  4.92,  4.90,
     @  0.00,  0.00,  0.54,  2.80,  4.74,  6.56,  7.99,  8.90,
     @ 10.10, 10.50, 11.90, 12.90, 15.10, 15.70, 17.06, 18.30,
     @ 18.86, 20.70, 21.10, 21.10, 21.50, 21.50, 21.90, 21.10,
     @ 21.10, 21.50, 21.50, 20.70
     @/
      data s0dd/
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  1.043,  1.836,  3.270,  5.313,  6.694,  7.662,
     @   8.281,  8.773,  9.416, 10.229,  9.659, 10.130, 10.387, 10.775,
     @  11.016, 10.773, 10.788, 10.363, 10.620, 10.450, 10.035, 10.155,
     @   9.181,  8.754,  8.164,  7.263,  6.640,  6.596,  6.401,  6.306,
     @   6.300,  6.185,  6.080,  5.945,  5.771,  5.627,  5.464,  5.282,
     @   5.080,  4.860,  4.610,  4.402,  4.104,  3.818,  3.503,  3.139,
     @  14.406, 16.224, 17.343, 14.854, 12.785,  9.898,  7.032,  4.007,
     @   2.514,  0.781,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
     @   0.000,  0.000,  0.000,  0.000
     @/
      data sppdn2/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  1.00,  2.57,  2.67,  2.65,
     @  2.58,  2.42,  2.29,  2.21,  2.77,  2.89,  3.04,  3.24,
     @  3.47,  3.72,  3.98,  4.27,  4.56,  4.54,  4.71,  5.06,
     @  5.48,  5.70,  6.02,  6.51,  6.75,  6.99,  7.15,  7.27,
     @  7.39,  7.49,  7.57,  7.63,  7.67,  7.69,  7.69,  7.68,
     @  7.64,  7.57,  7.48,  7.38,  7.26,  7.12,  6.96,  6.78,
     @  4.01,  3.80,  3.61,  3.34,  3.08,  2.85,  2.68,  2.59,
     @  2.33,  2.20,  1.91,  1.67,  1.17,  0.94,  0.54,  0.38,
     @  0.05,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00
     @/
      data spp2n2/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.14,  0.39,  0.66,
     @  0.95,  1.24,  1.55,  1.87,  2.19,  2.53,  2.88,  3.24,
     @  3.58,  3.96,  4.33,  4.72,  5.11,  5.50,  5.90,  6.31,
     @  8.66,  9.05,  9.46,  8.68,  8.07,  7.49,  7.17,  7.22,
     @  6.87,  7.18,  6.60,  6.14,  4.55,  4.30,  3.50,  2.56,
     @  2.50,  0.87,  0.64,  0.81,  0.59,  0.78,  0.58,  1.56,
     @  1.77,  1.58,  1.78,  2.77
     @/
      data snp2n2/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.14,  0.56,  0.89,  1.45,  1.67,  2.08,  2.60,  2.84,
     @  3.64,  4.14,  4.73,  5.51,  6.14,  6.56,  7.14,  7.68,
     @  8.19,  8.75,  9.32,  9.91, 10.53, 10.99, 11.45, 11.95,
     @ 12.45, 12.96, 13.51, 14.04, 14.59, 15.15, 15.72, 16.31,
     @ 11.97, 11.43, 11.26, 12.27, 13.13, 14.41, 15.77, 17.39,
     @ 18.03, 19.09, 19.65, 19.67, 19.01, 18.96, 18.63, 18.24,
     @ 18.25, 17.52, 17.44, 17.55, 17.47, 17.58, 17.49, 17.98,
     @ 18.08, 17.99, 18.09, 18.57
     @/
      data sks10/
     @   7.80,  7.19,  6.49,  6.02,  5.55,  5.08,  4.64,  4.38,
     @ 3.654, 3.741, 3.905, 4.198, 5.010, 5.745, 6.429, 6.685,
     @ 6.733, 5.920, 4.935, 3.869, 3.589, 3.137, 2.660, 2.259,
     @ 1.955, 1.760, 1.733, 1.846, 1.748, 1.650, 1.642, 1.633,
     @   1.44,  1.10,  0.85,  0.68,  0.59,  0.53,  0.48,  0.44,
     @   0.41,  0.38,  0.36,  0.34,  0.33,  0.31,  0.29,  0.28,
     @   0.27,  0.26,  0.24,  0.23,  0.21,  0.20,  0.20,  0.19,
     @   0.18,  0.17,  0.16,  0.15,  0.14,  0.13,  0.12,  0.12,
     @   0.11,  0.11,  0.10,  0.10,  0.09,  0.09,  0.08,  0.08,
     @   0.08,  0.07,  0.07,  0.07,  0.07,  0.06,  0.06,  0.06,
     @   0.05,  0.05,  0.05,  0.04,  0.04,  0.04,  0.03,  0.03,
     @   0.03,  0.03,  0.02,  0.02,  0.02,  0.01,  0.01,  0.01,
     @   0.01,  0.01,  0.01,  0.008
     @/
      data sks01/
     @40.719,36.695,30.366,27.314,50.764,27.079,19.306,13.094,
     @  13.50, 11.81, 10.48,  9.34,  8.36,  7.46,  6.79,  6.16,
     @   5.65,  5.24,  4.84,  4.46,  4.15,  3.87,  3.63,  3.40,
     @   3.18,  2.96,  2.77,  2.58,  2.39,  2.26,  2.13,  2.02,
     @   1.92,  1.82,  1.70,  1.58,  1.48,  1.39,  1.31,  1.22,
     @   1.15,  1.07,  1.00,  0.94,  0.89,  0.85,  0.81,  0.77,
     @   0.73,  0.70,  0.67,  0.64,  0.61,  0.57,  0.54,  0.50,
     @   0.47,  0.45,  0.43,  0.41,  0.39,  0.37,  0.36,  0.34,
     @   0.33,  0.31,  0.30,  0.28,  0.26,  0.25,  0.24,  0.23,
     @   0.22,  0.21,  0.20,  0.19,  0.18,  0.18,  0.17,  0.16,
     @   0.15,  0.14,  0.13,  0.12,  0.11,  0.10,  0.09,  0.08,
     @   0.08,  0.07,  0.06,  0.06,  0.05,  0.05,  0.04,  0.04,
     @   0.04,  0.03,  0.03,  0.03
     @/
      data sks11/
     @29.238,13.759, 9.522, 6.904, 5.373, 4.491, 3.759, 3.349,
     @ 3.245, 3.517, 5.862,  8.158, 9.292, 5.622,  3.84,  3.20,
     @   2.91,  2.62,  2.38,  2.19,  2.00,  1.83,  1.68,  1.52,
     @   1.41,  1.31,  1.22,  1.12,  1.05,  0.98,  0.91,  0.85,
     @   0.80,  0.75,  0.70,  0.65,  0.61,  0.57,  0.53,  0.50,
     @   0.46,  0.43,  0.40,  0.37,  0.34,  0.32,  0.30,  0.29,
     @   0.27,  0.25,  0.24,  0.23,  0.21,  0.20,  0.19,  0.18,
     @   0.17,  0.16,  0.15,  0.13,  0.12,  0.11,  0.10,  0.09,
     @   0.08,  0.07,  0.06,  0.06,  0.05,  0.05,  0.04,  0.04,
     @   0.04,  0.03,  0.03,  0.03,  0.03,  0.03,  0.02,  0.02,
     @   0.02,  0.02,  0.01,  0.01,  0.01,  0.01,  0.01,  0.01,
     @   12*0.0
     @/
      data skncs/
     @-500.00,274.34, 92.01, 40.21, 26.16, 20.26, 17.24, 15.43,
     @  15.40, 15.85, 16.44, 17.28, 20.91, 24.08, 30.82, 32.02,
     @  33.09, 33.95, 34.71, 34.05, 33.38, 32.71, 32.07, 31.57,
     @  31.07, 30.55, 30.02, 29.49, 28.94, 28.39, 27.82, 27.25,
     @  26.66, 26.06, 25.45, 24.82, 24.18, 23.70, 23.66, 23.61,
     @  23.56, 23.51, 23.46, 23.41, 23.36, 23.31, 23.16, 22.99,
     @  22.82, 22.65, 22.47, 22.36, 22.25, 22.14, 22.03, 21.91,
     @  21.79, 21.68, 21.60, 21.56, 21.52, 21.47, 21.43, 21.39,
     @  21.34, 21.30, 21.25, 21.27, 21.33, 21.38, 21.44, 21.49,
     @  21.55, 21.61, 21.67, 21.79, 21.93, 22.08, 22.23, 22.39,
     @  22.55, 22.37, 22.11, 21.85, 21.58, 21.31, 21.25, 21.19,
     @  21.13, 21.07, 21.01, 20.94, 20.99, 21.05, 21.12, 21.19,
     @  21.26, 21.33, 21.32, 21.28
     @/
      data skmne/
     @   0.00,  0.00,  0.00,  0.34,  1.31,  2.43,  3.33,  4.19,
     @   4.85,  5.60,  6.44,  7.38,  8.42,  9.62, 10.93, 13.87,
     @  16.84, 19.40, 19.37, 15.89, 14.38, 13.51, 12.92, 12.32,
     @  11.70, 11.08, 10.44,  9.79,  9.13,  8.46,  7.77,  7.13,
     @   6.97,  6.80,  6.64,  6.47,  6.29,  6.11,  5.93,  5.75,
     @   5.56,  5.37,  5.17,  4.97,  4.76,  4.55,  4.34,  4.18,
     @   4.12,  4.07,  4.01,  3.95,  3.89,  3.83,  3.77,  3.71,
     @   3.64,  3.58,  3.51,  3.44,  3.37,  3.33,  3.30,  3.28,
     @   3.27,  3.26,  3.25,  3.25,  3.24,  3.23,  3.22,  3.21,
     @   3.21,  3.20,  3.19,  3.18,  3.17,  3.16,  3.15,  3.14,
     @   3.13,  3.12,  3.11,  3.10,  3.09,  3.08,  3.07,  3.05,
     @   3.04,  3.03,  3.02,  3.01,  2.99,  2.98,  2.97,  2.95,
     @   2.94,  2.92,  2.91,  2.89
     @/
      data skmpce/
     @  17.98, 11.37,  8.01,  7.63, 11.01,  5.88,  4.63,  4.15,
     @   3.88,  3.70,  3.35,  2.35,  3.20,  4.20,  4.56,  4.90,
     @   5.69,  6.93,  7.71,  6.33,  4.76,  3.92,  3.00,  2.50,
     @  2.027, 1.892, 1.768, 1.655, 1.551, 1.455, 1.367, 1.285,
     @  1.209, 1.139, 1.074, 1.013, 0.956, 0.903, 0.854, 0.808,
     @  0.765, 0.724, 0.687, 0.651, 0.618, 0.586, 0.557, 0.529,
     @  0.502, 0.478, 0.454, 0.432, 0.411, 0.392, 0.373, 0.355,
     @  0.339, 0.323, 0.308, 0.294, 0.280, 0.268, 0.255, 0.244,
     @  0.233, 0.223, 0.213, 0.203, 0.194, 0.186, 0.178, 0.170,
     @  0.163, 0.156, 0.149, 0.142, 0.136, 0.131, 0.125, 0.120,
     @  0.115, 0.110, 0.105, 0.101, 0.097, 0.093, 0.089, 0.085,
     @  0.082, 0.078, 0.075, 0.072, 0.069, 0.066, 0.064, 0.061,
     @  0.059, 0.056, 0.054, 0.052/
      data skpcs/
     @ -500.0,344.87,163.85, 99.63, 76.39, 83.06, 63.93, 46.09,
     @  41.51, 38.84, 36.44, 35.36, 36.05, 37.62, 40.17, 42.55,
     @  44.50, 46.47, 45.22, 43.51, 41.72, 39.61, 37.43, 35.04,
     @  33.00, 33.19, 33.37, 33.56, 33.76, 33.95, 34.15, 33.93,
     @  33.04, 32.13, 31.20, 30.91, 30.78, 30.43, 30.08, 29.72,
     @  29.35, 28.97, 28.59, 28.20, 27.80, 27.39, 26.97, 26.54,
     @  26.11, 26.15, 26.25, 26.36, 26.47, 26.58, 26.70, 26.81,
     @  26.93, 27.05, 27.02, 26.93, 26.84, 26.75, 26.65, 26.55,
     @  26.45, 26.35, 26.25, 26.14, 26.04, 25.93, 25.81, 25.70,
     @  25.58, 25.46, 25.35, 25.29, 25.22, 25.15, 25.08, 25.01,
     @  24.94, 24.86, 24.78, 24.71, 24.63, 24.55, 24.46, 24.38,
     @  24.29, 24.20, 24.11, 24.02, 23.92, 23.83, 23.73, 23.63,
     @  23.53, 23.42, 23.31, 23.20
     @/
      data skmpe/
     @   0.00, 54.46, 47.13, 41.79, 36.16, 34.52, 29.21, 24.14,
     @  21.91, 20.17, 18.45, 16.75, 15.04, 17.01, 19.09, 20.30,
     @  21.02, 21.74, 22.33, 21.01, 19.66, 18.29, 16.90, 15.49,
     @  14.05, 12.59, 11.11,  9.59,  8.50,  8.82,  9.14,  9.47,
     @   9.61,  9.27,  8.92,  8.56,  8.20,  7.83,  7.45,  7.07,
     @   6.67,  6.32,  6.23,  6.14,  6.05,  5.96,  5.87,  5.77,
     @   5.67,  5.57,  5.47,  5.36,  5.26,  5.15,  5.03,  4.92,
     @   4.80,  4.69,  4.56,  4.44,  4.39,  4.36,  4.34,  4.32,
     @   4.29,  4.27,  4.25,  4.22,  4.20,  4.17,  4.14,  4.12,
     @   4.09,  4.06,  4.03,  4.00,  3.97,  3.94,  3.91,  3.88,
     @   3.84,  3.81,  3.77,  3.74,  3.70,  3.67,  3.65,  3.63,
     @   3.61,  3.59,  3.57,  3.55,  3.53,  3.51,  3.49,  3.47,
     @   3.45,  3.43,  3.40,  3.38
     @/
      data skppt/
     @  10.00, 10.00, 10.35, 10.80, 11.17, 11.33, 11.46, 11.59,
     @  11.70, 11.82, 11.94, 12.12, 12.41, 12.69, 13.15, 13.71,
     @  14.30, 15.08, 15.86, 16.65, 17.46, 18.26, 18.20, 18.14,
     @  18.08, 18.01, 17.95, 17.88, 17.82, 17.75, 17.68, 17.61,
     @  17.54, 17.46, 17.39, 17.31, 17.24, 17.16, 17.08, 16.99,
     @  16.91, 16.92, 16.92, 16.93, 16.93, 16.93, 16.94, 16.94,
     @  16.95, 16.95, 16.95, 16.96, 16.96, 16.97, 16.97, 16.98,
     @  16.98, 16.99, 16.99, 17.00, 17.00, 17.01, 17.01, 17.01,
     @  17.01, 17.02, 17.02, 17.02, 17.03, 17.03, 17.03, 17.04,
     @  17.04, 17.04, 17.05, 17.05, 17.05, 17.06, 17.06, 17.06,
     @  17.07, 17.07, 17.08, 17.08, 17.09, 17.09, 17.09, 17.10,
     @  17.10, 17.11, 17.11, 17.12, 17.12, 17.13, 17.14, 17.15,
     @  17.16, 17.17, 17.18, 17.19
     @/
      data skppe/
     @  10.00, 10.00, 10.35, 10.11, 10.39, 10.57, 10.73, 10.88,
     @  11.03, 11.18, 11.28, 11.28, 11.29, 11.29, 11.30, 11.31,
     @  11.31, 11.32, 11.22, 11.03, 10.84, 10.65, 10.46, 10.26,
     @  10.06,  9.85,  9.64,  9.43,  9.22,  8.98,  8.70,  8.41,
     @   8.11,  7.81,  7.50,  7.19,  6.87,  6.54,  6.32,  6.19,
     @   6.07,  5.94,  5.81,  5.67,  5.54,  5.40,  5.25,  5.11,
     @   4.96,  4.81,  4.68,  4.62,  4.57,  4.52,  4.46,  4.41,
     @   4.35,  4.29,  4.23,  4.17,  4.11,  4.04,  3.98,  3.91,
     @   3.84,  3.77,  3.70,  3.63,  3.56,  3.50,  3.43,  3.37,
     @   3.32,  3.34,  3.36,  3.39,  3.41,  3.44,  3.46,  3.49,
     @   3.51,  3.54,  3.57,  3.60,  3.60,  3.59,  3.57,  3.55,
     @   3.54,  3.52,  3.50,  3.49,  3.47,  3.45,  3.43,  3.41,
     @   3.40,  3.41,  3.42,  3.43
     @/
      data skpnt/
     @  10.00, 11.06, 12.22, 13.10, 13.80, 14.59, 15.20, 15.75,
     @  16.17, 16.58, 16.82, 16.88, 16.85, 16.83, 16.81, 17.28,
     @  18.10, 18.93, 19.77, 20.54, 21.00, 21.06, 20.50, 19.92,
     @  19.59, 19.45, 19.30, 19.16, 19.01, 18.85, 18.75, 18.70,
     @  18.65, 18.59, 18.54, 18.48, 18.42, 18.36, 18.30, 18.24,
     @  18.18, 18.12, 18.05, 17.98, 17.94, 17.91, 17.88, 17.85,
     @  17.83, 17.80, 17.77, 17.74, 17.71, 17.68, 17.65, 17.61,
     @  17.58, 17.56, 17.56, 17.55, 17.55, 17.55, 17.55, 17.54,
     @  17.54, 17.54, 17.54, 17.53, 17.53, 17.53, 17.52, 17.52,
     @  17.52, 17.51, 17.51, 17.51, 17.50, 17.50, 17.50, 17.49,
     @  17.49, 17.49, 17.48, 17.48, 17.48, 17.48, 17.48, 17.48,
     @  17.48, 17.48, 17.49, 17.49, 17.49, 17.49, 17.49, 17.49,
     @  17.50, 17.50, 17.50, 17.50
     @/
      data skpnel/
     @  10.00, 10.00, 10.00, 10.00, 10.00, 10.00, 10.00, 10.00,
     @  10.00, 10.00, 10.00, 10.00, 10.00, 10.00, 10.00, 10.00,
     @  11.31, 11.32, 11.22, 11.03, 10.84, 10.65, 10.46, 10.26,
     @  10.06,  9.85,  9.64,  9.43,  9.22,  8.98,  8.70,  8.41,
     @   8.11,  7.81,  7.50,  7.19,  6.87,  6.54,  6.32,  6.19,
     @   6.07,  5.94,  5.81,  5.67,  5.54,  5.40,  5.25,  5.11,
     @   4.96,  4.81,  4.68,  4.62,  4.57,  4.52,  4.46,  4.41,
     @   4.35,  4.29,  4.23,  4.17,  4.11,  4.04,  3.98,  3.91,
     @   3.84,  3.77,  3.70,  3.63,  3.56,  3.50,  3.43,  3.37,
     @   3.32,  3.34,  3.36,  3.39,  3.41,  3.44,  3.46,  3.49,
     @   3.51,  3.54,  3.57,  3.60,  3.60,  3.59,  3.57,  3.55,
     @   3.54,  3.52,  3.50,  3.49,  3.47,  3.45,  3.43,  3.41,
     @   3.40,  3.41,  3.42,  3.43
     @/
      data skpnce/
     @   0.00,  1.06,  2.22,  3.10,  3.80,  4.59,  5.20,  5.75,
     @   6.17,  6.58,  6.82,  6.88,  6.85,  6.83,  6.81,  6.64,
     @   6.45,  6.24,  6.03,  5.71,  5.40,  5.08,  4.58,  4.11,
     @   3.83,  3.58,  3.34,  3.03,  2.70,  2.37,  2.04,  1.70,
     @   1.48,  1.34,  1.19,  1.05,  0.91,  0.79,  0.67,  0.54,
     @   0.43,  0.32,  0.21,  0.15,  0.10,  0.05,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00/
      data skpd1/
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.20,  0.43,  0.98,  1.81,
     @   2.69,  3.44,  4.09,  4.40,  4.55,  4.52,  4.41,  4.28,
     @   4.12,  3.87,  3.62,  3.37,  3.12,  2.86,  2.65,  2.45,
     @   2.26,  2.08,  1.92,  1.80,  1.67,  1.57,  1.47,  1.43,
     @   1.40,  1.37,  1.33,  1.27,  1.22,  1.18,  1.13,  1.08,
     @   1.04,  0.99,  0.94,  0.89,  0.90,  0.50,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00/
      data skpd2/
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  1.57,  1.91,  2.23,
     @   2.52,  2.82,  3.13,  3.23,  3.27,  3.26,  3.15,  2.92,
     @   2.64,  2.45,  2.30,  2.12,  2.00,  1.91,  1.83,  1.77,
     @   1.73,  1.67,  1.61,  1.56,  1.51,  1.48,  1.46,  1.41,
     @   1.36,  1.32,  1.30,  1.25,  1.21,  1.19,  1.18,  1.00,
     @   0.80,  0.50,  0.30,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00/
      data skpd3/
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.31,  0.62,  0.89,
     @   1.14,  1.40,  1.66,  1.88,  2.00,  2.17,  2.24,  2.29,
     @   2.35,  2.41,  2.45,  2.48,  2.49,  2.46,  2.44,  2.39,
     @   2.33,  2.28,  2.22,  2.17,  2.13,  2.10,  1.50,  1.00,
     @   0.50,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @   0.00,  0.00,  0.00,  0.00/
      data splmt/
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @ 209.26, 34.00, 22.84, 21.23, 20.72, 21.46, 22.40, 24.24,
     @  26.01, 27.75, 29.65, 31.54, 33.41, 35.28, 36.53, 36.76,
     @  36.98, 37.20, 37.42, 37.65, 37.74, 37.58, 37.42, 37.26,
     @  37.09, 36.93, 36.76, 36.59, 36.42, 36.24, 36.06, 35.88,
     @  35.70, 35.57, 35.47, 35.38, 35.28, 35.18, 35.07, 34.97,
     @  34.86, 34.76, 34.65, 34.54, 34.42, 34.31, 34.19, 34.07,
     @  33.95, 33.82, 33.69, 33.58, 33.53, 33.49, 33.45, 33.41,
     @  33.36, 33.32, 33.27, 33.22, 33.17, 33.13, 33.08, 33.02,
     @  32.97, 32.92, 32.87, 32.81, 32.75, 32.70, 32.64, 32.58,
     @  32.52, 32.46, 32.39, 32.33, 32.26, 32.20, 32.13, 32.06,
     @  31.99, 31.91, 31.84, 31.77, 31.69, 31.61, 31.53, 31.45,
     @  31.37, 31.28, 31.19, 31.11
     @/
      data splmel/
     @   0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @ 209.26, 34.00, 22.84, 21.23, 18.87, 17.29, 15.81, 15.18,
     @  15.04, 14.91, 14.78, 14.65, 14.52, 14.38, 14.16, 13.94,
     @  13.72, 13.49, 13.27, 13.04, 12.81, 12.58, 12.34, 12.15,
     @  11.98, 11.81, 11.63, 11.45, 11.27, 11.09, 10.90, 10.71,
     @  10.52, 10.32, 10.13,  9.92,  9.72,  9.51,  9.36,  9.22,
     @   9.08,  8.94,  8.80,  8.66,  8.51,  8.36,  8.21,  8.05,
     @   7.89,  7.73,  7.59,  7.44,  7.28,  7.13,  6.97,  6.81,
     @   6.65,  6.48,  6.31,  6.13,  5.97,  5.94,  5.91,  5.88,
     @   5.85,  5.82,  5.79,  5.76,  5.72,  5.69,  5.66,  5.62,
     @   5.59,  5.55,  5.52,  5.48,  5.44,  5.40,  5.37,  5.33,
     @   5.29,  5.25,  5.21,  5.17,  5.13,  5.09,  5.05,  5.00,
     @   4.96,  4.91,  4.86,  4.82
     @/
      data wqnnnd/
     @   0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.021,
     @   0.168,  0.570,  1.423,  3.027,  5.836,  9.931, 14.440, 18.294,
     @  21.150, 23.073, 24.287, 24.965, 25.251, 25.251, 25.043, 24.684,
     @  24.217, 23.672, 23.074, 22.441, 21.787, 21.121, 20.452, 19.786,
     @  19.127, 18.479, 17.845, 17.226, 16.623, 16.038, 15.471, 14.921,
     @  14.573, 14.221, 13.866, 13.507, 13.144, 12.778, 12.408, 12.034,
     @  11.657, 11.276, 10.891, 10.502, 10.109,  9.712,  9.312,  8.907,
     @   8.498,  8.085,  7.668,  7.247,  6.821,  6.563,  6.314,  6.074,
     @   5.842,  5.618,  5.402,  5.194,  4.993,  4.799,  4.612,  4.431,
     @   4.258,  4.090,  3.928,  3.773,  3.623,  3.478,  3.339,  3.204,
     @   3.075,  2.951,  2.831,  2.715,  2.604,  2.497,  2.394,  2.295,
     @   2.200,  2.108,  2.020,  1.935,  1.853,  1.774,  1.699,  1.626,
     @   1.557,  1.490,  1.425,  1.364/
      data (dsdm( 1,j),j=1,20) /
     @  1.41, 1.38, 1.35, 1.32, 1.29, 1.26, 1.22, 1.19, 1.15, 1.11,
     @  1.07, 1.02, 0.94, 0.86, 0.80, 0.73, 0.65, 0.55, 0.44, 0.27/
      data (dsdm( 2,j),j=1,20) /
     @  1.36, 1.34, 1.32, 1.30, 1.28, 1.24, 1.21, 1.18, 1.15, 1.11,
     @  1.06, 1.01, 0.96, 0.90, 0.85, 0.76, 0.67, 0.57, 0.45, 0.28/
      data (dsdm( 3,j),j=1,20) /
     @  1.33, 1.31, 1.30, 1.28, 1.26, 1.23, 1.21, 1.18, 1.15, 1.11,
     @  1.07, 1.03, 0.98, 0.92, 0.86, 0.79, 0.70, 0.59, 0.48, 0.25/
      data (dsdm( 4,j),j=1,20) /
     @  1.29, 1.28, 1.27, 1.26, 1.24, 1.22, 1.20, 1.18, 1.15, 1.12,
     @  1.08, 1.04, 0.99, 0.93, 0.87, 0.80, 0.72, 0.61, 0.48, 0.27/
      data (dsdm( 5,j),j=1,20) /
     @  1.27, 1.26, 1.25, 1.24, 1.23, 1.22, 1.20, 1.18, 1.15, 1.12,
     @  1.09, 1.05, 1.00, 0.94, 0.88, 0.81, 0.72, 0.62, 0.49, 0.28/
      data (dsdm( 6,j),j=1,20) /
     @  1.24, 1.24, 1.24, 1.23, 1.23, 1.21, 1.20, 1.18, 1.16, 1.13,
     @  1.10, 1.06, 1.01, 0.95, 0.89, 0.82, 0.73, 0.62, 0.49, 0.28/
      data (dsdm( 7,j),j=1,20) /
     @  1.22, 1.22, 1.22, 1.22, 1.22, 1.21, 1.20, 1.18, 1.16, 1.14,
     @  1.10, 1.06, 1.02, 0.96, 0.90, 0.82, 0.73, 0.63, 0.50, 0.28/
      data (dsdm( 8,j),j=1,20) /
     @  1.19, 1.20, 1.21, 1.21, 1.21, 1.21, 1.20, 1.19, 1.17, 1.15,
     @  1.11, 1.07, 1.03, 0.98, 0.91, 0.84, 0.74, 0.63, 0.49, 0.26/
      data (dsdm( 9,j),j=1,20) /
     @  1.17, 1.19, 1.20, 1.20, 1.21, 1.21, 1.20, 1.19, 1.17, 1.15,
     @  1.12, 1.08, 1.03, 0.98, 0.91, 0.84, 0.74, 0.63, 0.49, 0.28/
      data (dsdm(10,j),j=1,20) /
     @  1.15, 1.17, 1.19, 1.20, 1.20, 1.21, 1.21, 1.20, 1.18, 1.16,
     @  1.13, 1.09, 1.04, 0.99, 0.92, 0.84, 0.74, 0.63, 0.48, 0.27/
      data (dsdm(11,j),j=1,20) /
     @  1.14, 1.16, 1.18, 1.19, 1.20, 1.21, 1.21, 1.20, 1.19, 1.17,
     @  1.14, 1.10, 1.05, 0.99, 0.92, 0.84, 0.74, 0.63, 0.49, 0.26/
      data (dsdm(12,j),j=1,20) /
     @  1.12, 1.14, 1.16, 1.18, 1.20, 1.21, 1.21, 1.21, 1.20, 1.18,
     @  1.15, 1.11, 1.06, 1.00, 0.93, 0.84, 0.74, 0.63, 0.48, 0.26/
      data (dsdm(13,j),j=1,20) /
     @  1.10, 1.13, 1.15, 1.18, 1.20, 1.21, 1.22, 1.22, 1.21, 1.19,
     @  1.16, 1.12, 1.07, 1.01, 0.93, 0.84, 0.74, 0.62, 0.47, 0.25/
      data (dsdm(14,j),j=1,20) /
     @  1.08, 1.11, 1.14, 1.17, 1.19, 1.21, 1.22, 1.22, 1.22, 1.20,
     @  1.17, 1.13, 1.08, 1.01, 0.93, 0.84, 0.74, 0.61, 0.47, 0.25/
      data (dsdm(15,j),j=1,20) /
     @  1.06, 1.10, 1.13, 1.16, 1.19, 1.21, 1.23, 1.23, 1.23, 1.21,
     @  1.18, 1.14, 1.08, 1.02, 0.94, 0.84, 0.74, 0.61, 0.46, 0.25/
      data (dsdm(16,j),j=1,20) /
     @  1.05, 1.08, 1.12, 1.16, 1.19, 1.22, 1.23, 1.24, 1.23, 1.22,
     @  1.19, 1.15, 1.09, 1.02, 0.94, 0.84, 0.73, 0.60, 0.45, 0.25/
      data (dsdm(17,j),j=1,20) /
     @  1.03, 1.07, 1.11, 1.15, 1.19, 1.22, 1.24, 1.25, 1.24, 1.23,
     @  1.20, 1.16, 1.10, 1.03, 0.94, 0.84, 0.73, 0.59, 0.44, 0.24/
      data (dsdm(18,j),j=1,20) /
     @  1.01, 1.06, 1.10, 1.15, 1.19, 1.22, 1.24, 1.26, 1.26, 1.24,
     @  1.21, 1.17, 1.11, 1.03, 0.94, 0.84, 0.72, 0.59, 0.44, 0.23/
      data (dsdm(19,j),j=1,20) /
     @  1.00, 1.04, 1.09, 1.14, 1.18, 1.22, 1.25, 1.26, 1.27, 1.25,
     @  1.22, 1.18, 1.11, 1.04, 0.94, 0.84, 0.72, 0.58, 0.43, 0.23/
      data (dsdm(20,j),j=1,20) /
     @  0.98, 1.03, 1.08, 1.13, 1.18, 1.22, 1.26, 1.27, 1.28, 1.27,
     @  1.23, 1.19, 1.12, 1.04, 0.95, 0.84, 0.71, 0.58, 0.42, 0.21/
      data (dsdm(21,j),j=1,20) /
     @  0.96, 1.02, 1.07, 1.13, 1.18, 1.23, 1.26, 1.28, 1.29, 1.28,
     @  1.25, 1.20, 1.13, 1.05, 0.95, 0.83, 0.71, 0.57, 0.41, 0.21/
      data (dsdm(22,j),j=1,20) /
     @  0.94, 1.00, 1.06, 1.12, 1.18, 1.23, 1.27, 1.29, 1.30, 1.29,
     @  1.26, 1.21, 1.14, 1.05, 0.95, 0.83, 0.70, 0.56, 0.40, 0.20/
      data (dsdm(23,j),j=1,20) /
     @  0.93, 0.99, 1.05, 1.11, 1.18, 1.23, 1.27, 1.30, 1.31, 1.30,
     @  1.27, 1.22, 1.15, 1.06, 0.95, 0.83, 0.70, 0.56, 0.40, 0.20/
      data (dsdm(24,j),j=1,20) /
     @  0.91, 0.97, 1.04, 1.11, 1.18, 1.23, 1.28, 1.31, 1.32, 1.31,
     @  1.28, 1.23, 1.15, 1.06, 0.95, 0.83, 0.69, 0.55, 0.39, 0.20/
      data (dsdm(25,j),j=1,20) /
     @  0.89, 0.96, 1.03, 1.10, 1.17, 1.24, 1.29, 1.32, 1.34, 1.33,
     @  1.30, 1.24, 1.16, 1.06, 0.95, 0.82, 0.69, 0.54, 0.38, 0.19/
      data (dsdm(26,j),j=1,20) /
     @  0.88, 0.94, 1.02, 1.10, 1.17, 1.24, 1.30, 1.33, 1.35, 1.34,
     @  1.31, 1.25, 1.17, 1.07, 0.95, 0.82, 0.68, 0.53, 0.37, 0.19/
      data (dsdm(27,j),j=1,20) /
     @  0.86, 0.93, 1.01, 1.09, 1.17, 1.24, 1.30, 1.34, 1.36, 1.35,
     @  1.32, 1.26, 1.18, 1.08, 0.95, 0.82, 0.67, 0.52, 0.36, 0.18/
      data (dsdm(28,j),j=1,20) /
     @  0.84, 0.92, 1.00, 1.08, 1.17, 1.24, 1.31, 1.35, 1.37, 1.37,
     @  1.33, 1.27, 1.19, 1.08, 0.95, 0.81, 0.67, 0.51, 0.36, 0.18/
      data (dsdm(29,j),j=1,20) /
     @  0.83, 0.90, 0.99, 1.07, 1.17, 1.25, 1.31, 1.36, 1.39, 1.38,
     @  1.35, 1.28, 1.19, 1.08, 0.95, 0.81, 0.66, 0.51, 0.35, 0.17/
      data (dsdm(30,j),j=1,20) /
     @  0.81, 0.89, 0.98, 1.07, 1.16, 1.25, 1.32, 1.37, 1.40, 1.39,
     @  1.36, 1.29, 1.20, 1.09, 0.95, 0.81, 0.65, 0.50, 0.34, 0.16/
      data (dsdm(31,j),j=1,20) /
     @  0.79, 0.87, 0.96, 1.06, 1.16, 1.25, 1.33, 1.38, 1.41, 1.41,
     @  1.37, 1.31, 1.21, 1.09, 0.95, 0.81, 0.65, 0.49, 0.33, 0.16/
      data (dsdm(32,j),j=1,20) /
     @  0.78, 0.86, 0.95, 1.06, 1.16, 1.26, 1.34, 1.40, 1.42, 1.42,
     @  1.39, 1.32, 1.22, 1.09, 0.95, 0.80, 0.64, 0.48, 0.32, 0.15/
      data (dsdm(33,j),j=1,20) /
     @  0.76, 0.84, 0.94, 1.05, 1.16, 1.26, 1.35, 1.41, 1.44, 1.43,
     @  1.40, 1.33, 1.23, 1.10, 0.95, 0.80, 0.63, 0.47, 0.32, 0.15/
      data (dsdm(34,j),j=1,20) /
     @  0.74, 0.83, 0.93, 1.04, 1.16, 1.26, 1.35, 1.42, 1.45, 1.45,
     @  1.41, 1.34, 1.23, 1.10, 0.95, 0.79, 0.63, 0.46, 0.31, 0.14/
      data (dsdm(35,j),j=1,20) /
     @  0.73, 0.81, 0.92, 1.03, 1.15, 1.27, 1.36, 1.43, 1.46, 1.46,
     @  1.42, 1.35, 1.24, 1.11, 0.95, 0.79, 0.62, 0.46, 0.30, 0.14/
      data (dsdm(36,j),j=1,20) /
     @  0.71, 0.80, 0.91, 1.03, 1.15, 1.27, 1.37, 1.44, 1.48, 1.48,
     @  1.44, 1.36, 1.25, 1.11, 0.95, 0.78, 0.61, 0.45, 0.29, 0.13/
      data (dsdm(37,j),j=1,20) /
     @  0.69, 0.79, 0.90, 1.02, 1.15, 1.27, 1.37, 1.45, 1.49, 1.49,
     @  1.45, 1.37, 1.25, 1.11, 0.95, 0.78, 0.61, 0.44, 0.29, 0.13/
      data (dsdm(38,j),j=1,20) /
     @  0.68, 0.77, 0.88, 1.01, 1.15, 1.27, 1.38, 1.46, 1.50, 1.50,
     @  1.46, 1.38, 1.26, 1.11, 0.95, 0.78, 0.60, 0.43, 0.28, 0.14/
      data (dsdm(39,j),j=1,20) /
     @  0.64, 0.73, 0.83, 0.96, 1.09, 1.21, 1.32, 1.40, 1.45, 1.47,
     @  1.44, 1.38, 1.28, 1.16, 1.01, 0.85, 0.68, 0.52, 0.36, 0.22/
      data (dsdm(40,j),j=1,20) /
     @  0.61, 0.69, 0.79, 0.91, 1.04, 1.16, 1.27, 1.36, 1.42, 1.45,
     @  1.43, 1.39, 1.30, 1.19, 1.05, 0.90, 0.74, 0.58, 0.43, 0.29/
      data (dsdm(41,j),j=1,20) /
     @  0.58, 0.66, 0.76, 0.87, 0.99, 1.11, 1.23, 1.32, 1.39, 1.42,
     @  1.42, 1.39, 1.32, 1.22, 1.09, 0.95, 0.80, 0.64, 0.49, 0.36/
      data (dsdm(42,j),j=1,20) /
     @  0.55, 0.63, 0.72, 0.83, 0.95, 1.07, 1.19, 1.28, 1.36, 1.40,
     @  1.41, 1.39, 1.33, 1.24, 1.13, 1.00, 0.85, 0.70, 0.56, 0.42/
      data (dsdm(43,j),j=1,20) /
     @  0.53, 0.60, 0.69, 0.80, 0.92, 1.03, 1.15, 1.25, 1.33, 1.38,
     @  1.40, 1.38, 1.34, 1.26, 1.16, 1.04, 0.90, 0.76, 0.62, 0.48/
      data (dsdm(44,j),j=1,20) /
     @  0.51, 0.58, 0.66, 0.77, 0.88, 1.00, 1.11, 1.21, 1.30, 1.35,
     @  1.38, 1.38, 1.35, 1.28, 1.19, 1.08, 0.95, 0.81, 0.67, 0.54/
      data (dsdm(45,j),j=1,20) /
     @  0.49, 0.55, 0.64, 0.74, 0.85, 0.96, 1.08, 1.18, 1.27, 1.33,
     @  1.37, 1.38, 1.35, 1.30, 1.22, 1.12, 1.00, 0.87, 0.73, 0.60/
      data (dsdm(46,j),j=1,20) /
     @  0.47, 0.53, 0.61, 0.71, 0.82, 0.93, 1.04, 1.15, 1.24, 1.31,
     @  1.35, 1.37, 1.36, 1.31, 1.25, 1.15, 1.04, 0.92, 0.79, 0.65/
      data (dsdm(47,j),j=1,20) /
     @  0.45, 0.51, 0.59, 0.68, 0.79, 0.90, 1.01, 1.12, 1.21, 1.29,
     @  1.34, 1.36, 1.36, 1.33, 1.27, 1.19, 1.09, 0.97, 0.84, 0.71/
      data (dsdm(48,j),j=1,20) /
     @  0.43, 0.49, 0.57, 0.66, 0.76, 0.87, 0.98, 1.09, 1.19, 1.27,
     @  1.32, 1.36, 1.36, 1.34, 1.29, 1.22, 1.13, 1.02, 0.90, 0.77/
      data (dsdm(49,j),j=1,20) /
     @  0.42, 0.47, 0.55, 0.63, 0.73, 0.84, 0.95, 1.06, 1.16, 1.24,
     @  1.31, 1.35, 1.36, 1.35, 1.31, 1.25, 1.16, 1.06, 0.95, 0.82/
      data (dsdm(50,j),j=1,20) /
     @  0.40, 0.46, 0.53, 0.61, 0.71, 0.82, 0.93, 1.04, 1.14, 1.23,
     @  1.29, 1.34, 1.36, 1.36, 1.33, 1.28, 1.20, 1.11, 1.00, 0.88/
      data (dsdm(51,j),j=1,20) /
     @  0.39, 0.44, 0.51, 0.59, 0.69, 0.79, 0.90, 1.01, 1.11, 1.20,
     @  1.28, 1.33, 1.36, 1.37, 1.35, 1.30, 1.23, 1.15, 1.05, 0.93/
      data (dsdm(52,j),j=1,20) /
     @  0.38, 0.43, 0.49, 0.57, 0.67, 0.77, 0.88, 0.99, 1.09, 1.19,
     @  1.27, 1.32, 1.36, 1.37, 1.36, 1.33, 1.27, 1.19, 1.09, 0.99/
      data (dsdm(53,j),j=1,20) /
     @  0.36, 0.41, 0.48, 0.56, 0.65, 0.75, 0.86, 0.96, 1.07, 1.17,
     @  1.25, 1.31, 1.36, 1.38, 1.38, 1.35, 1.30, 1.23, 1.14, 1.04/
      data dnnnfc/
     @ 2357.86, 350.16, 104.86,
     @ 41.17,18.44, 9.09, 5.05, 3.26, 2.43, 1.97, 1.70, 1.53, 1.40,
     @  1.31, 1.24, 1.19, 1.14, 1.11, 1.08, 1.06, 1.04, 1.02, 1.01,
     @  1.00, 0.99, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98,
     @  0.99, 0.99, 1.00, 1.00, 1.01, 1.05, 1.09, 1.13, 1.16, 1.20,
     @  1.24, 1.27, 1.31, 1.34, 1.38, 1.41, 1.44, 1.48, 1.51, 1.54/
      real*4 cgksq
      common/cgkblk/ cgksq(227)
      data (cgksq(i),i=1,120)/  0., 0.5, 0.5, 0., 1., 0.5,
     @ 0.50000, 1.00000, 0.00000, 0.33333, 0.66667, 0.66667,
     @ 0.33333, 0.00000, 1.00000, 0.66667, 0.33333, 0.33333,
     @ 0.66667, 1.00000, 0.00000, 0.25000, 0.50000, 0.75000,
     @ 0.75000, 0.50000, 0.25000, 0.00000, 1.00000, 0.75000,
     @ 0.50000, 0.25000, 0.25000, 0.50000, 0.75000, 1.00000,
     @ 0.00000, 0.66667, 0.33333, 0.33333, 0.66667, 0.00000,
     @ 1.00000, 0.33333, 0.66667, 0.66667, 0.33333, 1.00000,
     @ 0.00000, 0.00000, 0.33333, 0.00000, 0.33333, 0.00000,
     @ 0.33333, 0.00000, 0.00000, 0.00000, 0.50000, 0.50000,
     @ 0.50000, 0.00000, 0.50000, 0.50000, 0.50000, 0.00000,
     @ 1.00000, 0.50000, 0.16667, 0.50000, 0.66667, 0.50000,
     @ 0.16667, 0.50000, 1.00000, 0.00000, 0.00000, 0.16667,
     @ 0.50000, 0.00000, 0.33333, 0.33333, 0.00000, 0.50000,
     @ 0.16667, 0.00000, 0.00000, 0.00000, 0.40000, 0.53333,
     @ 0.40000, 0.60000, 0.06667, 0.06667, 0.60000, 0.40000,
     @ 0.53333, 0.40000, 0.00000, 1.00000, 0.60000, 0.30000,
     @ 0.10000, 0.40000, 0.60000, 0.60000, 0.40000, 0.10000,
     @ 0.30000, 0.60000, 1.00000, 0.00000, 0.75000, 0.25000,
     @ 0.50000, 0.50000, 0.25000, 0.75000, 0.00000, 1.00000/
       data (cgksq(i),i=121,227) /
     @ 0.25000, 0.75000, 0.50000, 0.50000, 0.75000, 0.25000,
     @ 1.00000, 0.00000, 0.00000, 0.50000, 0.00000, 0.33333,
     @ 0.16667, 0.16667, 0.33333, 0.00000, 0.50000, 0.00000,
     @ 0.00000, 0.00000, 0.60000, 0.40000, 0.40000, 0.06667,
     @ 0.53333, 0.53333, 0.06667, 0.40000, 0.40000, 0.60000,
     @ 0.00000, 1.00000, 0.40000, 0.10000, 0.60000, 0.60000,
     @ 0.30000, 0.30000, 0.60000, 0.60000, 0.10000, 0.40000,
     @ 1.00000, 0.00000, 0.00000, 0.00000, 0.25000, 0.00000,
     @ 0.00000, 0.25000, 0.00000, 0.00000, 0.25000, 0.00000,
     @ 0.00000, 0.25000, 0.00000, 0.00000, 0.00000, 0.00000,
     @ 0.00000, 0.30000, 0.45000, 0.00000, 0.40000, 0.05000,
     @ 0.30000, 0.30000, 0.05000, 0.40000, 0.00000, 0.45000,
     @ 0.30000, 0.00000, 0.00000, 0.00000, 0.50000, 0.50000,
     @ 0.25000, 0.50000, 0.00000, 0.25000, 0.50000, 0.50000,
     @ 0.25000, 0.00000, 0.50000, 0.25000, 0.50000, 0.50000,
     @ 0.00000, 1.00000, 0.50000, 0.20000, 0.05000, 0.50000,
     @ 0.60000, 0.45000, 0.20000, 0.20000, 0.45000, 0.60000,
     @ 0.50000, 0.05000, 0.20000, 0.50000, 1.00000
     @ /
      end
      subroutine retcgk(it1,np1,it2,np2,j,cgk2)
#include "amsrqmd.h"
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
       np1a=iabs(np1)
       if(it1.gt.15) then
         if(np1a.le.0.or.np1a.gt.70) then
           call errex('retcgk:wrong input')
         end if
         j1=isosp(np1a)
         m1=isign(1,np1)*isosp3(np1a)
       else if(it1.eq.15) then
         j1=2
         m1=2*np1
       else if(it1.eq.14) then
         j1=1
         m1=isign(1,np1)*(2*np1a-3)
       else if(it1.eq.12.or.it1.eq.13) then
         j1=0
         m1=0
       else if(it1.ge.7.and.it1.le.9) then
         j1=2
         m1=2*it1-16
       else if(it1.ge.3.and.it1.le.6) then
         j1=3
         m1=2*it1-9
       else if(mod(it1,9).eq.1.or.mod(it1,9).eq.2) then
         j1=1
         m1=2*mod(it1,9)-3
       else
         call errex('retcgk:wrong input')
       end if
       if(j.lt.0) then
         it2=j1
         np2=m1
         return
       end if
       np2a=iabs(np2)
       if(it2.gt.15) then
         if(np2a.le.0.or.np2a.gt.70) then
           call errex('retcgk:wrong input')
         end if
         j2=isosp(np2a)
         m2=isign(1,np2)*isosp3(np2a)
       else if(it2.eq.15) then
         j2=2
         m2=2*np2
       else if(it2.eq.14) then
         j2=1
         m2=isign(1,np2)*(2*np2a-3)
       else if(it2.eq.12.or.it2.eq.13) then
         j2=0
         m2=0
       else if(it2.ge.7.and.it2.le.9) then
         j2=2
         m2=2*it2-16
       else if(it2.ge.3.and.it2.le.6) then
         j2=3
         m2=2*it2-9
       else if(mod(it2,9).eq.1.or.mod(it2,9).eq.2) then
         j2=1
         m2=2*mod(it2,9)-3
       else
         call errex('retcgk:wrong input')
       end if
       cgk2=cgks(j1,j2,j,m1,m2)
      return
      end
      function cgks(j1,j2,j,m1,m2)
#include "amsrqmd.h"
      dimension ivek(9)
      data ivek /0,8,20,36,48,75,111,127,163/
      common/cgkblk/ cgksq(227)
      if(j.gt.j1+j2.or.j.lt.iabs(j1-j2) .or.
     &       iabs(m1).gt.j1.or.iabs(m2).gt.j2) then
        cgks=0.
        return
      else if(mod(j1,2).ne.mod(iabs(m1),2).or.
     &             mod(j2,2).ne.mod(iabs(m2),2)) then
        cgks=0.
        return
      else if(mod(j1+j2+j,2).ne.0) then
        cgks=0.
        return
      end if
       iofs1=((j-iabs(j1-j2))*(j1+1)*(j2+1))/2
       iofs2=((m1+j1)*(j2+1))/2
       iofs3=(m2+j2)/2
       if(j1.gt.0.and.j2.gt.0) then
         iarg=(j1-1)*3+j2
         if(iarg.le.0.or.iarg.gt.9) then
            call errex('wrong input in cgks')
            cgks=0.
            return
         end if
         ifofs=iofs1+iofs2+iofs3+1+ivek((j1-1)*3+j2)
         if(1.le.ifofs.and.227.ge.ifofs) then
            cgks=cgksq(ifofs)
         else
            call errex('wrong index in cgks')
            cgks=0.
         end if
       else if(j1.eq.j.or.j2.eq.j) then
         cgks=1.
       else
         call errex('wrong input in cgks')
         cgks=0.
       end if
       return
       end
      subroutine isocgk(m1,j1,m2,j2,j1new,j2new,m1new,m2new,itag)
#include "amsrqmd.h"
      real*4 cgksq
      common/cgkblk/ cgksq(227)
      dimension pjin(4),prbout(7),m1out(7)
      common /pjbk/ pjin
      data nj,jmin / 0,0 /
      if(itag.ne.-100) then
        itag=0
      end if
      m=m1+m2
      jminol=max0(iabs(j1-j2),iabs(m))
      jmaxol=j1+j2
      jminnw=max0(iabs(j1new-j2new),iabs(m))
      jmaxnw=j1new+j2new
      jmin=max0(jminol,jminnw)
      jmax=min0(jmaxol,jmaxnw)
      nj=(jmax-jmin)/2 +1
      if(j1.eq.0.or.j2.eq.0) then
         if(jmin.ne.jmax) call errex('j1(2)=0,jmin.ne.jmax in isocgk')
         pjin(1)=1.
         go to 310
      end if
      if(nj.le.0) then
         itag=-1
         return
      end if
       ifind=0
       ifg=0
       do 20 j1pr=1,3
       do 19 j2pr=1,3
       do 18 jpr=iabs(j1pr-j2pr),j1pr+j2pr,2
       do 17 m1pr=-j1pr,j1pr,2
       do 16 m2pr=-j2pr,j2pr,2
       ifg=ifg+1
       if((m1.eq.m1pr).and.
     a    (m2.eq.m2pr).and.
     a    (j1.eq.j1pr).and.
     a    (j2.eq.j2pr) )then
          if((jpr.ge.jmin).and.(jpr.le.jmax)) then
            ifind=ifind+1
            pjin(ifind)=cgksq(ifg)
          end if
       end if
   16 continue
   17 continue
   18 continue
   19 continue
   20 continue
      if(ifind.ne.nj) then
           write(lun8,*)'j1,m1,j2,m2,j1new,j2new'
           write(lun8,*) j1,m1,j2,m2,j1new,j2new
           write(lun8,*) 'jmin,jmax,ifind,nj'
           write(lun8,*)  jmin,jmax,ifind,nj
           call errex('error in isocgk ifind.ne.nj')
      end if
      prbsum=0.
      do 30 il=1,nj
   30 prbsum=prbsum+pjin(il)
      if(prbsum.le.0.) then
           write(lun8,*)'j1,m1,j2,m2,j1new,j2new'
           write(lun8,*) j1,m1,j2,m2,j1new,j2new
           write(lun8,*) 'jmin,jmax,ifind,nj'
           write(lun8,*)  jmin,jmax,ifind,nj
           write(lun8,*) (pjin(il),il=1,nj),'pjin'
           call errex('error in isocgk 30:prbsum.le.0.')
      end if
      do 31 il=1,nj
   31 pjin(il)=pjin(il)/prbsum
      if(itag.eq.-100) then
          itag=0
          return
      else
          go to 310
      end if
      entry isoent(m1,j1,m2,j2,j1new,j2new,m1new,m2new,itag)
      m=m1+m2
 310  kjfnd=0
      zrand=ranf(0)
      do 32 il=1,nj
      if(kjfnd.lt.0) go to 33
      if(zrand.le.pjin(il)) then
         kjfnd=-1
         jtot=jmin +2*(il-1)
      else
         zrand=zrand-pjin(il)
      end if
   32 continue
   33 continue
      go to 34
      entry isonew(jin,min,j1new,j2new,m1new,m2new,itag)
      if(itag.eq.-50) then
         jtot=jin
         m=min
         itag=0
      end if
   34 continue
      if(j1new.eq.0.or.j2new.eq.0) then
        if(jtot.ne.j1new+j2new)
     a       call errex('isocgk:j1/2new=0,jtot different')
        if(j1new.eq.0) then
          m1new=0
          m2new=m
        else
          m2new=0
          m1new=m
        end if
        return
      end if
      m1pos=0
      ifg=0
      do 40 j1pr=1,3
      do 39 j2pr=1,3
      do 38 jpr=iabs(j1pr-j2pr),j1pr+j2pr,2
      do 37 m1pr=-j1pr,j1pr,2
      do 36 m2pr=-j2pr,j2pr,2
       ifg=ifg+1
       mpr=m1pr+m2pr
       if((j1new.eq.j1pr).and.
     a    (j2new.eq.j2pr).and.
     a    (jtot.eq.jpr).and.
     a    (m .eq. mpr) )then
            m1pos=m1pos+1
            m1out(m1pos)=m1pr
            prbout(m1pos)=cgksq(ifg)
       end if
   36 continue
   37 continue
   38 continue
   39 continue
   40 continue
      if(m1pos.eq.0) call errex('in isocgk: m1pos=0 error')
      prbsum=0.
      do 50 m1p=1,m1pos
   50 prbsum=prbsum+prbout(m1p)
      if(prbsum.le.0.) call errex('error in isocgk:prbsum.le.0.')
      do 51 m1p=1,m1pos
   51 prbout(m1p)=prbout(m1p)/prbsum
      km1fnd=0
      zrand=ranf(0)
      m1new=-1000
      do 52 m1p=1,m1pos
      if(km1fnd.lt.0) go to 52
      if(zrand.le.prbout(m1p)) then
         km1fnd=-1
         m1new=m1out(m1p)
      else
         zrand=zrand-prbout(m1p)
      end if
   52 continue
      m2new=m-m1new
      return
      end
CPAT,CLUST    .
      subroutine clustr
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      include 'storbig'
      real*4 force,dcoef
      common/blocal/ ngbor(ntotma),force(0:3,ntotma),dcoef(ntotma)
      dimension att(17,ntotma)
      dimension qlk(0:3),pclust(0:3)
      equivalence(att(1,1),at(1,1) )
      if(nclmx*nclmx.lt.17*ntotma) then
         call errex('att has not enough space ,abort in clustr')
      end if
      io=0
      do 631 iclu=1,itripl-1
        io=io+iclusz(iclu)
  631 continue
      inold=io
      io=io+iclusz(itripl)
      nttot= nrbar(itripl)+nrmes(itripl)
      do 4000 l=1,nttot
        il=inold+l
        do 3990 i=0,3
         att(1+i,l)=x(i,il)
         att(5+i,l)=p(i,il)
 3990 continue
         att(9,l)=em(il)
         att(10,l)=decay(il)
         att(15,l)=tlast(il)
 4000 continue
      do 4110 l=1,nttot
         il=inold+l
         att(11,l)=float(ityp(il))
         att(13,l)=float(npidec(il))
         att(14,l)=float(lastcl(il))
         att(16,l)=float(ichbig(il))
         att(12,l)=float(issn(il))
 4110 continue
      if(nttot.le.1) then
       do 657 l=1,nttot
        ngbrnr(l)=1
  657  continue
      end if
      do 3790 l=1,nttot
      il=inold+l
      if(ngbrnr(l).eq.1) go to 3790
      mnr=1
 3791 if(ngbrnr(l).lt.mnr) go to 3790
      m=nghbor(ngbsum(l)+mnr)
      im=inold+m
      if((m.eq.l-1).or.(m.eq.l+1)) then
          do 3799 i=0,3
          qlk(i)=  x(i,il)-x(i,im)
 3799     continue
          dqlksq = qlk(0) *qlk(0)
          do  3800 i=1,3
          dqlksq = dqlksq - qlk(i) *qlk(i)
 3800     continue
          if(-dqlksq.gt.dstint) then
           do 3794 lnr=mnr+1,ngbrnr(l)
 3794      nghbor(ngbsum(l)+lnr-1)=nghbor(ngbsum(l)+lnr)
           ngbrnr(l)=ngbrnr(l)-1
           go to 3791
          end if
      else if(((l.eq.1).and.(m.eq.nttot)).or.
     a       ((m.eq.1).and.(l.eq.nttot)))then
        do 3803 i=0,3
        qlk(i)=  x(i,il)-x(i,im)
 3803   continue
        dqlksq = qlk(0) *qlk(0)
        do  3802 i=1,3
        dqlksq = dqlksq - qlk(i) *qlk(i)
 3802   continue
        if(-dqlksq.gt.dstint) then
           do 3793 lnr=mnr+1,ngbrnr(l)
 3793      nghbor(ngbsum(l)+lnr-1)=nghbor(ngbsum(l)+lnr)
           ngbrnr(l)=ngbrnr(l)-1
           go to 3791
        end if
      end if
      mnr=mnr+1
      go to 3791
 3790 continue
      lclust=itripl-1
      iloop= inold
      if(nrclst.gt.itripl) then
         do 655 kcl=itripl+1,nrclst
           do 654 l=1,nrbar(kcl)+nrmes(kcl)
             lclust=lclust+1
             il=io+l
             iloop=iloop+1
              do 653 i=0,3
                x(i,iloop)=x(i,il)
                p(i,iloop)=p(i,il)
  653         continue
              em(iloop)=em(il)
              ityp(iloop)=ityp(il)
              decay(iloop)=decay(il)
              lastcl(iloop)=lastcl(il)
              issn(iloop)=issn(il)
              npidec(iloop)=npidec(il)
              tlast(iloop)=tlast(il)
              ichbig(iloop)=0
  654      continue
           nonrel(lclust)=.false.
           iclusz(lclust)= 1
           if(nrbar(kcl).eq.1) then
              nrbar(lclust)=1
              nrmes(lclust)=0
           else
              nrbar(lclust)=0
              nrmes(lclust)=1
           endif
           io=io+iclusz(kcl)
  655    continue
      end if
      lclold=lclust
      nrclst=lclold
      ngrprv=0
      ngr=0
      do 3100 l=1,nttot
      if(ngbrnr(l).eq.0) go to 3100
      mnr=0
      nrclst=nrclst+1
      if(ngbrnr(l).eq.1) then
          ngr=ngr+1
          ngbor(ngr)=l
          go to 3099
      else
          do 3049 knr=1,ngbrnr(l)
             ngr=ngr+1
             ngbor(ngr) =nghbor(ngbsum(l)+knr)
 3049     continue
      end if
 3050 mnr=mnr+1
      if(ngbrnr(l).lt.mnr) go to 3099
      m=ngbor(ngrprv+mnr)
      if(m.eq.l) go to 3050
      do 3060 knr=1,ngbrnr(m)
      k=nghbor(ngbsum(m)+knr)
      ic=0
      do 3055 llnr=ngrprv+1,ngrprv+ngbrnr(l)
        ll=ngbor(llnr)
        if(ll.eq.k) ic=1
 3055 continue
      if(ic.eq.0) then
          ngbrnr(l)=ngbrnr(l)+1
          ngr=ngr+1
          ngbor(ngr)=k
      end if
 3060 continue
      ngbrnr(m)=0
      go to 3050
 3099 continue
      ngrprv=ngr
 3100 continue
      if(ngr.ne.nttot) then
         write(lun8,*)'ngr=',ngr,'nttot=',nttot
         write(lun8,*) 'clustr: m,ngbor(m),ngbrnr(m)'
         do 7100 m=1,nttot
          ic=0
          do 7101 k=1,ngr
           if(ngbor(k).eq.m) ic=1
 7101     continue
          if(ic.eq.0) write(lun8,*) m,' ist faul......'
          write(lun8,*) m,ngbor(m),ngbrnr(m)
 7100    continue
         call errex('ngr=nttot not fulfilled in clustr')
      end if
      ilauf=iloop
      nl1=0
      nl2=0
      do 4120 l=1,nttot
      if(ngbrnr(l).eq.0) go to 4120
      lclust= lclust+1
      nrbar(lclust)=0
      nrmes(lclust)=0
      do 4118 mnr=1,ngbrnr(l)
      nl1=nl1+1
      m=ngbor(nl1)
      if((nint(att(11,m)).le.6).or.
     a    ( (nint(att(11,m)).ge.10).and.
     b               (nint(att(11,m)).le.11))
     c          .or.(nint(att(11,m)).eq.13)
     d          .or.(nint(att(11,m)).eq.15) )then
         ilauf=ilauf+1
         if(ilauf.gt.ntotma)
     a           call errex('storage overflow in entry clustr')
         nrbar(lclust)=nrbar(lclust)+1
         do 4115 i=0,3
         x(i,ilauf)=att(1+i,m)
         p(i,ilauf)=att(5+i,m)
 4115    continue
         em(ilauf)=att(9,m)
         decay(ilauf)=att(10,m)
         ityp(ilauf)=nint(att(11,m))
         npidec(ilauf)=nint(att(13,m))
         lastcl(ilauf)=nint(att(14,m))
         tlast(ilauf)=att(15,m)
         ichbig(ilauf)=nint(att(16,m))
         issn(ilauf)=nint(att(12,m))
      end if
 4118 continue
        do 4119 mnr=1,ngbrnr(l)
         nl2=nl2+1
         m=ngbor(nl2)
         if(((nint(att(11,m)).ge.7)
     a                .and.(nint(att(11,m)).le.9)).or.
     b         (nint(att(11,m)).eq.12) .or.
     c         (nint(att(11,m)).eq.14) .or.
     d         (nint(att(11,m)).ge.85.and.
     d          nint(att(11,m)).le.98).or.
     e         (nint(att(11,m)).eq.99)          )then
           ilauf=ilauf+1
           if(ilauf.gt.ntotma)
     a           call errex('storage overflow in entry clustr')
           nrmes(lclust)=nrmes(lclust)+1
           do 4116 i=0,3
            x(i,ilauf)=att(1+i,m)
            p(i,ilauf)=att(5+i,m)
 4116      continue
           em(ilauf)=att(9,m)
           decay(ilauf)=att(10,m)
           ityp(ilauf)=nint(att(11,m))
           npidec(ilauf)=nint(att(13,m))
           lastcl(ilauf)=nint(att(14,m))
           tlast(ilauf)=att(15,m)
           ichbig(ilauf)=nint(att(16,m))
           issn(ilauf)=nint(att(12,m))
         end if
 4119 continue
      iwid= nint(float(nrbar(lclust))/5.)
      do 4117 ilf=ilauf+1,ilauf+iwid
      do 4121 i=0,3
      x(i,ilf)=0.
      p(i,ilf)=0.
 4121 continue
      em(ilf)=0.
      decay(ilf)=0.
      ityp(ilf)=0
      lastcl(ilf)=0
 4117 continue
      ilauf=ilauf+iwid
      iclusz(lclust)= nrmes(lclust)+ nrbar(lclust)  +iwid
 4120 continue
      lmax=ilauf
      if(lmax.ge.ntotma+1-nspect)
     a   call errex('too high line number in clustr')
      nall=nspect
      do 503 l=1,nrclst
  503 nall= nall + nrbar(l)+nrmes(l)
      if(nall.ne.nt+ npion) then
        call errex('particle number not constant in clustr')
      end if
      iof=0
      do 1809 kcl=1,itripl-1
       iof=iof+iclusz(kcl)
 1809 continue
      do 1810 kcl=itripl,nrclst
          nonrel(kcl)=.false.
          ntt=nrbar(kcl)
          nrpion=nrmes(kcl)
          if(ntt+nrpion.gt.1) then
             do 1811 i=0,3
                pclust(i)=0.
 1811        continue
             do 1813 l=1,ntt+nrpion
               do 1812 i=0,3
                  pclust(i)=pclust(i)+ p(i,iof+l)
 1812          continue
 1813        continue
             xmass =pclust(0)*pclust(0)
             do 1888 i=1,3
 1888        xmass =xmass -pclust(i)*pclust(i)
             if(ntt.gt.0) then
                 xmass = sqrt(xmass )/ntt
                 if(xmass.lt. 0.970) then
                    nonrel(kcl)=.true.
                   write(lun8,*) 'nonrelativistic cluster ntt=',ntt
                 end if
                write(lun8,*)'irun=',irun,'kcl=',kcl,'xmass=',xmass,
     a                              'ntt=',ntt
             end if
          end if
          iof=iof+iclusz(kcl)
 1810 continue
      return
      end
CPAT,CMASS    .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine rqmd_cmass(srt,pr,em1,em2,
     a                 ityp1,ityp2,iqcnvt,icltyp,npid1,npid2,ic)
        include 'scatter7'
        include 'sigmasx'
#include "amsrqmd.h"
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      real*4  branch(500),embr(4),zbr(4),beta(100)
      save embr
      data (branch(i),i=1,250)/
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.800,0.200,0.000,0.800,0.800,0.800,0.200,0.000,0.800,0.800,
     @ 0.752,0.248,0.000,0.800,0.800,0.708,0.292,0.000,0.800,0.800,
     @ 0.670,0.330,0.000,0.800,0.800,0.624,0.376,0.000,0.800,0.780,
     @ 0.579,0.421,0.000,0.800,0.754,0.541,0.459,0.000,0.800,0.740,
     @ 0.499,0.372,0.000,0.800,0.727,0.462,0.393,0.000,0.800,0.706,
     @ 0.430,0.412,0.000,0.800,0.692,0.402,0.427,0.000,0.800,0.678,
     @ 0.376,0.442,0.000,0.800,0.661,0.353,0.456,0.000,0.800,0.650,
     @ 0.333,0.467,0.000,0.800,0.632,0.315,0.477,0.000,0.800,0.619,
     @ 0.299,0.486,0.000,0.800,0.605,0.284,0.200,0.295,0.800,0.592,
     @ 0.272,0.200,0.302,0.800,0.578,0.261,0.200,0.308,0.800,0.567,
     @ 0.252,0.200,0.313,0.800,0.555,0.245,0.200,0.317,0.800,0.545/
      data (branch(i),i=251,500)/
     @ 0.240,0.200,0.320,0.800,0.531,0.235,0.200,0.323,0.800,0.522,
     @ 0.232,0.200,0.324,0.800,0.510,0.230,0.200,0.326,0.800,0.500,
     @ 0.227,0.200,0.327,0.800,0.493,0.225,0.200,0.329,0.800,0.483,
     @ 0.224,0.200,0.329,0.800,0.472,0.222,0.200,0.330,0.800,0.465,
     @ 0.221,0.200,0.331,0.800,0.457,0.221,0.200,0.331,0.800,0.449,
     @ 0.220,0.200,0.331,0.800,0.445,0.219,0.200,0.332,0.800,0.439,
     @ 0.219,0.200,0.332,0.800,0.431,0.218,0.200,0.332,0.800,0.428,
     @ 0.217,0.200,0.333,0.800,0.423,0.217,0.200,0.333,0.800,0.419,
     @ 0.216,0.200,0.334,0.800,0.417,0.216,0.200,0.334,0.800,0.414,
     @ 0.216,0.200,0.334,0.799,0.412,0.215,0.200,0.334,0.799,0.410,
     @ 0.215,0.200,0.334,0.797,0.408,0.215,0.200,0.334,0.794,0.407,
     @ 0.215,0.200,0.335,0.793,0.405,0.214,0.200,0.335,0.790,0.406,
     @ 0.214,0.200,0.335,0.791,0.406,0.214,0.200,0.335,0.789,0.405,
     @ 0.214,0.200,0.335,0.788,0.404,0.214,0.200,0.335,0.786,0.402,
     @ 0.213,0.200,0.335,0.781,0.402,0.213,0.200,0.335,0.782,0.402,
     @ 0.213,0.200,0.335,0.783,0.402,0.213,0.200,0.335,0.779,0.401,
     @ 0.213,0.200,0.336,0.778,0.401,0.212,0.200,0.336,0.785,0.401,
     @ 0.212,0.200,0.336,0.782,0.401,0.212,0.200,0.336,0.780,0.400,
     @ 0.212,0.200,0.336,0.778,0.400,0.212,0.200,0.336,0.781,0.400,
     @ 0.212,0.200,0.336,0.779,0.399,0.212,0.200,0.336,0.777,0.399,
     @ 0.212,0.200,0.336,0.777,0.399,0.212,0.200,0.336,0.780,0.398,
     @ 0.212,0.200,0.336,0.779,0.398,0.211,0.200,0.336,0.776,0.398,
     @ 0.211,0.200,0.336,0.778,0.398,0.211,0.200,0.336,0.781,0.398,
     @ 0.211,0.200,0.336,0.779,0.399,0.211,0.200,0.336,0.783,0.399,
     @ 0.211,0.200,0.337,0.783,0.399,0.211,0.200,0.337,0.780,0.399
     @ /
      data beta/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.03,  0.00,  0.02,  0.00,  0.02,
     @  0.00,  0.10,  0.28,  0.20,  0.40,  0.68,  0.70,  0.78,
     @  0.48,  0.48,  0.38,  0.08,  0.01,  0.04,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  1.67,  1.89,  1.93,  1.77,  1.64,  1.48,  1.32,  1.12,
     @  1.10,  1.01,  1.02,  1.00,  1.20,  1.22,  1.26,  1.31,
     @  1.31,  1.36,  1.34,  1.32,  1.31,  1.28,  1.27,  1.23,
     @  1.21,  1.20,  1.19,  1.15/
      data emdsmn/ 1.708/
      data vernum/'version   rqmd 1.09--- 25-jan-94'/
      data pronam/'module: c m a s s '/
      data ttvers/.true./
      real*4 pjin(4)
      common /pjbk/ pjin
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
        embr(1)=emmnn2
        embr(2)=emnuc+2.*(empion+ekinmi)
        embr(3)=emnuc+emrho+ekinmi
        embr(4)=emnuc+emeta+ekinmi
      end if
      s=srt
      if(s.gt.tblhig) then
         ic=0
         return
      end if
      xpt= log(srt)
      tlow = log(tbllow)
      index= int((xpt- tlow)/tblstp)
      if( index .le. 0) index =1
      if( index .gt. itblsz) index =itblsz
      bet= beta(index)
      if(icltyp.le.3) then
        pdn=min(cvalu1,exp(-bet*(srt- emdsmn-emnuc)))
        pdd=min(cvalu1,exp(-bet*(srt- 2*emdsmn)))
        pdnp=min(cvalu1,exp(-bet*(srt- emdsmn-emmnn2)))
        p1plus=0.5*(srt-ekinmi) + pr
        p1mins=0.5*(srt-ekinmi) - pr
        p2plus=p1mins
        p2mins=p1plus
        pplus=srt-ekinmi
        pminus=srt-ekinmi
      else if(ic.ge.3.and.
     a       icltyp.ge.4.and.icltyp.le.17.and.
     b                                     min(ityp1,ityp2).le.2) then
        go to 8
      else if(ic.ge.3.and.
     a       icltyp.ge.4.and.icltyp.le.21.and.
     b                                     min(ityp1,ityp2).ge.3) then
        go to 9
      end if
      goto (
     >   1,  2,  3,  4,  5,
     >   4,  5,  6,  4,  5,
     >   6,  7,  5,  6,  7,
     >   7,  4,  6,  7,  4,
     >   4,  4,  4,  4,  4,
     >   4,  4,  4,  4,  4,
     >   4,  4,  4,  4,  4,
     >   4,  4,  4,  4,  4,
     >   4,  4,  4,  4,  4,
     >   5,  6,  4,  5,  6,
     >   7,  4,  4,  4,  5,
     >   6,  7,  5,  6,  7,
     >   4,  4,  4,  4,  6,
     >   7
     & ) , icltyp
      write(lun8,*)' icltyp invalid in  cmass   ',icltyp
      call errex( 'cmass:fatal error')
    1 assign 100 to label
      if (ic .eq. 1 .or. ic .eq. 2 ) then
          goto 1000
      else if (ic .eq. 3 ) then
          goto 2000
      else if (ic .eq. 4 .or. ic .eq. 5 ) then
          goto 3000
      else if (ic .eq. 6 .or. ic .eq. 7 ) then
          goto 4000
      else if (ic .eq. 8 ) then
          goto 5000
      else
          call errex( 'error in cmass 1 invalid channel' )
      end if
  100 if (ic .eq. 1) then
        if (ranf(0) .gt. 0.5) then
          em1=em
          ityp1=4
          if(ipdn.eq.0) then
             npid1=1
          else
             npid1=npid
          end if
        else
          em2=em
          ityp2=4
          if(ipdn.eq.0) then
             npid2=1
          else
             npid2=npid
          end if
        end if
      else if (ic .eq. 2) then
        if (ranf(0) .gt. 0.5) then
          em1=em
          ityp1=3
          ityp2=2
          if(ipdn.eq.0) then
             npid1=1
          else
             npid1=npid
          end if
        else
          em2=em
          ityp1=2
          ityp2=3
          if(ipdn.eq.0) then
             npid2=1
          else
             npid2=npid
          end if
        end if
      else if (ic .eq. 3) then
        if (ranf(0) .gt. 0.5) then
          em1=em
          ityp1=10
          npid1=npid
        else
          em2=em
          ityp2=10
          npid2=npid
        end if
      else if (ic .eq. 4) then
        em1=ema
        em2=emb
        if(ipdd.eq.0) then
           npid1=1
           npid2=1
        else
           npid1=npida
           npid2=npidb
        end if
        if (ranf(0) .gt. 0.5) then
          ityp1=5
          ityp2=3
        else
          ityp1=3
          ityp2=5
        end if
      else if (ic .eq. 5) then
        em1=ema
        em2=emb
          ityp1=4
          ityp2=4
        if(ipdd.eq.0) then
           npid1=1
           npid2=1
        else
           npid1=npida
           npid2=npidb
        end if
      else if (ic .eq. 6) then
        if (ranf(0) .gt. 0.5) then
          em1=ema
          em2=emb
          ityp1=4
          ityp2=10
          if(ipdnp.eq.0) then
             npid1=1
          else
             npid1=npida
          end if
          npid2=npidb
        else
          em1=emb
          em2=ema
          ityp1=10
          ityp2=4
          if(ipdnp.eq.0) then
             npid2=1
          else
             npid2=npida
          end if
          npid1=npidb
        end if
      else if (ic .eq. 7) then
        if (ranf(0) .gt. 0.5) then
          em1=ema
          em2=emb
          ityp1=3
          ityp2=11
          if(ipdnp.eq.0) then
             npid1=1
          else
             npid1=npida
          end if
          npid2=npidb
        else
          em1=emb
          em2=ema
          ityp1=11
          ityp2=3
          if(ipdnp.eq.0) then
             npid2=1
          else
             npid2=npida
          end if
          npid1=npidb
        end if
      else if (ic .eq. 8) then
          em1=ema
          em2=emb
          ityp1=10
          ityp2=10
          npid1=npida
          npid2=npidb
      else
        call errex( 'ic-error cmass-100' )
      end if
      return
    2 assign 200 to label
      if (ic .eq. 1 .or. ic .eq. 2 ) then
          goto 1000
      else if (ic .eq. 3 .or. ic .eq. 4 ) then
          goto 2000
      else if (ic .eq. 5 .or. ic .eq. 6 ) then
          goto 3000
      else if (ic .eq. 7 .or. ic .eq. 8 ) then
          goto 4000
      else if (ic .eq. 9 ) then
          goto 5000
      else
          call errex( 'error in cmass 1 invalid channel' )
      end if
  200 if (ic .eq. 1) then
        if (ranf(0).gt. 0.5) then
          em1=em
          ityp1=5
          ityp2=1
          if(ipdn.eq.0) then
             npid1=1
          else
             npid1=npid
          end if
        else
          em2=em
          ityp1=1
          ityp2=5
          if(ipdn.eq.0) then
             npid2=1
          else
             npid2=npid
          end if
        end if
      else if (ic .eq. 2) then
        if (ranf(0).gt. 0.5) then
          em1=em
          ityp1=4
          ityp2=2
          if(ipdn.eq.0) then
             npid1=1
          else
             npid1=npid
          end if
        else
          em2=em
          ityp1=2
          ityp2=4
          if(ipdn.eq.0) then
             npid2=1
          else
             npid2=npid
          end if
        end if
      else if (ic .eq. 3) then
        if (ranf(0).gt. 0.5) then
          em1=em
          ityp1=11
          ityp2=1
          npid1=npid
        else
          em2=em
          ityp1=1
          ityp2=11
          npid2=npid
        end if
      else if (ic .eq. 4) then
        if (ranf(0).gt. 0.5) then
          em1=em
          ityp1=10
          ityp2=2
          npid1=npid
        else
          em2=em
          ityp1=2
          ityp2=10
          npid2=npid
        end if
      else if (ic .eq. 5) then
        em1=ema
        em2=emb
        if(ipdd.eq.0) then
           npid1=1
           npid2=1
        else
           npid1=npida
           npid2=npidb
        end if
        if (ranf(0).gt. 0.5) then
          ityp1=4
          ityp2=5
        else
          ityp1=5
          ityp2=4
        end if
      else if (ic .eq. 6) then
        em1=ema
        em2=emb
        if(ipdd.eq.0) then
           npid1=1
           npid2=1
        else
           npid1=npida
           npid2=npidb
        end if
        if (ranf(0).gt. 0.5) then
          ityp1=6
          ityp2=3
        else
          ityp1=3
          ityp2=6
        end if
      else if (ic .eq. 7) then
        if (ranf(0).gt. 0.5) then
          em1=ema
          ityp1=5
          em2=emb
          ityp2=10
          if(ipdnp.eq.0) then
             npid1=1
          else
             npid1=npida
          end if
          npid2=npidb
        else
          em1=emb
          ityp1=10
          em2=ema
          ityp2=5
          if(ipdnp.eq.0) then
             npid2=1
          else
             npid2=npida
          end if
          npid1=npidb
        end if
      else if (ic .eq. 8) then
        if (ranf(0).gt. 0.5) then
          em1=ema
          ityp1=4
          em2=emb
          ityp2=11
          if(ipdnp.eq.0) then
             npid1=1
          else
             npid1=npida
          end if
          npid2=npidb
        else
          em1=emb
          ityp1=11
          em2=ema
          ityp2=4
          if(ipdnp.eq.0) then
             npid2=1
          else
             npid2=npida
          end if
          npid1=npidb
        end if
      else if (ic .eq. 9) then
        em1=ema
        em2=emb
        npid1=npida
        npid2=npidb
        if (ranf(0).gt. 0.5) then
          ityp1=10
          ityp2=11
        else
          ityp1=11
          ityp2=10
        end if
      else
        call errex( 'ic-error cmass-200' )
      end if
      return
    3 assign 300 to label
      if (ic .eq. 1 .or. ic .eq. 2 ) then
          goto 1000
      else if (ic .eq. 3 ) then
          goto 2000
      else if (ic .eq. 4 .or. ic .eq. 5 ) then
          goto 3000
      else if (ic .eq. 6 .or. ic .eq. 7 ) then
          goto 4000
      else if (ic .eq. 8 ) then
          goto 5000
      else
          call errex( 'error in cmass 2 invalid channel' )
      end if
  300 if (ic .eq. 1) then
        if (ranf(0) .gt. 0.5) then
          em1=em
          ityp1=5
          if(ipdn.eq.0) then
             npid1=1
          else
             npid1=npid
          end if
        else
          em2=em
          ityp2=5
          if(ipdn.eq.0) then
             npid2=1
          else
             npid2=npid
          end if
        end if
      else if (ic .eq. 2) then
        if (ranf(0) .gt. 0.5) then
          em1=em
          ityp1=6
          ityp2=1
          if(ipdn.eq.0) then
             npid1=1
          else
             npid1=npid
          end if
        else
          em2=em
          ityp1=1
          ityp2=6
          if(ipdn.eq.0) then
             npid2=1
          else
             npid2=npid
          end if
        end if
      else if (ic .eq. 3) then
        if (ranf(0) .gt. 0.5) then
          em1=em
          ityp1=11
          npid1=npid
        else
          em2=em
          ityp2=11
          npid2=npid
        end if
      else if (ic .eq. 4) then
        em1=ema
        em2=emb
        if(ipdd.eq.0) then
           npid1=1
           npid2=1
        else
           npid1=npida
           npid2=npidb
        end if
        if (ranf(0) .gt. 0.5) then
          ityp1=6
          ityp2=4
        else
          ityp1=4
          ityp2=6
        end if
      else if (ic .eq. 5) then
        em1=ema
        em2=emb
          ityp1=5
          ityp2=5
        if(ipdd.eq.0) then
           npid1=1
           npid2=1
        else
           npid1=npida
           npid2=npidb
        end if
      else if (ic .eq. 6) then
        if (ranf(0) .gt. 0.5) then
          em1=ema
          em2=emb
          ityp1=5
          ityp2=11
          if(ipdnp.eq.0) then
             npid1=1
          else
             npid1=npida
          end if
          npid2=npidb
        else
          em1=emb
          em2=ema
          ityp1=11
          ityp2=5
          if(ipdnp.eq.0) then
             npid2=1
          else
             npid2=npida
          end if
          npid1=npidb
        end if
      else if (ic .eq. 7) then
        if (ranf(0) .gt. 0.5) then
          em1=ema
          em2=emb
          ityp1=6
          ityp2=10
          if(ipdnp.eq.0) then
             npid1=1
          else
             npid1=npida
          end if
          npid2=npidb
        else
          em1=emb
          em2=ema
          ityp1=10
          ityp2=6
          if(ipdnp.eq.0) then
             npid2=1
          else
             npid2=npida
          end if
          npid1=npidb
        end if
      else if (ic .eq. 8) then
          em1=ema
          em2=emb
          ityp1=11
          ityp2=11
          npid1=npida
          npid2=npidb
      else
        call errex( 'ic-error cmass-300' )
      end if
      return
    4 call errex( ' cmass -- 4')
    5 em1=emnuc
      em2=emnuc
      ityp1=1
      ityp2=1
      npid1=0
      npid2=0
      return
    6 em1=emnuc
      em2=emnuc
      npid1=0
      npid2=0
      if( ranf(0) .gt. 0.5 ) then
         ityp1=1
         ityp2=2
      else
         ityp1=2
         ityp2=1
      end if
      return
    7 em1=emnuc
      em2=emnuc
      ityp1=2
      ityp2=2
      npid1=0
      npid2=0
      return
    8 continue
      ibasd= 9
      ibasn= 3
      if(ityp1.le.2) then
          m1= 2 * ityp2 - ibasd
          m2= 2 * ityp1 - ibasn
      else
          m1= 2 * ityp1 - ibasd
          m2= 2 * ityp2 - ibasn
      end if
      m=m1+m2
      if(mod(ic,2).eq.0) then
            jnew=4
      else
            jnew=2
      end if
      if(ic.le.4) then
        npid1=0
        npid2=0
        pdn=1.
        assign 801 to label
        go to 1000
  801   continue
        itag=-50
        j1new=1
        j2new=3
        call isonew(jnew,m,j1new,j2new,m1new,m2new,itag)
        if(itag.eq.-1) then
         write(lun8,*) 'dn==> closed in cmass ????? itag=-1'
         ic=0
         return
        end if
        if(ityp2.le.2) then
          em1=emnuc
          em2=em
          ityp1=(m1new+ibasn)/2
          ityp2=(m2new+ibasd)/2
          npid2=1
        else
          em2=emnuc
          em1=em
          ityp2=(m1new+ibasn)/2
          ityp1=(m2new+ibasd)/2
          npid1=1
        end if
      else
        if(da(12).lt.1.) then
          if(ranf(0).gt.da(12)) then
             ic=0
             return
          end if
        end if
        npid1=1
        npid2=1
        pdd=1.
        assign 800 to label
        go to 3000
  800   continue
        em1=ema
        em2=emb
        j1new=3
        j2new=3
        itag=-50
        call isonew(jnew,m,j1new,j2new,m1new,m2new,itag)
        if(itag.eq.-1) then
         write(lun8,*) 'dn==> closed in cmass ????? itag=-1'
         ic=0
         return
        end if
        ityp1=(m1new+ibasd)/2
        ityp2=(m2new+ibasd)/2
      end if
      return
    9 continue
      ibasd= 9
      ibasn= 3
      m1= 2 * ityp1 - ibasd
      m2= 2 * ityp2 - ibasd
      m=m1+m2
      if(mod(ic,2).eq.0) then
            jnew=4
      else
            jnew=2
      end if
      itag=-50
      j1new=1
      j2new=3
      call isonew(jnew,m,j1new,j2new,m1new,m2new,itag)
      if(itag.eq.-1) then
       write(lun8,*) 'dd==>dn closed in cmass ????? itag=-1'
         ic=0
         return
      end if
      if(ranf(0).gt.0.5) then
          em1=emnuc
          ityp1=(m1new+ibasn)/2
          ityp2=(m2new+ibasd)/2
          npid1=0
          npid2=1
      else
          em2=emnuc
          ityp2=(m1new+ibasn)/2
          ityp1=(m2new+ibasd)/2
          npid2=0
          npid1=1
      end if
      if(em1+em2+ekinmi.ge.s) then
        assign 900 to label
        go to 1000
  900   continue
        if(em1.eq.emnuc) then
          em2=em
        else
          em1=em
        end if
      end if
      return
 1000 emmax=srt-emnuc-ekinmi
      ipdn=0
      if(ranf(0).gt.pdn) then
        if(emmax.gt.emdsmn) then
          ipdn=1
          go to 1001
        else
          write(lun8,*)'cmass:not enough cms energy in n+delta* channel'
        end if
      end if
      if(emmax.le.emnuc+empion) then
          ic=0
          return
      end if
      xmax=(atan(2.*(emmax-emdelt)/widdlt)-const1)/const2
      itry=0
  998 continue
      xmax=min(cvalu1,xmax)
      if (xmax.le.0.) then
        ic=0
        write(lun8,*) ' lower delta threshold violated in cmass 1000'
        return
      end if
      x=xmax*ranf(0)
      t=tan(x*const2)
      em=emdelt+.5*widdlt*(const+t)/(1.-const*t)
      prel=pcmsr(em,emnuc,empion)
      gamd=29.*prel**3/(1.+40.*prel*prel)
      prbact=gamd/((em-emdelt)**2+0.25*gamd*gamd)
      index=int((log(s)-log(tbllow))/tblstp) + 1
      if(index.gt.7) then
        if(index.gt.60) index=60
        indeff=index-7
        emmin=emnuc+empion
        emdmx=2.0
        mbin=
     a    int(float(20)*(em-emmin)/(min(emdmx,s-emnuc)-emmin))+1
        mbin=min(20,max(1,mbin))
        prbact=prbact*dsdm(indeff,mbin)
      end if
      prbmxa=3.0*widdlt/((em-emdelt)**2+0.25*widdlt*widdlt)
      prbact=prbact/prbmxa
      if(prbact.gt.1.3) then
         write(lun8,*) 'cmass-warning: 1.3< prbact=',prbact
      end if
      if(itry.lt.30.and.ranf(0).gt.prbact) then
           itry=itry+1
           go to 998
      else if(itry.eq.30) then
           write(lun8,*) itry,s,'cmass 1000:itry=30 ????   em=',em
      end if
      if(em.gt.emmax) then
        write(lun8,*)'warning: em.gt.emmax in cmass1000 ',em,emmax
        em=emmax
      end if
      goto label
 1001 continue
      zbr(1)=0.2
      zbr(2)=0.65
      zbr(3)=1.0
      zbr(4)=1.0
      zchnce=ranf(0)
      do 1002 i=1,4
        if(zchnce.lt.zbr(i)) then
          ist=i
          go to 1003
        end if
 1002 continue
 1003 continue
      embrd=embr(ist)
      if(srt-ekinmi.lt. emnuc+max(emmnd2,embrd))then
         write(lun8,*) 'cmass:1003 lower cmsenergy threshold violated'
         write(lun8,*) srt, ist
         if(ist.eq.1) then
             ic=0
             return
         end if
         ist=1
         go to 1003
      end if
      epdmin=srt
      epmin=emnuc
      etdmin=emmnd2
      etmin=emmnd2
      assign 1004 to label2
      ltry=0
      go to 60
 1004 continue
      em=em2new
      ltry=ltry+1
      npid=-mbafnd(1,em)
      if(npid.eq.3) then
        if(ltry.gt.50) then
          npid=-9
        else
          go to 1004
        end if
      end if
      if(iqcnvt.eq.0) npid=-1000*ist+npid
      go to label
 2000 continue
      zbr(1)=0.7
      zbr(2)=0.86
      zbr(3)=0.86
      zbr(4)=1.0
      zchnce=ranf(0)
      do 2002 i=1,4
        if(zchnce.lt.zbr(i)) then
          ist=i
          go to 2003
        end if
 2002 continue
 2003 continue
      if(srt-ekinmi.lt. emnuc+embr(ist))then
         write(lun8,*) 'cmass:2003 lower cmsenergy threshold violated'
         write(lun8,*) srt, ist
         if(ist.eq.1) then
             ic=0
             return
         end if
         ist=1
         go to 2003
      end if
      epdmin=srt
      epmin=emnuc
      etdmin=emmnn2
      etmin=emmnn2
      assign 2004 to label2
      ltry=0
      go to 60
 2004 continue
      em=em2new
      ltry=ltry+1
      npid=-mbafnd(2,em)
      if(npid.eq.3) then
        if(ltry.gt.50) then
          npid=-10
        else
          go to 2004
        end if
      end if
      if(iqcnvt.eq.0) npid=-1000*ist+npid
      goto label
 3000 continue
      ipdd=0
      if(ranf(0).gt.pdd) then
         ipdd=1
         zbr(1)=0.2
         zbr(2)=0.65
         zbr(3)=1.0
         zbr(4)=1.0
         zchnce=ranf(0)
         do 3002 i=1,4
          if(zchnce.lt.zbr(i)) then
            ista=i
            go to 3003
          end if
 3002    continue
 3003    continue
         zchnce=ranf(0)
         do 3004 i=1,4
          if(zchnce.lt.zbr(i)) then
            istb=i
            go to 3005
          end if
 3004    continue
 3005    continue
         if(srt-ekinmi.lt.embr(ista)+embr(istb)) then
            write(lun8,*)
     +    'cmass:3005 lower cms energy threshold violated'
            write(lun8,*) srt, ist
            if(ista.eq.1.and.istb.eq.1) then
               ic=0
               return
            end if
            if(ista.eq.1.and.istb.ne.1) istb=1
            ista=1
            if(ista+istb.gt.2 ) go to 3003
            go to 3005
         end if
         epdmin=emmnd2
         epmin=emmnd2
         etdmin=emmnd2
         etmin=emmnd2
         assign 3008 to label2
         ltry=0
         npida=3
         npidb=3
         go to 60
 3008    continue
         ema=em1new
         emb=em2new
         if(npida.eq.3) npida=-mbafnd(1,ema)
         if(npidb.eq.3) npidb=-mbafnd(1,emb)
         ltry=ltry+1
         if(npida.eq.3.or.npidb.eq.3) then
            if(ltry.gt.50) then
              if(npida.eq.3) npida=-9
              if(npidb.eq.3) npidb=-9
            else
              go to 3008
            end if
         end if
         if(iqcnvt.eq.0) npida=-1000*ista+npida
         if(iqcnvt.eq.0) npidb=-1000*istb+npidb
         if (ema+emb.ge.s-ekinmi ) then
            call errex('cmass:too large masses in d* d* branch')
         end if
         go to label
      else
        emmx1=srt-(emnuc+empion+ekinmi)
        if(emmx1.le.emnuc+empion) then
           ic=0
           return
        end if
        itry=0
 3009   continue
        xmax=(atan(2.*(emmx1-emdelt)/widdlt)-const1)/const2
        xmax=min(cvalu1,xmax)
        if (xmax .le. 0.) then
           ic=0
           write(lun8,*) ' lower threshold violated in cmass 3000'
           return
        end if
        x=xmax*ranf(0)
        t=tan(x*const2)
        ema = emdelt+.5*widdlt*(const+t)/(1.-const*t)
        prel=pcmsr(ema,emnuc,empion)
        gamd=29.*prel**3/(1.+40.*prel*prel)
        prbact=gamd/((ema-emdelt)**2+0.25*gamd*gamd)
        prbmxa=1.9*widdlt/((ema-emdelt)**2+0.25*widdlt*widdlt)
        prbact=prbact/prbmxa
        if(itry.lt.30.and.ranf(0).gt.prbact) then
           itry=itry+1
           go to 3009
        end if
        emmx2=srt-(ema+ekinmi)
        xmax=(atan(2.*(emmx2-emdelt)/widdlt)-const1)/const2
        xmax=min(cvalu1,xmax)
        if (xmax.le.0.) then
           ic=0
           write(lun8,*) 'lower threshold violated in cmass 3000'
           return
        end if
        x=xmax*ranf(0)
        t=tan(x*const2)
        emb = emdelt+.5*widdlt*(const+t)/(1.-const*t)
        prel=pcmsr(emb,emnuc,empion)
        gamd=29.*prel**3/(1.+40.*prel*prel)
        prbact=gamd/((emb-emdelt)**2+0.25*gamd*gamd)
        prbmxb=1.9*widdlt/((emb-emdelt)**2+0.25*widdlt*widdlt)
        prbact=prbact/prbmxb
        if(itry.lt.30.and.ranf(0).gt.prbact) then
           itry=itry+1
           go to 3009
        end if
        if(ranf(0).gt.0.5) then
          em=ema
          ema=emb
          emb=em
        end if
        goto label
      end if
 4000 continue
      ipdnp=0
      if(ranf(0).gt.pdnp) then
         ipdnp=1
         xpt= log(s-ekinmi)
         tlow = log(tbllow)
         index= int((xpt- tlow)/tblstp)+1
         if( index.le.0) index =1
         indf=5*(index-1)+4
         zbr(1)=branch(indf)
         zbr(2)=1.
         zbr(3)=1.
         zbr(4)=1.
         zchnce=ranf(0)
         do 4004 i=1,4
          if(zchnce.lt.zbr(i)) then
            istb=i
            go to 4005
          end if
 4004    continue
 4005    continue
         zbr(1)=0.2
         zbr(2)=0.65
         zbr(3)=1.0
         zbr(4)=1.0
         zchnce=ranf(0)
         do 4002 i=1,4
          if(zchnce.lt.zbr(i)) then
            ista=i
            go to 4003
          end if
 4002    continue
 4003    continue
         if(srt-ekinmi.lt.embr(ista)+embr(istb)) then
            write(lun8,*)
     +     'cmass:4005 lower cms energy threshold violated'
            write(lun8,*) srt, ist
            if(ista.eq.1.and.istb.eq.1) then
               ic=0
               return
            end if
            if(istb.eq.1) ista=1
            istb=1
            if(ista+istb.gt.2 ) go to 4005
            go to 4003
         end if
         epdmin=emmnd2
         epmin=emmnd2
         etdmin=emmnn2
         etmin=emmnn2
         assign 4009 to label2
         ltry=0
         npida=3
         npidb=3
         go to 60
 4009    continue
         ema=em1new
         emb=em2new
         if(npida.eq.3) npida=-mbafnd(1,ema)
         if(npidb.eq.3) npidb=-mbafnd(2,emb)
         ltry=ltry+1
         if(npida.eq.3.or.npidb.eq.3) then
            if(ltry.gt.50) then
              if(npida.eq.3) npida=-9
              if(npidb.eq.3) npidb=-10
            else
              go to 4009
            end if
         end if
         if(iqcnvt.eq.0) npida=-1000*ista+npida
         if(iqcnvt.eq.0) npidb=-1000*istb+npidb
         if(ema+emb.gt.srt) then
             write(lun8,*) 'ema,emb,s',ema,emb,s
             call errex('wrong masses in cmass 4000/first branch')
         end if
         go to label
      else
         xpt= log(srt)
         tlow = log(tbllow)
         index= int((xpt- tlow)/tblstp)+1
         if( index .le. 0) index =1
         indf=5*(index-1)+1
         zbr(1)=branch(indf)
         zbr(2)=zbr(1)+branch(indf+1)
         zbr(3)=zbr(2)+branch(indf+2)
         zbr(4)=1.0
         zchnce=ranf(0)
         do 4006 i=1,4
          if(zchnce.lt.zbr(i)) then
            ist=i
            go to 4007
          end if
 4006    continue
 4007    continue
         if(srt-ekinmi.lt. emdelt+embr(ist))then
           write(lun8,*) 'cmass:4007 lower cmsenergy threshold violated'
           write(lun8,*) srt, ist
           if(ist.eq.1) then
               ic=0
               return
           end if
           ist=1
           go to 4007
         end if
         epdmin=srt
         epmin=emdelt
         etdmin=emmnn2
         etmin=emmnn2
         assign 4008 to label2
         ltry=0
         go to 60
 4008    continue
         ema=emdelt
         emb=em2new
         npidb=-mbafnd(2,emb)
         ltry=ltry+1
         if(npidb.eq.3) then
            if(ltry.gt.50) then
              if(npidb.eq.3) npidb=-10
            else
              go to 4008
            end if
         end if
         if(iqcnvt.eq.0) npidb=-1000*ist+npidb
         if( ema+emb.gt.srt) then
             write(lun8,*) 'ema,emb,s',ema,emb,s
             call errex('too large masses in cmass4000')
         end if
         go to label
      end if
 5000 continue
      xpt= log(s-ekinmi)
      tlow = log(tbllow)
      index= int((xpt- tlow)/tblstp)+1
      if( index .le. 0) index =1
      indf=5*(index-1)+5
      zbr(1)=branch(indf)
      zbr(2)=1.0
      zbr(3)=1.0
      zbr(4)=1.0
      zchnce=ranf(0)
      do 5002 i=1,4
       if(zchnce.lt.zbr(i)) then
          ista=i
          go to 5003
       end if
 5002 continue
 5003 continue
      zchnce=ranf(0)
      do 5004 i=1,4
       if(zchnce.lt.zbr(i)) then
         istb=i
         go to 5005
       end if
 5004 continue
 5005 continue
      if(srt-ekinmi.lt.embr(ista)+embr(istb)) then
          write(lun8,*)
     +   'cmass:3005 lower cms energy threshold violated'
          write(lun8,*) srt, ist
          if(ista.eq.1.and.istb.eq.1) then
               ic=0
               return
          end if
          if(ista.eq.1.and.istb.ne.1) istb=1
          ista=1
          if(ista+istb.gt.2 ) go to 5003
          go to 5005
      end if
      epdmin=emmnn2
      epmin=emmnn2
      etdmin=emmnn2
      etmin=emmnn2
      assign 5009 to label2
      ltry=0
      npida=3
      npidb=3
      go to 60
 5009 continue
      ema=em1new
      emb=em2new
      if(npida.eq.3) npida=-mbafnd(2,ema)
      if(npidb.eq.3) npidb=-mbafnd(2,emb)
      ltry=ltry+1
      if(npida.eq.3.or.npidb.eq.3) then
        if(ltry.gt.50) then
          if(npida.eq.3) npida=-10
          if(npidb.eq.3) npidb=-10
        else
          go to 5009
        end if
      end if
      if(iqcnvt.eq.0) npida=-1000*ista+npida
      if(iqcnvt.eq.0) npidb=-1000*istb+npidb
      if (ema+emb.ge.srt) then
          write(lun8,*) 'ema,emb,srt',ema,emb,srt
          call errex('not allowed n* masses in cmass 5000' )
      end if
      go to label
   60 continue
      if(srt.lt.(etmin+epmin)) then
         write(lun8,*)
     +   'cmass 60: elastic scattering, too low cms energy'
         write(lun8,*) 'srt,icltyp,ic,etmin,epmin'
         write(lun8,*)  srt,icltyp,ic,etmin,epmin
         ic=0
         return
      end if
      nyrak=0
      p1mi= p1mins
      p1pl=p1plus
      p2mi=p2mins
      p2pl=p2plus
  201 nyrak=nyrak+1
      if(nyrak.gt.20) then
          if(epdmin.gt.epmin) then
             em1max=epmin
          else
             em1max=epmin+0.5*(srt-ekinmi-epmin-etmin)
          end if
          em2max=etmin+0.5*(srt-ekinmi-epmin-etmin)
          z1rand=ranf(0)
          z2rand=ranf(0)
          em1new=epmin*(em1max/epmin)**z1rand
          em2new=etmin*(em2max/etmin)**z2rand
          go to label2
      end if
      p1mins= p1mi
      p1plus=p1pl
      p2mins=p2mi
      p2plus=p2pl
      zprand = ranf(0)
      zmrand = ranf(0)
      p1mins= p1mins*(p2mins/p1mins)**zmrand
      p2plus= p2plus*(p1plus/p2plus)**zprand
      p1plus= pplus - p2plus
      p2mins= pminus- p1mins
      if(p1plus.le.p1mins) go to 201
      if(p2plus.gt.p2mins) go to 201
      arg=p1plus*p1mins
      if(arg.gt.0.) then
          em1new=sqrt(arg)
      else
         go to 201
      end if
      arg=p2plus*p2mins
      if(arg.gt.0.) then
          em2new=sqrt(arg)
      else
         go to 201
      end if
      if(em1new.lt. epmin) go to 201
      if(em2new.lt. etmin) go to 201
      if( em1new.lt. epdmin) then
           pminny=(epmin*epmin)/p1plus
           delpm= p1mins- pminny
           p1mins= pminny
           p2mins= p2mins+delpm
           em1new= epmin
           em2new=sqrt(p2plus*p2mins)
           if(em2new.lt.etmin) go to 201
      end if
      if( em2new.lt. etdmin) then
           pptany= (etmin*etmin)/p2mins
           delpp= p2plus- pptany
           p1plus= p1plus+delpp
           em2new= etmin
           em1new=sqrt(p1plus*p1mins)
           if(em1new.lt.epmin) go to 201
      end if
      go to label2
      end
CPAT,COLL     .
      subroutine coll(ind)
        include 'scatter7'
#include "amsrqmd.h"
        logical absrb
        include 'partblk7'
        common /ioutbk/i1,i2,i3,i4,nop,ichanl,iexpn1,iexpn2
     a                 ,idcid1,idcid2,iqsq
        common /routbk/xold1(0:3),xold2(0:3),srt,bxtot,bytot,bztot
        real*4  xform(0:3),pform(0:3)
        dimension xvold(0:3)
        common /ierdum/ierr
        common /prpsto/ kmulo1,ltypo1,kmulo2,ltypo2
        data  iruact,itprn,dtprn /0,0,1.0/
       real*4 plund
       common /lujets/ nlund,k(2000,2),plund(2000,5)
       data ncrit/600/
       i1=i1c(ind)
       i2=i2c(ind)
       ident1=issn(i1)
       ident2=issn(i2)
       idud(1,ident1)=idud(1,ident1)-1
       idud(1,ident2)=idud(1,ident2)-1
       if(itdth(5,ident1).lt.0) then
         itdth(5,ident1)=0
         itdth(5,ident2)=0
         iqsq=1
         dtceff=datsto(ident1)-tlast(i1)
         datsto(ident1)=datsto(ident2)
         if(dtceff.lt.0.0) call errex('coll:wrong dtceff')
       else
         iqsq=0
       end if
       tnexev=ctime(ind)
       if(tlstev.gt.tnexev) then
         write(lun8,*)'??? tlstev>tnexev',tnexev,tlstev
         i1c(ind)=-1
         return
       end if
       tlstev=tnexev
       if(tnexev.gt.timmax) then
         write(lun8,*)'coll??? tnexev>timmax',tnexev,timmax
         i1c(ind)=-1
         return
       end if
       dtprop=tnexev-(time+dt)
       absrb=.false.
       ntag12=0
       ncoli1=nclcnt(ident1)
       ncoli2=nclcnt(ident2)
       itagdl=0
       if(switch(8)) then
         if(ncoli1.eq.0.and.ncoli2.eq.0) then
           if((ident1.le.n1old.and.ident2.le.n1old).or.
     a         (ident1.gt.n1old.and.ident1.le.n1old+n2old.and.
     b             ident2.gt.n1old.and.ident2.le.n1old+n2old))then
             xfirst=xfirst+1.
             i1c(ind)=-1
             return
           end if
         end if
       end if
      if(ida(47).eq.1) then
        if((itdth(1,ident1).ne.0.and.
     a      itdth(2,ident1).eq.0).or.
     b              (itdth(1,ident2).ne.0  .and.
     c               itdth(2,ident2).eq.0)) then
              i1c(ind)=-1
              return
        end if
      end if
      do 162 i=0,3
       xold1(i)=x(i,i1)+qdot(i,i1)*dtprop
       xold2(i)=x(i,i2)+qdot(i,i2)*dtprop
  162 continue
      isubr1=0
      isubr2=0
      if(ida(15).ne.0) then
        if(ident1.gt.n1old+n2old) then
          if(tdtg(ident1).le.xold1(0)) then
            i1c(ind)=-1
            return
          end if
        end if
        if(ident2.gt.n1old+n2old) then
          if(tdtg(ident2).le.xold2(0)) then
            i1c(ind)=-1
            return
          end if
        end if
      end if
      if(ida(7).eq.1) then
        il=i1
        ident=ident1
 1214   continue
        isubr=0
        if(itdth(2,ident).ne.0)then
          if(tdtg(ident).le.x(0,il)+qdot(0,il)*dtprop) then
            isubr=6
            startt=tdtg(ident)
            call dupdat(il,startt)
          else
            isubr=1
          end if
          call ofshel(isubr,il,ident)
        end if
        isubr2=isubr
        if(il.eq.i1) then
            il=i2
            ident=ident2
            isubr1=isubr
            go to 1214
        end if
      end if
            em1=em(i1)
            npid1=npidec(i1)
            ityp1=ityp(i1)
            em2=em(i2)
            npid2=npidec(i2)
            ityp2=ityp(i2)
      call oldnew(1,ityp1,npid1,em1,kmulo1,ltypo1)
      call oldnew(1,ityp2,npid2,em2,kmulo2,ltypo2)
            isubs1=0
            if(ityp1.ge.85.and.ityp1.le.97) then
              isubs1=1
              call substi(ityp1,npid1)
            end if
            isubs2=0
            if(ityp2.ge.85.and.ityp2.le.97) then
              isubs2=1
              call substi(ityp2,npid2)
            end if
            icltyp=ictype(ityp1,ityp2)
            p0i1=p(0,i1)
            p0i2=p(0,i2)
            pz1=p(3,i1)
            pz2=p(3,i2)
            px1=p(1,i1)
            px2=p(1,i2)
            py1=p(2,i1)
            py2=p(2,i2)
            pi1sqo=p0i1*p0i1-px1*px1-py1*py1-pz1*pz1
            pi2sqo=p0i2*p0i2-px2*px2-py2*py2-pz2*pz2
            p0tot=p0i1+p0i2
            p1tot=px1+px2
            p2tot=py1+py2
            p3tot=pz1+pz2
            bxtot=p1tot/p0tot
            bytot=p2tot/p0tot
            bztot=p3tot/p0tot
            srt=sqrt(p0tot*p0tot-p1tot*p1tot-p2tot*p2tot-p3tot*p3tot)
              prel=pcmsr(srt,sqrt(pi1sqo),sqrt(pi2sqo))
              velrat=1.0
              enlrge=1./da(8)
              if(nt.gt.2.and.((itripl.eq.1.and..not.switch(17))
     a              .or.ida(34).gt.0.or.switch(6)).and.
     b                                (ncoli1.eq.0.or.ncoli2.eq.0))then
                call frzcor(enlfrz,i1,i2)
                enlrge=enlrge*enlfrz
              else if(.not.switch(6).and.srt.gt.em1+em2) then
                pfree=pcmsr(srt,em1,em2)
                enlrge=enlrge*pfree/prel
              end if
            if((ida(40).eq.2.or.ida(40).eq.3).and.ida(34).ne.2
     a                                           .and.iqsq.eq.0) then
              icltp=min(maxtyp+1,icltyp)
              call cross1(1,srt,prel,icltp,sigt,em1,em2,
     a                                  ityp1,ityp2,npid1,npid2)
              sigsto=csig(ind)
              if(sigsto.gt.sigt) then
                i1c(ind)=-1
                if(isubr1.eq.1) then
                  do 67 i=0,3
   67              p(i,i1)=p(i,i1)-frfp(i,ident1)
                end if
                if(isubr2.eq.1) then
                  do 68 i=0,3
   68              p(i,i2)=p(i,i2)-frfp(i,ident2)
                end if
                return
              end if
            end if
            deltz=zlast(ident1)-zlast(ident2)
            delty=ylast(ident1)-ylast(ident2)
            if(delty.gt.1.0) then
              if(deltz.gt.1.0) then
               write(lun8,*) deltz,delty,deltz*delty,'zy warning'
              end if
            end if
            if(abs(deltz).le.3.0) deltz=0.
            if(abs(delty).le.1.6) delty=0.
            if(deltz*delty.gt.3.0) then
             write(lun8,*) deltz,delty,deltz*delty,'zy warning'
             write(lun8,*) ityp1,ityp2,ident1,ident2
            end if
       call sveifo(i1,1)
       call sveifo(i2,2)
       call contnt(ltypo1,ltypo2,istra1,istra2,
     a                         imeso1,imeso2,ibry1,ibry2,iann)
       iqcnvt=0
       if((ibry1.lt.0.or.ibry2.lt.0).and.ibry1*ibry2.ge.0)then
         call qinvrt(ityp1,npid1,em1)
         call qinvrt(ityp2,npid2,em2)
         icltyp=ictype(ityp1,ityp2)
         iqcnvt=1
       else if(ibry1*ibry2.lt.0)then
         if(isubs1.eq.1.and.ityp1.ge.85.and.ityp1.le.97) ityp1=98
         if(isubs2.eq.1.and.ityp2.ge.85.and.ityp2.le.97) ityp2=98
         icltyp=ictype(ityp1,ityp2)
       end if
       ierr=systim(strt,dummy)
       idcid1=0
       idcid2=0
       call scattr(srt,p0tot,p1tot,p2tot,p3tot,enlrge,
     &             p0i1,px1,py1,pz1, p0i2,px2,py2,pz2, em1,em2,
     &                 pi1sqo,pi2sqo,dtau1,dtau2,prbhd1,prbhd2,
     &                 dtceff,ityp1,npid1,ityp2,npid2,iqsq,
     &                 icltyp,iexpn1,iexpn2,itagdl,itag1,itag2,
     &                 i1,i2,i3,i4, idcid1,idcid2, isubr1,isubr2,
     &                  kdiffr,nchain,ichanl,ibbban,nop,absrb)
       jcolt=0
       if(ichanl.gt.0) then
         call coltim(ichanl,ind,ident1,ident2,i1,i2,iqsq,
     a                  itag1,itag2,nop,idcid1,idcid2,dtau1,dtau2,
     b                                              prbhd1,prbhd2)
         if(ibbban.eq.1.and.ichanl.gt.0) then
             if(ida(49).eq.3) then
               pbarpa=0.05
               pbarpb=0.6
               sig0n=120.
               srt0=2.*emnuc
               rppbbw=(pbarpa*srt0)**2/
     a                      ((srt**2-srt0**2)**2+(pbarpa*srt0)**2)
               rppbto=pbarpb+rppbbw
               sann=sig0n*(srt0/srt)**2*rppbto
               if(ranf(0).lt.rppbbw/rppbto) then
                 ichanl=-3
                 itdth(4,ident1)=ident2
                 if(ityp(i1).eq.-9999) itdth(4,ident1)=-itdth(4,ident1)
                 itdth(4,ident2)=ident1
                 if(ityp(i2).eq.-9999) itdth(4,ident2)=-itdth(4,ident2)
                 zrand=ranf(0)
                 deltt=-log(max(zrand,cvalu2))/
     a                        (da(21)*pbarpa*5.0674/da(4))
                 deltt=deltt*p0tot/srt
               else
                 ibbban=0
               end if
             else
               ibbban=0
             end if
         else if(ibbban.eq.1) then
           ibbban=0
         end if
         if(ichanl.lt.0) jcolt=1
       end if
       if(ichanl.gt.0) then
         if(iabs(isubr1).eq.1) then
           do 97 i=0,3
            if(isubr1.eq.-1) then
              p(i,i1)=p(i,i1)-frfp(i,ident1)
            else
              psyst(i)=psyst(i)+frfp(i,ident1)
              frfp(i,ident1)=0.
            end if
   97      continue
         end if
         if(iabs(isubr2).eq.1) then
           do 98 i=0,3
            if(isubr2.eq.-1) then
              p(i,i2)=p(i,i2)-frfp(i,ident2)
            else
              psyst(i)=psyst(i)+frfp(i,ident2)
              frfp(i,ident2)=0.
            end if
   98      continue
         end if
       end if
       if(ierror.eq.1) return
       if(ichanl.le.0) nop=2
       if(idcid1.ne.0.or.idcid2.ne.0) ntag12=10
       if(iqcnvt.eq.1) ntag12=10
       if(nop.gt.2)  ntag12=10
       ierr=systim(tend,dummy)
       tmsctr=tmsctr+tend-strt
       if(switch(4).or.ntag12.gt.0.or.ichanl.le.0) then
         ntag1=0
         ntag2=0
       else
         ierr=systim(strt,dummy)
         ntag1=0
         ntag2=0
         call paulin(i1,ntag1)
         call paulin(i2,ntag2)
         if(ierror.eq.1) return
         ierr=systim(tend,dummy)
         tmpali=tmpali+tend-strt
       end if
       ntag12=ntag1+ntag2+ntag12
       i1c(ind)=0
       if(ntag12.lt.0.or.ichanl.le.0) then
         ichanl=0
         if(ntag1.lt.0.or.ntag2.lt.0) then
           ncoll=ncoll+1
           xblock=xblock+1.
           npaubl=npaubl+1
         end if
         call rstifo(i1,1)
         call rstifo(i2,2)
         if(ibbban.eq.1) then
           decay(i1)=xold1(0)+deltt
           decay(i2)=xold2(0)+deltt
         end if
         if(isubr1.eq.-1.or.
     a       (isubr1.eq.1.and.jcolt.eq.1)) then
           do 94 i=0,3
            p(i,i1)=p(i,i1)-frfp(i,ident1)
   94      continue
         end if
         if(isubr2.eq.-1.or.
     a       (isubr2.eq.1.and.jcolt.eq.1)) then
           do 93 i=0,3
            p(i,i2)=p(i,i2)-frfp(i,ident2)
   93      continue
         end if
         if(nop.gt.2) then
           npion=npion-1
           if(i3.gt.iofset+iclusz(kclst))then
                nrclst=nrclst-1
           else
                nrmes(kclst)=nrmes(kclst)-1
           end if
           if(nop.ge.4) then
              do  510 i4a=i4,i4+nop-4
               npion=npion-1
               if(i4a.gt.iofset+iclusz(kclst))then
                   nrclst=nrclst-1
               else
                   nrmes(kclst)=nrmes(kclst)-1
               end if
  510         continue
           end if
         end if
       else if(ichanl.gt.0) then
         call xtupdt
         if(isubs1.eq.1.or.isubs2.eq.1) then
           if(isubs1.eq.1) then
             call oldat(
     a            1,itol1,npol1,p0ol1,pxol1,pyol1,pzol1,emol1)
             call transl(-1,itol1,npol1,kfb)
             call transl(-1,ityp(i1),npidec(i1),kfa)
             if(ichanl.eq.1.or.(abs(emol1-em(i1)).lt.1.e-4
     a                                  .and.kfa.eq.kfb)) then
               ityp(i1)=itol1
               npidec(i1)=npol1
             end if
           end if
           if(isubs2.eq.1) then
             call oldat(
     a            2,itol2,npol2,p0ol2,pxol2,pyol2,pzol2,emol2)
             call transl(-1,itol2,npol2,kfb)
             call transl(-1,ityp(i2),npidec(i2),kfa)
             if(ichanl.eq.1.or.(abs(emol2-em(i2)).lt.1.e-4
     a                                  .and.kfa.eq.kfb)) then
               ityp(i2)=itol2
               npidec(i2)=npol2
             end if
           end if
         end if
         imscst=1
         if(ida(28).eq.0) then
           if(imeso1.eq.0) then
             call mscstr(imscst,i1,i2,isccss)
           else
             call mscstr(imscst,i2,i1,isccss)
           end if
         end if
         ierr=systim(strt,dummy)
         startt=x(0,i1)
         call dupdat(i1,startt)
         startt=x(0,i2)
         call dupdat(i2,startt)
         if(nchain.gt.0) then
           if(idcid1.ne.0) decay(i1)=x(0,i1)
           if(idcid2.ne.0) decay(i2)=x(0,i2)
         end if
         if((kdiffr.eq.2.or.ichanl.eq.1)
     a             .and.itdth(2,ident1).ne.0.and.
     b                      tdtg(ident1).gt.tlast(i1)) then
           decay(i1)=tdtg(ident1)
         end if
         if((kdiffr.eq.1.or.ichanl.eq.1)
     a             .and.itdth(2,ident2).ne.0.and.
     b                      tdtg(ident2).gt.tlast(i2)) then
           decay(i2)=tdtg(ident2)
         end if
         if(nop.ge.3) then
           startt=x(0,i3)
           call dupdat(i3,startt)
           if(nop.ge.4) then
             do 512 i4a=i4,i4+nop-4
             startt=x(0,i4a)
  512        call dupdat(i4a,startt)
           end if
         end if
         if(ida(4).eq.2.and.itagdl.eq.1) then
           if(ityp(i1).ge.3.and.ityp(i1).le.6) then
             decay(i1)=x(0,i1)
           else if(ityp(i2).ge.3.and.ityp(i2).le.6) then
             decay(i2)=x(0,i2)
           end if
         end if
         call output(1)
         i1a=i1
         i2a=i2
         if(idcid1.ne.0.and.decay(i1).eq.x(0,i1)) then
           i1a=-2
         else
           if(itdth(2,ident1).ne.0.and.
     a              tdtg(ident1).gt.tlast(i1)) then
             call qdrot(i1,ident1,bxtot,bytot,bztot)
             if(ida(42).eq.1) then
               do 501 i=0,3
                pform(i)=p(i,i1)+frfp(i,ident1)
                xform(i)=x(i,i1)+qdot(i,i1)/qdot(0,i1)*
     a                             (tdtg(ident1)-x(0,i1))
  501          continue
               write(lun7)
     &              ityp(i1),issn(i1),npidec(i1),
     &              (xform(i),i=0,3),
     &              (pform(i),i=0,3),em(i1),
     &              0.0,0,0
             end if
           end if
         end if
         if(idcid2.ne.0.and.decay(i2).eq.x(0,i2)) then
           i2a=-2
         else
           if(itdth(2,ident2).ne.0.and.
     a               tdtg(ident2).gt.tlast(i2)) then
             call qdrot(i2,ident2,bxtot,bytot,bztot)
             if(ida(42).eq.1) then
               do 502 i=0,3
                pform(i)=p(i,i2)+frfp(i,ident2)
                xform(i)=x(i,i2)+qdot(i,i2)/qdot(0,i2)*
     a                             (tdtg(ident2)-x(0,i2))
  502          continue
               write(lun7)
     &              ityp(i2),issn(i2),npidec(i2),
     &              (xform(i),i=0,3),
     &              (pform(i),i=0,3),em(i2),
     &              0.0,0,0
             end if
           end if
         end if
         if(i1a.gt.0.or.i2a.gt.0) then
           call propag(i1a,i2a,0)
         end if
         if(nop.eq.3) then
           if(i3.le.iofset+iclusz(kclst))call propag(i3,-2,0)
         else if(nop.ge.4) then
           if(i3.le.iofset+iclusz(kclst).and.
     a                       i4.le.iofset+iclusz(kclst)) then
                  call propag(i3,i4,0)
           else if(i3.le.iofset+iclusz(kclst)) then
                 call propag(i3,-2,0)
           end if
           if(nop.gt.4) then
              do 516 i4a=i4+1,i4+nop-4
  516         call propag(i4a,-2,0)
           end if
         end if
         if(ityp(i1).gt.0.and.itdth(2,ident1).ne.0  ) then
           if(tdtg(ident1).gt.tlast(i1)) then
             if(i1a.lt.0) then
               do  168 i=0,3
  168          x(i,i1)=x(i,i1)-qdot(i,i1)*dtprop
             end if
           else
             tdtg(ident1)=0.0
             itdth(1,ident1)=0
             itdth(2,ident1)=0
             itdth(4,ident1)=0
           end if
         end if
         if(ityp(i2).gt.0.and.itdth(2,ident2).ne.0  ) then
           if(tdtg(ident2).gt.tlast(i2)) then
             if(i2a.lt.0) then
               do  169 i=0,3
  169          x(i,i2)=x(i,i2)-qdot(i,i2)*dtprop
             end if
           else
             tdtg(ident2)=0.0
             itdth(1,ident2)=0
             itdth(2,ident2)=0
             itdth(4,ident2)=0
           end if
         end if
         ibb=min(1,ispect(i1))+min(1,ispect(i2)) +1
         if(ibb.le.0.or.ibb.gt.3) then
            write(lun8,*) 'wrong ibb=',ibb
         else
            xcnt(ibb)=xcnt(ibb)+1.
         end if
         if(ida(50).eq.1)  then
           ipur=0
           if(ityp(i1).eq.-9999) then
             if(kspin(iabs(ltypo1)).eq.1) ipur=i1
           else if(ityp(i2).eq.-9999) then
             if(kspin(iabs(ltypo2)).eq.1) ipur=i2
           end if
           if(ipur.ne.0) then
             idntpu=issn(ipur)
             call purglu(idntpu)
           end if
         end if
         if(nlund.gt.ncrit)  call purglu(0)
         if(absrb) then
           if(nop.ge.3) iabspi=iabspi+1
         else if(icltyp.gt.3.and.iabs(ityp(i1)).le.2.and.
     a                                      iabs(ityp(i2)).le.2) then
               if(nop.eq.2) then
                  iabspi=iabspi+1
               else if(nop.eq.3.and.iabs(ityp(i3)).le.2) then
                  iabspi=iabspi+1
               end if
         end if
       end if
       ierr=systim(tend,dummy)
       tmupdt=tmupdt+tend-strt
      return
      end
      subroutine coltim(ichanl,ind,ident1,ident2,i1,i2,iqsq,
     a                  itag1,itag2,nop,idcid1,idcid2,dtau1,dtau2,
     b                                              prbhd1,prbhd2)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       dimension ibeqlc(2)
       dimension iblock(2)
        if(ida(57).eq.0) return
        if(idcid1.ne.0.and.idcid2.ne.0) return
        if(itag1.ne.0.and.itag2.ne.0) return
        if(ityp(i1).eq.-9999.or.ityp(i2).eq.-9999) return
        if(iqsq.eq.1) return
        if(nop.ne.2) return
        if(itag1.eq.0)then
          jpar1=ident1
        else
          jpar1=mod(itdth(3,ident1),100000)
        end if
        if(itag2.eq.0)then
          jpar2=ident2
        else
          jpar2=mod(itdth(3,ident2),100000)
        end if
        if(jpar1.gt.n1old.and.jpar1.le.n1old+n2old) then
          jpar1=1
        else if(jpar1.gt.0.and.jpar1.le.n1old) then
          jpar1=-1
        else
          jpar1=0
        end if
        if(jpar2.gt.n1old.and.jpar2.le.n1old+n2old) then
          jpar2=1
        else if(jpar2.gt.0.and.jpar2.le.n1old) then
          jpar2=-1
        else
          jpar2=0
        end if
        if(jpar1.eq.0.and.jpar2.eq.0) return
        ibeqlc(1)=0
        ibeqlc(2)=0
        iblock(1)=0
        iblock(2)=0
        kblock=0
        do 100 jjj=1,nument
         if(i1c(jjj).ne.i1.and.i2c(jjj).ne.i1.and.
     a      i1c(jjj).ne.i2.and.i2c(jjj).ne.i2) go to 100
         if(i1c(jjj).eq.i1.and.i2c(jjj).eq.i2) go to 100
         if(i1c(jjj).eq.i1.or.i2c(jjj).eq.i1) then
           if(itag1.ne.0.or.idcid1.ne.0) go to 100
           if(dtau1.eq.cvalu0) go to 100
           if(jpar1.eq.0) go to 100
           if(ibeqlc(1).eq.1) go to 100
           if(iblock(1).eq.1) go to 100
           if(prbhd1.eq.cvalu0) go to 100
           if(ranf(0).gt.prbhd1) go to 100
           jpara=jpar1
           ia=i1
           ib=i1c(jjj)+i2c(jjj)-i1
           dtaua=dtau1
           ii=1
         else if(i1c(jjj).eq.i2.or.i2c(jjj).eq.i2) then
           if(itag2.ne.0.or.idcid2.ne.0) go to 100
           if(dtau2.eq.cvalu0) go to 100
           if(jpar2.eq.0) go to 100
           if(ibeqlc(2).eq.1) go to 100
           if(iblock(2).eq.1) go to 100
           if(prbhd2.eq.cvalu0) go to 100
           if(ranf(0).gt.prbhd2) go to 100
           jpara=jpar2
           ia=i2
           ib=i1c(jjj)+i2c(jjj)-i2
           dtaua=dtau2
           ii=2
         end if
         if(ib.le.0) go to 100
         identb=issn(ib)
         if(identb.le.n1old+n2old) then
           jparb=identb
         else
           jparb=mod(itdth(3,identb),100000)
         end if
         if(jparb.gt.n1old.and.jparb.le.n1old+n2old) then
           jparb=1
         else if(jparb.gt.0.and.jparb.le.n1old) then
           jparb=-1
         else
           jparb=0
         end if
         if(jpara*jparb.ne.-1) go to 100
         dtinv2=qdot(0,ia)**2
         do 33 i=1,3
   33    dtinv2=dtinv2-qdot(i,ia)**2
         if(dtinv2.le.0.0) then
           if(ctime(jjj).lt.ctime(ind)) then
             call errex('coltim:dtinv2.le.0.0')
           else
             write(lun8,*) 'coltim warning:dtinv2.le.0.0'
           end if
           ibeqlc(ii)=1
           write(lun8,*) dtinv2,i1c(jjj),i2c(jjj)
           write(lun8,*) ia,issn(ia),ident1,ident2,jjj,ind
           write(lun8,*) 'qdot=',(qdot(i,ia),i=0,3)
           write(lun8,*) ctime(jjj),ctime(ind)
           go to 100
         end if
         dtinv2=dtinv2*(ctime(jjj)-ctime(ind))**2
         if(sqrt(dtinv2).lt.dtaua) then
           call oldat(ii,itola,npola,p0ola,pxola,pyola,pzola,emola)
           if(ityp(ib).eq.0) then
             write(lun8,*) ib,issn(ib),jjj,ia,ident1,ident2,ii
             write(lun8,*) ii,'coltim:',
     a            itola,npola,ityp(ib),npidec(ib)
           end if
           call transl(-1,itola,npola,ltypa)
           call transl(-1,ityp(ib),npidec(ib),ltypb)
           call contnt(
     a            ltypa,ltypb,istra1,istra2,
     b                           imeso1,imeso2,ibry1,ibry2,iann)
           icqflv=itdth(2,identb)
           if(icqflv.ne.0) then
             tcolb=x(0,ib)+qdot(0,ib)*
     a               (ctime(jjj)-(time+dt))
             if(tdtg(identb).gt.tcolb) icqflv=0
           end if
           redcqf=1.0
           if(icqflv.ne.0) redcqf=redcqi(imeso2,icqflv)
           sighrd=sigasy(1,imeso1,istra1,imeso2,istra2)
           if(ranf(0).lt.sighrd/csig(jjj)) then
             iblock(ii)=1
               kblock=1
               go to 200
           end if
         end if
  100   continue
  200   continue
        if(kblock.eq.1) ichanl=-2
      return
      end
      subroutine output(iwoher)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
        common /ioutbk/i1,i2,i3,i4,nop,ichanl,iexpn1,iexpn2
     a                 ,idcid1,idcid2,iqsq
       common /routbk/xold1(0:3),xold2(0:3),srt,bxtot,bytot,bztot
       logical issers
       dimension xvold(0:3)
       ident1=issn(i1)
       iexpn1=itdth(2,ident1)
       ident2=issn(i2)
       iexpn2=itdth(2,ident2)
       if(ida(25).eq.1) then
         if(nop.eq.1) then
           if(ityp(i1).eq.-9999) then
            ind1=i2
            do 659 i=0,3
  659       xold1(i)=xold2(i)
           else if(ityp(i2).eq.-9999) then
            ind1=i1
           end if
         end if
         if(switch(23)) then
            ken=itripl
         else
            ken=kdt
         end if
         write(lun15,661) irun,ken,1,ncollt+ncoll,nop,ichanl,
     a                    issn(i1)*1000+nclcnt(ident1),
     b                    issn(i2)*1000+nclcnt(ident2)
  661    format(1x,i3,1x,i3,1x,i1,1x,i5,1x,i3,1x,i2,1x,i8,1x,i8)
  662    format(1x,i4,1x,i4,1x,f8.3,1x,2(f7.3,1x),f8.3,1x,
     a               f7.3,i3,1x,i8,1x,f8.3,2(1x,f7.3),1x,f8.3)
 
         call oldat(1,itol1,npol1,p0ol1,pxol1,pyol1,pzol1,emol1)
         if(-npol1.gt.99) then
             npol1=-mod(-npol1,100)
         end if
         iexpo1=isign(1,iexpn1)*mod(iabs(iexpn1),100)
         write(lun15,662)
     a      itol1,npol1,p0ol1,pxol1,pyol1,pzol1,emol1,iexpo1
         call oldat(
     a          2,itol2,npol2,p0ol2,pxol2,pyol2,pzol2,emol2)
         if(-npol2.gt.99) then
           npol2=-mod(-npol2,100)
         end if
         iexpo2=isign(1,iexpn2)*mod(iabs(iexpn2),100)
         write(lun15,662)
     a          itol2,npol2,p0ol2,pxol2,pyol2,pzol2,emol2,iexpo2
         if(nop.eq.1) then
           if(-npidec(ind1).gt.99) then
             npidl=-mod(-npidec(ind1),100)
           else
             npidl=npidec(ind1)
           end if
           if(ind1.eq.i1)  iexpo=iexpo1
           if(ind1.eq.i2)  iexpo=iexpo2
           write(lun15,662)ityp(ind1),npidl,(p(i,ind1),i=0,3),
     a          em(ind1),iexpo,issn(ind1),xold1(0),
     b                  xold1(1),xold1(2),xold1(3)
         else
           if(-npidec(i1).gt.99) then
             npidl=-mod(-npidec(i1),100)
           else
             npidl=npidec(i1)
           end if
           if(-ityp(i1).eq.9999) then
             itypl=9999
           else
             itypl=ityp(i1)
           end if
           write(lun15,662) itypl,npidl,(p(i,i1),i=0,3),
     a                em(i1),iexpo1,issn(i1),xold1(0),
     b                        xold1(1),xold1(2),xold1(3)
           if(-npidec(i2).gt.99) then
             npidl=-mod(-npidec(i2),100)
           else
             npidl=npidec(i2)
           end if
           if(-ityp(i2).eq.9999) then
             itypl=9999
           else
             itypl=ityp(i2)
           end if
           write(lun15,662) itypl,npidl,(p(i,i2),i=0,3),
     a              em(i2),iexpo2,issn(i2),xold2(0),
     b                        xold2(1),xold2(2),xold2(3)
         end if
         if(nop.gt.2) then
           write(lun15,662) ityp(i3),npidec(i3),(p(i,i3),i=0,3),
     a                    em(i3),0,issn(i3),x(0,i3),
     b                        x(1,i3),x(2,i3),x(3,i3)
         end if
         if(nop.ge.4) then
           do 513 i4a=i4,i4+nop-4
            write(lun15,662)
     a         ityp(i4a),npidec(i4a),(p(i,i4a),i=0,3),
     b             em(i4a),0,issn(i4a),x(0,i4a),
     c                   x(1,i4a),x(2,i4a),x(3,i4a)
  513      continue
         end if
         if(ida(36).eq.1) then
            call dnscal(1,i1,i2,dens1)
            call dnscal(1,i2,i1,dens2)
            write(lun15,663) dens1,dens2
         end if
       end if
       emi1=em(i1)
       emi2=em(i2)
       if(ida(38).eq.3.or.ida(38).eq.4) then
         kstor(ident1,1)=1
                  kstor(ident2,1)=1
                  do 203 i=1,4
  203             stork(ident1,i)=xold1(i-1)
                  do 303 i=6,8
  303             stork(ident1,i)=p(i-5,i1)
                  do 204 i=1,4
  204             stork(ident2,i)=xold2(i-1)
                  do 304 i=6,8
  304             stork(ident2,i)=p(i-5,i2)
                  if(nop.gt.2) then
                    ident3=issn(i3)
                    kstor(ident3,1)=1
                    do 205 i=1,4
  205               stork(ident3,i)=x(i-1,i3)
                    do 305 i=6,8
  305               stork(ident3,i)=p(i-5,i3)
                  end if
                  if(nop.gt.3) then
                    ident4=issn(i4)
                    kstor(ident4,1)=1
                    do 206 i=1,4
  206               stork(ident4,i)=x(i-1,i4)
                    do 306 i=6,8
  306               stork(ident4,i)=p(i-5,i4)
                  end if
       else if((ida(38).eq.1.or.ida(38).eq.2.or.
     a            ida(38).eq.5.or.ida(38).eq.7)
     b                                     .and.ichanl.gt.1) then
           if(ida(38).eq.1.or.ida(38).eq.2) then
             jeng=1
             keng=1
           else if(ida(38).eq.5) then
             jeng=0
             keng=0
           else if(ida(38).eq.7) then
             if(nop.ge.2) then
               jeng=1
             else
               jeng=0
             end if
             keng=1
           end if
           if(issers(jeng,ida(38),itol1,npol1,emol1).and.
     a     .not.issers(jeng,ida(38),ityp(i1),npidec(i1),emi1).and.
     b     .not.issers(jeng,ida(38),ityp(i2),npidec(i2),emi2))then
             write(lun13,888) ident1,0,itol1,npol1,
     a                               p0ol1,-pxol1,-pyol1,-pzol1
             write(lun13,889) (stork(ident1,i),i=1,5)
             write(lun13,890) (kstor(ident1,i),i=1,7)
             isser1=1
           else
             isser1=0
           end if
           if(issers(jeng,ida(38),itol2,npol2,emol2).and.
     a     .not.issers(jeng,ida(38),ityp(i1),npidec(i1),emi1).and.
     b     .not.issers(jeng,ida(38),ityp(i2),npidec(i2),emi2))then
             write(lun13,888) ident2,0,itol2,npol2,
     a                          p0ol2,-pxol2,-pyol2,-pzol2
             write(lun13,889) (stork(ident2,i),i=1,5)
             write(lun13,890) (kstor(ident2,i),i=1,7)
             isser2=1
           else
             isser2=0
           end if
           if((.not.issers(keng,ida(38),itol1,npol1,emol1).and.
     a        .not.issers(keng,ida(38),itol2,npol2,emol2)).or.
     b         isser1+isser2.ne.0.or.
     c     (.not.issers(keng,ida(38),ityp(i1),npidec(i1),emi1).and.
     d      .not.issers(keng,ida(38),ityp(i2),npidec(i2),emi2)))then
                   stork(ident1,1)=srt
                   stork(ident1,2)=emol1
                   stork(ident1,3)=emol2
                   stork(ident1,4)=em(i1)
                   stork(ident1,5)=em(i2)
                   kstor(ident1,1)=itol1
                   kstor(ident1,2)=npol1
                   kstor(ident1,3)=itol2
                   kstor(ident1,4)=npol2
                   kstor(ident1,5)=ichanl
                   kstor(ident1,6)=itdth(2,ident1)
                   kstor(ident1,7)=itdth(2,ident2)
                   stork(ident2,1)=srt
                   stork(ident2,2)=emol1
                   stork(ident2,3)=emol2
                   stork(ident2,4)=em(i1)
                   stork(ident2,5)=em(i2)
                   kstor(ident2,1)=itol1
                   kstor(ident2,2)=npol1
                   kstor(ident2,3)=itol2
                   kstor(ident2,4)=npol2
                   kstor(ident2,5)=ichanl
                   kstor(ident2,6)=itdth(2,ident1)
                   kstor(ident2,7)=itdth(2,ident2)
           end if
           if(nop.ge.3) then
                     ident3=issn(i3)
                     stork(ident3,1)=srt
                     stork(ident3,2)=emol1
                     stork(ident3,3)=emol2
                     stork(ident3,4)=em(i1)
                     stork(ident3,5)=em(i2)
                     kstor(ident3,1)=itol1
                     kstor(ident3,2)=npol1
                     kstor(ident3,3)=itol2
                     kstor(ident3,4)=npol2
                     kstor(ident3,5)=ichanl
                     kstor(ident3,6)=itdth(2,ident1)
                     kstor(ident3,7)=itdth(2,ident2)
           end if
           if(nop.ge.4) then
                    do 515 i4a=i4,i4+nop-4
                     ident4=issn(i4a)
                     stork(ident4,1)=srt
                     stork(ident4,2)=emol1
                     stork(ident4,3)=emol2
                     stork(ident4,4)=em(i1)
                     stork(ident4,5)=em(i2)
                     kstor(ident4,1)=itol1
                     kstor(ident4,2)=npol1
                     kstor(ident4,3)=itol2
                     kstor(ident4,4)=npol2
                     kstor(ident4,5)=ichanl
                     kstor(ident4,6)=itdth(2,ident1)
                     kstor(ident4,7)=itdth(2,ident2)
  515               continue
           end if
           if(isser1.eq.1) then
             if(nop.ge.2) then
               kphid=-2
             else
               kphid=-1
             end if
             write(lun13,888) ident1,kphid,itol1,npol1,
     a                             p0ol1,-pxol1,-pyol1,-pzol1
             write(lun13,889) (stork(ident1,i),i=1,5)
             write(lun13,890) (kstor(ident1,i),i=1,7)
           end if
           if(isser2.eq.1) then
             if(nop.ge.2) then
               kphid=-2
             else
               kphid=-1
             end if
             write(lun13,888) ident2,kphid,itol2,npol2,
     a                        p0ol2,-pxol2,-pyol2,-pzol2
             write(lun13,889) (stork(ident2,i),i=1,5)
             write(lun13,890) (kstor(ident2,i),i=1,7)
           end if
  888      format(1x,4(i7,1x),1x,4(f7.3,1x))
  889      format(1x,5(f7.3,1x))
  890      format(1x,5(i7,1x),2(i4,1x))
       end if
  663  format(1x,2(f6.3,1x))
       if(ida(42).eq.1) then
           write(lun7)
     &              ityp(i1),issn(i1),npidec(i1),
     &              x(0,i1),x(1,i1),x(2,i1),x(3,i1),
     &              p(0,i1),p(1,i1),p(2,i1),p(3,i1),em(i1),
     &              tdtg(ident1),itdth(2,ident1),itdth(3,ident1)
           write(lun7)
     &              ityp(i2),issn(i2),npidec(i2),
     &              x(0,i2),x(1,i2),x(2,i2),x(3,i2),
     &              p(0,i2),p(1,i2),p(2,i2),p(3,i2),em(i2),
     &              tdtg(ident2),itdth(2,ident2),itdth(3,ident2)
           if(nop.gt.2) then
             write(lun7)
     &              ityp(i3),issn(i3),npidec(i3),
     &              x(0,i3),x(1,i3),x(2,i3),x(3,i3),
     &              p(0,i3),p(1,i3),p(2,i3),p(3,i3),em(i3),
     &              0.0,0,0
             if(nop.ge.4) then
               do 517 i4a=i4,i4+nop-4
                write(lun7)
     &                 ityp(i4a),issn(i4a),npidec(i4a),
     &                 x(0,i4a),x(1,i4a),x(2,i4a),x(3,i4a),
     &                 p(0,i4a),p(1,i4a),p(2,i4a),p(3,i4a),
     &                 em(i4a),0.0,0,0
  517          continue
             end if
           end if
       end if
      return
      end
      subroutine xtupdt
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       common /ioutbk/i1,i2,i3,i4,nop,ichanl,iexpn1,iexpn2
     a                 ,idcid1,idcid2,iqsq
       common /routbk/xold1(0:3),xold2(0:3),srt,bxtot,bytot,bztot
       ident1=issn(i1)
       ident2=issn(i2)
       itdt31=itdth(3,ident1)
       itdt32=itdth(3,ident2)
         nclcnt(ident1)=nclcnt(ident1)+1
         nclcnt(ident2)=nclcnt(ident2)+1
         ncoll=ncoll+1
         itdth(2,ident1)=iexpn1
         itdth(2,ident2)=iexpn2
         itdth(5,ident1)=0
         itdth(5,ident2)=0
         if(iexpn1.eq.0) then
           tdtg(ident1)=0.0
           itdth(1,ident1)=0
           itdth(4,ident1)=0
         end if
         if(iexpn2.eq.0) then
           tdtg(ident2)=0.0
           itdth(1,ident2)=0
           itdth(4,ident2)=0
         end if
         if(ichanl.gt.1) then
           if(itdt31.ne.0) then
             itd1=mod(itdt31,100000)
           else
             itd1=ident1
           end if
           if(itdt32.ne.0) then
             itd2=mod(itdt32,100000)
           else
             itd2=ident2
           end if
           itdth(3,ident1)=100000*itd2+itd1
           itdth(3,ident2)=100000*itd1+itd2
         end if
         do 163 i=0,3
          x(i,i1)=xold1(i)
          x(i,i2)=xold2(i)
  163    continue
         tlast(i1)=xold1(0)
         tlast(i2)=xold2(0)
         if(iexpn1.eq.0) then
           do  164 i=0,3
  164      qdot(i,i1)=0.
         end if
         if(iexpn2.eq.0) then
           do  165 i=0,3
  165      qdot(i,i2)=0.
         end if
         if(p(0,i1).gt.0.01) then
           ylast(ident1)=0.5*log((p(0,i1)+p(3,i1))/
     a                               (p(0,i1)-p(3,i1)))
         end if
         zlast(ident1)=x(3,i1)-(pnorm(0)*x(0,i1)-
     a                                 pnorm(3)*x(3,i1))*pnorm(3)
         if(p(0,i2).gt.0.01) then
           ylast(ident2)=0.5*log((p(0,i2)+p(3,i2))/
     a                                (p(0,i2)-p(3,i2)))
         end if
         zlast(ident2)=x(3,i2)-(pnorm(0)*x(0,i2)-
     a                                 pnorm(3)*x(3,i2))*pnorm(3)
         if(iqcnvt.eq.1) then
           emi1=em(i1)
           emi2=em(i2)
           call qinvrt(ityp(i1),npidec(i1),emi1)
           call qinvrt(ityp(i2),npidec(i2),emi2)
           if((ityp(i1).eq.98.and.idcid1.eq.0).or.
     a            (ityp(i2).eq.98.and.idcid2.eq.0)) then
             call errex('coll: charge reversed string, no init.')
           end if
         end if
         if(nop.ge.3) then
           if(iqcnvt.eq.1) then
             em3=em(i3)
             call qinvrt(ityp(i3),npidec(i3),em3)
           end if
           if(x(0,i3).eq.0.) then
             do  166 i=0,3
              x(i,i3)=x(i,i1)
              qdot(i,i3)=0.
  166        continue
           else
             do  265 i=0,3
              x(i,i3)=x(i,i3)+qdot(i,i3)*dtprop
              qdot(i,i3)=0.
  265        continue
           end if
           tlast(i3)=x(0,i3)
           ident3=issn(i3)
           tdtg(ident3)=0.0
           itdth(1,ident3)=0
           itdth(2,ident3)=0
           if(iabs(npidec(i3)).ne.40) then
             itdth(3,ident3)=0
           end if
           itdth(5,ident3)=0
           itdth(4,ident3)=0
           ylast(ident3)=0.5*log((p(0,i3)+p(3,i3))/
     a                                (p(0,i3)-p(3,i3)))
           zlast(ident3)=x(3,i3)-(pnorm(0)*x(0,i3)-
     a                        pnorm(3)*x(3,i3))*pnorm(3)
           if(nop.ge.4) then
             do 511 i4a=i4,i4+nop-4
              if(iqcnvt.eq.1) then
                em4=em(i4a)
                call qinvrt(ityp(i4a),npidec(i4a),em4)
              end if
              if(x(0,i4a).eq.0.) then
                do  167 i=0,3
                 x(i,i4a)=x(i,i2)
                 qdot(i,i4a)=0.
  167           continue
              else
                do  266 i=0,3
                 x(i,i4a)=x(i,i4a)+qdot(i,i4a)*dtprop
                 qdot(i,i4a)=0.
  266           continue
              end if
              tlast(i4a)=x(0,i4a)
              ident4=issn(i4a)
              tdtg(ident4)=0.0
              itdth(1,ident4)=0
              itdth(2,ident4)=0
              if(iabs(npidec(i4a)).ne.40) then
                itdth(3,ident4)=0
              end if
              itdth(5,ident4)=0
              itdth(4,ident4)=0
              ylast(ident4)=0.5*log((p(0,i4a)+p(3,i4a))/
     a                                         (p(0,i4a)-p(3,i4a)))
              zlast(ident4)=x(3,i4a)-(pnorm(0)*x(0,i4a)-
     a                                pnorm(3)*x(3,i4a))*pnorm(3)
  511        continue
           end if
         end if
      return
      end
CPAT,COLOAD   .
      subroutine coload
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      logical hit
      data vernum/'version   rqmd 2.2 -- 28-oct-95'/
      data pronam /'coload -- collision array rebuild'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      iorig=0
      if(.not.switch(23).and.ida(57).eq.1) iorig=1
      ntotal=nrbar(kclst)+nrmes(kclst)
      if(ida(11).eq.1) ntotal=nrbar(kclst)
      nument=0
      if(ida(34).eq.2) then
        do 20 i1=iofset+1,iofset+ntotal
         prop(i1)=.false.
   20   continue
      end if
      do 21 i1e=1,ntotal
        i1=i1e+iofset
        if(ida(34).eq.2) then
            ident1=issn(i1)
            ncoli1=nclcnt(ident1)
            if(prop(i1).or.
     a         (ident1.le.nt.and.ident1.gt.n1.and.ncoli1.eq.0)) then
            else
               iclyes=0
               call hit34(iorig,i1,i2,sig,thit,iclyes)
               if(iclyes.eq.1) then
                   prop(i1)=.true.
                   prop(i2)=.true.
                   nument=nument+1
                   if (nument.gt.numema)
     a                call errex( 'coload, collision storage exceeded')
                   i1c(nument)=i1
                   i2c(nument)=i2
                   ctime(nument)=thit
                   csig(nument)=sig
               else
                 do 12 i2e=i1e+1,ntotal
                   i2=i2e+iofset
                   ident2=issn(i2)
                   ncoli2=nclcnt(ident2)
                   if(prop(i2).or.
     a                 (ident2.le.nt.and.ident2.gt.n1.and.ncoli2.eq.0))
     b                                                         go to 12
                   if(hit(iorig,i1,i2,srt,sig,sigel,thit)) then
                       nument=nument+1
                       if (nument.gt.numema)
     a                call errex( 'coload, collision storage exceeded')
                       i1c(nument)=i1
                       i2c(nument)=i2
                       ctime(nument)=thit
                       csig(nument)=sig
                       prop(i1)=.true.
                       prop(i2)=.true.
                       go to 13
                   end if
   12            continue
               end if
   13          continue
            end if
        else
           do 22 i2e=i1e+1,ntotal
            i2=i2e+iofset
              if(hit(iorig,i1,i2,srt,sig,sigel,thit)) then
                nument=nument+1
                if (nument.gt.numema)
     a                call errex('coload, collision storage exceeded')
                i1c(nument)=i1
                i2c(nument)=i2
                idud(1,issn(i1))=idud(1,issn(i1))+1
                idud(1,issn(i2))=idud(1,issn(i2))+1
                ctime(nument)=thit
                csig(nument)=sig
              end if
   22      continue
        end if
   21 continue
      return
      end
CPAT,CROSS1   .
      subroutine cross1(iswel,srt,pr,icltp,sig,em1,em2,
     a                                 ityp1,ityp2,npid1,npid2)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      real*4 pjin
      dimension pjin(4)
      common /pjbk/ pjin
      real*4 cgk212,cgk232
      common /xspibk/ xspin1,xspin3,wnorm1,wnorm3,pow12,pow32,
     a                xsbgl1,xsbgl3,xs1218,xs32pn,xs12pn
      real*4 a,b,en,c,d
      data emkofs /0.483/
      data fstrsq / 4.5238/
      data   ibaspi,j1,j1new,j2,j2new,j1d,j2d,j1dnew,j1n,j2n,j2dnew,
     @       ibasd,ibasn,zmltp,parama,paramb,b0im  /
     @           16,2,2,2,2,3,3,3,1,1,3,9,3,4*0.0 /
      data vernum/'version rqmd 2.1  -- 24-nov-94'/
      data pronam /'cross1 -- total and elastic crossections'/
      data ttvers/.true./
       tblfit(plab,a,b,en,c,d)=a+b*plab**en+c*(log(plab))**2+
     a                              d*log(plab)
      if(ttvers) then
        zmltp=80.*pi/(5.0674**2)
        parama=fstrsq/empion/empion/6./pi*emnuc
        paramb=20./3.*fstrsq/empion/empion*(hc/pi2)**2
        b0im=0.035/empion**4
         xs32pn=36.11
         xs12pn=34.45
         pow32=4.6
         pow12=5.4
         xspin1=30.0
         xspin3=30.32
         xsbgl1=4.7
         xsbgl3=4.7
         stest=2.0
         pcms=pcmsr(stest,emnuc,empion)
         bwigs=0.0
         do 166 jent=1,9
          call bwdist(1,1,stest,jent,1,zdnp,bwig)
          bwigs=bwigs+bwig
  166    continue
         gmdlt=29.*pcms**3/(1.+40.*pcms*pcms)
         bwigs=bwigs+
     a          4.*gmdlt/((stest-emdelt)**2+0.25*gmdlt**2)
         sigbws=0.5*pi*10.0*(hc/pi2)**2/pcms**2*bwigs
         wnorm3=sigbws/xspin3
         stest=1.8
         pcms=pcmsr(stest,emnuc,empion)
         bwigs=0.0
         do 165 jent=1,9
          call bwdist(2,1,stest,jent,1,zdnp,bwig)
          bwigs=bwigs+bwig
  165    continue
         sigbws=0.5*pi*10.0*(hc/pi2)**2/pcms**2*bwigs
         xs1218=(37.64-9.78)
         wnorm1=sigbws/xs1218
         write(lun8,*) 'wnorm1=',wnorm1,'wnorm3=',wnorm3
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      icltyp=icltp
      if(icltyp.gt.maxtyp) icltyp=maxtyp+1
      if(icltyp.le.66) then
        s=sqrt(em1**2+pr*pr)+sqrt(em2**2+pr*pr)
      else
        s=srt
      end if
      if(s.lt.em1+em2) then
          sig=0.
          return
      end if
      iswold=iswel
      iswelt=mod(iswel,2)
      itp1=ityp1
      npd1=npid1
      itp2=ityp2
      npd2=npid2
      igo=0
   11 continue
      igo=igo+1
      if(igo.gt.2) then
        write(lun8,*) 'wrong igo in cross1',igo
        call errex('cross1:wrong igo')
      end if
      tblsft=0.0
      if(icltyp.eq.maxtyp+1) then
        if(itp1.ge.85.and.itp1.le.99) then
          if(npd1.eq.34.or.npd1.eq.35) then
            if(itp2.le.11.and.mod(itp2,10).le.6)  go to 92
          else if(npd1.eq.28.or.npd1.eq.29) then
            if(itp2.eq.13.or.itp2.eq.15) go to 92
          end if
        else if(itp2.ge.85.and.itp2.le.99) then
          if(npd2.eq.34.or.npd1.eq.35) then
            if(itp1.le.11.and.mod(itp1,10).le.6) go to 92
          else if(npd2.eq.28.or.npd2.eq.29) then
            if(itp1.eq.13.or.itp1.eq.15) go to 92
          end if
        end if
      end if
      goto (
     >  10, 20, 10, 30, 30, 30, 30, 30, 30, 30,
     >  30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     >  30, 80, 80,110, 92, 92, 92,110, 80, 80,
     >  92, 92, 92, 92,110,110, 80, 80, 92, 92,
     >  92,110,110,110,110, 30, 30, 30, 30, 30,
     >  30, 92, 92, 92, 30,
     >  30, 30, 30, 30, 30, 30, 92, 92, 92, 30,
     >  30, 92, 92, 92, 92, 92, 92,110,110,110,
     >  92, 92,110,110,110,110,110,110,110,110,
     > 110,110,110,110,110,110,400,400,110,110,
     > 110,110,110,110,110,110,110,110, 86,110,
     > 110,110,110,110,110,110,110,110,110,110,
     > 110,110,110, 86,110,
     >  110
     & ) , icltyp
       write(lun8,*)' icltyp invalid in  cross1   ',icltyp
       write(lun8,*) itp1,itp2,npd1,npd2
       call errex('cross1:fatal error')
 10    continue
       if(s.gt.2.*emnuc) then
         ppr=sqrt(((s*s-2.*emnuc*emnuc)/(2.*emnuc))**2-emnuc*emnuc)
       else
         ppr=0.
       end if
       if(ppr.gt.3.)then
         if(iswelt.eq.1) then
           sig=tblfit(ppr,45.60,219.0,-4.23,0.410,-3.41)
         else
           sig=tblfit(ppr,11.20,25.5,-1.12,0.151,-1.62)
         end if
       else
          if(iswelt.eq.1) then
            ioftab=itblsz*4
          else
            ioftab=itblsz*5
          end if
          assign 100 to label
          goto 1000
  100     sig=sigin
       end if
       if(iswelt.eq.1.and.s.lt.snnlim.and.ida(4).gt.0) then
            ioftab=itblsz*6
            assign 101 to label
            goto 1000
  101       sig=sig+(enhcnd-1.)*sigin
       end if
       return
 20    continue
       if(s.gt.2.*emnuc) then
         ppr=sqrt(((s*s-2.*emnuc*emnuc)/(2.*emnuc))**2-emnuc*emnuc)
       else
         ppr=0.
       end if
       if(iswelt.eq.1) then
           if(ppr.gt.280.) then
              sig=38.3+ 0.43*(log(s*s*0.01))**2
           else if(ppr.gt.2.)then
              sig=tblfit(ppr,47.70,-100.0,-4.57,0.512,-4.29)
           else
              ioftab=itblsz*2
              assign 200 to label
              goto 1000
  200         sig=sigin
           end if
           if(s.lt.snnlim.and.ida(4).gt.0) then
              ioftab=itblsz*6
              assign 202 to label
              goto 1000
  202         sig=sig+0.5*(enhcnd-1.)*sigin
           end if
       else
           if(s.ge.tblhig)then
              sig=tblfit(ppr,11.20,25.5,-1.12,0.151,-1.62)
           else
              ioftab=itblsz*3
              assign 201 to label
              goto 1000
  201         sig=sigin
           end if
       end if
       return
 30    continue
       if(s.lt.tblhig.and.iabs(npd1).le.1.and.iabs(npd2).le.1.and.
     a     ((itp1.le.2.and.itp2.ge.3.and.itp2.le.6).or.
     b           (itp2.le.2.and.itp1.ge.3.and.itp1.le.6))) then
         idnyes=1
       else
         idnyes=0
       end if
       if(s.lt.tblhig.and.iabs(npd1).le.1.and.iabs(npd2).le.1.and.
     a       itp1.ge.3.and.itp1.le.6.and.
     b            itp2.ge.3.and.itp2.le.6) then
         iddyes=1
       else
         iddyes=0
       end if
       srtold=s
       prelsq=pr*pr
       srtact=s
       if(srtact.gt.2.*emnuc) then
         ppr=sqrt(((srtact*srtact-2.*emnuc*emnuc)
     a                       /(2.*emnuc))**2-emnuc*emnuc)
       else
         call errex('cross1:ppr=0.')
       end if
       if(iswelt.eq.1) then
         if(ppr.gt.280.) then
           sig=38.3+0.43*(log(srtact*srtact*0.01))**2
         else if(ppr.gt.2.)then
           sig=tblfit(ppr,47.70,-100.0,-4.57,0.512,-4.29)
         else
           s=srtact
           ioftab=itblsz*2
           assign 300 to label
           goto 1000
  300      sig=sigin
           s=srtold
         end if
       else
         if(srtact.ge.tblhig)then
           sig=tblfit(ppr,11.20,25.5,-1.12,0.151,-1.62)
         else
           s=srtact
           ioftab=itblsz*3
           assign 301 to label
           goto 1000
  301      sig=sigin
           s=srtold
         end if
       end if
       if(idnyes.eq.1) then
         go to 35
       else
         if(iswelt.eq.1) then
           call detbal(s,pr,icltyp,itp1,npd1,itp2,npd2,em1,em2,sigdb)
           sig=sig+sigdb
           if(iddyes.eq.1) then
             ioftab=itblsz*23
             assign 302 to label
             goto 1000
  302        continue
             m1=2*itp1-ibasd
             m2=2*itp2-ibasd
             itag=-100
             call isocgk(
     a                m1,j1d,m2,j2d,j1dnew,j2dnew,m1new,m2new,itag)
             m=m1+m2
             ino=0
             sigdd=0.
             do 305 imt=iabs(m),6,2
              if(iabs(m)+2*ino.eq.2)then
                sigdd=0.44444*pjin(ino+1)*sigin
                sigdd=sigdd+0.8*pjin(ino+2)*sigin
                go to 306
              else if(iabs(m)+2*ino.eq.4)then
                sigdd=0.8*pjin(ino+1)*sigin
                go to 306
              end if
              ino=ino+1
  305        continue
  306        continue
             emmxd=s-max(em1,em2)
             vfd=pi/(atan(2.*(emmxd-emdelt)/widdlt)-
     a                 atan(2.*(emnuc+empion-emdelt)/widdlt))
             sigdd=vfd*sigdd*da(12)
             if(s.gt.emnuc+emdelt) then
               pout=pcmsr(s,emnuc,emdelt)
             else
               pout=0.
             end if
             sig=sig+0.5*pout**2/prelsq*sigdd
           end if
         end if
         return
       end if
   35  continue
       if(iswelt.eq.0) then
         if(s.le.emdelt+emnuc) then
           s=sqrt(emnuc**2+pr**2)+sqrt(emdelt**2+pr**2)
         end if
         ioftab=itblsz*22
         assign 351 to label
         goto 1000
  351    sigeld=sigin
         s=srtold
         emmin=emnuc+empion
         emmxd=max(s-emnuc,emmin)
         vfd=1./pi*(atan(2.*(emmxd-emdelt)/widdlt)-
     a            atan(2.*(emmin-emdelt)/widdlt))
         sigeld=sigeld*vfd
         sigeno=max(cvalu0,vfd*sig-sigeld)
         sig=sigeno
         return
       else  if(iswelt.eq.1) then
         call wqdnch(icltyp,itp1,itp2,npd1,npd2,s,pr,em1,em2,
     a                       sigeno,sigel1,sigel2,sigdd1,sigdd2,sigdb)
         if(s.gt.2.5) then
           sig=max(sig,sigdb+sigel1+sigel2+sigeno+sigdd1+sigdd2)
         else
           sig=sigdb+sigel1+sigel2+sigeno+sigdd1+sigdd2
         end if
         return
       end if
   80 continue
      if(npd1.ne.0.or.npd2.ne.0) then
        go to 92
      end if
      tblsft=emnuc
      if(s+tblsft.lt.tbllow ) then
        sig=0.0
        return
      end if
      if((icltyp.eq.22).or.(icltyp.eq.38) )then
         imixt=1
         ioftab=itblsz*7
         ioftb2=itblsz*16
      else if((icltyp.eq.37).or.(icltyp.eq.23) )then
         imixt=2
         ioftab=itblsz*15
         ioftb2=itblsz*17
      else if((icltyp.eq.29).or.(icltyp.eq.30) )then
         imixt=3
         ioftab=itblsz*7
         ioftb2=itblsz*16
      end if
      ppr=sqrt(((s*s-emnuc*emnuc-empion*empion)/
     a                                 (2.*emnuc))**2-empion*empion)
      if(ppr.le.4.) then
         assign 800 to label
         goto 1000
  800    if(iswelt.eq.1)then
           if(imixt.eq.3) then
             sig=0.5*sigin
             ioftab=itblsz*15
             assign 810 to label
             goto 1000
  810        sig=sig+0.5*sigin
           else
             sig=sigin
           end if
         else
           ioftab=ioftb2
           assign 820 to label
           goto 1000
  820      if(imixt.eq.3) then
             sig=0.5*sigin
             ioftab=itblsz*17
             assign 830 to label
             goto 1000
  830        sig=sig+0.5*sigin
           else
             sig=sigin
           end if
         end if
         if(ida(4).gt.0.and.iswelt.eq.1) then
            if(s.le.emnuc+empion.or.s.gt.1.5) then
            else
              pcms=pcmsr(s,emnuc,empion)
              gamd=parama/s*pcms**3
              sigin=paramb/(s/emnuc*pcms)*
     a             pcms**2*0.04/((s-emdelt)**2+0.25*gamd**2)
              sig=sig+sigin
              pilu=sqrt(empion*empion+ppr*ppr)
              tpion=pilu-empion
              sigsab=1.5*(hc/pi2)**5*20.*pi2/ppr*
     a             (1.+0.5*pilu/empion)*b0im*rho0*
     b                            exp(-6.*max(cvalu0,tpion-.1))
              sig=sig+sigsab
            end if
         end if
      else
         pprmx=340.
         ppr=min(ppr,pprmx)
         if(imixt.eq.1) then
           if(iswelt.eq.1) then
             sig=tblfit(ppr,32.10,48700.0,-7.85,0.540,-4.41)
           else
             sig=tblfit(ppr,7.07,11.3,-1.60,0.160,-1.56)
           end if
         elseif(imixt.eq.2) then
           if(iswelt.eq.1) then
             sig=tblfit(ppr,33.10,15.0,-1.41,0.458,-4.06)
           else
             sig=tblfit(ppr,1.73,11.2,-0.63,0.0437,0.00)
           end if
         elseif(imixt.eq.3) then
           if(iswelt.eq.1) then
             sig=0.5*tblfit(ppr,33.10,15.0,-1.41,0.458,-4.06)+
     a             0.5* tblfit(ppr,32.10,48700.0,-7.85,0.540,-4.41)
           else
             sig=0.5*tblfit(ppr,1.73,11.2,-0.63,0.0437,0.0)+
     a             0.5*tblfit(ppr,7.07,11.3,-1.60,0.160,-1.56)
           end if
         endif
      end if
      if(iswold.eq.1) then
      else if(iswold.eq.3) then
          if(s.le.2.0) then
            rlimit=1.0
          else
            if(imixt.eq.3) then
              xspin=0.3333*xs12pn+0.6667*xs32pn
            else if(imixt.eq.2) then
              xspin=0.3333*xs32pn+0.6667*xs12pn
            else
              xspin=xs32pn
            end if
            rlimit=min(cvalu1,xspin*(4.0/s**2)**da(7)/sig)
          end if
          sig=max(cvalu0,sig*(1.-rlimit))
      else if(iswold.eq.0) then
        if(iswelt.eq.1) then
          if(s.le.2.0) then
            rlimit=1.0
          else
            if(imixt.eq.3) then
              xspin=0.3333*xs12pn+0.6667*xs32pn
            else if(imixt.eq.2) then
              xspin=0.3333*xs32pn+0.6667*xs12pn
            else
              xspin=xs32pn
            end if
            rlimit=min(cvalu1,xspin*(4.0/s**2)**da(7)/sig)
          end if
          sig=max(cvalu0,sigto*(1.-rlimit))
        else
          sigto=sig
          iswelt=1
          go to 80
        end if
      end if
      return
   86  continue
       if(itp2.eq.13.or.itp2.eq.15) then
         if(npd1.lt.0) go to 110
       else  if(itp1.eq.13.or.itp1.eq.15) then
         if(npd2.lt.0) go to 110
       else
         go to 92
       end if
   92 continue
      ichd=-99
      ichn=-99
      if(itp1.le.6.or.itp1.eq.10.or.itp1.eq.11.or.
     a   itp1.eq.13.or.itp1.eq.15.or.
     b   (itp1.ge.98.and.itp1.le.99.and.
     c    kspin(min(max(iabs(npd1),1),71)).ge.2)) then
        call ndstar(s,pr,em2,em1,icltyp,itp2,npd2,itp1,npd1,
     a              icollc,mstr,ichd,ichn,ireco,nscod,strrat,vfspin)
      else
        call ndstar(s,pr,em1,em2,icltyp,itp1,npd1,itp2,npd2,
     a              icollc,mstr,ichd,ichn,ireco,nscod,strrat,vfspin)
      end if
      qlimit=min(cvalu1,(4.0/s**2)**da(7))
      if(mstr.eq.0) then
        sig=sigasy(iswelt,1,0,0,0)
      else
        sig=sigasy(iswelt,1,1,0,1)
      end if
      sig=(1.-qlimit)*sig
      if(iswelt.eq.1) then
        if(icltyp.eq.67.or.icltyp.eq.68) then
          sig=sig+10.0*(1.5/s)**2
        else if(icltyp.eq.76.or.icltyp.eq.77) then
          sig=sig+10.0*(1.5/s)**2
        else if(icltyp.eq.104) then
          if((itp1.eq.14.and.npd1.gt.0).or.
     a              (itp2.eq.14.and.npd2.gt.0))  then
            sig=sig+10.0*(1.5/s)**2
          end if
        end if
      end if
      if(iswold.eq.1) then
        if(s.gt.1.3) then
          xsann=xsesti(1,s,pr,strrat,ireco,mstr,icollc)
          sig=sig+xsann
        end if
      end if
      return
  400 continue
      tblsft=emkofs
      ppr=sqrt(((s*s-emnuc*emnuc-emkap*emkap)/
     a                                 (2.*emnuc))**2-emkap*emkap)
      if(ppr.gt.3.0) then
        ippr=1
      else
        ippr=0
      end if
      jann=0
      if(((itp1.eq.1).and.(npd2.eq.-2))
     &        .or.((itp2.eq.1).and.(npd1.eq.-2))
     &        .or.((itp1.eq.2).and.(npd2.eq.-1))
     &        .or.((itp2.eq.2).and.(npd1.eq.-1))) then
               jann=1
               if(ippr.eq.1) then
                 if(iswelt.eq.1) then
                   sig=tblfit(ppr,25.2,0.,0.,0.38,-2.9)
                 else
                   sig=tblfit(ppr,7.24,46.0,-4.71,0.279,-2.35)
                 end if
               else
                 if(iswelt.eq.1) then
                   ioftab=(kaofs+6)*itblsz
                 else
                   ioftab=(kaofs+7)*itblsz
                 end if
               end if
      else if(((itp1.eq.2).and.(npd2.eq.-2))
     &        .or.((itp2.eq.2).and.(npd1.eq.-2))
     &        .or.((itp1.eq.1).and.(npd2.eq.-1))
     &        .or.((itp2.eq.1).and.(npd1.eq.-1))) then
               jann=2
               if(ippr.eq.1) then
                 if(iswelt.eq.1) then
                   if(ppr.gt.310.0) ppr=310.0
                   sig=tblfit(ppr,-21.1,56.2,-0.27,-0.155,6.24)
                 else
                   sig=tblfit(ppr,7.24,46.0,-4.71,0.279,-2.35)
                 end if
               else
                 if(iswelt.eq.1) then
                   ioftab=(kaofs+8)*itblsz
                 else
                   ioftab=(kaofs+9)*itblsz
                 end if
               end if
               if(itp1.eq.14.and.npd1.eq.-1.or.
     b                    itp2.eq.14.and.npd2.eq.-1) tblsft=tblsft+.004
      else if(((itp1.eq.2).and.(npd2.eq.2))
     &       .or.((itp2.eq.2).and.(npd1.eq.2))
     &       .or.((itp1.eq.1).and.(npd2.eq.1))
     &       .or.((itp2.eq.1).and.(npd1.eq.1))) then
               if(ippr.eq.1) then
                 if(iswelt.eq.1) then
                   sig=tblfit(ppr,17.1,5.54,-2.67,0.139,-0.270)
                 else
                   sig=tblfit(ppr,5.84,17.2,-3.06,0.206,-1.71)
                 end if
               else
                 if(iswelt.eq.1) then
                  ioftab=(kaofs+10)*itblsz
                 else
                  ioftab=(kaofs+11)*itblsz
                 end if
               end if
      else if(((itp1.eq.1).and.(npd2.eq.2))
     &        .or.((itp2.eq.1).and.(npd1.eq.2))
     &        .or.((itp1.eq.2).and.(npd2.eq.1))
     &        .or.((itp2.eq.2).and.(npd1.eq.1))) then
               if(ippr.eq.1) then
                 if(iswelt.eq.1) then
                   sig=tblfit(ppr,18.4,175.,-7.85, 0.198,-0.753)
                 else
                   sig=tblfit(ppr,5.84,17.2,-3.06,0.206,-1.71)
                 end if
               else
                 if(iswelt.eq.1) then
                  ioftab=(kaofs+12)*itblsz
                 else
                  ioftab=(kaofs+13)*itblsz
                 end if
               end if
      else
         write(lun8,*) itp1,npd1,itp2,npd2
         call errex('undefined particle pair in cross1,400')
      end if
      if(ippr.eq.0) then
        if(s.ge.tblhig-tblsft) then
          call errex('cross1: kaon nucleon cm energy out of range')
        end if
        assign 106 to label
        goto 1000
  106   continue
        sig=sigin
      end if
      if(iswold.eq.0.and.jann.eq.2) then
          inum=4
          itot=0
          call retcgk(itp1,npd1,i1,m1,-1,cgk212)
          call retcgk(itp2,npd2,i2,m2,-1,cgk212)
          if(i1.eq.1) then
            if(i2.ne.1) call errex('cross1:i2.ne.1')
            call iswap(i1,i2)
            call iswap(m1,m2)
          end if
          sigch=piynkb(i1,m1,i2,m2,itot,inum,s,pr)
          sig=max(cvalu0,sig-sigch)
      else if(iswold.eq.0.and.jann.eq.1) then
        if(s.le.2.0) then
          sig=0.
        else
          sig=sig*(1.-(2./s)**5)
        end if
      else if(iswold.eq.3.and.jann.gt.0) then
        qlimit=min(cvalu1,(4.0/s**2)**da(7))
        signon=sig*(1.-qlimit)
        if(ippr.eq.1) then
          sigin=tblfit(ppr,7.24,46.0,-4.71,0.279,-2.35)
        else
          ioftab=(ioftab/itblsz+1)*itblsz
          assign 107 to label
          goto 1000
  107     continue
        end if
        sig=sigin*qlimit+signon
        if(jann.eq.2) then
          inum=4
          itot=0
          call retcgk(itp1,npd1,i1,m1,-1,cgk212)
          call retcgk(itp2,npd2,i2,m2,-1,cgk212)
          if(i1.eq.1) then
            if(i2.ne.1) call errex('cross1:i2.ne.1')
            call iswap(i1,i2)
            call iswap(m1,m2)
          end if
          sigch=piynkb(i1,m1,i2,m2,itot,inum,s,pr)
        else if(jann.eq.1) then
          sigch=sigin*min(cvalu1,(2./s)**5)
        end if
        sig=max(cvalu0,sig-sigch)
      end if
      return
  110 continue
       call transl(-1,itp1,npd1,ltyp1)
       call transl(-1,itp2,npd2,ltyp2)
       call contnt(ltyp1,ltyp2,istra1,istra2,
     a                            imeso1,imeso2,ibry1,ibry2,iann)
        if(ibry1*ibry2.ge.2) then
          if(istra1+istra2.eq.1) then
            snew=s
            ppr=sqrt(((snew*snew-emlamb*emlamb-emnuc*emnuc)/
     a                                 (2.*emnuc))**2-emlamb*emlamb)
            if(iswelt.eq.1) then
              if(ppr.lt.3.0) then
                ioftab=(kaofs+19)*itblsz
                sold=s
                s=snew
                assign 102 to label
                go to 1000
  102           continue
                sig=sigin
              else
                pprmax=21.
                pprmin=3.0
                ppr=max(pprmin,min(pprmax,ppr))
                sig=tblfit(ppr,30.4,0.0,1.0,0.0,1.60)
              end if
            else
              if(ppr.lt.3.) then
                ioftab=(kaofs+20)*itblsz
                sold=s
                s=snew
                assign 103 to label
                go to 1000
  103           continue
                sig=sigin
              else
                pprmax=24.
                pprmin=3.
                ppr=max(pprmin,min(pprmax,ppr))
                sig=tblfit(ppr,12.3,0.0,1.0,0.0,-2.4)
              end if
            end if
          else
            sig=sigasy(iswelt,0,istra1,0,istra2)
          end if
        else if(ibry1*ibry2.lt.0) then
          dsann=0.0
          if(ida(19).eq.0) then
            snew=s
            if(iswelt.eq.1) then
              sann=sppban(snew)
              dsann=0.0
            end if
          else
            snew=2.*sqrt(emnuc**2+pr**2)
            if(iswelt.eq.1) then
              sann=sppban(snew)
              if(ibry1*ibry2.eq.-1)  dsann=sann-sppban(s)
            end if
          end if
          if(ibry1*ibry2.eq.-1) then
            ppr=sqrt((0.5*s*s/emnuc-emnuc)**2-emnuc*emnuc)
            if(iswelt.eq.1) then
              if(ppr.gt.5.) then
                sig=tblfit(ppr,41.1,77.2,-0.68,0.293,-1.82)
              else
                sold=s
                s=min(snew,tblhig-ekinmi)
                ioftab=18*itblsz
                assign 111 to label
                goto 1000
  111           continue
                sig=sigin
              end if
              sig=sig+dsann
            else
              if(ppr.gt.2.) then
                sig=tblfit(ppr,10.6,53.1,-1.19,0.136,-1.41)
              else
                sold=s
                s=min(snew,tblhig-ekinmi)
                ioftab=19*itblsz
                assign 112 to label
                goto 1000
  112           continue
                sig=sigin
              end if
            end if
          else
            sig=sigasy(iswelt,0,istra1,0,istra2)
            if(iswelt.eq.1) then
              sig=sig+sann
            end if
          end if
        else if(ibry1.lt.0.or.ibry2.lt.0) then
          call qinvrt(itp1,npd1,em1)
          call qinvrt(itp2,npd2,em2)
          icltyp=ictype(itp1,itp2)
          if(icltyp.gt.maxtyp) icltyp=maxtyp+1
          go to 11
        else if(ibry1.eq.0.and.ibry2.eq.0) then
          sig=sigasy(iswelt,1,istra1,1,istra2)
          qlimit=min(cvalu1,1.6/s)
          if(iswelt.eq.0) then
            sig=(1.-qlimit)*sig
          else if(iswelt.eq.1) then
            siglow=0.0
            if(s.lt.1.8.or.pr.lt.0.9) then
              if(icltyp.le.45.and.npd1.eq.0.and.
     a                                     npd2.eq.0) then
                if(icltyp.eq.35.or.icltyp.eq.44) then
                  siglow=120.0
                else if(icltyp.eq.43) then
                  siglow=150.0
                else
                  siglow=40.0
                end if
              else if(icltyp.eq.105.and.npd1*npd2.lt.0) then
                if(s.lt.1.2) then
                  siglow=6./pr**2
                else
                  siglow=40.0
                end if
              else if(icltyp.ge.98.and.icltyp.le.100) then
                if(s.gt.0.822.and.s.lt.0.962)  then
                  siglow=130.
                else
                  siglow=40.0
                end if
              else
                siglow=25.0/pr
              end if
            else if(s.lt.2.5) then
              if(icltyp.eq.105.and.npd1*npd2.lt.0) then
                siglow=10.0
              else if(icltyp.le.45.and.
     a                (npd1.ne.0.or.npd2.ne.0)) then
                siglow=10.0
              end if
            end if
            sig=sig+siglow
          end if
        else if((ibry1.ne.0.and.ibry1*ibry2.eq.0).or.
     a           (ibry2.ne.0.and.ibry1*ibry2.eq.0)) then
          if(iann.eq.4) then
            if(s.gt.2.0) then
              qlimit=(4.0/s**2)**da(7)
              sig=sigasy(iswelt,imeso1,istra1,imeso2,istra2)
              sigbas=max(cvalu0,sig*(1.-qlimit))
              sig=sigbas
            else
              sig=0.0
            end if
          else if(iann.eq.3) then
            if(s.gt.2.0) then
              qlimit=(4.0/s**2)**da(7)
              sig=sigasy(iswelt,imeso1,istra1,imeso2,istra2)
              sigbas=max(cvalu0,sig*(1.-qlimit))
              sig=sigbas
            else
              sig=0.0
            end if
            if(iswold.eq.1) then
              xsann=xsesti(5,s,pr,strdum,iredu,mdum,icodum)
              sig=sig+xsann
            end if
          else if(iann.eq.2) then
              if(s.le.1.50) then
                sig=0.0
                return
              else
                if(s.gt.2.0) then
                  qlimit=(4.0/s**2)**da(7)
                  sig=sigasy(iswelt,imeso1,istra1,imeso2,istra2)
                  sigbas=max(cvalu0,sig*(1.-qlimit))
                  sig=sigbas
                else
                  sig=0.0
                end if
                if(iswold.eq.1) then
                  xsann=xsesti(4,s,pr,strdum,iredu,mdum,icodum)
                  sig=sig+xsann
                end if
              end if
          else
            sig=sigasy(iswelt,imeso1,istra1,imeso2,istra2)
          end if
        end if
      return
 1000 xpt=log(s+tblsft)
      tlow=log(tbllow)
       if(xpt.lt.tlow) then
         xpt=tlow
       end if
       index=int((xpt-tlow)/tblstp)+1
       if(index.ge.itblsz) then
         write(lun8,*)'warning:index.ge.itblsz in cross1 index=',index
         write(lun8,*)'icltyp,s',icltyp,s
         index=itblsz-1
       end if
       indin=ioftab+index
       x1=(index-1)*tblstp+tlow
       y1in=sigcom(indin)
       y2in=sigcom(indin+1)
       slin=(y2in-y1in)/tblstp
       sigin=slin*(xpt-x1)+y1in
      goto label
      end
      subroutine contnt(kl1,kl2,istra1,istra2,
     a                            imeso1,imeso2,ibry1,ibry2,iann)
#include "amsrqmd.h"
                    call luiflv(kl1,ifla1,iflb1,iflc1,ksp)
                    istra1=0
                    imeso1=0
                    istra2=0
                    imeso2=0
                    ibry1=0
                    ibry2=0
                    if(iabs(ifla1).eq.3) istra1=1
                    if(iabs(iflb1).eq.3) istra1=istra1+1
                    if(iabs(iflc1).eq.3) istra1=istra1+1
                    if(iflc1.eq.0) then
                       imeso1=1
                    else if(iflc1.lt.0) then
                       if((-kl1.ge.41.and.-kl1.le.42).or.
     a                    (-kl1.ge.61.and.-kl1.le.64)) then
                         ibry1=-1
                       else
                         ibry1=-2
                       end if
                    else if(iflc1.gt.0) then
                       if((kl1.ge.41.and.kl1.le.42).or.
     a                    (kl1.ge.61.and.kl1.le.64)) then
                         ibry1=1
                       else
                         ibry1=2
                       end if
                    end if
                    call luiflv(kl2,ifla2,iflb2,iflc2,ksp)
                    if(iabs(ifla2).eq.3) istra2=1
                    if(iabs(iflb2).eq.3) istra2=istra2+1
                    if(iabs(iflc2).eq.3) istra2=istra2+1
                    if(iflc2.eq.0) then
                       imeso2=1
                    else if(iflc2.lt.0) then
                       if((-kl2.ge.41.and.-kl2.le.42).or.
     a                    (-kl2.ge.61.and.-kl2.le.64)) then
                         ibry2=-1
                       else
                         ibry2=-2
                       end if
                    else if(iflc2.gt.0) then
                       if((kl2.ge.41.and.kl2.le.42).or.
     a                    (kl2.ge.61.and.kl2.le.64)) then
                         ibry2=1
                       else
                         ibry2=2
                       end if
                    end if
        iann=0
        if((ibry1.ne.0.or.ibry2.ne.0).and.ibry1*ibry2.eq.0) then
          if(iflc1.ne.0) then
            iann=ianout(kl1,istra1,ifla1,iflb1,iflc1,
     a                              kl2,istra2,ifla2,iflb2)
          else if(iflc2.ne.0) then
            iann=ianout(kl2,istra2,ifla2,iflb2,iflc2,
     a                              kl1,istra1,ifla1,iflb1)
          end if
        end if
       return
       end
       subroutine qinvrt(itp1,npd1,em1)
         include 'scatter7'
#include "amsrqmd.h"
         ires=0
         if((itp1.ge.10.and.itp1.le.11).or.
     a    (itp1.ge.3.and.itp1.le.6.and.npd1.ne.0.and.npd1.ne.1)) then
           call subst2(1,itp1,npd1)
           if(itp1.le.11) then
             ires=1
           else
             ires=-5
           end if
         else if((itp1.eq.98).and.
     a          ( (-npd1.ge.41.and.-npd1.le.42).or.
     b            (-npd1.ge.61.and.-npd1.le.64) )) then
               ires=-1
         else if(itp1.ge.7.and.itp1.le.9)then
                ires=-2
         else if(itp1.eq.12) then
                ires=-2
         else if((itp1.eq.98).and.
     a          ((-npd1.ge.43.and.-npd1.le.45).or.
     b                                    (npd1.eq.-57))) then
         else if(itp1.eq.13.or.itp1.eq.15) then
                if(em1.ge.emlamb+empion) ires=-4
         else if(itp1.ge.85.and.itp1.le.97)then
           ires=-5
         else if(itp1.eq.98)then
           ires=-3
         end if
         itpold=itp1
         npdold=npd1
         call transl(-1,itp1,npd1,kl2)
         if((kl2.eq.23).or.(kl2.eq.24).or.(kl2.eq.25).or.(kl2.eq.33)
     a         .or.(kl2.eq.34).or.(kl2.eq.35).or.(kl2.eq.36) ) then
           kl2=-kl2
         end if
         call transl(1,itp1,npd1,-kl2)
         if(ires.eq.1) then
             itp1=98
         else if(ires.eq.-1) then
             if(itp1.ge.3.and.itp1.le.6) then
             else if(itp1.ge.1.and.itp1.le.2) then
                itp1=9+itp1
             else
                write(lun8,*) 'ires,itp1,npd1,em1'
                write(lun8,*)  ires,itp1,npd1,em1
                call errex('what is this particle in qinvrt')
             end if
             npd1=3
         else if(ires.eq.-2) then
             npd1=npdold
         else if(ires.eq.-3.or.ires.eq.-5) then
             itp1=itpold
             if(ires.eq.-5) then
               npd1=-kl2
               if(npd1.gt.40) call subst2(2,itp1,npd1)
             end if
         else if(ires.eq.-4) then
             itp1=98
         end if
       return
       end
       function kfcrev(kl2)
#include "amsrqmd.h"
         if((kl2.eq.23).or.(kl2.eq.24).or.(kl2.eq.25).or.(kl2.eq.33)
     a         .or.(kl2.eq.34).or.(kl2.eq.35).or.(kl2.eq.36) ) then
           kfcrev=kl2
         else
           kfcrev=-kl2
         end if
       return
       end
      subroutine detbal(s,pr,icltyp,ityp1,npid1,ityp2,npid2,
     a                                                em1,em2,sigdb)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
      dimension beta(100)
      data beta/
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.03,  0.00,  0.02,  0.00,  0.02,
     @  0.00,  0.10,  0.28,  0.20,  0.40,  0.68,  0.70,  0.78,
     @  0.48,  0.48,  0.38,  0.08,  0.01,  0.04,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,
     @  1.67,  1.89,  1.93,  1.77,  1.64,  1.48,  1.32,  1.12,
     @  1.10,  1.01,  1.02,  1.00,  1.20,  1.22,  1.26,  1.31,
     @  1.31,  1.36,  1.34,  1.32,  1.31,  1.28,  1.27,  1.23,
     @  1.21,  1.20,  1.19,  1.15/
      data emdsmn/ 1.708/
      sigdb=0.
      if(s.ge.tblhig) return
      if(pr.lt.0) call errex(' detbal, pr invalid')
      sigin0=0.
      pr2new=.25*s*s-emnuc**2
      if(icltyp.eq.4.or.icltyp.eq.5.or.
     a              icltyp.eq.7.or.icltyp.eq.8.or.
     b                    icltyp.eq.11.or.icltyp.eq.12.or.
     c                         icltyp.eq.16.or.icltyp.eq.17) then
           emd=max(em1,em2)
             if(icltyp.eq.4.or.icltyp.eq.17) then
               return
             else if(icltyp.eq.5) then
               weight=0.25*.75
             else if(icltyp.eq.7) then
               weight=0.25*.25
             else if((icltyp.eq.11).or.(icltyp.eq.8)) then
               weight=0.25*.5
             else if(icltyp.eq.16) then
               weight=0.25*.75
             else if(icltyp.eq.12) then
               weight=0.25*.25
             end if
             if(ida(4).gt.0.and.npid1.le.1.and.npid2.le.1) then
               call wqdnnn(s,pr,emd,wqout)
               sigdb=weight*wqout
               return
             else
               iofs=6
               assign 500 to label
               go to 1000
             end if
      end if
      if(icltyp.eq.10) then
             weight=.1
             iofs=10
      else if(icltyp.eq.15) then
             weight=.1
             iofs=10
      else if((icltyp.eq.46).or.(icltyp.eq.57)) then
             weight=.5
             iofs=8
      else if((icltyp.eq.47).or.(icltyp.eq.56)) then
             weight=.5
             iofs=9
      else if((icltyp.eq.49).or.(icltyp.eq.60)) then
            weight=1./ 16.
            iofs=12
      else if((icltyp.eq.50).or.(icltyp.eq.59)) then
            weight=0.125
            iofs=12
      else if((icltyp.eq.51).or.(icltyp.eq.58)) then
            weight=3./ 16.
            iofs=12
      else if((icltyp.eq.55).or.(icltyp.eq.66)) then
            weight=1.
            iofs=13
      else if(icltyp.eq.65) then
            weight=1.
            iofs=14
      else
         weight=0.
         if(icltyp.eq.13) then
            weight=3./40.
         else if(icltyp.eq.14) then
            weigh0=1./16.
            weigh1=0.0125
         else if(icltyp.eq.18) then
            weigh0=1./16.
            weigh1=9./80.
         else if(icltyp.eq.19) then
            weight=3./40.
         else
            sigdb=0.
            return
         end if
         if(weight.eq.0.) then
           iofs=11
           assign 970 to label
           goto 1000
  970      sigin0=weigh0*sintot
           weight=weigh1
         end if
         iofs=10
      end if
      assign 500 to label
      go to 1000
  500 sintot=weight*sintot
      emmax1=s-em2
      emmax2=s-em1
      index=index-iofst
      if(index.le.0.or.index.gt.itblsz) then
        write(lun8,*) 'detbal: s,pr=',s,pr,'icltyp=',icltyp
        write(lun8,*) 'ityp1,npid1,ityp2,npid2,em1,em2'
        write(lun8,*)  ityp1,npid1,ityp2,npid2,em1,em2
        write(lun8,*)  'index=',index
        write(lun8,*) 'index out of range in detbal'
        sigdb=0.0
        return
      end if
      if(iofs.eq.6) then
        bet=beta(index)
        pdn=min(cvalu1,exp(-bet*(s- emdsmn-emnuc)))
        if(ityp1.le.2) then
               if(npid2.eq.0.or.npid2.eq.1) then
               else
                  pdn=(1.-pdn)*probdl(emmax2,em2,npid2)
               end if
        else if(ityp2.le.2) then
               if(npid1.eq.0.or.npid1.eq.1) then
               else
                  pdn=(1.-pdn)*probdl(emmax1,em1,npid1)
               end if
        else
              call errex('missing nucleon in ndelta channel,detbal')
        end if
        sintot=pdn*sintot
      else if(iofs.eq.10.or.iofs.eq.11) then
           bet=beta(index)
           pdd=min(cvalu1,exp(-bet*(s- 2.*emdsmn)))
           if((npid1.eq.0.or.npid1.eq.1).and.
     a              (npid2.eq.0.or.npid2.eq.1)) then
           else if(npid1.ne.0.and.npid1.ne.1.and.
     a               npid2.ne.0.and.npid2.ne.1) then
               pdd=(1.-pdd)*probdl(emmax2,em2,npid2)*
     a                                        probdl(emmax1,em1,npid1)
           else
               pdd=0.
           end if
           sintot=pdd*sintot
           sigin0=pdd*sigin0
      else if(iofs.eq.8.or.iofs.eq.9) then
           if(ityp1.le.2) then
                  pnn=probn2(emmax2,em2,npid2)
           else if(ityp2.le.2) then
                  pnn=probn2(emmax1,em1,npid1)
           else
              call errex('missing nucleon in nn* channel,detbal')
           end if
           sintot=pnn*sintot
      else if(iofs.eq.13.or.iofs.eq.14) then
            pnn=probn2(emmax1,em1,npid1)*probn2(emmax2,em2,npid2)
            sintot=pnn*sintot
      else if(iofs.eq.12) then
        bet=beta(index)
        pdnp=min(cvalu1,exp(-bet*(s- emdsmn-emmnn2)))
           if(ityp1.ge.3.and.ityp1.le.6) then
                  if(npid1.eq.0.or.npid1.eq.1) then
                  else
                     pdnp=probdl(emmax1,em1,npid1)*(1.-pdnp)
                  end if
                  pdnp=probn2(emmax2,em2,npid2) *pdnp
           else if(ityp2.ge.3.and.ityp2.le.6) then
                  if(npid2.eq.0.or.npid2.eq.1) then
                  else
                     pdnp=probdl(emmax2,em2,npid2)*(1.-pdnp)
                  end if
                  pdnp=probn2(emmax1,em1,npid1) *pdnp
           else
              call errex('missing delta in dn* channel,detbal')
           end if
           sintot=pdnp*sintot
      end if
      sigdb=pr2new*(sigin0+sintot)/ (pr*pr)
      return
 1000 xpt=log(s)
      iofst=itblsz*iofs
      tlow=log(tbllow)
      index=int((xpt-tlow)/tblstp)+1
      if(index.le.0)then
        sintot=0.
        goto label
      else if(index.ge.itblsz) then
        sintot=sigcom(itblsz+iofst)
        goto label
      end if
      x1=(index-1)*tblstp + tlow
      index=index+iofst
      if(index.gt.indmax)
     a call errex('wrong index  in detbal' )
      y1in=sigcom(index)
      y2in=sigcom(index+1)
      slin=(y2in-y1in)/tblstp
      sintot=slin*(xpt-x1) + y1in
      goto label
      end
        subroutine wqdnch(icltyp,itp1,itp2,npd1,npd2,srt,pr,em1,em2,
     a                       sigeno,sigel1,sigel2,sigdd1,sigdd2,sigdb)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
        real*4 pjin
        dimension pjin(4)
        common /pjbk/ pjin
        data sold / -1./
        ioften=itblsz*3
        iofte1=itblsz*20
        iofte2=itblsz*21
        ioftdd=itblsz*23
        j1d=3
        j1dnew=3
        j2n=1
        j2dnew=3
        ibasd=9
        ibasn=3
        srtact=2.*sqrt(emnuc*emnuc+pr*pr)
        s=srtact
        sold=-1.0
        assign  10 to label
        ioftab=ioften
        go to 1000
   10   continue
        sigeno=sigin
        s=srt
        if(itp1.le.2) then
          m1=2*itp2-ibasd
          m2=2*itp1-ibasn
        else
          m1=2*itp1-ibasd
          m2=2*itp2-ibasn
        end if
        itag=-100
        call isocgk(m1,j1d,m2,j2n,j1dnew,j2dnew,m1new,m2new,itag)
        m=m1+m2
        if(s.le.emdelt+emnuc) then
          s=sqrt(emnuc**2+pr**2)+sqrt(emdelt**2+pr**2)
        end if
        sigel1=0.
        sigel2=0.
        assign  20 to label
        ioftab=iofte1
        go to 1000
   20   continue
        sigel1=sigin
        assign  30 to label
        ioftab=iofte2
        go to 1000
   30   continue
        sigel2=sigin
        assign  40 to label
        ioftab=22*itblsz
        go to 1000
   40   continue
        saver=sigin
        s=srt
        emmin=emnuc+empion
        emmxd=max(s-emnuc,emmin)
        vfd=1./pi*(atan(2.*(emmxd-emdelt)/widdlt)-
     a            atan(2.*(emmin-emdelt)/widdlt))
        sigeno=max(cvalu0,vfd*sigeno-vfd*saver)
        sigel1=max(cvalu0,sigel1-sigeno)
        sigel2=max(cvalu0,sigel2-sigeno)
        if(iabs(m).eq.4)then
          sigel1=0.
          sigel2=vfd*sigel2*pjin(1)
        else
          sigel1=vfd*sigel1*pjin(1)
          sigel2=vfd*sigel2*pjin(2)
        end if
        assign  50 to label
        ioftab=ioftdd
        go to 1000
   50   continue
        sigred=sigin
        if(da(12).gt.1.) sigred=da(12)*sigred
        s=srt
        if(iabs(m).eq.4)then
          sigdd1=0.
          sigdd2=sigred*0.8*pjin(1)
        else
          sigdd1=sigred*4./9.*pjin(1)
          sigdd2=sigred*0.8* pjin(2)
        end if
        call detbal(s,pr,icltyp,itp1,npd1,itp2,npd2,em1,em2,sigdb)
        return
 1000 continue
      if(s.ne.sold) then
        xpt=log(s)
        tlow=log(tbllow)
        if(xpt.lt.tlow) xpt=tlow
        index=int((xpt-tlow)/tblstp)+1
        if(index.ge.itblsz) then
          write(lun8,*)'warning:index.ge.itblsz in wqdnch index=',index
          write(lun8,*)'icltyp,srt',icltyp,s
          index=itblsz-1
        end if
        x1=(index-1)*tblstp+tlow
      end if
      sold=s
      indin=ioftab+index
      if(indin.lt.0) then
        write(lun8,*) indin,ioftab,index,s,xpt
        call errex('abort in wqdnch,1000')
      end if
      y1in=sigcom(indin)
      y2in=sigcom(indin+1)
      slin=(y2in-y1in)/tblstp
      sigin=slin*(xpt-x1) + y1in
      goto label
        end
      subroutine  wqdnnn(srt,prel,emdlt,wqout)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
      wqout=0.
      emmin=emnuc+empion
      emmax=2.
      if(srt.le.emdlt+emnuc.or.srt.gt.tblhig) then
         return
      else
         assign 800 to label
         goto 1000
      end if
  800 continue
      sigin=1./prel**2*(0.25*srt*srt-emnuc*emnuc)*sigin
      if(index.gt.7.and.index.le.60) then
        mbin=
     a   int(float(20)*(emdlt-emmin)/(min(emmax,srt-emnuc)-emmin))+1
        mbin=min(20,max(1,mbin))
        indeff=index-7
        xdown=max(cvalu0,min(cvalu1,1.-(xpt-x1)/tblstp))
        fcact=xdown*dnnnfc(indeff)+(1-xdown)*dnnnfc(min(53,indeff+1))
        sem=xdown*dsdm(indeff,mbin)+
     a                            (1-xdown)*dsdm(min(53,indeff+1),mbin)
        wqout=sigin*fcact*sem
      else
        wqout=sigin
      endif
      return
 1000 xpt=log(srt)
      tlow=log(tbllow)
      index=int((xpt-tlow)/tblstp)+1
      if(xpt.lt.tlow+7.*tblstp) then
        xpt=tlow+7.*tblstp
        index=8
      end if
      indin=index
      x1=(index-1)*tblstp+tlow
      y1in=wqnnnd(indin)
      y2in=wqnnnd(indin+1)
      slin=(y2in-y1in)/tblstp
      sigin=slin*(xpt-x1)+y1in
      goto label
      end
      function mbafnd(ibar,em)
       include 'scatter7'
#include "amsrqmd.h"
       common /xspibk/ xspin1,xspin3,wnorm1,wnorm3,pow12,pow32,
     a                xsbgl1,xsbgl3,xs1218,xs32pn,xs12pn
       real*4 gamres
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       common /gamrbk/ gamres
       dimension prob(11),gamact(11)
       dimension kflv(8)
       data kflv / 61,41,57,43,46,65,68,70/
        if(ibar.le.0.or.ibar.gt.8)
     a  call errex('mbafnd abort: wrong ibar input')
        iremx=mxbsta(ibar)
        emadd=0.0
        if(ibar.eq.1) then
          powr=pow32
          embas=2.0
        else if(ibar.eq.2) then
          embas=1.80
          powr=pow12
          iremx=10
        else
          embas=2.00
          if(ibar.le.4) then
            emadd=0.15
          else if(ibar.eq.5) then
            emadd=0.3
          else
            emadd=0.15*(ibar-5)
          end if
          embas=embas+emadd
          powr=5.0
        end if
        if(em.le.2.8+emadd) then
          zlim=(embas/em)**(powr-1.)
          if(ranf(0).lt.zlim) then
            probs=0.0
            do 20 i=1,iremx
             prob(i)=0.0
             jspb=jspbar(i,ibar)
             kf=kflv(ibar)
             gamb=widr(i,kf,em)
             if(gamb.le.cvalu0) go to 20
             prob(i)=(jspb+1.)*gamb/
     a          ((em-embarr(i,ibar))**2+0.25*gamb**2)
             probs=probs+prob(i)
   20       continue
            zrand=ranf(0)
            do 30 i=1,iremx
             jentry=i
             prob(i)=prob(i)/probs
             if(i.gt.1) prob(i)=prob(i-1)+prob(i)
             if(zrand.lt.prob(i)) go to 31
   30       continue
   31       continue
          else
            jentry=-3
          end if
        else
          jentry=-3
        end if
        mbafnd=jentry
      return
      end
      function mmefnd(imes,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 gamres
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       common /gamrbk/ gamres
       dimension prob(11),gamact(11)
       dimension kflv(8)
       data kflv / 17,24,25,18,27,34,35,28/
        if(imes.le.0.or.imes.gt.8)
     a  call errex('mmefnd abort: wrong imes input')
        iremx=mxmsta(imes)
        dem=0.0
        if(imes.eq.4.or.imes.eq.8) then
          ndem=1
        else if(imes.eq.3.or.imes.eq.7) then
          ndem=2
        else
          ndem=0
        end if
        dem=ndem*0.15
        if(em.le.1.6+dem) then
          probs=0.0
          do 20 i=1,iremx
           prob(i)=0.0
           jspm=jspmes(i,imes)
           if(jspm.lt.0) go to 20
           if(em.le.emmmin(imes)) go to 20
           kf=kflv(imes)
           gamm=widr(i,kf,em)
           if(gamm.le.cvalu0) go to 20
           prob(i)=(jspm+1.)*gamm/
     a          ((em-emmesr(i,imes))**2+0.25*gamm**2)
           probs=probs+prob(i)
   20     continue
          if(probs.eq.cvalu0) then
            mmefnd=9999
            return
          end if
          zrand=ranf(0)
          do 30 i=1,iremx
           jentry=i
           prob(i)=prob(i)/probs
           if(i.gt.1) prob(i)=prob(i-1)+prob(i)
           if(zrand.lt.prob(i)) go to 31
   30     continue
   31     continue
        else
          jentry=-1
        end if
        mmefnd=jentry
      return
      end
      function probdl(emmax,em1,npid1)
      include 'scatter7'
#include "amsrqmd.h"
      dimension emdl( 9)
      data emdl  /1.60, 1.62, 1.700, 1.90, 1.905, 1.910,
     a              1.92,1.93,1.95/
      if(npid1.ge.2.and.npid1.le.4) then
           probdl=0.
           return
      else
           npid=-npid1
           if(npid.gt.100) npid=mod(npid,100)
      end if
      bwsum=0.
      do 21 i=1,9
       gamr=0.1*emdl(i)
       gamsq=gamr**2
       bwterm=gamr/((em1-emdl(i))**2 + 0.25* gamsq)
       if(npid.eq.i) bwi=bwterm
       bwsum=bwsum+bwterm
   21 continue
      if(ida(4).gt.0) then
        enhanc=pi/(atan(2.*(emmax-emdl(npid))/gamr)+0.5*pi)
      else
        enhanc=1.
      end if
      probdl=bwi/bwsum*enhanc
      return
      end
      function probn2(emmax,em1,npid1)
      include 'scatter7'
#include "amsrqmd.h"
      dimension emn2(10)
      data emn2  /1.44, 1.52, 1.535, 1.65, 1.675, 1.680,
     a              1.7, 1.71, 1.72, 1.99/
      if(npid1.ge.0.and.npid1.le.4) then
         probn2=0.
         return
      else
         npid=-npid1
         if(npid.gt.100) npid=mod(npid,100)
      end if
      bwsum=0.
      do 26 i=1,10
       gamr=0.1*emn2(i)
       gamsq=gamr**2
       bwterm=gamr/((em1-emn2(i))**2 + 0.25* gamsq)
       if(npid.eq.i) bwi=bwterm
       bwsum=bwsum+bwterm
   26 continue
      if(ida(4).gt.0) then
        enhanc=pi/(atan(2.*(emmax-emn2(npid))/gamr)+0.5*pi)
      else
        enhanc=1.
      end if
      probn2=bwi/bwsum*enhanc
      return
      end
      function sigasy(iswelt,imeso1,istra1,imeso2,istra2)
        include 'scatter7'
#include "amsrqmd.h"
        imeso=imeso1+imeso2
        sig=40.*0.6666**imeso*
     a        (1.-0.4*istra1/(3.-imeso1))*(1.-0.4*istra2/(3.-imeso2))
        if(iswelt.eq.0) then
          sigasy=sig**1.5*(10./40.**1.5)
        else
          sigasy=sig
        end if
      return
      end
      function ianout(kl1,istra1,ifla1,iflb1,iflc1,
     a                              kl2,istra2,ifla2,iflb2)
#include "amsrqmd.h"
        ian=-1
        ivz3=isign(3,iflc1)
        if(istra2.eq.2) then
          if(istra1.gt.0) then
            ian=istra1
          else
            if(kl2.eq.24.or.kl2.eq.25) ian=0
          end if
        else if(istra2.eq.1) then
          if(istra1.eq.0) then
            if(ifla2.eq.ivz3.or.iflb2.eq.ivz3) then
              isum=isign(1,ivz3)*(ifla1+iflb1+iflc1+ifla2+iflb2)
              if(isum.ge.5.and.isum.le.7) ian=1
            end if
          else if(istra1.eq.1) then
            if(ifla2.eq.-ivz3.or.iflb2.eq.-ivz3) then
              ian=0
            else
              isum=ifla1+iflb1+iflc1+ifla2+iflb2-ivz3*2
              if(isum.eq.isign(1,ivz3).or.
     a           isum.eq.isign(2,ivz3)) ian=2
            end if
          else if(istra1.eq.2) then
            if(ifla2.eq.-ivz3.or.iflb2.eq.-ivz3) then
              ian=1
            else
              if(ifla1+iflb1+iflc1+ifla2+iflb2.eq.ivz3*3) ian=3
            end if
          else if(istra1.eq.3) then
            if(ifla2.eq.-ivz3.or.iflb2.eq.-ivz3) ian=2
          end if
        else if(istra2.eq.0) then
          if(istra1.eq.0) then
            isum=ifla1+iflb1+iflc1+ifla2+iflb2
            isum=iabs(isum)
            if(isum.gt.2.and.isum.lt.7) ian=0
          else if(istra1.eq.1) then
            isum=isign(1,ivz3)*(ifla1+iflb1+iflc1+ifla2+iflb2)
            if(isum.ge.5.and.isum.le.7) ian=1
          else if(istra1.eq.2) then
            isum=ifla1+iflb1+iflc1+ifla2+iflb2-ivz3*2
            if(isum.eq.isign(1,ivz3).or.
     a           isum.eq.isign(2,ivz3)) ian=2
          else if(istra1.eq.3) then
            isum=ifla1+iflb1+iflc1+ifla2+iflb2-ivz3*3
            if(isum.eq.0) then
              if(mod(iabs(kl2),10).ne.3) ian=3
            end if
          end if
        end if
       ianout=ian+1
      return
      end
CPAT,CROSS2   .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine cross2(srt,pr,em1,em2,npid1,npid2,icltyp,
     &               istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     &                  ityp1,ityp2,sig,sigel,sigin,icnum,nscop,nonstr)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
        real*4 empar(99,4),itpar(99,4),nppar(99,4)
        common/sigsum/vkp,vlam,vtot,vsgp,sgt,vk0,vksp,vknul,vkm,
     &                vk0kq,vkpkq,vk0km,vkpkm,empar,itpar,nppar
      dimension sigin(mxchan)
      real*4 cgks
      real*4 pjin(4)
      common /pjbk/ pjin
      data vernum/'version rqmd 1.09 -- 14-jul-93'/
      data pronam/'module: c r o s s 2'/
      data ttvers/.true./
      data j1d,j2d,j1dnew,j2n,j2dnew,ibasd,ibasn
     a       /3,  3,   3,    1,   3,    9,    3    /
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      tblsft=0.
      nscop=0
      if(icltyp.le.66) then
          s=sqrt(em1**2+pr*pr)+sqrt(em2**2+pr*pr)
      else
          s=srt
      end if
      nonstr=2
      ibn1=0
      ibn2=0
      if((icltyp.ge.4754).and.(icltyp.le.4950)) then
        if(imeso1.eq.1.and.imeso2.eq.1) then
        else
            go to 720
        end if
      else
        if(ityp1.le.15) then
           call  retcgk(ityp1,npid1,j1,m1,-1,cgks)
           if(ibry1.gt.0) ibn1=1
        else
            call errex('wrong ityp in cross2')
        end if
        if(ityp2.le.15) then
           call  retcgk(ityp2,npid2,j2,m2,-1,cgks)
           if(ibry2.gt.0) ibn2=1
        else
           call errex('wrong ityp in cross2')
        end if
      end if
      if (ibn1.eq.1.and.ibn2.eq.1) then
      goto (
     >  10, 20, 10, 50, 50,
     >   65, 50, 50,  65,65,
     >  50, 50, 65, 65, 65,
     >  50, 50, 65, 65,  65,
     >   65, 40,  40, 40, 40,
     >  40, 40, 40, 40, 40,
     >  40, 40, 40, 40, 40,
     >  40, 40, 40, 40, 40,
     >  40, 40, 40, 40, 40,
     > 110,110,110,110,110,
     > 110, 40, 40, 40,110,
     > 110,110,110,110,110,110,40 ,40 ,40 ,110 ,
     > 110, 40, 40, 40, 40, 40, 40, 40, 40, 40 ,
     >  40, 40, 40,150,150,150,150,150,150, 40 ,
     >  40, 40,150,150, 40,150, 40, 40, 40, 40 ,
     >  40, 40, 40, 40, 40, 40, 40, 40, 40, 40 ,
     > 150,150,150,150,150,150, 40, 40, 40,150 ,
     > 150, 40,150, 40,150
     & ) , icltyp
   40 continue
      write(lun8,*)' icltyp invalid in  cross2(bb)   ',icltyp,ibn1,ibn2
      call errex( 'fatal error')
      return
 10   continue
      if (s.lt.2.*emnuc+empion+ekinmi ) then
        icnum=1
        return
      end if
      if(s .ge. tblhig ) then
         sigin(1)=sig-sigel
         icnum=2
         return
      end if
      iofs=itblsz * 6
      assign 100 to label
      goto 1000
  100 sigin(1)=.25*sintot
      sigin(2)=.75*sintot
      if(s.lt.snnlim.and.ida(4).gt.0) then
         sigin(1)=enhcnd*sigin(1)
         sigin(2)=enhcnd*sigin(2)
      end if
      iofs=itblsz * 8
      assign 101 to label
      goto 1000
  101 sigin(3)= sintot
      iofs=itblsz * 10
      assign 102 to label
      goto 1000
  102 sigin(4)= 0.6 * sintot
      sigin(5)= 0.4 * sintot
      iofs=itblsz * 12
      assign 103 to label
      goto 1000
  103 sigin(6)= 0.25 * sintot
      sigin(7)= 0.75 * sintot
      iofs=itblsz * 13
      assign 104 to label
      goto 1000
  104 sigin(8)= sintot
      k=8
      nonstr=8
      icnum=k+1
      if(s.gt.snnlim.and.ida(26).gt.0) then
         return
      else
         goto 6000
      end if
 20   continue
      if (s.lt.2.*emnuc+empion+ekinmi ) then
        icnum=1
        return
      end if
      if(s .ge. tblhig ) then
         sigin(1)=sig-sigel
         icnum=2
         return
      end if
      iofs=itblsz * 6
      assign 200 to label
      goto 1000
  200 sigin(1)=.25*sintot
      sigin(2)=sigin(1)
      if(s.lt.snnlim.and.ida(4).gt.0) then
         sigin(1)=enhcnd*sigin(1)
         sigin(2)=enhcnd*sigin(2)
      end if
      iofs=itblsz * 9
      assign 201 to label
      goto 1000
  201 sigin(3)= 0.5 * sintot
      sigin(4)= sigin(3)
      iofs=itblsz * 10
      assign 202 to label
      goto 1000
  202 sigin(5)= 0.05* sintot
      sigin(6)= 0.45* sintot
      iofs=itblsz * 11
      assign 203 to label
      goto 1000
  203 sigin(5)= sigin(5) + 0.25 * sintot
      sigin(6)= sigin(6) + 0.25 * sintot
      iofs=itblsz * 12
      assign 204 to label
      goto 1000
  204 sigin(7)= 0.25 * sintot
      sigin(8)= sigin(7)
      iofs=itblsz * 14
      assign 205 to label
      goto 1000
  205 sigin(9)= sintot
      sigin(10)=0.
      sigin(11)=0.
      k=11
      nonstr=11
      icnum=k+1
      if(s.gt.snnlim.and.ida(26).gt.0) then
         return
      else
         goto 6000
      end if
   50 continue
      k=2
      if(s.lt.tblhig.and.iabs(npid1).le.1.and.iabs(npid2).le.2) then
        k=6
        call wqdnch(icltyp,ityp1,ityp2,npid1,npid2,s,pr,em1,em2,
     a                       sigeno,sigel1,sigel2,sigdd1,sigdd2,sigdb)
        sigin(1)=sigdb
        sigin(3)=sigel1
        sigin(4)=sigel2
        sigin(5)=sigdd1
        sigin(6)=sigdd2
        siginl=sigin(1)
        do 501 jch=1,4
  501   siginl=siginl+sigin(jch+2)
      else
        call detbal(s,pr,icltyp,ityp1,npid1,ityp2,npid2,em1,em2,sigdb)
        sigin(1)=sigdb
        siginl=sigin(1)
      end if
      if(siginl.gt.sig-sigel+1.) then
         write(lun8,*) 'cross2-warning: sum of channels> sigtot for d n'
         write(lun8,*) sigin(1),(sigin(ij),ij=3,6), sig, sigel,icltyp,s
      end if
      nonstr=k
      sigin(2)= max(cvalu0,sig-sigel-siginl)
      icnum=k+1
      if(s.gt.snnlim.and.ida(26).gt.0) then
         return
      else
         goto 6000
      end if
   65 continue
      k=2
      sigin(3)=0.
      sigin(4)=0.
      if(s.lt.tblhig)then
        call detbal(s,pr,icltyp,ityp1,npid1,ityp2,npid2, em1,em2,sigdb)
        sigin(1)= min(sig-sigel, sigdb)
        if(sigdb.gt.sig-sigel+1.) then
           write(lun8,*) 'delta + delta'
           write(lun8,*) 'warning from cross2: sigdb>sig-sigel'
           write(lun8,*) s,pr,icltyp,ityp1,npid1,ityp2,npid2
           write(lun8,*) em1,em2,sigdb,sig,sigel
        end if
        if(iabs(npid1).le.1.and.iabs(npid2).le.1) then
          k=4
          iofs=itblsz*23
          assign 301 to label
          goto 1000
  301     continue
          emmxd=s-max(em1,em2)
          vfd=pi/(atan(2.*(emmxd-emdelt)/widdlt)-
     a                 atan(2.*(emnuc+empion-emdelt)/widdlt))
          sintot=vfd*da(12)*sintot
          if(s.gt.emnuc+emdelt) then
            pout=pcmsr(s,emnuc,emdelt)
          else
            pout=0.
          end if
          m1= 2 * ityp1 - ibasd
          m2= 2 * ityp2 - ibasd
          itag=-100
          call isocgk(
     a               m1,j1d,m2,j2d,j1dnew,j2dnew,m1new,m2new,itag)
          m=m1+m2
          ino=0
          do 305 imt=iabs(m),6,2
           if(iabs(m)+2*ino.eq.2)then
             sigin(3)=0.5*pout**2/pr/pr*sintot*0.44444*pjin(ino+1)
             sigin(4)=0.5*pout**2/pr/pr*sintot*0.8*pjin(ino+2)
             go to 306
           else if(iabs(m)+2*ino.eq.4)then
             sigin(3)=0.
             sigin(4)=0.5*pout**2/pr/pr*sintot*0.8*pjin(ino+1)
             go to 306
           end if
           ino=ino+1
  305    continue
  306    continue
        end if
      else
        sigin(1)=0.
      end if
      sigin(2)=sig-sigel-sigin(1)-sigin(3)-sigin(4)
      if (sigin(2).lt.0.) then
       if (sigin(2).lt.-2.) then
         write(lun8,*)
     a       'warning from cross2: sum(inelastic channels) > siginel'
         write(lun8,*) icltyp,s,sigin(2),sig,sigel
       end if
       sigin(2)=0.
      end if
      nonstr=k
      icnum=k+1
      if(s.gt.snnlim.and.ida(26).gt.0) then
         return
      else
         goto 6000
      end if
  110 continue
      k=2
      if(s.lt.tblhig)then
        call detbal(s,pr,icltyp,ityp1,npid1,ityp2,npid2, em1,em2,sigdb)
        sigin(1)= min(sig-sigel, sigdb)
        if(sigdb.gt.sig-sigel+1.) then
           write(lun8,*) 'warning from cross2: sigdb>sig-sigel'
           write(lun8,*) s,pr,icltyp,ityp1,npid1,ityp2,npid2
           write(lun8,*) em1,em2,sigdb,sig,sigel
        end if
      else
          sigin(1)=0.
      end if
      sigin(2)=sig-sigel-sigin(1)
      if (sigin(2).lt.0.) then
       if (sigin(2).lt.-2.) then
         write(lun8,*)
     a       'warning from cross2: sum(inelastic channels) > siginel'
         write(lun8,*) icltyp,s,sigin,sig,sigel
       end if
       sigin(2)=0.
      end if
      nonstr=k
      icnum=k+1
      if(s.gt.snnlim.and.ida(26).gt.0) then
         return
      else
         goto 6000
      end if
  150 continue
      sigin(1)=0.
      sigin(2)=sig-sigel
      k=2
      nonstr=2
      icnum=k+1
      return
 6000 continue
      iflag=0
      ikinp=0
      nscop=k
         parstr=0.
         call getbb(s,sigin,k,ityp1,ityp2,npid1,npid2,em1,em2,
     &   itp1,itp2,itp3,npd1,npd2,npd3,emb,emy,emk,iflag,ikinp,
     &   parstr,arat)
      if(ida(26).gt.0.and.icltyp.gt.3) then
         do 6001 i=nonstr+1,k
          sigin(i)=0.
 6001    continue
      end if
         iflg=0
         call gpair(icltyp,ityp1,npid1,em1,ityp2,npid2,em2,
     &               itp1,npd1,e1,
     &               itp2,npd2,e2,
     &               itp3,npd3,e3,
     &               itp4,npd4,e4,
     &               ikinp,iflg,
     &               sigin,k,nscop,s,parstr,arat)
      if(icltyp.gt.3) then
          sumin=0.
          if (k.gt.nonstr) then
                     do 6002 i=nonstr+1,k
                     sumin=sumin+sigin(i)
 6002                continue
              if(sigin(2).lt.sumin) then
                 sigin(2)=0.
              else
                 sigin(2)=sigin(2)-sumin
              end if
          end if
      end if
      icnum=k+1
      return
      else if (ibn1.eq.0.and.ibn2.eq.0) then
      nscop=2
      sigin(1)=0.
      nonstr=2
      sigadd=sigasy(1,imeso1,istra1,imeso2,istra2)-
     a           sigasy(0,imeso1,istra1,imeso2,istra2)
      rlimit=min(cvalu1,1.6/s)
      sigin(2)=(1.-rlimit)*sigadd
      sigin(3)=sig-sigin(2)
      if(sigin(3).lt.0.0) then
        write(lun8,*) icltyp,ityp1,npid1,ityp2,npid2,s
        write(lun8,*) 'sigadd,rlimit,istra1,imeso1,istra2,imeso2'
        write(lun8,*) sigadd,rlimit,istra1,imeso1,istra2,imeso2
        write(lun8,*) 'sigel,sig,sigin(2),sigin(3)'
        write(lun8,*) sigel,sig,sigin(2),sigin(3)
        call errex('cross2:mm-sigin(3)<0')
      end if
      icnum=4
      return
      else if(ibn1.eq.1.or.ibn2.eq.1) then
   60 continue
      sigin(1)=0.
      sigin(2)=sig-sigel
      k=2
      nonstr=k
      if(icltyp.eq.67.or.icltyp.eq.68) then
        go to 601
      else if(icltyp.le.75) then
        go to 44
      else
          goto(
     >    601,601,41, 41, 41, 41, 41, 41, 41, 44,
     >     44, 44, 41, 41, 44, 41,622,622, 44, 44,
     >    44, 44, 41, 41, 41, 44, 44, 41,601, 41,
     >    41, 41, 41, 41, 41, 41, 44, 44, 44, 41,
     >    41, 44, 41, 44, 41
     &                     ) , icltyp-75
      end if
   41 continue
      write(lun8,*)' icltyp invalid in  cross2(mb) ',icltyp,ibn1,ibn2
      call errex( 'fatal error')
  601 continue
      ictest=0
      call  enlk(icltyp,ityp1,npid1,ityp2,npid2,
     a                          em1,em2,s,pr,ictest)
      if(ictest.ne.0) then
        k=k+1
        sigin(k)=10.0*(1.5/s)**2
      end if
      go to 44
  622 continue
      sigin(1)=0
      sigin(2)=sig-sigel
      k=2
      nonstr=k
      if(s.le.tbllow-0.46) s=1.44
      if((ityp1.eq.14.and.npid1.lt.0.and.ityp2.le.2)
     &     .or.(ityp2.eq.14.and.npid2.lt.0.and.ityp1.le.2)) then
      elseif((ityp1.eq.14.and.npid1.gt.0.and.ityp2.le.2)
     &          .or.(ityp2.eq.14.and.npid2.gt.0.and.ityp1.le.2)) then
           if(m1+m2.eq.0) then
             tblsft=0.46
             iofs=(kaofs+14)*itblsz
             assign 702 to label
             goto 1000
  702        continue
             sigin(k+1)=sintot
             k=k+1
           else
             tblsft=0.46
             iofs=(kaofs+16)*itblsz
             assign 703 to label
             goto 1000
  703        continue
             sigin(k+1)=sintot
             k=k+1
             iofs=(kaofs+17)*itblsz
             assign 704 to label
             goto 1000
  704        continue
             sigin(k+1)=sintot
             k=k+1
             iofs=(kaofs+18)*itblsz
             assign 705 to label
             goto 1000
  705        continue
             sigin(k+1)=sintot
             k=k+1
           end if
      else
           call errex('wrong  type in cross2')
      end if
   44 continue
      if ((k.gt.nonstr)) then
                     sinto=0.
                     do 53 i=nonstr+1,k
                     sinto=sinto+sigin(i)
   53                continue
                     if (sinto.gt.sigin(2)) then
                       do 623 i=nonstr+1,k
                       sigin(i)=sigin(i)*sigin(2)/sinto
  623                  continue
                       sigin(2)=0.
                     else
                       do 624 i=nonstr+1,k
                       sigin(2)=sigin(2)-sigin(i)
  624                  continue
                     end if
      end if
      icnum=k+1
      return
      end if
  720  continue
      sigin(1)=0.
      sigin(2)=sig-sigel
      nonstr=2
      icnum=3
      return
 1000 xpt=log(s+tblsft)
      tlow=log(tbllow)
      index=int((xpt-tlow)/tblstp)+1
      if(index.le.0)then
            sintot=0.
            goto label
      else if(index.ge.itblsz) then
            sintot=sigcom(itblsz+iofs)
            goto label
      end if
      x1=(index-1)*tblstp + tlow
      index=index+iofs
      if(index .gt.indmax)
     a call errex(' index too big in cross2' )
      y1in=sigcom(index)
      y2in=sigcom(index+1)
      slin=(y2in-y1in)/tblstp
      sintot=slin*(xpt-x1) + y1in
      goto label
      end
      subroutine
     a     enlk(icltyp,ityp1,npid1,ityp2,npid2,em1,em2,s,pr,ic)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
        real*4 cgks
       icstor=ic
       if(icltyp.eq.67.or.icltyp.eq.68) then
         iforw=1
         ibares=0
         if(ic.eq.0) ic=1
       else if(icltyp.eq.76.or.icltyp.eq.77) then
         iforw=1
         ibares=1
         if(ic.eq.0) ic=1
       else if(icltyp.eq.104) then
         iforw=2
         if((ityp1.eq.14.and.npid1.gt.0).or.
     a      (ityp2.eq.14.and.npid2.gt.0)) then
           if(ic.eq.0) ic=1
         end if
         if((ityp1.eq.13.and.em1.lt.1.2).or.
     a             (ityp2.eq.13.and.em2.lt.1.2)) then
           ibares=1
         else
           ibares=0
         end if
       else
         call errex('enlk:wrong icltyp')
       end if
       if(icstor.eq.0) return
       sigmax=10.0*(1.5/s)**2
       tblsft=0.46
       iofs=(kaofs+14)*itblsz
       xpt=log(s+tblsft)
       tlow=log(tbllow)
       index=int((xpt-tlow)/tblstp)+1
       if(index.ge.itblsz) then
         sintot=0.
       else if(s.gt.emlamb+emka0) then
         x1=(index-1)*tblstp + tlow
         index=index+iofs
         if(index.gt.indmax)
     a            call errex(' index too big in enlk')
         y1in=sigcom(index)
         y2in=sigcom(index+1)
         slin=(y2in-y1in)/tblstp
         sintot=slin*(xpt-x1) + y1in
       else
         sintot=0.
       end if
       call  retcgk(ityp1,npid1,j1,m1,-1,cgks)
       call  retcgk(ityp2,npid2,j2,m2,-1,cgks)
       m=m1+m2
       if(ityp1.eq.12.or.ityp1.eq.14) then
         isw=1
       else
         isw=0
       end if
       if(iforw.eq.1) then
         if(ibares.eq.1) then
           if(isw.eq.0) embar=em1+0.16
           if(isw.eq.1) embar=em2+0.16
           if(embar.lt.1.4) embar=emlamb
         else
           embar=emlamb
         end if
         if(m.eq.1) then
           emmes=emkap
         else
           emmes=emka0
         end if
       else
         if(ibares.eq.1) then
           if(isw.eq.0) embar=em1-0.16
           if(isw.eq.1) embar=em2-0.16
           if(embar.lt.1.3) then
             embar=emnuc
             ibares=0
           end if
         else
           embar=emnuc
         end if
         emmes=emeta
       end if
       if(s.gt.embar+emmes) then
         pout=pcmsr(s,embar,emmes)
       else
         pout=0.
       end if
       senlk=pout**2/pr**2*sintot
       if(senlk.gt.sigmax) then
         write(lun8,*) 'warning:  eta n(*) <==> lambda(*)+kaon'
         write(lun8,*) 'sigma>max',ityp1,npid1,ityp2,npid2,em1,em2,senlk
       end if
       if(ranf(0).lt.senlk/sigmax) then
          if(iforw.eq.1) then
            ityp1=13
            npid1=0
            if(ibares.eq.1.and.embar.ge.1.4) then
              ityp1=85
              npid1=57
            end if
            ityp2=14
            npid2=(m+3)/2
          else
            ityp1=(m+3)/2
            if(ibares.eq.0) then
              npid1=0
            else
              npid1=-mbafnd(2,em1)
            end if
            ityp2=12
            npid2=2
          end if
          em1=embar
          em2=emmes
          if(isw.eq.1) then
            call swap(em1,em2)
            call iswap(npid1,npid2)
            call iswap(ityp1,ityp2)
          end if
       else
          ic=0
       end if
      return
      end
      function piynkb(i1,m1,i2,m2,itot,jnum,srt,pin)
       include 'scatter7'
#include "amsrqmd.h"
       include 'sigmasx'
       data srtofs /0.46/
       real*4 cgks
       piynkb=0.0
       inum=jnum
       ivz=isign(1,inum)
       inum=iabs(inum)
       if(inum.le.0.or.inum.gt.4) then
         call errex('piynkb: inum out of range')
       end if
       if(inum.eq.1) then
         if(itot.ne.2) return
         if(i2.eq.2) return
       else if(inum.eq.2) then
         if(itot.ne.0) return
         if(i2.eq.0) return
       else if(inum.eq.3) then
         if(itot.ne.2) return
         if(i2.eq.0) return
       else if(inum.eq.4) then
         if(itot.ne.0) return
         if(i2.eq.0.or.i2.eq.2) return
       end if
       s=srt
       if(s.le.1.441) s=1.441
       cgk2=cgks(i1,i2,itot,m1,m2)
       if(inum.le.3) then
         iofs=itblsz*(kaofs+inum-1)
       else
         iofs=itblsz*(kaofs+15)
       end if
       xpt=log(s+srtofs)
       tlow=log(tbllow)
       maxtbl=itblsz
       index=int((xpt-tlow)/tblstp)+1
       if(index.ge.maxtbl)then
         sintot=0.
       else
         x1=(index-1)*tblstp+tlow
         index=index+iofs
         y1in=sigcom(index)
         y2in=sigcom(index+1)
         slin=(y2in-y1in)/tblstp
         sintot=slin*(xpt-x1)+y1in
       end if
       if(inum.eq.4) sintot=2.*sintot
       if(ivz.eq.1.and.inum.le.3) then
         if(inum.eq.1) then
           emy=emlamb
         else
           emy=emsig0
         end if
         pout=pcmsr(s,emy,empion)
         sintot=sintot*(pout/pin)**2
       end if
       piynkb=cgk2*sintot
      return
      end
CPAT,CROSS3   .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine getbb(srt,sigma,ktot,ityp1,ityp2,npid1,npid2,em1,em2,
     &                 itp1,itp2,itp3,npd1,npd2,npd3,emb,emy,emk,
     &                 iflag,ikinp,
     &                 vkkb,arat)
      include 'scatter7'
#include "amsrqmd.h"
      dimension itb(2)
      dimension ity(4)
      dimension itk(2)
      dimension sigma(99)
      real*4 cgks,cgks2
      real*4 empar(99,4),itpar(99,4),nppar(99,4)
      common/sigsum/vkp,vlam,vtot,vsgp,sgt,vk0,vksp,vknul,vkm,
     &           vk0kq,vkpkq,vk0km,vkpkm,empar,itpar,nppar
      data itb /1,3/
      data ity /0,2,0,2/
      data itk /1,1/
      vkkb=0
      call  retcgk(ityp1,npid1,it1,im1,-1,cgks2)
      call  retcgk(ityp2,npid2,it2,im2,-1,cgks2)
      do 50 i=ktot+1,99
      sigma(i)=0.
 50   continue
      vkp=0
      vk0=0
      vlam=0
      vtot=0
      vsgp=0
      vksp=0
      kcount=ktot
      do 100 ib=1,2
             it=itb(ib)
      do 100 iy=1,4
      do 100 imy=-ity(iy),ity(iy),2
      do 100 ik=1,2
      do 100 nu=-itk(ik),itk(ik),2
      val1=0
       if (iy.gt.2.and.ik.gt.1) goto 100
      ich=0
      icoin=0
 200  continue
       m=imy+nu
       mu=m-im2
       im=im1-mu
       if (iabs(im).gt.it.and.ich.eq.0) then
          icoin=1
          goto 300
       else
     & if (iabs(im).gt.it.and.ich.eq.1) then
          if (icoin.eq.1) then
               goto 100
          else
               goto 300
          end if
       else
     & if (ich.eq.1.and.icoin.eq.1) then
          kcount=kcount+1
       end if
       if (iabs(mu).gt.2.and.ich.eq.0) then
          icoin=1
          goto 300
       else
     & if (iabs(mu).gt.it.and.ich.eq.1) then
          if (icoin.eq.1) then
               goto 100
          else
               goto 300
          end if
       else
     & if (ich.eq.1.and.icoin.eq.1) then
          kcount=kcount+1
       end if
       call getifo(1,ib,it,im,itp1,npd1,emb)
       call getifo(2,iy,ity(iy),imy,itp2,npd2,emy)
       call getifo(3,ik,itk(ik),nu,itp3,npd3,emk)
      if (iflag.eq.1) then
          if(ich.eq.0.and.ikinp.eq.kcount+1) then
          empar(ikinp,1)=emb
          empar(ikinp,2)=emy
          empar(ikinp,3)=emk
          empar(ikinp,4)=0
          itpar(ikinp,1)=itp1
          itpar(ikinp,2)=itp2
          itpar(ikinp,3)=itp3
          itpar(ikinp,4)=0
          nppar(ikinp,1)=npd1
          nppar(ikinp,2)=npd2
          nppar(ikinp,3)=npd3
          nppar(ikinp,4)=0
               return
          else
     &    if(ich.eq.1.and.ikinp.eq.kcount) then
          empar(ikinp,1)=emb
          empar(ikinp,2)=emy
          empar(ikinp,3)=emk
          empar(ikinp,4)=0
          itpar(ikinp,1)=itp1
          itpar(ikinp,2)=itp2
          itpar(ikinp,3)=itp3
          itpar(ikinp,4)=0
          nppar(ikinp,1)=npd1
          nppar(ikinp,2)=npd2
          nppar(ikinp,3)=npd3
          nppar(ikinp,4)=0
          return
          end if
      else
      end if
       if (srt.lt.emb+emy+emk) then
               kcount=kcount+1
               goto 100
       else
              call getpar(srt,p1,p2,p3,psf,vkkb,arat,iy,ik,emb,emy,emk)
       end if
           arat=arat*1.3
           vkkb=vkkb/1.3
       vals=cgks(it,2,it1,im,mu)
       valy=0.
       do 510 i=1,3,2
        if (ity(iy).eq.0) then
           if (i.eq.1) then
                 g=p1
           else
                 g=0.
           end if
        else if(ity(iy).eq.2) then
           if (i.eq.1) then
                g=p2
           else if(i.eq.3) then
                g=p3
           else
                call errex( 'wrong i in getbb')
           end if
        else
           call errex( 'wrong ity in getbb')
        end if
      valy=valy+cgks(it2,2,i,im2,mu)*cgks(ity(iy),itk(ik),i,imy,nu)*g
 
 510  continue
      vals=vals*valy
      if (iy.le.2.and.ik.eq.1) then
        vals=vals*psf
      end if
      if (srt-emb-emk-emy.lt.0.25) then
        if ((iy.gt.2.or.ik.gt.1).and.ib.gt.1)
     @    vals=vals*(srt-emb-emy-emk)*4
      end if
      if (ich.eq.0)
     &             kcount=kcount+1
      sigma(kcount)=sigma(kcount)+vals
      val1=sigma(kcount)
 300  continue
      if (ich.eq.1) then
           sigma(kcount)=sigma(kcount)/2
           val1=val1/2
      end if
      if ((im1.ne.im2.or.it1.ne.it2).and.ich.eq.0) then
            ich=1
            mm=im1
            tt=it1
            im1=im2
            it1=it2
            im2=mm
            it2=tt
            goto 200
      else
     &if (ich.eq.1) then
            mm=im1
            tt=it1
            im1=im2
            it1=it2
            im2=mm
            it2=tt
      end if
          if (ik.eq.2) then
                  mu=nu-1
                  c1=cgks(1,2,1,1,mu)
                  mu=nu+1
                  c2=cgks(1,2,1,-1,mu)
                  vkp=vkp+val1*c1/(c1+c2)
                  vk0=vk0+val1*c2/(c1+c2)
                  vknul=vknul+val1*c2/(c1+c2)
                  if (nu.eq.1) vksp=vksp+val1
          else
                  if (nu.eq.1) then
                  vkp=vkp+val1
                  else
                  vk0=vk0+val1
                  vknul=vknul+val1
                  end if
          end if
          if (iy.gt.2) then
                if (ity(iy).eq.0) then
                  mu=imy-0
                  c1=cgks(2,2,0,0,mu)
                  mu=imy-2
                  c2=cgks(2,2,0,2,mu)
                  mu=imy+2
                  c3=cgks(2,2,0,-2,mu)
                  vlam=vlam+val1*c1/(c1+c2+c3)
                  vsgp=vsgp+val1*c2/(c1+c2+c3)
                else
                  fac=0.9
                  vlam=vlam+val1*fac
                  mu=imy-0
                  c1=cgks(2,2,ity(iy),0,mu)
                  mu=imy-2
                  c2=cgks(2,2,ity(iy),2,mu)
                  mu=imy+2
                  c3=cgks(2,2,ity(iy),-2,mu)
                  vlam=vlam+val1*(1-fac)*c1/(c1+c2+c3)
                  vsgp=vsgp+val1*(1-fac)*c2/(c1+c2+c3)
                end if
          else
               if (ity(iy).eq.0) then
                  vlam=vlam+val1
               else
                   if (imy.eq.0) then
                       vlam=vlam+val1
                   else
     &             if (imy.eq.2) then
                       vsgp=vsgp+val1
                   end if
               end if
          end if
          vtot=vtot+val1
 100  continue
       ktot=kcount
      return
      end
      subroutine getpar(srt,p1,p2,p3,psf,vkkq,arat,iy,ik,em1,em2,em3)
      include 'scatter7'
#include "amsrqmd.h"
      common/fpars/ vpar1,vpar2,vpar3,vpar4,vpar5,vpar6,vpar7,
     &              vpar8,vpar9,vpkkb,vprat,vpmax
      dimension pararr(1200)
       data (pararr(i),i=1,100) /
     @ 0.0000,0.0010,0.0020,0.0030,0.0040,0.0065,0.0099,0.0133,
     @ 0.0167,0.0201,0.0250,0.0298,0.0346,0.0395,0.0445,0.0510,
     @ 0.0575,0.0639,0.0704,0.0770,0.0836,0.0901,0.0941,0.0973,
     @ 0.1005,0.1037,0.1069,0.1101,0.1128,0.1152,0.1175,0.1198,
     @ 0.1222,0.1245,0.1268,0.1292,0.1312,0.1330,0.1348,0.1366,
     @ 0.1384,0.1402,0.1420,0.1439,0.1457,0.1477,0.1500,0.1522,
     @ 0.1545,0.1567,0.1590,0.1613,0.1635,0.1658,0.1681,0.1703,
     @ 0.1726,0.1743,0.1756,0.1768,0.1781,0.1794,0.1807,0.1820,
     @ 0.1832,0.1845,0.1858,0.1881,0.1907,0.1934,0.1961,0.1988,
     @ 0.2015,0.2042,0.2068,0.2095,0.2122,0.2149,0.2176,0.2202,
     @ 0.2229,0.2258,0.2293,0.2328,0.2364,0.2399,0.2434,0.2469,
     @ 0.2504,0.2539,0.2574,0.2610,0.2645,0.2679,0.2713,0.2747,
     @ 0.2780,0.2814,0.2848,0.2882
     @/
       data (pararr(i),i=101,200) /
     @ 0.3882,0.3882,0.4165,0.4448,0.4730,0.5013,0.5305,0.5635,
     @ 0.5966,0.6297,0.6628,0.6958,0.7289,0.7620,0.7951,0.8247,
     @ 0.8527,0.8808,0.9089,0.9370,0.9651,0.9932,1.0212,1.0450,
     @ 1.0664,1.0878,1.1092,1.1306,1.1520,1.1735,1.1949,1.2163,
     @ 1.2377,1.2591,1.2805,1.3020,1.3237,1.3460,1.3682,1.3905,
     @ 1.4127,1.4350,1.4572,1.4795,1.5017,1.5240,1.5462,1.5697,
     @ 1.5936,1.6176,1.6416,1.6655,1.6895,1.7134,1.7374,1.7614,
     @ 1.7853,1.8093,1.8346,1.8638,1.8929,1.9221,1.9513,1.9804,
     @ 2.0096,2.0388,2.0679,2.0971,2.1262,2.1574,2.1918,2.2261,
     @ 2.2604,2.2947,2.3291,2.3634,2.3977,2.4320,2.4664,2.5007,
     @ 2.5350,2.5754,2.6171,2.6588,2.7004,2.7421,2.7838,2.8255,
     @ 2.8671,2.9088,2.9506,2.9926,3.0346,3.0765,3.1185,3.1605,
     @ 3.2025,3.2445,3.2864,3.3284
     @/
       data (pararr(i),i=201,300) /
     @ 0.1388,0.1463,0.1538,0.1612,0.1687,0.1762,0.1837,0.1911,
     @ 0.1986,0.2069,0.2151,0.2234,0.2317,0.2400,0.2483,0.2566,
     @ 0.2649,0.2732,0.2812,0.2892,0.2971,0.3050,0.3130,0.3209,
     @ 0.3288,0.3368,0.3447,0.3526,0.3606,0.3685,0.3794,0.3929,
     @ 0.4065,0.4201,0.4336,0.4472,0.4608,0.4743,0.4879,0.5015,
     @ 0.5150,0.5284,0.5385,0.5486,0.5587,0.5687,0.5788,0.5889,
     @ 0.5990,0.6090,0.6191,0.6292,0.6392,0.6579,0.6783,0.6988,
     @ 0.7192,0.7397,0.7625,0.7898,0.8172,0.8445,0.8719,0.8992,
     @ 0.9265,0.9539,0.9888,1.0263,1.0639,1.1015,1.1390,1.1766,
     @ 1.2142,1.2517,1.2951,1.3391,1.3830,1.4270,1.4709,1.5149,
     @ 1.5588,1.5930,1.6211,1.6491,1.6771,1.7051,1.7331,1.7611,
     @ 1.7798,1.7964,1.8131,1.8297,1.8464,1.8630,1.8797,1.8963,
     @ 1.9107,1.9228,1.9348,1.9468
     @/
      dimension g3(100)
       data (pararr(i),i=301,400) /
     @ 1.0130,1.0129,1.0128,1.0128,1.0127,1.0126,1.0125,1.0125,
     @ 1.0124,1.0123,1.0122,1.0122,1.0121,1.0120,1.0119,1.0119,
     @ 1.0118,1.0117,1.0116,1.0116,1.0115,1.0114,1.0113,1.0113,
     @ 1.0112,1.0111,1.0110,1.0110,1.0109,1.0108,1.0107,1.0107,
     @ 1.0106,1.0105,1.0104,1.0104,1.0103,1.0102,1.0101,1.0101,
     @ 1.0100,1.0109,1.0118,1.0127,1.0135,1.0144,1.0153,1.0161,
     @ 1.0170,1.0179,1.0188,1.0196,1.0242,1.0317,1.0391,1.0466,
     @ 1.0540,1.0615,1.0690,1.0764,1.0870,1.0994,1.1117,1.1240,
     @ 1.1364,1.1487,1.1610,1.1733,1.1864,1.2022,1.2180,1.2337,
     @ 1.2495,1.2653,1.2811,1.2968,1.3166,1.3391,1.3615,1.3839,
     @ 1.4063,1.4287,1.4511,1.4736,1.4964,1.5293,1.5621,1.5950,
     @ 1.6279,1.6607,1.6936,1.7264,1.7593,1.7947,1.8325,1.8703,
     @ 1.9080,1.9458,1.9836,2.0214
     @/
      data (pararr(i),i=401,500) /
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0011,0.0028,0.0097,0.0178,
     @ 0.0259,0.0340,0.0420,0.0501,0.0582,0.0663,0.0744,0.0826,
     @ 0.0908,0.0991,0.1073,0.1155,0.1237,0.1319,0.1465,0.1614,
     @ 0.1764,0.1913,0.2062,0.2211,0.2428,0.2654,0.2880,0.3107,
     @ 0.3329,0.3446,0.3564,0.3681,0.3806,0.3965,0.4125,0.4284,
     @ 0.4444,0.4603,0.4763,0.4922,0.5082,0.5241,0.5401,0.5560,
     @ 0.5720,0.5880,0.6027,0.6147,0.6267,0.6387,0.6507,0.6628,
     @ 0.6748,0.6868,0.6988,0.7108,0.7228,0.7348,0.7468,0.7562,
     @ 0.7641,0.7721,0.7800,0.7879,0.7959,0.8038,0.8117,0.8197,
     @ 0.8276,0.8357,0.8446,0.8535,0.8624,0.8713,0.8802,0.8891,
     @ 0.8981,0.9070,0.9159,0.9238,0.9304,0.9371,0.9437,0.9503,
     @ 0.9570,0.9636,0.9702,0.9769
     @/
      data (pararr(i),i=501,600) /100*0.0/
      data (pararr(i),i=601,700) /
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0006,0.0026,0.0045,0.0065,0.0115,
     @ 0.0169,0.0223,0.0278,0.0333,0.0387,0.0420,0.0453,0.0486,
     @ 0.0519,0.0552,0.0584,0.0615,0.0647,0.0678,0.0710,0.0737,
     @ 0.0761,0.0785,0.0808,0.0832,0.0856,0.0880,0.0903,0.0922,
     @ 0.0941,0.0960,0.0979,0.0998,0.1017,0.1035,0.1047,0.1059,
     @ 0.1072,0.1084,0.1096,0.1109,0.1120,0.1132,0.1143,0.1155,
     @ 0.1166,0.1178,0.1189,0.1193
     @/
       data (pararr(i),i=701,800) /100*0.0/
       data (pararr(i),i=801,900) /100*0.0/
       data (pararr(i),i=901,1000) /100*0.0/
       data (pararr(i),i=1001,1100) /
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0021,0.0055,0.0089,0.0294,
     @ 0.0730,0.1308,0.1938,0.2499,0.2952,0.3405,0.3857,0.4204,
     @ 0.4472,0.4741,0.5009,0.5278,0.5546,0.5814,0.6061,0.6265,
     @ 0.6469,0.6674,0.6878,0.7063,0.7228,0.7394,0.7560,0.7725,
     @ 0.7891,0.8056,0.8212,0.8328,0.8444,0.8559,0.8675,0.8791,
     @ 0.8906,0.9022,0.9138,0.9247,0.9349,0.9451,0.9552,0.9654,
     @ 0.9756,0.9858,0.9959,1.0061,1.0165,1.0273,1.0380,1.0488,
     @ 1.0595,1.0702,1.0810,1.0917,1.1024,1.1132,1.1261,1.1392,
     @ 1.1523,1.1654,1.1785,1.1916,1.2047,1.2179,1.2310,1.2408,
     @ 1.2491,1.2574,1.2658,1.2741
     @/
       data (pararr(i),i=1101,1200) /
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     @ 0.0000,0.0000,0.0000,0.0000,0.0000,0.0034,0.0108,0.0182,
     @ 0.0333,0.0484,0.0635,0.0838,0.1139,0.1440,0.1740,0.2041,
     @ 0.2342,0.2595,0.2813,0.3031,0.3249,0.3467,0.3728,0.3989,
     @ 0.4249,0.4504,0.4747,0.4990,0.5233,0.5476,0.5719,0.5963,
     @ 0.6156,0.6341,0.6526,0.6710,0.6895,0.7080,0.7260,0.7386,
     @ 0.7512,0.7638,0.7765,0.7891,0.8017,0.8143,0.8270,0.8396,
     @ 0.8463,0.8515,0.8568,0.8621,0.8673,0.8726,0.8794,0.8867,
     @ 0.8941,0.9014,0.9088,0.9161
     @/
      data ds/0.026/,smin/2.555/
      data dp/0.023/,pmin/0.001/
      fpms(x)=
     & sqrt((x**2-(em1+em2+em3)**2)*(x**2-(em1+em2-em3)**2))/2/x
      if (ik.eq.1.and.iy.le.2) then
                 iofset=100
      else
     &if (ik.eq.2.and.iy.le.2) then
                 iofset=400
      else
     &if (ik.eq.1.and.iy.gt.2) then
                 iofset=700
      else
           p1=0
           p2=0
           p3=0
           psf=0
           return
      end if
      if (srt.lt.em1+em2+em3) then
        call errex( 'wrong srt in getpar')
      else
        pmax=fpms(srt)
      end if
       if(iofset.lt.400) then
          vmax=pmax
          vmin=pmin
          dv=dp
       else
          vmax=srt
          vmin=smin
          dv=ds
       end if
       index=int((vmax-vmin)/dv+1)
       if (index.lt.1.or.index.gt.100) then
              p1=0
              p2=0
              p3=0
              psf=0
              vkkq=0
              return
       else if (index.eq.100) then
              p1=pararr(iofset+100)
              p2=pararr(iofset+200)
              p3=pararr(iofset+300)
              psf=pararr(100)
              vkkq=pararr(1100)
              return
       end if
      if (iofset.lt.400) then
         psf=(vmax-vmin-(index-1)*dv)*(pararr(index+1)-pararr(index))/dv
         psf=psf+pararr(index)
      else
         psf=0
      end if
      p1=(vmax-vmin-(index-1)*dv)*
     &            (pararr(iofset+index+1)-pararr(iofset+index))/dv
      p1=p1+pararr(iofset+index)
      p2=(vmax-vmin-(index-1)*dv)*
     &        (pararr(iofset+100+index+1)-pararr(iofset+100+index))/dv
      p2=p2+pararr(iofset+100+index)
      p3=(vmax-vmin-(index-1)*dv)*
     &        (pararr(iofset+200+index+1)-pararr(iofset+200+index))/dv
      p3=p3+pararr(iofset+200+index)
         index=int((vmax-vmin)/dv+1)
      vkkq=(vmax-vmin-(index-1)*dv)*
     &        (pararr(1000+index+1)-pararr(1000+index))/dv
      vkkq=vkkq+pararr(1000+index)
         index=int((vmax-vmin)/dv+1)
      arat=(vmax-vmin-(index-1)*dv)*
     &        (pararr(1100+index+1)-pararr(1100+index))/dv
      arat=arat+pararr(1100+index)
      if (ik.eq.1.and.iy.le.2..and.em1+em2+em3.lt.2.56) then
                 vpmax=pmax
                 vpar1=p1*psf
                 vpar2=p2*psf
                 vpar3=p3*psf
                 vprat=arat
                 vpkkb=vkkq
      else
     &if (ik.eq.2.and.iy.le.2) then
                 vpar4=p1
                 vpar5=p2
                 vpar6=p3
      else
     &if (ik.eq.1.and.iy.gt.2) then
                 vpar7=p1
                 vpar8=p2
                 vpar9=p3
      end if
      return
      end
      subroutine getifo(ikat,i,it,im,itp,npd,em)
      include 'scatter7'
#include "amsrqmd.h"
      if (ikat.eq.1) then
            if (i.eq.1) then
              npd=0
              em=emnuc
              itp=(im+3)/2
              if (itp.lt.1.or.itp.gt.2) then
                 call errex('wrong im in getifo:ikat,i,it,im')
              end if
              return
            else
     &      if (i.eq.2) then
              npd=1
              em=emdelt
              itp=(im+9)/2
              if(itp.lt.3.or.itp.gt.6) then
                 call errex('wrong im in getifo:ikat,i,it,im')
              end if
            else
              call errex(
     a              'wrong i in getifo:ikat,i,it,im')
            end if
              return
      else
     &if (ikat.eq.2) then
            if (i.eq.1) then
              npd=0
              em=emlamb
              itp=13
              return
            else
     &      if (i.eq.2) then
              itp=15
              npd=im/2
              if (im.eq.-2) em=emsigm
              if (im.eq. 0) em=emsig0
              if (im.eq. 2) em=emsigp
              if (im.lt.-2.or.im.gt.2.or.mod(im,2).ne.0) then
              call errex(
     a               'wrong im in getifo:ikat,i,it,im')
              end if
              return
            else
     &      if (i.eq.3) then
              npd=1
              em=1.405
              itp=13
              return
            else
     &      if (i.eq.4) then
              itp=99
              npd=(132-im)/2
              if (im.eq.-2) em=1.389
              if (im.eq. 0) em=1.384
              if (im.eq. 2) em=1.383
              if (im.lt.-2.or.im.gt.2.or.mod(im,2).ne.0) then
                call errex('wrong im in getifo')
              end if
              return
            else
              call errex(
     a                'wrong i in getifo:ikat,i,it,im')
            end if
      else
     &if (ikat.eq.3) then
            if (i.eq.1) then
              itp=14
              npd=(im+3)/2
              if (im.eq.-1) em=0.498
              if (im.eq. 1) em=0.494
              if (npd.lt.1.or.npd.gt.2) then
                call errex(
     a               'wrong im in getifo:ikat,i,it,im')
              end if
              return
            else
     &      if (i.eq.2) then
              itp=99
              npd=(57-im)/2
              em=0.892
              if (npd.lt.28.or.npd.gt.29) then
                call errex(
     a               'wrong im in getifo:ikat,i,it,im')
              end if
              return
            else
                call errex(
     a               'wrong i in getifo:ikat,i,it,im')
            end if
      else
     &if (ikat.eq.4) then
            if(i.eq.1) then
              itp=14
              npd=(im-3)/2
              if (npd.eq.-1) then
                 em=0.498
                 return
              else
     &        if (npd.eq.-2) then
                 em=0.494
                 return
              else
                call errex(
     a          'wrong im in ikat4, getifo,im=')
              end if
            else
              call errex(
     a            'wrong i in ikat4, getifo,i=')
            end if
      else
            call errex(
     a         'wrong ikat in getifo')
      end if
      end
      subroutine gpair(icltyp,ityp1,npid1,em1,ityp2,npid2,em2,
     &               itp1,npd1,e1,
     &               itp2,npd2,e2,
     &               itp3,npd3,e3,
     &               itp4,npd4,e4,
     &               ikinp,iflg,
     &               sigin,k,nscop,srt,par,arat)
      include 'scatter7'
#include "amsrqmd.h"
      include 'sigmasx'
      dimension sigin(mxchan)
      real*4 cgks,cgks2
      real*4  empar(99,4),itpar(99,4),nppar(99,4)
        common/sigsum/vkp,vlam,vtot,vsgp,sgt,vk0,vksp,vknul,vkm,
     &                vk0kq,vkpkq,vk0km,vkpkm,empar,itpar,nppar
      call  retcgk(ityp1,npid1,it1,im1,-1,cgks2)
      call  retcgk(ityp2,npid2,it2,im2,-1,cgks2)
      ic=k
      nscop=k
      do 10 i=nscop+1,mxchan
      sigin(i)=0
  10  continue
      sgt=0
      ich=0
      do 100 imn1=-1,1,2
      do 100 imk=-1,1,2
300   continue
      imy=im1-imk
      if (iabs(imy).gt.2) goto 210
      itn1=1
      imkq=imy-imn1
      if (iabs(imkq).gt.1) goto 210
      itk=1
      itkq=1
      ic=ic+1
      if(ich.eq.0) then
           itp2=ityp2
           npd2=npid2
           e2=em2
           call getifo(1,1,itn1,imn1,itp1,npd1,e1)
      else
           itp2=ityp1
           npd2=npid1
           e2=em1
           call getifo(1,1,itn1,imn1,itp1,npd1,e1)
      end if
      call getifo(3,1,itk,imk,itp3,npd3,e3)
      call getifo(4,1,itkq,imkq,itp4,npd4,e4)
      if (ikinp.eq.ic.and.iflg.eq.1) then
         return
      end if
      sigin(ic)=0.
      if (e1+e2+e3+e4.gt.srt) goto 210
      do 200 ity=0,2,2
      if (iabs(imy).gt.ity) goto 200
      if(ity.eq.0) then
          a=arat*.35
      else
          a=0.25
      end if
      sigin(ic)=sigin(ic)+par*a*cgks(ity,itk,it1,imy,imk)
     &                         *cgks(itn1,itkq,ity,imn1,imkq)
 200  continue
      if(ityp1.ne.ityp2.or.npid1.ne.npid2) sigin(ic)=sigin(ic)/2.
      sgt=sgt+sigin(ic)
      val1=sigin(ic)
                  if (imk.eq.1) then
                     vkp=vkp+val1
                     if (imkq.eq.1) vkpkq=vkpkq+val1
                     if (imkq.eq.-1) vkpkm=vkpkm+val1
                  else
                     vk0=vk0+val1
                     vknul=vknul+val1
                     if (imkq.eq.1) vk0kq=vk0kq+val1
                     if (imkq.eq.-1) vk0km=vk0km+val1
                  end if
                  if (imkq.eq.1) then
                     vk0=vk0+val1
                  else
                     vkm=vkm+val1
                  end if
 210  continue
      if((ityp1.ne.ityp2.or.npid1.ne.npid2).and.ich.eq.0)then
           it=it1
           im=im1
           it1=it2
           im1=im2
           it2=it
           im2=im
           ich=1
           goto 300
      else
     &if((ityp1.ne.ityp2.or.npid1.ne.npid2).and.ich.eq.1)then
           it=it1
           im=im1
           it1=it2
           im1=im2
           it2=it
           im2=im
           ich=0
      end if
 100  continue
      if (iflg.eq.1) then
          call errex(
     a             'wrong ikinp in gpair')
      end if
      nscop=k
      k=ic
      return
      end
CPAT,CUPDAT   .
      subroutine cupdat(i1,i2)
        include 'scatter7'
        include 'partblk7'
#include "amsrqmd.h"
      logical hit
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version   rqmd 2.2  -- 28-oct-95'/
      data pronam/'c u p d a t  -- collision update'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      idelte = 0
      do 100 jjj=1,nument
        if((i1c(jjj).eq.i1).or.(i2c(jjj).eq.i1).or.
     *      (i1c(jjj).eq.i2).or.(i2c(jjj).eq.i2).or.
     *                        (i1c(jjj).le.0)) then
           idelte=idelte+1
          if(i1c(jjj).le.0) then
          else if(i1c(jjj).eq.i2.or.i2c(jjj).eq.i2) then
            idud(1,issn(i2))=idud(1,issn(i2))-1
            if(i1c(jjj).eq.i2) then
              idud(1,issn(i2c(jjj)))=idud(1,issn(i2c(jjj)))-1
            else
              idud(1,issn(i1c(jjj)))=idud(1,issn(i1c(jjj)))-1
            end if
          else
            idud(1,issn(i1))=idud(1,issn(i1))-1
            if(i1c(jjj).eq.i1) then
              idud(1,issn(i2c(jjj)))=idud(1,issn(i2c(jjj)))-1
            else
              idud(1,issn(i1c(jjj)))=idud(1,issn(i1c(jjj)))-1
            end if
          end if
          go to 100
      end if
      jj=jjj-idelte
      if(idelte.gt.0) then
        i1c(jj)=i1c(jjj)
        i2c(jj)=i2c(jjj)
        ctime(jj)=ctime(jjj)
        csig(jj)=csig(jjj)
      end if
  100 continue
      nument=nument-idelte
      if(ifndnx.eq.1) then
         return
      end if
      if(ida(34).eq.2)  return
      iorig=0
      if(.not.switch(23).and.ida(57).eq.1) iorig=1
      if(i1.gt.0) then
        if(ida(11).eq.1.and.i1.gt.iofset+ntclst) go to 30
        do 22 i3e=1,ntclst
          i3=i3e+iofset
          if(i3.eq.i1) go to 22
          if (hit(iorig,i1,i3,srt,sig,sigel,thit)) then
            nument=nument+1
            if(nument.gt.numema)
     *        call errex( 'cupdat, collision storage exceeded')
            i1c(nument)=i1
            i2c(nument)=i3
            ctime(nument)=thit
            csig(nument)=sig
            idud(1,issn(i1))=idud(1,issn(i1))+1
            idud(1,issn(i3))=idud(1,issn(i3))+1
          end if
   22   continue
      end if
   30 continue
      if(i2.gt.0) then
        if(ida(11).eq.1.and.i2.gt.iofset+ntclst) return
        do 33 i3e=1,ntclst
          i3=i3e+iofset
          if(i3.eq.i2) go to 33
          if(i3.eq.i1) go to 33
          if (hit(iorig,i2,i3,srt,sig,sigel,thit)) then
            nument=nument+1
            if (nument .gt. numema)
     *        call errex( 'cupdat, collision storage exceeded')
            i1c(nument)=i2
            i2c(nument)=i3
            ctime(nument)=thit
            csig(nument)=sig
            idud(1,issn(i2))=idud(1,issn(i2))+1
            idud(1,issn(i3))=idud(1,issn(i3))+1
          end if
   33   continue
      end if
      return
      end
CPAT,DUPDAT   .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine dupdat(ind,startt)
        include 'scatter7'
        include 'partblk7'
#include "amsrqmd.h"
      dimension pind(0:3)
       common /dtestb/ ammag
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 2.2  -- 17-mar-95'/
      data pronam/'d u p d a t  --  decay update'/
      data ttvers/.true./
      if(ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      lfin=0
      itp1=ityp(ind)
      npid1=npidec(ind)
      if(itp1.eq.-9999) then
        decay(ind)=1.e+35
        return
      else if(itp1.eq.98.and.npid1.eq.40) then
        decay(ind)=startt
        return
      end if
      em1=em(ind)
      do  9 i=0,3
    9 pind(i)=p(i,ind)
      emeff=pind(0)*pind(0)
      do 10 i=1,3
   10 emeff=emeff-pind(i)*pind(i)
      emeff=sqrt(emeff)
      ammag=gamind(kerr,itp1,npid1,lfin,em1,emeff)
      if(kerr.eq.-100) then
        write(lun8,*) ind,issn(ind),itp1,npid1,em1,emeff
        call errex('dupdat:kerr=-100')
      else if(ammag.ne.cvalu0) then
        deltt=timelf(ammag,emeff,pind(1),pind(2),pind(3))
        decay(ind)=startt+deltt
      else
        decay(ind)= 1.e+35
      end if
      return
      end
      function widr(kmult,npid,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       real*4 gemla(11),gemsi(11),
     a        gemca(11),gemsis(11),gemcas(11),gemom(11)
       equivalence (gemla(1),gambar(1,3))
       equivalence (gemsi(1),gambar(1,4))
       equivalence (gemca(1),gambar(1,5))
       equivalence (gemsis(1),gambar(1,6))
       equivalence (gemcas(1),gambar(1,7))
       equivalence (gemom(1),gambar(1,8))
       real*4 gamres
       common /gamrbk/ gamres
       real*4 prtgam
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
       real*4 dcrm
       npida=iabs(npid)
       if(kmult.lt.0.or.kmult.gt.11) then
         call errex('wrong input in widr: kmult unknown')
       end if
       if(kmult.eq.0) then
         if(npida.eq.0.or.npida.gt.70) then
           call errex('wrong input in widr: npida unknown')
         else
           widr=prtgam(npida)
         end if
       else if(npida.eq.41.or.npida.eq.42) then
         ientry=kmult
         dummy=dcratn(1,ientry,em)
         widr=gamres
       else if(npida.ge.61.and.npida.le.64) then
         ientry=kmult
         dummy=dcratd(1,ientry,em)
         widr=gamres
       else if(npida.eq.57) then
         widr=gemla(kmult)
       else if(npida.ge.43.and.npida.le.45) then
         widr=gemsi(kmult)
       else if(npida.eq.46.or.npida.eq.47) then
         if(kmult.eq.2.or.kmult.eq.3.or.
     a                     kmult.eq.4.or.kmult.eq.9) then
           ientry=min(4,kmult-1)
           dummy=dcratc(1,ientry,em)
           widr=gamres
         else
           widr=gemca(kmult)
         end if
       else if(npida.ge.65.and.npida.le.67) then
         widr=gemsis(kmult)
       else if(npida.eq.68.or.npida.eq.69) then
         if(kmult.eq.4) then
           ientry=5
           dummy=dcratc(1,ientry,em)
           widr=gamres
         else
           widr=gemcas(kmult)
         end if
       else if(npida.eq.70) then
         widr=gemom(kmult)
       else
         widr=dcrm(kmult,npid,em)
       end if
      return
      end
      function gamind(kerr,itp1,npid1,lfin,em1,emeff)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 prtgam
       common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
       real*4 gamres
       common /gamrbk/ gamres
       kerr=0
               if(itp1.eq.-9999) then
                 gamind=cvalu0
               else if(itp1.le.2) then
                 gamind=cvalu0
               else if((itp1.ge.7.and. itp1.le.9).and.
     a                              (npid1.eq.0))then
                 gamind=cvalu0
               else if(itp1.eq.12.and.em1.lt.0.6)then
                 gamind=cvalu0
               else if(itp1.eq.13.and.em1.lt.1.2)then
                 gamind=cvalu0
               else if(itp1.eq.15.and.em1.le.1.2)then
                 gamind=cvalu0
               else if(itp1.eq.14.and.em1.le.0.5)then
                 gamind=cvalu0
               else if(itp1.le.6) then
                   if(npid1.eq.3.or.npid1.eq.4) then
                     gamind=gamcon(emeff)
                   else if(npid1.eq.1.or.npid1.eq.0) then
                     gamind=dwidth(emeff)
                   else
                     kmult=mod(-npid1,100)
                     dummy=dcratd(1,kmult,emeff)
                     gamind=gamres
                   end if
               else if(itp1.ge.7.and.itp1.le.9) then
                   if(npid1.eq.3.or.npid1.eq.4) then
                     gamind=gamcon(emeff)
                   else if(npid1.eq.2) then
                     gamind=widrho
                   else if(npid1.eq.1) then
                     gamind=-1.0
                   end if
               else if(itp1.ge.10.and.itp1.le.11) then
                   if(npid1.eq.3.or.npid1.eq.4) then
                     gamind=gamcon(emeff)
                   else
                     kmult=mod(-npid1,100)
                     dummy=dcratn(1,kmult,emeff)
                     gamind=gamres
                   end if
               else if(itp1.ge.12.and.itp1.le.15) then
                     gamind=gamcon(emeff)
               else if(itp1.ge.85.and.itp1.le.97) then
                 kmult=itp1-84
                 gamind=widr(kmult,npid1,emeff)
                 if(gamind.le.0.0) then
                   kerr=-100
                 end if
               else if(itp1.eq.98) then
                     gamind=gamcon(emeff)
               else if(itp1.eq.99) then
                     kl2=npid1
                     kfa=iabs(kl2)
                     if(kfa.lt.100)then
                         idc=kfa
                     else
                         call luiflv(kfa,ifla,iflb,iflc,ksp)
                         idc=76+5*ifla+ksp
                     end if
                     if(prtgam(idc).gt.0.) then
                       gamind=prtgam(idc)
                     else
                       gamind=cvalu0
                     end if
               else
                 write(lun8,*) 'itp1=',itp1
                 call errex(' gamind: this type not implemented')
               end if
      return
      end
      function gamcon(emeff)
       include 'scatter7'
#include "amsrqmd.h"
       data decstr  /0.0/
       if(decstr.eq.0.0) then
         if(emctst.le.2.) then
           decstr=1000.
         else
           decstr=log(2.0)/(emctst-2.)
         end if
       end if
       if(ida(18).eq.2) then
         deccst=decstr*(emeff-2.)
         if(deccst.lt.20.) then
           prblif=exp(-deccst)
         else
           prblif=0.
         end if
         if(ranf(0).lt.prblif) then
           gamcon=abs(gmprop)
         else
           gamcon=gmprop
         end if
       else if(ida(18).eq.1.and.emeff.lt.emctst) then
         gamcon=abs(gmprop)
       else
         gamcon=gmprop
       end if
      return
      end
      subroutine oldnew(jwhat,ityp,npidec,emin,kmult,ltype)
       include 'scatter7'
#include "amsrqmd.h"
       if(jwhat.ne.0) then
         kmult=-2
         call transl(-1,ityp,npidec,ltype)
         if(ityp.eq.-9999) then
           kmult=0
         else if(ityp.eq.1.or.ityp.eq.2) then
           kmult=0
         else if((ityp.ge.7.and. ityp.le.9).and.
     a                              npidec.eq.0)then
           kmult=0
         else if(ityp.eq.12.and.npidec.eq.2
     a                         .and.emin.lt.0.60) then
           kmult=0
         else if(ityp.eq.13.and.emin.lt.1.2)then
           kmult=0
         else if(ityp.eq.15.and.emin.lt.1.2)then
           kmult=0
         else if(ityp.eq.14.and.emin.lt.0.5)then
           kmult=0
         else if(ityp.le.6) then
           if(npidec.eq.3.or.npidec.eq.4) then
             kmult=-1
           else if(npidec.eq.1.or.npidec.eq.0) then
             kmult=0
           else
             kmult=mod(-npidec,100)
           end if
         else if(ityp.ge.7.and.ityp.le.9) then
           if(npidec.eq.3.or.npidec.eq.4) then
             kmult=-1
           else if(npidec.eq.2) then
             kmult=0
           else if(npidec.eq.1) then
             kmult=-1
           else if(npidec.eq.0) then
             kmult=0
           end if
         else if(ityp.ge.10.and.ityp.le.11) then
           if(npidec.eq.3.or.npidec.eq.4) then
             kmult=-1
           else
              kmult=mod(-npidec,100)
           end if
         else if(ityp.ge.12.and.ityp.le.15) then
           kmult=-1
         else if(ityp.ge.85.and.ityp.le.95) then
           kmult=ityp-84
         else if(ityp.eq.98) then
           kmult=-1
         else if(ityp.eq.99) then
           kmult=0
         else
           write(lun8,*) 'ityp=',ityp
           call errex('oldnew: this type not implemented')
         end if
         if(kmult.lt.-1.or.kmult.gt.11)
     a                   call errex('oldnew: wrong kmult')
       else
         call transl(1,ityp,npidec,ltype)
         if(kmult.gt.0) then
           if(kmult.gt.13) then
             call errex('oldnew 0:kmult out of range')
           end if
           if(iabs(ltype).le.40) then
             ityp=84+kmult
             npidec=ltype
           else
             if(ityp.eq.99) then
               ityp=84+kmult
             else if(ityp.eq.13) then
               ityp=84+kmult
               npidec=57
             else if(ityp.eq.15) then
               ityp=84+kmult
               npidec=44-npidec
             else if(ityp.le.6) then
               npidec=-kmult
               if(ityp.eq.1.or.ityp.eq.2) then
                 ityp=ityp+9
               end if
             else
               write(lun8,*) ityp,npidec
               call errex('oldnew 0, wrong ityp for baryon')
             end if
           end if
         else if(kmult.eq.0) then
         else if(kmult.eq.-1) then
           if(ityp.eq.99) then
             ityp=98
           else if(ityp.gt.0.and.ityp.le.15) then
             if(ityp.le.6) then
               npidec=3
               if(ityp.eq.1.or.ityp.eq.2) then
                 ityp=ityp+9
               end if
             else if(ityp.le.9) then
               if(npidec.eq.0) then
                 npidec=3
               else
                 npidec=4
               end if
             end if
           else
             call errex('oldnew 0, kmult=-1, wrong ityp')
           end if
         else
           call errex('oldnew:kmult out of range')
         end if
       end if
      return
      end
      subroutine hprop(kmult,ltype,emin,em,gamma)
       include 'scatter7'
#include "amsrqmd.h"
       dimension jentry(70)
       data jentry /
     a  16*-1,1,4,4,-1,
     b   2*-1,1,2,3,-1,5,8,8,3*-1,5,6,7,5*-1,
     c   2*2,3*4,2*5,9*-1,3,3*-1,4*1,3*6,2*7,8
     d             /
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       if(kmult.lt.-1.or.kmult.gt.11)
     a      call errex('hprop: wrong input')
       ltypa=iabs(ltype)
       if(ltypa.eq.0.or.ltypa.gt.70)
     a      call errex('hprop: wrong input')
       jent=jentry(ltypa)
       if(jent.le.0)
     a      call errex('hprop: wrong input')
       if(kmult.ge.0) then
         if(ltypa.gt.40) then
           em=embarr(kmult,jent)
           gamma=gambar(kmult,jent)
         else
           em=emmesr(kmult,jent)
           gamma=gammes(kmult,jent)
         end if
       else
         em=emin
         gamma=abs(gmprop)*emin
       end if
       if(em.le.0.0)
     a      call errex('hprop: wrong output')
      return
      end
CPAT,FNDNXT   .
      subroutine fndnxt(index,iwhat)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
        data iloop /0/
      save iruno,itripo,kclsto
      data wrilim / 9999.99 /
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version  rqmd 1.09 -- 07-jul-94'/
      data pronam/'fndnxt: find the next event(collision,decay)'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      nttot=nrbar(kclst)+nrmes(kclst)
   89 continue
      if(iloop.eq.1) then
        if(irun.ne.iruno.or.itripl.ne.itripo.or.kclst.ne.kclsto) then
          iloop=0
          ifndnx=0
        end if
      end if
      if(iloop.eq.1) then
         do 91 je=1,nttot
          j=je+iofset
          if(decay(j).lt.wrilim) then
            decayj=decay(j)
            identj=issn(j)
            if(qdot(0,j).gt.0.0) then
              do 88 i=0,3
               x(i,j)=x(i,j)+qdot(i,j)/qdot(0,j)*
     a                              (decayj-x(0,j))
   88         continue
            else
              do 87 i=0,3
               x(i,j)=x(i,j)+p(i,j)/p(0,j)*
     a                              (decayj-x(0,j))
   87         continue
            end if
            qdot(0,j)=0.
            decay(j)=x(0,j)
          end if
   91    continue
      end if
      imin=0
      tmin=timmax
      if((iloop.ne.0).or.(.not.switch(18)))then
        do 101 je=1,nttot
         j=je+iofset
         if(ichbig(j).eq.3.and.(iloop.eq.0.or.ida(15).eq.2)) go to 101
         if(decay(j).le.x(0,j)) then
           if(qdot(0,j).gt.1.e-20) then
             delts=(decay(j)-x(0,j)+qdot(0,j)*dt)/qdot(0,j)
           else if(qdot(0,j).eq.0..and.x(0,j).eq.decay(j)) then
             delts=tlstev-time
           else
             go to 101
           end if
           if(time+delts.lt.tmin) then
             imin=j
             tmin=time+delts
             iwhat=2
           end if
         end if
  101   continue
      end if
      if(iloop.eq.0) then
       do 100 i=1,nument
       if(i1c(i).le.0) go to 100
          if (ctime(i).le.tmin) then
            tmin=ctime(i)
            imin=i
            iwhat=1
          end if
  100  continue
      end if
      if(imin.eq.0) then
        iwhat=0
      else
        index=imin
      end if
      if(iwhat.eq.0.and.iloop.eq.0.and.kdt.eq.ndt
     a        .and.(itripl.gt.1.or.switch(17).or.switch(23)))then
         iloop=1
         ifndnx=1
         iruno=irun
         itripo=itripl
         kclsto=kclst
         goto 89
      end if
      return
      end
CPAT,FRAGM    .
      subroutine lusysj(ip)
#include "amsrqmd.h"
      dimension pall(4),ifstor(2)
      dimension zpm(2)
      common /luspbk/ pall,iqqsp,ifirst,ibegin,istart,istfl
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
      common /zdisbk/ paraqq,paraq,paraqs
      common /su3mix/ angmxv,angeff
      common /luopt1/
     a         iopt(20),kfstr,icqq,mbfix,ideltq,ibbcol,
     b         mmult(100),
     a         iprbcq,ilead,iback,ibrtag,icqbar,idlj,klmold,
     b         klbold,isot,misot,lbreak(100),emst,emda,emdb
      common /prinbk/ iprin
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      dimension ps(5),ifl(3),px(4),py(4),gam(3),pr(2),in(9),hm(4),hg(4),
     &  lrk(2),ie(2),iflf(2),iflj(2),pxj(2),pyj(2),zj(2),
     &  zpos(2),pmq(3)
      double precision dp(5,5),dfour,hkc,hks,hk1,hk2,hc12,hcx1,hcx2,
     &  hcxx,hcy1,hcy2,hcyx,hcyy
      four(i,j)=p(i,4)*p(j,4)-p(i,1)*p(j,1)-p(i,2)*p(j,2)-p(i,3)*p(j,3)
      dfour(i,j)=dp(i,4)*dp(j,4)-dp(i,1)*dp(j,1)-dp(i,2)*dp(j,2)-
     &  dp(i,3)*dp(j,3)
      if(iopt(7).ne.0) jdeltq=ideltq
      kopt1=0
      icqstr=icqbar
      igpar=mgpar(iabs(kfstr))
      par1=par(1)
      par2=par(2)
      par11=par(11)
      par51=par(51)
      par52=par(52)
      if(icqq.eq.2) lflav=int(rlu(0)*(2.+par(3)))+1
      if(kopt1.eq.1)then
         iantop=1
         iantpr=1
         par1=par(1)
         par(1)=10.
      else
         iantop=0
         iantpr=0
      end if
      ifirst=0
      ibegin=0
      istart=0
      ntry=0
      np=0
      do 100 j=1,5
  100 ps(j)=0.
      i=ip-1
  110 i=i+1
      if(i.gt.min(n,mst(30)-np-5-mst(31))) then
        mst(24)=mst(24)+1
        mst(25)=2
        if(i.le.n) mst(25)=1
        if(mst(23).ge.1) return
      endif
      if(k(i,1).ge.20000.or.iabs(k(i,2)).lt.500) goto 110
      np=np+1
      k(n+np,1)=i
      k(n+np,2)=k(i,2)
      do 120 j=1,5
      p(n+np,j)=p(i,j)
  120 ps(j)=ps(j)+p(i,j)
      if(p(n+np,4)**2.lt.p(n+np,1)**2+p(n+np,2)**2+p(n+np,3)**2) then
        p(n+np,4)=sqrt(p(n+np,1)**2+p(n+np,2)**2+p(n+np,3)**2+
     &  p(n+np,5)**2)
        ps(4)=ps(4)+max(0.,p(n+np,4)-p(i,4))
      endif
      if(k(i,1).ge.10000) goto 110
      mbst=0
      if(ps(1)**2+ps(2)**2+ps(3)**2.gt.0.5*ps(4)**2) then
        mbst=1
        pebst=max(ps(4),1.0001*sqrt(ps(1)**2+ps(2)**2+ps(3)**2))
        mst(1)=n+1
        mst(2)=n+np
        call lurobo(0.,0.,-ps(1)/pebst,-ps(2)/pebst,-ps(3)/pebst)
      endif
      do  4 i=1,4
    4 pall(i)=ps(i)
      emstr=pall(4)**2-(pall(1)**2+pall(2)**2+pall(3)**2)
      emstr=sqrt(emstr)
      iflab=-1
      nr=np
  130 if(nr.le.2) goto 180
      drmin=2.*par(59)
      do 140 i=n+1,n+nr
      if(i.eq.n+nr.and.iabs(k(n+1,2)).ne.500) goto 140
      i1=i+1-nr*(i/(n+nr))
      pap=sqrt((p(i,1)**2+p(i,2)**2+p(i,3)**2)*(p(i1,1)**2+
     &p(i1,2)**2+p(i1,3)**2))
      pvp=p(i,1)*p(i1,1)+p(i,2)*p(i1,2)+p(i,3)*p(i1,3)
      dr=4.*(pap-pvp)**2/(par(60)**2*pap+2.*(pap-pvp))
      if(dr.lt.drmin) then
        ir=i
        drmin=dr
      endif
  140 continue
      if(drmin.lt.par(59).and.ir.eq.n+nr) then
        do 150 j=1,4
  150   p(n+1,j)=p(n+1,j)+p(n+nr,j)
        p(n+1,5)=sqrt(max(0.,p(n+1,4)**2-p(n+1,1)**2-p(n+1,2)**2-
     &  p(n+1,3)**2))
        nr=nr-1
        goto 130
      elseif(drmin.lt.par(59)) then
        do 160 j=1,4
  160   p(ir,j)=p(ir,j)+p(ir+1,j)
        p(ir,5)=sqrt(max(0.,p(ir,4)**2-p(ir,1)**2-p(ir,2)**2-
     &  p(ir,3)**2))
        do 170 i=ir+1,n+nr-1
        k(i,2)=k(i+1,2)
        do 170 j=1,5
  170   p(i,j)=p(i+1,j)
        if(ir.eq.n+nr-1) k(ir,2)=k(n+nr,2)
        nr=nr-1
        goto 130
      endif
  180 if(n+5*nr+11.ge.mst(30)-5-mst(31)) then
        mst(24)=mst(24)+1
        mst(25)=1
        if(mst(23).ge.1) return
      endif
 
      if(iabs(k(n+1,2)).ne.500) then
        ns=nr-1
        nb=1
      else
        ns=nr+1
        w2sum=0.
        do 190 is=1,nr
        p(n+nr+is,1)=0.5*four(n+is,n+is+1-nr*(is/nr))
  190   w2sum=w2sum+p(n+nr+is,1)
        w2ran=ranf(0)*w2sum
        nb=0
  200   nb=nb+1
        w2sum=w2sum-p(n+nr+nb,1)
        if(w2sum.gt.w2ran.and.nb.lt.nr) goto 200
      endif
 
      do 220 is=1,ns
      is1=n+is+nb-1-nr*((is+nb-2)/nr)
      is2=n+is+nb-nr*((is+nb-1)/nr)
      do 210 j=1,5
      dp(1,j)=p(is1,j)
      if(iabs(k(is1,2)).eq.500) dp(1,j)=0.5*dp(1,j)
      dp(2,j)=p(is2,j)
  210 if(iabs(k(is2,2)).eq.500) dp(2,j)=0.5*dp(2,j)
      dp(3,5)=dfour(1,1)
      dp(4,5)=dfour(2,2)
      hkc=dfour(1,2)
      if(dp(3,5)+2.*hkc+dp(4,5).le.0.) then
        dp(3,5)=dp(1,5)**2
        dp(4,5)=dp(2,5)**2
        dp(1,4)=dsqrt(dp(1,1)**2+dp(1,2)**2+dp(1,3)**2+dp(1,5)**2)
        dp(2,4)=dsqrt(dp(2,1)**2+dp(2,2)**2+dp(2,3)**2+dp(2,5)**2)
        hkc=dfour(1,2)
      endif
      hks=dsqrt(hkc**2-dp(3,5)*dp(4,5))
      hk1=0.5*((dp(4,5)+hkc)/hks-1.)
      hk2=0.5*((dp(3,5)+hkc)/hks-1.)
      in1=n+nr+4*is-3
      p(in1,5)=sqrt(dp(3,5)+2.*hkc+dp(4,5))
      do 220 j=1,4
      p(in1,j)=(1.+hk1)*dp(1,j)-hk2*dp(2,j)
  220 p(in1+1,j)=(1.+hk2)*dp(2,j)-hk1*dp(1,j)
      nrs=nr+4*ns+7
  230 ntry=ntry+1
      if(ntry.gt.200) then
        mst(24)=mst(24)+1
        mst(25)=3
        if(mst(23).ge.1) return
      endif
      i=n+nrs
      do 240 j=1,4
      p(i,j)=0.
      do 240 is=1,nr
  240 p(i,j)=p(i,j)+p(n+is,j)
      do 250 jt=1,2
      lrk(jt)=0
      ie(jt)=k(n+1+(jt/2)*(np-1),1)
      iflj(jt)=0
      pxj(jt)=0.
      pyj(jt)=0.
      zj(jt)=0.
      zpos(jt)=1.
      zpm(jt)=1.
      in(3*jt+1)=n+nr+1+4*(jt/2)*(ns-1)
      in(3*jt+2)=in(3*jt+1)+1
      in(3*jt+3)=n+nr+4*ns+2*jt-1
      do 250 in1=n+nr+2+jt,n+nr+4*ns-2+jt,4
      p(in1,1)=2-jt
      p(in1,2)=jt-1
  250 p(in1,3)=1.
      igparb=igpar
      igpara=1
      ideltq=0
      zqq=0.0
      iqqsp=0
      istfl=0
      iprtno=0
      iflstr=0
      ifjsid=0
      iplus=0
      icqqop=0
      jfl1=-1
      jfl2=-1
      mresex=0
      ipun=1
      if(ns.eq.nr-1) then
        px(1)=0.
        py(1)=0.
        if(ns.eq.1) call luptdi(93,px(1),py(1))
        px(2)=-px(1)
        py(2)=-py(1)
        kfsum=0
        do 260 jt=1,2
        iflf(jt)=mod(k(ie(jt),2),500)
        kfsum=kfsum+isign(1,iflf(jt)*(10-iabs(iflf(jt))))
        ifl(jt)=iflf(jt)
        gam(jt)=0.
        if(iabs(iflf(jt)).ge.10) then
          ifjsid=jt
          if(icqq.ne.0) then
            iflqq=ifl(jt)
            ifl(jt)=iqqrnd(iflqq)
          end if
          if(icqq.eq.2.and.ntry.le.100) then
            if(iflf(jt)/10.ne.3.and.mod(iflf(jt),10).ne.3) then
              if(lflav.eq.3) then
                ihisbm=3
              else
                ihisbm=4
              end if
            else
              if(lflav.eq.3) then
                ihisbm=1
              else
                ihisbm=2
              end if
            end if
          else
            ihisbm=0
          end if
        end if
        if(mod(mst(10),2).eq.1.and.iabs(iflf(jt)).ge.10) then
          ifla=iflf(jt)/10
          iflb=iflf(jt)-10*ifla
          if(iflab.eq.-1) then
            iflab=int(ranf(0)+0.5)
            if(ibbcol.eq.0) then
            else if(iabs(iflb).eq.3.and.iflab.eq.0) then
              if(ranf(0).le.0.25) iflab=1
            else if(iabs(ifla).eq.3.and.iflab.eq.1) then
              if(ranf(0).le.0.25) iflab=0
            end if
          end if
          iflj(jt)=ifla+iflab*(iflb-ifla)
          if(n.gt.ie(jt).and.k(ie(jt)+1,1)/10000.eq.6.and.iabs(k(ie(jt)+
     &    1,2)).ge.610) iflj(jt)=mod(k(ie(jt)+1,2)/10,10)
          ifl(jt)=ifla+iflb-iflj(jt)
          ifstor(jt)=ifl(jt)
          ibrtag=0
          icqbar=icqstr
          idlj=-1
          inol=0
          if(iflj(jt).ne.0) then
           iqqsp=1
           if(icqstr.ne.0) then
              if(iflj(jt).ne.icqstr) then
                 if(icqstr.ne.ifla.and.icqstr.ne.iflb) then
                     write(lun8,*) 'icqstr,ifla,iflb',icqstr,ifla,iflb
                     call errex('wrong icqstr in lusysj input')
                 end if
                 iflj(jt)=icqstr
                 ifl(jt)=ifla+iflb-icqstr
              end if
           end if
          end if
          call luzdis(0,1,0.,zj(jt))
          if(iopt(4).ne.0) zj(jt)=0.0
          if(par(12).gt.0.) then
            call luptdi(94,pxr,pyr)
          else
            pxr=0.
            pyr=0.
          end if
          px(jt)=0.5*px(jt)+pxr
          py(jt)=0.5*py(jt)+pyr
          pxj(jt)=px(jt)-2.*pxr
          pyj(jt)=py(jt)-2.*pyr
          if(n.gt.ie(jt).and.k(ie(jt)+1,1)/10000.eq.6) p(ie(jt)+1,1)=
     &    zj(jt)
        endif
        pmq(jt)=ulmass(2,ifl(jt))
  260   continue
        if(kfsum.ne.0) then
          mst(24)=mst(24)+1
          mst(25)=2
          if(mst(23).ge.1) return
        endif
      else
        ifl(3)=int(1.+(2.+par(2))*ranf(0))*(-1)**int(ranf(0)+0.5)
        call luifld(ifl(3),0,0,ifl(1),kdump)
        call luifld(-ifl(3),0,0,ifl(2),kdump)
        if(iabs(ifl(2)).lt.100) ifl(2)=-mod(ifl(1),100)
        if(iabs(ifl(2)).gt.100) ifl(1)=-mod(ifl(2),100)
        iflstr=(iabs(ifl(1))+90)/100
        call luptdi(ifl(1),px(1),py(1))
        px(2)=-px(1)
        py(2)=-py(1)
        pr3=min(25.,0.1*p(n+nr+1,5)**2)
  270   call luzdis(ifl(1),0,pr3,z)
        zr=pr3/(z*p(n+nr+1,5)**2)
        if(zr.ge.1.) goto 270
        do 280 jt=1,2
        pmq(jt)=ulmass(2,ifl(jt))
        gam(jt)=pr3*(1.-z)/z
        in1=n+nr+3+4*(jt/2)*(ns-1)
        p(in1,jt)=1.-z
        p(in1,3-jt)=jt-1
        p(in1,3)=(2-jt)*(1.-z)+(jt-1)*z
        p(in1+1,jt)=zr
        p(in1+1,3-jt)=2-jt
  280   p(in1+1,3)=(2-jt)*(1.-zr)+(jt-1)*zr
      endif
 
      do 320 jt=1,2
      if(jt.eq.1.or.ns.eq.nr-1) then
        in1=in(3*jt+1)
        in3=in(3*jt+3)
        do 290 j=1,4
        dp(1,j)=p(in1,j)
        dp(2,j)=p(in1+1,j)
        dp(3,j)=0.
  290   dp(4,j)=0.
        dp(1,4)=dsqrt(dp(1,1)**2+dp(1,2)**2+dp(1,3)**2)
        dp(2,4)=dsqrt(dp(2,1)**2+dp(2,2)**2+dp(2,3)**2)
        dp(5,1)=dp(1,1)/dp(1,4)-dp(2,1)/dp(2,4)
        dp(5,2)=dp(1,2)/dp(1,4)-dp(2,2)/dp(2,4)
        dp(5,3)=dp(1,3)/dp(1,4)-dp(2,3)/dp(2,4)
        if(dp(5,1)**2.le.dp(5,2)**2+dp(5,3)**2) dp(3,1)=1.
        if(dp(5,1)**2.gt.dp(5,2)**2+dp(5,3)**2) dp(3,3)=1.
        if(dp(5,2)**2.le.dp(5,1)**2+dp(5,3)**2) dp(4,2)=1.
        if(dp(5,2)**2.gt.dp(5,1)**2+dp(5,3)**2) dp(4,3)=1.
        hc12=dfour(1,2)
        hcx1=dfour(3,1)/hc12
        hcx2=dfour(3,2)/hc12
        hcxx=1./dsqrt(1.+2.*hcx1*hcx2*hc12)
        hcy1=dfour(4,1)/hc12
        hcy2=dfour(4,2)/hc12
        hcyx=hcxx*(hcx1*hcy2+hcx2*hcy1)*hc12
        hcyy=1./dsqrt(1.+2.*hcy1*hcy2*hc12-hcyx**2)
        do 300 j=1,4
        dp(3,j)=hcxx*(dp(3,j)-hcx2*dp(1,j)-hcx1*dp(2,j))
        p(in3,j)=dp(3,j)
  300   p(in3+1,j)=hcyy*(dp(4,j)-hcy2*dp(1,j)-hcy1*dp(2,j)-
     &  hcyx*dp(3,j))
      else
        do 310 j=1,4
        p(in3+2,j)=p(in3,j)
  310   p(in3+3,j)=p(in3+1,j)
      endif
  320 continue
      io4qq=0
      istore=i+1
  330 i=i+1
      if(i.ge.mst(30)-5-mst(31)) then
        mst(24)=mst(24)+1
        mst(25)=1
        if(mst(23).ge.1) return
      endif
      ipun=max(0,ipun-1)
      iprtno=iprtno+1
      mmult(iprtno)=0
      if(iprtno.eq.1) then
        if(iopt(3).gt.0) then
          iopt(3)=1
          if(ifjsid.ne.0) then
            jtopt3=ifjsid
          else
            jtopt3=1
          end if
          if(iopt(4).ne.0) call errex('lusysj:iopt(3)/iopt(4).ne.0')
        else if(iopt(4).gt.0) then
          iopt(4)=1
          if(ifjsid.ne.0) then
            jtopp=3-ifjsid
            call luifld(ifl(jtopp),0,0,ifl(3),k(i,2))
          end if
          if(iabs(ifl(3)).gt.10.and.ranf(0).gt.0.5) io4qq=1
        end if
      end if
      if(iopt(7).eq.1.and.iprtno.eq.1) then
        iop7=1
      else
        iop7=0
      end if
      if(iop7.eq.1) then
        if(iabs(ifl(1)).gt.10) then
          jt=2
        else if(iabs(ifl(2)).gt.10) then
          jt=1
        else
          call errex('lusysj: missing qq at end for iop7=1')
        end if
        if(px(jt).ne.0.0.or.py(jt).ne.0.0)
     a      call errex('lusysj:iop7=1  with init pt')
        iflfb=iflf(3-jt)
        iflfa=iflf(jt)
        if(iprbcq.eq.0.and.jdeltq.eq.0.and.iopt(11).eq.0) then
          kswi=1
        else
          kswi=2
        end if
        ichobr=iopt(10)
        ida53=iopt(12)
        ida55=iopt(13)
        call bresdc(imany,
     a              iflfb,iflfa,ichobr,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbar,kfmes,kmltba,kmltme,
     d              iflb,ifla,ifl3,kdfr,embar,emmes,ptx,pty
     e                 )
        if(imany.eq.1) then
          iopt(7)=2
          go to 230
        end if
        ifl(3-jt)=iflb
        ifl(jt)=ifla
        ifl(3)=ifl3
        px(3)=ptx
        py(3)=pty
        if(kswi.eq.1) then
          iflf(3-jt)=iflb
          iflf(jt)=ifla
          ideltq=100*iflf(jt)+iflf(3-jt)
        end if
        if(kdfr.eq.1) then
          iopt(5)=2
          iprbcq=2
        end if
        k(i,2)=kfmes
      end if
      if(iprtno.ge.2) then
        lrkjr=lrk(3-jt)
      else
        lrkjr=0
      end if
      lrkjt=0
      kreflc=0
      if(icqq.eq.2.and.iprtno.eq.2) kreflc=1
      if(iop7.eq.1) then
      else if(io4qq.eq.1.and.iprtno.eq.1) then
        jt=3-ifjsid
      else if(iopt(4).ne.0.and.(iflj(1).ne.0.or.iflj(2).ne.0)) then
        jt=ifjsid
      else if(iopt(5).eq.1.and.iprtno.eq.1) then
        jt=1
      else if(icqq.eq.1.and.iprtno.le.2) then
        jt=1
        if(iprtno.eq.1) kreflc=1
      else if(iopt(3).eq.1) then
        jt=jtopt3
      else if(icqq.eq.0.and.iprbcq.ne.0.and.iprtno.eq.1) then
        jt=3-iprbcq
        if(iopt(7).eq.0) kreflc=1
      else if(iprbcq.eq.0.and.iprtno.ge.2.and.
     a                   (iopt(3).ne.0.or.iopt(4).ne.0).and.
     b                                           lrkjr.eq.0) then
        lrkjt=lrk(jt)
        jt=3-jt
      else
        jt=1.5+ranf(0)
      end if
      if(iop7.eq.1) then
      else
        call luptdi(ifl(jt),px(3),py(3))
      end if
      px(4)=px(3)
      py(4)=py(3)
      mqj=0
      if(iflj(jt).ne.0) then
        prji=par(37)**2+(px(jt)+px(3))**2+(py(jt)+py(3))**2
        call luzdis(ifl(jt),iflj(jt),prji,z)
        if((1.-z)*zpos(jt).le.zj(jt)) mqj=1
      end if
      lrk(jt)=lrk(jt)+1
      jr=3-jt
      js=3-2*jt
      k(i,1)=ie(jt)
      if(mqj.eq.1) then
           if(iabs(ifl(jt)).gt.10) goto 230
           if(lrk(jt).eq.1) ifl(jt)=iflf(jt)
           if(lrk(jt).eq.1) pmq(jt)=ulmass(2,ifl(jt))
           px(jt)=px(jt)+pxj(jt)
           py(jt)=py(jt)+pyj(jt)
           if(n.gt.ie(jt).and.k(ie(jt)+1,1)/10000.eq.6)
     &                                              p(ie(jt)+1,2)=i-nrs
      end if
      prbdcp=par(11)
      prboct=par(77)
      if(iopt(14).eq.1.and.ifjsid.eq.jt.and.mresex.eq.0
     a           .and.iopt(5).eq.0.and.icqq.eq.0
     b           .and.(iabs(ifl(jt)).gt.10.or.mqj.eq.1)) then
        iresex=1
        par(11)=prbdcp/(1.+prboct)
      else
        iresex=0
      end if
      if(iop7.eq.1) then
        go to 103
      else if(io4qq.eq.1.and.iprtno.eq.1) then
        go to 103
      end if
      mtry=0
  101 continue
      mtry=mtry+1
      if(mtry.gt.50) then
            call errex('lusysj101:infinite loop?? ')
      end if
      call luifld(ifl(jt),mqj*iflj(jt),0,ifl(3),k(i,2))
      if(k(i,2).eq.25.and.ranf(0).gt.par(80)) then
        mmult(iprtno)=1
        k(i,2)=24
      end if
      par(2)=par2
      if(iopt(9).ne.0) then
        if(k(i,2).eq.34.or.k(i,2).eq.35) then
          probch=0.6667*(sin(angmxv)-cos(angmxv)/sqrt(2.0))**2
          if(k(i,2).eq.34) then
            if(ranf(0).lt.probch) k(i,2)=35
          else if(k(i,2).eq.35) then
            if(ranf(0).lt.probch) k(i,2)=34
          end if
        end if
      end if
  103 continue
      par(2)=par2
      par(1)=par1
      par(11)=par11
      if(k(i,2).eq.0)  then
        goto 230
      end if
      if(iresex.eq.1) then
        if(iopt(7).eq.1) call errex('lusysj-abort,iopt(7)=1')
        mresex=1
        kfbar=k(i,2)
        kmltba=mlt810(k(i,2),embar)
        if(kmltba.lt.0) go to 101
        mmult(iprtno)=kmltba
      end if
      if(jfl1.eq.-1.and.jt.eq.1) then
        jfl1=0
      else
        jfl1=ifl(1)
      end if
      if(jfl2.eq.-1.and.jt.eq.2) then
        jfl2=0
      else
        jfl2=ifl(2)
      end if
      if(iopt(5).eq.1) then
        if(iprtno.eq.1) then
          if(iabs(ifl(3)).eq.3) then
            if(ranf(0).gt.0.2) go to 230
          end if
          k(i,2)=kfstr
          mmult(iprtno)=0
          if(ranf(0).gt.0.5) ifl(3)=-ifl(3)
          ifl(2)=ifl(3)
        end if
      end if
      if(jt.eq.1) then
        lbreak(iprtno)=ifl(3)
        lbreak(iprtno+1)=ifl(2)
        if(iprtno.eq.2.and.icqq.eq.2) lbreak(iprtno+1)=-ifl(3)
      else
        lbreak(iprtno)=ifl(2)
        lbreak(iprtno+1)=-ifl(3)
      end if
      if(jt.ne.ifjsid) istore=istore+1
      if(jt.eq.ifjsid.and.inol.eq.0) then
          idlj=idlj+1
      end if
      if(mqj.eq.1) inol=1
      if(mqj.eq.1.and.i.gt.istore) then
         if(jt.eq.1) then
            ibrtag=2
         else
            ibrtag=1
         end if
         icqbar=ifstor(jt)
      end if
      if(igpar.ne.0) then
        igparh=mgpar(iabs(k(i,2)))
        igpara=igpara*igparh
        if(igparh.eq.0) igparb=0
      end if
      if(iantop.eq.1.and.iantpr.eq.0)then
         if(i.eq.n+nrs+1) then
            iantpr=1
            par(1)=10.
         end if
      end if
      if(iantpr.eq.1)then
         kl2=iabs(k(i,2))
       if(kl2.eq.41.or.kl2.eq.42.or.(kl2.ge.61.and.kl2.le.64)) then
         ifyes=1
       else
         ifyes=0
       end if
       if(kopt1.eq.1.and.ifyes.eq.0) then
         if(ntry.lt.20) then
            go to 230
         else
            kopt1=0
            par(1)=par1
         end if
       else if(kopt1.eq.1.and.ifyes.ne.0) then
         iantpr=0
         par(1)=par1
       end if
      end if
      lfl3=iabs(ifl(3))
      if(ihisbm.eq.2.and.lfl3.eq.3) then
        go to 230
      else if(ihisbm.eq.3.and.lfl3.ne.3) then
        go to 230
      end if
      pmq(3)=ulmass(2,ifl(3))
      wmin=par(22+mst(4))+pmq(1)+pmq(2)+par(26)*pmq(3)
      if(iflj(jt).ne.0.and.mqj.eq.0) wmin=wmin+ulmass(2,iflj(jt))
      if(iflj(jr).ne.0) wmin=wmin+ulmass(2,iflj(jr))
      if(iabs(ifl(jt)).gt.100) wmin=wmin+par(26)*(ulmass(2,mst(33))-
     &   pmq(3))
      wrem2=four(n+nrs,n+nrs)
      if(iop7.eq.1.or.ipun.eq.1) go to 460
      if(wrem2.lt.0.10) goto 230
      if(iopt(7).eq.2.and.iprtno.eq.1.and.wrem2.gt.4.0) then
      else
     &  if(wrem2.lt.max(wmin*(1.+(2.*ranf(0)-1.)*par(27)),
     &                          par(22)+pmq(1)+pmq(2))**2) then
        goto 460
      end if
      if(mst(4).eq.1.and.max(mod(iabs(ifl(1)),10),mod(iabs(ifl(2)),
     &10)).ge.4) then
        wm1=max(par(22),pmq(1))**2
        wm2=max(par(22),pmq(2))**2
        gamh=0.5*(wrem2-wm1-wm2-sqrt((wrem2-wm1-wm2)**2-4.*wm1*wm2))*
     &  par(32)/(1.+par(31))
        if(gamh.lt.1..and.0.5*gamh**(1.+par(31)).gt.ranf(0)) goto 460
        if(gamh.ge.1..and.0.4+0.1*gamh.gt.ranf(0)) goto 460
      endif
      if(iresex.ne.0) then
        p(i,5)=embar
      else if(mmult(iprtno).ne.0) then
        minw=mmult(iprtno)
        p(i,5)=getms4(minw,k(i,2),0,-1.0)
      else
        p(i,5)=ulmass(1,k(i,2))
      end if
      pr(jt)=p(i,5)**2+(px(jt)+px(3))**2+(py(jt)+py(3))**2
      if(io4qq.eq.1.and.iprtno.eq.2) then
        go to 230
      end if
      if(iopt(4).eq.1.and.mqj.eq.0.and.io4qq.eq.0) then
        if(iabs(ifl(3)).eq.3) then
          if(ranf(0).gt.par(79)) go to 230
        end if
        call luzdis(0,1,0.,z)
        zqq=1.0-z
        par(51)=paraqs
        par(52)=paraqs
        call luzdis(0,1,0.,z)
        z=zqq*z
        zqq=zqq-z
        par(51)=par51
        par(52)=par52
        ifljcq=iflj(jt)
        if(ifljcq.eq.0) then
           call errex('lusysj:ifljcq=0')
        end if
      else if(iopt(4).eq.1.and.mqj.eq.1) then
        iopt(4)=2
        if(zqq.eq.0.0) then
          call errex('lusysj:uninitialized value of zqq')
        end if
        z=zqq
        z=z/zpm(jt)
        if(z.ge.1.0) go to 230
      else if(iopt(3).eq.1.and.jt.eq.jtopt3) then
        call luzdis(0,1,0.,z)
        z=1.0-z
        iopt(3)=2
      else if(iopt(5).eq.1.and.iprtno.eq.1) then
        call luzdis(0,1,0.,z)
        if(iabs(ifl(jt)).gt.10) then
          par(51)=paraqq
          par(52)=paraq
        else
          par(51)=paraqs
          par(52)=paraqs
        end if
        call luzdis(0,1,0.,zint)
        par(51)=par51
        par(52)=par52
        call luzdis(ifl(jt),0,pr(jt),z)
        z=1.0-(1.0-z)*zint
      else if(mqj.eq.0) then
        call luzdis(ifl(jt),0,pr(jt),z)
      elseif(mqj.eq.1) then
        gamji=(1.+par(35))/par(36)
        zbc=(pr(jt)-prji-z*gamji+prji/z)/(2.*gamji)
        z=sqrt(zbc**2+pr(jt)/gamji)-zbc
        if(iopt(3).ne.0.or.iopt(4).ne.0.or.
     a              iopt(5).ne.0) then
          call errex('lusysj: this z branch should not be called')
        end if
      endif
      if(iopt(4).ne.0) then
        istfl=1
        if(iflj(jt).ne.0.and.mqj.eq.0) then
          if(ifjsid.gt.0) zj(ifjsid)=1.0
        end if
      end if
      if(icqq.eq.2.and.jt.eq.ifjsid.and.icqqop.eq.0) then
        icqqop=1
        z=pr(jt)**2/(emstr*emstr*z)
        if(z.ge.1.0) go to 230
      end if
      if(lrkjt.ne.0) then
        if(icqq.ne.2) then
          z=pr(jt)**2/(emstr*emstr*zpm(3-jt)*z)
          if(z.ge.1.0) go to 230
        end if
      end if
      gam(3)=(1.-z)*(gam(jt)+pr(jt)/z)
      do 340 j=1,3
  340 in(j)=in(3*jt+j)
      if(in(1)+1.eq.in(2).and.z*p(in(1)+2,3)*p(in(2)+2,3)*
     &p(in(1),5)**2.ge.pr(jt)) then
        p(in(jt)+2,4)=z*p(in(jt)+2,3)
        p(in(jr)+2,4)=pr(jt)/(p(in(jt)+2,4)*p(in(1),5)**2)
        do 350 j=1,4
  350   p(i,j)=(px(jt)+px(3))*p(in(3),j)+(py(jt)+py(3))*p(in(3)+1,j)
        goto 420
      elseif(in(1)+1.eq.in(2)) then
        p(in(jr)+2,4)=p(in(jr)+2,3)
        p(in(jr)+2,jt)=1.
        in(jr)=in(jr)+4*js
        if(js*in(jr).gt.js*in(4*jr)) goto 230
        if(four(in(1),in(2)).le.1e-2) then
          p(in(jt)+2,4)=p(in(jt)+2,3)
          p(in(jt)+2,jt)=0.
          in(jt)=in(jt)+4*js
        endif
      endif
  360 if(js*in(1).gt.js*in(3*jr+1).or.js*in(2).gt.js*in(3*jr+2).or.
     &in(1).gt.in(2)) goto 230
      if(in(1).ne.in(3*jt+1).or.in(2).ne.in(3*jt+2)) then
        do 370 j=1,4
        dp(1,j)=p(in(1),j)
        dp(2,j)=p(in(2),j)
        dp(3,j)=0.
  370   dp(4,j)=0.
        dp(1,4)=dsqrt(dp(1,1)**2+dp(1,2)**2+dp(1,3)**2)
        dp(2,4)=dsqrt(dp(2,1)**2+dp(2,2)**2+dp(2,3)**2)
        hc12=dfour(1,2)
        if(hc12.le.1e-2) then
          p(in(jt)+2,4)=p(in(jt)+2,3)
          p(in(jt)+2,jt)=0.
          in(jt)=in(jt)+4*js
          goto 360
        endif
        in(3)=n+nr+4*ns+5
        dp(5,1)=dp(1,1)/dp(1,4)-dp(2,1)/dp(2,4)
        dp(5,2)=dp(1,2)/dp(1,4)-dp(2,2)/dp(2,4)
        dp(5,3)=dp(1,3)/dp(1,4)-dp(2,3)/dp(2,4)
        if(dp(5,1)**2.le.dp(5,2)**2+dp(5,3)**2) dp(3,1)=1.
        if(dp(5,1)**2.gt.dp(5,2)**2+dp(5,3)**2) dp(3,3)=1.
        if(dp(5,2)**2.le.dp(5,1)**2+dp(5,3)**2) dp(4,2)=1.
        if(dp(5,2)**2.gt.dp(5,1)**2+dp(5,3)**2) dp(4,3)=1.
        hcx1=dfour(3,1)/hc12
        hcx2=dfour(3,2)/hc12
        hcxx=1./dsqrt(1.+2.*hcx1*hcx2*hc12)
        hcy1=dfour(4,1)/hc12
        hcy2=dfour(4,2)/hc12
        hcyx=hcxx*(hcx1*hcy2+hcx2*hcy1)*hc12
        hcyy=1./dsqrt(1.+2.*hcy1*hcy2*hc12-hcyx**2)
        do 380 j=1,4
        dp(3,j)=hcxx*(dp(3,j)-hcx2*dp(1,j)-hcx1*dp(2,j))
        p(in(3),j)=dp(3,j)
  380   p(in(3)+1,j)=hcyy*(dp(4,j)-hcy2*dp(1,j)-hcy1*dp(2,j)-
     &  hcyx*dp(3,j))
        px(3)=-(px(4)*four(in(3*jt+3),in(3))+py(4)*
     &  four(in(3*jt+3)+1,in(3)))
        py(3)=-(px(4)*four(in(3*jt+3),in(3)+1)+py(4)*
     &  four(in(3*jt+3)+1,in(3)+1))
        if(abs(px(3)**2+py(3)**2-px(4)**2-py(4)**2).gt.0.01) then
          px(3)=px(4)
          py(3)=py(4)
        endif
      endif
      do 400 j=1,4
      hg(j)=0.
      p(i,j)=px(jt)*p(in(3*jt+3),j)+py(jt)*p(in(3*jt+3)+1,j)+
     &px(3)*p(in(3),j)+py(3)*p(in(3)+1,j)
      do 390 in1=in(3*jt+1),in(1)-4*js,4*js
  390 p(i,j)=p(i,j)+p(in1+2,3)*p(in1,j)
      do 400 in2=in(3*jt+2),in(2)-4*js,4*js
  400 p(i,j)=p(i,j)+p(in2+2,3)*p(in2,j)
      hm(1)=four(i,i)
      hm(2)=2.*four(i,in(1))
      hm(3)=2.*four(i,in(2))
      hm(4)=2.*four(in(1),in(2))
 
      do 410 in2=in(1)+1,in(2),4
      do 410 in1=in(1),in2-1,4
      hc=2.*four(in1,in2)
      hg(1)=hg(1)+p(in1+2,jt)*p(in2+2,jt)*hc
      if(in1.eq.in(1)) hg(2)=hg(2)-js*p(in2+2,jt)*hc
      if(in2.eq.in(2)) hg(3)=hg(3)+js*p(in1+2,jt)*hc
  410 if(in1.eq.in(1).and.in2.eq.in(2)) hg(4)=hg(4)-hc
 
      hs1=hm(jr+1)*hg(4)-hm(4)*hg(jr+1)
      if(abs(hs1).lt.1e-4) goto 230
      hs2=hm(4)*(gam(3)-hg(1))-hm(jt+1)*hg(jr+1)-hg(4)*
     &(p(i,5)**2-hm(1))+hg(jt+1)*hm(jr+1)
      hs3=hm(jt+1)*(gam(3)-hg(1))-hg(jt+1)*(p(i,5)**2-hm(1))
      p(in(jr)+2,4)=0.5*(sqrt(max(0.,hs2**2-4.*hs1*hs3))/abs(hs1)-
     &hs2/hs1)
      if(hm(jt+1)+hm(4)*p(in(jr)+2,4).le.0.) goto 230
      p(in(jt)+2,4)=(p(i,5)**2-hm(1)-hm(jr+1)*p(in(jr)+2,4))/
     &(hm(jt+1)+hm(4)*p(in(jr)+2,4))
 
      if(p(in(jr)+2,4).gt.p(in(jr)+2,3)) then
        p(in(jr)+2,4)=p(in(jr)+2,3)
        p(in(jr)+2,jt)=1.
        in(jr)=in(jr)+4*js
        if(js*in(jr).gt.js*in(4*jr)) goto 230
        if(four(in(1),in(2)).le.1e-2) then
          p(in(jt)+2,4)=p(in(jt)+2,3)
          p(in(jt)+2,jt)=0.
          in(jt)=in(jt)+4*js
        endif
        goto 360
      elseif(p(in(jt)+2,4).gt.p(in(jt)+2,3)) then
        p(in(jt)+2,4)=p(in(jt)+2,3)
        p(in(jt)+2,jt)=0.
        in(jt)=in(jt)+4*js
        goto 360
      endif
  420 do 430 j=1,4
      p(i,j)=p(i,j)+p(in(1)+2,4)*p(in(1),j)+p(in(2)+2,4)*p(in(2),j)
  430 p(n+nrs,j)=p(n+nrs,j)-p(i,j)
      jfl3=ifl(3)
      if(jt.eq.1) then
        jfljt=jfl1
      else
        jfljt=jfl2
      end if
      call lupos(z,zact,emht,i,jt,mqj,jfl3,jfljt)
      zr=emht*emht/(emstr*emstr*zact*zpm(jt))
      zpm(jt)=(1.-zact)*zpm(jt)
      zpm(3-jt)=zpm(3-jt)-zr
      if(p(i,4).le.0.) goto 230
      if(kreflc.eq.1) then
        ifl(jt)=ifl(3-jt)
        ifl(3-jt)=-ifl(3)
        ifl(3)=-ifl(jt)
        if(lrk(3-jt).eq.0.and.ifjsid.eq.3-jt) ifjsid=jt
      end if
      ifl(jt)=-ifl(3)
      pmq(jt)=pmq(3)
      if(mqj.eq.1) iflj(jt)=0
      zpos(jt)=(1.-z)*zpos(jt)
      px(jt)=-px(3)
      py(jt)=-py(3)
      gam(jt)=gam(3)
      if(in(3).ne.in(3*jt+3)) then
        do 440 j=1,4
        p(in(3*jt+3),j)=p(in(3),j)
  440   p(in(3*jt+3)+1,j)=p(in(3)+1,j)
      endif
      do 450 jq=1,2
      in(3*jt+jq)=in(jq)
      p(in(jq)+2,3)=p(in(jq)+2,3)-p(in(jq)+2,4)
  450 p(in(jq)+2,jt)=p(in(jq)+2,jt)-js*(3-2*jq)*p(in(jq)+2,4)
      goto 330
  460 continue
      if(max(iabs(ifl(jr)),iabs(ifl(3))).gt.100) goto 230
      if(iopt(7).eq.1) then
      else if(iopt(6).gt.0.and.iprtno.eq.1) then
        if(iabs(ifl(3)).eq.3.and.
     a                 ranf(0).gt.0.6666667) goto 230
      end if
      jfl3=ifl(3)
      if(jt.eq.1) then
        jfla=jfl1
        jflb=jfl2
      else
        jfla=jfl2
        jflb=jfl1
      end if
      mmult(iprtno+1)=0
      do 470 jf=jt,jr,js
      if(jf.eq.jr) i=i+1
      if(jf.eq.jr) lrk(jf)=lrk(jf)+1
      if(jf.eq.jr) k(i,1)=ie(jf)
      if(jf.eq.jr) iprtno=iprtno+1
      if(jf.eq.jt.and.(1-mqj)*iflj(jf).eq.0) then
      elseif(jf.eq.jr.and.iflj(jf).eq.0) then
        if(min(iabs(ifl(jf)),iabs(ifl(3))).gt.10) goto 230
        if(iop7.eq.1) then
          k(i,2)=kfbar
        else
          call luifld(ifl(jf),0,-ifl(3),ifldmp,k(i,2))
        end if
        if(iopt(9).ne.0) then
          if(iopt(9).eq.2.and.(iopt(3).eq.1.or.iopt(4).eq.1)
     a                                     .and.ifjsid.ne.0) then
            angmix=angeff
          else
            angmix=angmxv
          end if
          if(k(i,2).eq.34.or.k(i,2).eq.35) then
            probch=0.6667*(sin(angmix)-cos(angmix)/sqrt(2.0))**2
            if(k(i,2).eq.34) then
              if(ranf(0).lt.probch) k(i,2)=35
            else if(k(i,2).eq.35) then
              if(ranf(0).lt.probch) k(i,2)=34
            end if
          end if
        end if
      else
        if(iabs(ifl(jf)).gt.100) goto 230
        if(iflj(jf).ne.0.and.iabs(ifl(jf)).gt.10) goto 230
        ifl3=0
        if(jf.eq.jr) ifl3=-ifl(3)
        if((iabs(ifl(jf)).gt.10.or.iflj(jf).ne.0).and.iabs(ifl3).gt.10)
     &  goto 230
        call luifld(ifl(jf),iflj(jf),ifl3,ifl(3),k(i,2))
        if(k(i,2).eq.0) goto 230
        mmult(iprtno)=0
        if(jf.eq.ifjsid.and.inol.eq.0.and.jf.eq.jr) then
            idlj=idlj+1
        end if
        if(jf.eq.jr.and.jf.ne.ifjsid) istore=istore+1
        if(i.gt.istore) then
           if(jf.eq.1) then
              ibrtag=2
           else
              ibrtag=1
           end if
           icqbar=ifstor(jf)
        end if
        if(iflj(jf).ne.0.and.mqj*jf.ne.jt) px(jf)=px(jf)+pxj(jf)
        if(iflj(jf).ne.0.and.mqj*jf.ne.jt) py(jf)=py(jf)+pyj(jf)
        if(iflj(jf).ne.0.and.n.gt.ie(jf).and.k(ie(jf)+1,1)/10000.eq.6)
     &  p(ie(jf)+1,2)=i-nrs
      endif
      if(jf.eq.jr.and.iflj(jf).ne.0) then
          mqjj=1
      else if(iflj(jf).ne.0.and.mqj.eq.0) then
          mqj=1
      else
          mqjj=0
      end if
      if(iop7.eq.1) then
        if(jf.eq.jt) then
          p(i,5)=emmes
          mmult(1)=kmltme
        else
          p(i,5)=embar
          mmult(2)=kmltba
        end if
      else if(iresex.ne.0.and.jf.eq.jt) then
        k(i,2)=kfbar
        p(i,5)=embar
        mmult(iprtno)=kmltba
      else if(mmult(iprtno).ne.0) then
        minw=mmult(iprtno)
        p(i,5)=getms4(minw,k(i,2),0,-1.0)
      else
        p(i,5)=ulmass(1,k(i,2))
      end if
      if(jf.eq.jt) pr(jf)=p(i,5)**2+(px(jf)+px(3))**2+(py(jf)+py(3))**2
      if(jf.eq.jr) pr(jf)=p(i,5)**2+(px(jf)-px(3))**2+(py(jf)-py(3))**2
  470 continue
      jq=1
      if(p(in(4)+2,3)*p(in(5)+2,3)*four(in(4),in(5)).lt.p(in(7),3)*
     &p(in(8),3)*four(in(7),in(8))) jq=2
      hc12=four(in(3*jq+1),in(3*jq+2))
      hr1=four(n+nrs,in(3*jq+2))/hc12
      hr2=four(n+nrs,in(3*jq+1))/hc12
      if(in(4).ne.in(7).or.in(5).ne.in(8)) then
        px(3-jq)=-four(n+nrs,in(3*jq+3))-px(jq)
        py(3-jq)=-four(n+nrs,in(3*jq+3)+1)-py(jq)
        pr(3-jq)=p(i+(jt+jq-3)**2-1,5)**2+(px(3-jq)+(2*jq-3)*js*
     &  px(3))**2+(py(3-jq)+(2*jq-3)*js*py(3))**2
      endif
      wrem2=wrem2+(px(1)+px(2))**2+(py(1)+py(2))**2
      hd=(sqrt(pr(1))+sqrt(pr(2)))/sqrt(wrem2)
      if(iop7.eq.1.and.hd.ge.1.) then
        write(lun8,*) 'wrem2,pr(1),pr(2)=',wrem2,pr(1),pr(2)
        write(lun8,*) sqrt(wrem2),sqrt(pr(1)),sqrt(pr(2))
        call errex('lusysj:iop7=1 energy too small for final two')
      end if
      if(hd.ge.1.) goto 230
      if(isot.ge.0.and.iprtno.eq.2) then
        if(iop7.eq.1) call errex('lusysj:isot/iop7 conflict')
        iso1=isosp(iabs(k(i-1,2)))
        i31=isign(1,k(i-1,2))*isosp3(iabs(k(i-1,2)))
        iso2=isosp(iabs(k(i,2)))
        i32=isign(1,k(i,2))*isosp3(iabs(k(i,2)))
        punis=cgks(iso1,iso2,isot,i31,i32)
        ipun=2
        if(ranf(0).gt.punis) go to 230
      end if
      if(iopt(7).ne.1.and.
     a         (iopt(3).eq.1.or.iopt(4).eq.1)) then
        call luzdis(0,1,0.,z)
        z=1.0-z
        if(z.lt.0.5) then
          prvrs=1.
        else
          prvrs=0.
        end if
      else if(iopt(5).ne.0.and.iprtno.le.3) then
        prvrs=0.
      else if(icqq.eq.1.and.iprtno.le.3) then
        prvrs=0.0
      else if(iopt(7).ne.1.and.
     a        lrk(1).ne.lrk(2).and.
     a        ((lrk(1).eq.1.and.iprbcq.ne.1).or.
     b         (lrk(2).eq.1.and.iprbcq.ne.2))) then
        if(lrk(1).eq.1) then
          prvrs=0.
        else
          prvrs=1.
        end if
      else
         prvrs=0.5*hd**par(27+mst(4))
      end if
      ha=wrem2+pr(jt)-pr(jr)
      vzdir=js*(ranf(0)-prvrs)
      hb=sign(sqrt(max(0.,ha**2-4.*wrem2*pr(jt))),
     &                                         vzdir)
      if(max(mod(iabs(ifl(1)),10),mod(iabs(ifl(2)),10)).ge.6)
     &  hb=sign(sqrt(max(0.,ha**2-4.*wrem2*pr(jt))),float(js))
      do 480 j=1,4
       p(i-1,j)=(px(jt)+px(3))*p(in(3*jq+3),j)+(py(jt)+py(3))*
     &  p(in(3*jq+3)+1,j)+0.5*(hr1*(ha+hb)*p(in(3*jq+1),j)+
     &  hr2*(ha-hb)*p(in(3*jq+2),j))/wrem2
       p(i,j)=p(n+nrs,j)-p(i-1,j)
  480 continue
      if(mbst.eq.1) then
        mst(1)=n+nrs+1
        mst(2)=i
        call lurobo(0.,0.,ps(1)/pebst,ps(2)/pebst,ps(3)/pebst)
        mst(1)=0
        mst(2)=0
      endif
      if(igpar.ne.0) then
        igparh=mgpar(iabs(k(i,2)))
        igpara=igpara*igparh
        if(igparh.eq.0) igparb=0
        if(igpara.ne.igparb) then
          go to 230
        end if
      end if
      if(jt.eq.1) then
        jtact=3
      else
        jtact=-3
      end if
      call lupos(0.,zact,emht,i-1,jtact,mqj,jfl3,jfla)
      call lupos(0.,zact,emht,i,4,mqjj,-jfl3,jflb)
      ni=i-nrs
      do 490 i=n+1,n+np
  490 k(k(i,1),1)=k(k(i,1),1)+20000
      do 500 i=n+1,ni
      k(i,1)=k(i+nrs,1)
      k(i,2)=k(i+nrs,2)
      do 500 j=1,5
  500 p(i,j)=p(i+nrs,j)
      if(mst(22).ge.1) then
        if(2*ni-n.ge.mst(30)-5-mst(31)) then
          mst(24)=mst(24)+1
          mst(25)=1
          if(mst(23).ge.1) return
        endif
        do 510 i=n+1,ni
        k(i-n+ni,1)=k(i,1)
        k(i-n+ni,2)=k(i,2)
        do 510 j=1,5
  510   p(i-n+ni,j)=p(i,j)
        i1=n
        do 530 i=ni+1,2*ni-n
        if(k(i,1).ne.ie(1)) goto 530
        i1=i1+1
        k(i1,1)=k(i,1)
        k(i1,2)=k(i,2)
        do 520 j=1,5
  520   p(i1,j)=p(i,j)
  530   continue
        do 550 i=2*ni-n,ni+1,-1
        if(k(i,1).eq.ie(1)) goto 550
        i1=i1+1
        k(i1,1)=k(i,1)
        k(i1,2)=k(i,2)
        do 540 j=1,5
  540   p(i1,j)=p(i,j)
  550   continue
      endif
      if(mst(22).ge.2.and.iflstr.ne.0) then
        do 560 i=n+1,n+iflstr
        k(i-n+ni,1)=k(i,1)
        k(i-n+ni,2)=k(i,2)
        do 560 j=1,5
  560   p(i-n+ni,j)=p(i,j)
        do 570 i=n+1,ni
        k(i,1)=k(i+iflstr,1)
        k(i,2)=k(i+iflstr,2)
        do 570 j=1,5
  570   p(i,j)=p(i+iflstr,j)
      endif
      n=ni
      return
      end
       subroutine lupos(z,zact,emht,iact,jt,mqj,jfl3,jfljt)
#include "amsrqmd.h"
      dimension xpos(0:5,100),xprev(2,2),phd(5),pall(4)
      dimension jtstor(100)
      common /luspbk/ pall,iqqsp,ifirst,ibegin,istart,istfl
      common /lujets/ n,k(2000,2),p(2000,5)
      common /lupobk/ xpos,ilund
      common /luopt1/
     a         iopt(20),kfstr,icqq,mbfix,ideltq,ibbcol,
     b         mmult(100),
     a         iprbcq,ilead,iback,ibrtag,icqbar,idlj,klmold,
     b         klbold,isot,misot,lbreak(100),emst,emda,emdb
      common /prinbk/ iprin
      dimension ltagqq(100)
      dimension plchd(2,100)
      save xprev,jerror,pplus,pminus,pp,pm,ifnl2,icqend,
     a     jt1f,ibar,xpold,xmold,xplus,xminus,deltf,deltb,
     b     jlead,jback,jtstor,ltagqq,plchd,plc1f,jtdif
      data isignl/0/
      ifljt=iabs(jfljt)
      ifl3=iabs(jfl3)
      phd(1)=p(iact,1)
      phd(2)=p(iact,2)
      phd(3)=p(iact,3)
      phd(4)=p(iact,4)
      phd(5)=p(iact,5)
      if(iabs(jt).eq.3) then
         if(jt.eq.3) then
           jtdif=0
         else
           jtdif=1
         end if
         jt=3
      else if(jt.eq.4) then
      else
         jtdif=0
      end if
      if(iact.eq.istart) ibegin=0
      if(ifirst.eq.0) then
         ifirst=1
         istart=iact
      end if
      if(ibegin.eq.0) then
         jerror=0
         ibegin=1
         pplus=pall(4)+pall(3)
         pminus=pall(4)-pall(3)
         pm=pminus
         pp=pplus
         ilund=0
         xprev(1,1)=pplus
         xprev(2,1)=0.
         xprev(1,2)=0.
         xprev(2,2)=pminus
         xpold=0.
         xmold=0.
         if(jt.eq.3) then
           ifnl2=1
         else
           ifnl2=0
         end if
         icqend=mod(3-iprbcq,3)
         if(iopt(2).gt.1.and.icqend.ne.1.and.icqend.ne.0) then
            call errex('wrong icqend in lupos')
         end if
         deltf=0.
         deltb=0.
         jlead=0
         ilead=0
         jback=0
         iback=0
         jt1f=0
         ibar=0
      end if
      ilund=ilund+1
      if(jt.eq.4) then
          jtact=2-jtdif
          isignl=1
      else if(jt.eq.3) then
          jtact=1+jtdif
      else
          jtact=jt
      end if
      if(mqj.eq.1) then
        if(jt.eq.4) jtact=1
        ibar=ibar+1
      else if(iqqsp.eq.0.and.jtact.eq.1.and.ibar.eq.0) then
        ibar=ibar+1
      end if
      jtstor(ilund)=jtact
      emhtsq=phd(5)*phd(5)+phd(1)*phd(1)+phd(2)*phd(2)
      emht=sqrt(emhtsq)
      pphd=phd(4)+phd(3)
      pmhd=phd(4)-phd(3)
      if(jtact.eq.1) then
         if(pphd.lt.0.0.or.pplus.lt.0.0) then
           if(jerror.eq.1) then
             write(lun8,*) 'pphd or pplus <0 in lupos  '
             write(lun8,*) pmhd,pphd,(phd(i),i=1,5)
             write(lun8,*) 'pplus,pminus,xmold,xpold'
             write(lun8,*)  pplus,pminus,xmold,xpold
           end if
           pplus=max(pphd,pplus)
           jerror=1
         end if
         if(pphd.gt.pplus+0.001) then
           if(jerror.eq.1) then
             write(lun8,*) 'pphd>pplus in lupos  '
             write(lun8,*) pmhd,pphd,(phd(i),i=1,5)
             write(lun8,*) 'pplus,pminus,xmold,xpold'
             write(lun8,*)  pplus,pminus,xmold,xpold
           end if
           zact=1.
           jerror=1
         else
             zact=pphd/pplus
         end if
         deltp=zact*pplus
         xplus=xpold+(1.-zact)*pplus
         pplus=(1.-zact)*pplus
         deltm=emhtsq/deltp
         pminus=pminus-deltm
         xminus=xmold+deltm
         xmold=xmold+deltm
         if(xmold.gt.1.001*pm) then
             write(lun8,*) 'xmold>pm in lupos?????? '
             write(lun8,*) 'pp,pm,xmold,xpold'
             write(lun8,*)  pp,pm,xmold,xpold
         end if
      else if(jtact.eq.2) then
         if(pmhd.lt.0.0.or.pminus.lt.0.0) then
           if(jerror.eq.1) then
             write(lun8,*) 'pmhd or pminus <0 in lupos  ?????? '
             write(lun8,*) pmhd,pphd,(phd(i),i=1,5)
             write(lun8,*) 'pplus,pminus,xmold,xpold'
             write(lun8,*)  pplus,pminus,xmold,xpold
           end if
           pminus=max(pmhd,pminus)
           jerror=1
         end if
         if(pmhd.gt.pminus+0.001) then
           if(jerror.eq.1) then
             write(lun8,*) 'pmhd>pminus in lupos  ?????? '
             write(lun8,*) pmhd,pphd,(phd(i),i=1,5)
             write(lun8,*) 'pplus,pminus,xmold,xpold'
             write(lun8,*)  pplus,pminus,xmold,xpold
           end if
           zact=1.
           jerror=1
         else
             zact=pmhd/pminus
         end if
         deltm=zact*pminus
         xminus=xmold+(1.-zact)*pminus
         pminus=(1.-zact)*pminus
         deltp=emhtsq/deltm
         pplus=pplus-deltp
         xplus=xpold+deltp
         xpold=xpold+deltp
         if(xpold.gt.1.001*pp) then
             write(lun8,*) 'xpold>pp in lupos?????? '
             write(lun8,*) 'pp,pm,xmold,xpold'
             write(lun8,*)  pp,pm,xmold,xpold
         end if
      else
            write(lun8,*) '??????????? in lupos  jtact=',jtact
      end if
      if(ilund.gt.100) then
          write(lun8,*) 'ilund too large in lupos'
          call errex('array overflow in lupos')
      end if
      plchd(1,ilund)=deltp
      plchd(2,ilund)=deltm
      xpos(4,ilund)=emht
      xpos(1,ilund)=0.
      xpos(2,ilund)=0.
      if((ifl3.gt.10.or.ifljt.gt.10).and.
     a   (ifl3.lt.10.or.ifljt.lt.10)) then
        ltagqq(ilund)=1
      else
        ltagqq(ilund)=0
      end if
      if(iopt(2).le.1.or.ifnl2.eq.1) then
        if(iopt(2).eq.0.or.ifnl2.eq.1) then
          xphad=0.5*(xprev(1,jtact)+ xplus)
          xmhad=0.5*(xprev(2,jtact)+ xminus)
        else
          if(jtact.eq.1) then
             xmhad=xprev(2,1)
             xphad=xplus
          else
             xphad=xprev(1,2)
             xmhad=xminus
          endif
        endif
        if(xphad.gt.pp.or.xphad.lt.0.) then
          write(lun8,*) 'xphad is nonsense  xphad,pp=',xphad,pp
        end if
        if(xmhad.gt.pm.or.xmhad.lt. 0.) then
            write(lun8,*) 'xmhad is nonsense  xmhad,pm=',xmhad,pm
        end if
        xprev(1,jtact)=xplus
        xprev(2,jtact)=xminus
        xpos(0,ilund)=0.5*(xphad+xmhad)
        xpos(3,ilund)=0.5*(xphad-xmhad)
        if(iopt(8).eq.1) then
          if(ltagqq(ilund).eq.1) then
            xpos(0,ilund)=xpos(0,ilund)+0.5*(deltp+deltm)
            xpos(3,ilund)=xpos(3,ilund)+0.5*(deltp-deltm)
          end if
        end if
      else
        xp=xplus-deltb
        xm=xminus-deltf
        if(icqend.ne.1.and.jtact.eq.2.and.jback.eq.0) then
          jback=1
          iback=ilund
          deltb=deltp
          if(iopt(2).eq.2) then
            xphad=0.5*deltp
            xmhad=0.5*deltm
          else
            xphad=0.
            xmhad=0.
          end if
          do 49 il=1,ilund-1
           if(il.eq.ilead) go to 49
           xpos(0,il)=xpos(0,il)-deltb
   49     continue
        else if(icqend.ne.2.and.jtact.eq.1.and.jlead.eq.0
     a            .and.(mqj.eq.1.or.istfl.eq.0.or.iqqsp.eq.0))then
          jlead=1
          ilead=ilund
          deltf=deltm
          plc1f=0.0
          do 50 il=1,ilund-1
           if(il.eq.iback) go to 50
           if(jt1f.gt.0.and.jtstor(il).eq.1) then
             xpos(0,il)=xpos(0,il)-deltp
             plc1f=plc1f+plchd(1,il)
           else if(jtstor(il).eq.1) then
             write(lun8,*) 'lupos-warning:jt1f=0,jtstor=1 before'
           else
             xpos(3,il)=xpos(3,il)-deltm
           end if
   50     continue
          if(icqend.eq.0.and.icqq.ne.2) then
            xphad=pp-(deltp+plc1f)
          else
            if(iopt(2).eq.2) then
              xphad=0.5*deltp
            else
              xphad=0.
            end if
          end if
          if(iopt(2).eq.2) then
            xmhad=0.5*deltm
          else
            xmhad=0.
          end if
        else
          if(jtact.eq.1.and.jlead.eq.0
     a         .and.mqj.eq.0.and.istfl.eq.1) jt1f=jt1f+1
          xphad=xp
          xmhad=xm
        end if
        xpos(0,ilund)=xphad
        xpos(3,ilund)=xmhad
      end if
      if(isignl.eq.1 ) then
         if(istfl.eq.1.and.ibar.ne.1) then
            write(lun8,*) 'wrong ibar for baryon string in lupos',ibar
            call errex('inconsistent baryon fragmentation')
         end if
         if(iopt(2).ge.2.and.ifnl2.eq.0) then
           if(iopt(5).gt.0) then
             if(icqend.ne.1)
     a                call errex('lupos:icqend.ne.1,iopt(5)>0')
             icqend=0
             xprev(1,2)=0.
             xprev(2,2)=pm-deltf
           end if
            if(jlead.gt.0) then
              if(icqend.eq.0.and.icqq.ne.2) then
                if(ilund.gt.jback+1+jt1f) then
                  xpos(0,ilead)=xpos(0,ilead)-deltb
                else
                  if(iopt(2).eq.2) then
                    xpos(0,ilead)=0.5*plchd(1,ilead)
                  else
                    xpos(0,ilead)=0.
                  end if
                end if
              end if
              xprev(1,1)=pp-(plchd(1,ilead)+deltb)
              xprev(2,1)=0.
            else
              xprev(1,1)=pp-deltb
              xprev(2,1)=0.
            end if
            if(iback.gt.0) then
              xprev(1,2)=0.
              xprev(2,2)=pm-(plchd(2,iback)+deltf)
            else
              xprev(2,2)=pm-deltf
              xprev(1,2)=0.
            end if
           do 70 il=1,ilund
            jtact=jtstor(il)
            if(jtact.eq.1) then
              deltxp=0.5*(xprev(1,1)-xpos(0,il))
              deltxm=0.5*(xpos(3,il)-xprev(2,1))
            else
              deltxp=0.5*(xpos(0,il)-xprev(1,2))
              deltxm=0.5*(xprev(2,2)-xpos(3,il))
            end if
            if(il.eq.ilead.or.il.eq.iback) then
              xphad=xpos(0,il)
              xmhad=xpos(3,il)
              if(il.eq.ilead) then
                xprev(1,1)=pp-(plchd(1,il)+deltb+plc1f)
                xprev(2,1)=0.
              end if
            else if(jt1f.gt.0.and.jtact.eq.1) then
              jt1f=jt1f-1
              if(iopt(2).eq.2) then
                xphad=0.5*plchd(1,il)
                xmhad=0.5*plchd(2,il)
              else
                xphad=0.
                xmhad=0.
              end if
            else
              if(iopt(2).eq.2) then
                xphad=0.5*(xprev(1,jtact)+ xpos(0,il))
                xmhad=0.5*(xprev(2,jtact)+ xpos(3,il))
              else
                if(jtact.eq.1) then
                  xmhad=xprev(2,1)
                  xphad=xpos(0,il)
                else
                  xphad=xprev(1,2)
                  xmhad=xpos(3,il)
                end if
              end if
              xprev(1,jtact)=xpos(0,il)
              xprev(2,jtact)=xpos(3,il)
              if(deltxp.le.0.0.or.deltxm.le.0.0) then
                write(lun8,*)
     a            'lupos:deltxp.or.deltxm.le.0.0',deltxp,deltxm
                jerror=2
              end if
              inkrem=0
              if(ilead.eq.0.or.iback.eq.0) inkrem=1
              if(ilund.eq.3-inkrem) then
                xmhad=xmhad+deltf
              end if
            end if
            if(iopt(8).eq.1.and.ilund.gt.3-inkrem) then
              if(ltagqq(il).eq.1) then
                xphad=xphad+deltxp
                xmhad=xmhad+deltxm
              end if
            end if
            xpos(0,il)=0.5*(xphad+xmhad)
            xpos(3,il)=0.5*(xphad-xmhad)
   70      continue
         end if
         isignl=0
         ifirst=0
         ibegin=0
         istart=0
         if(jerror.eq.1) then
            write(lun8,*) 'jerror=1 in lupos energy and/or momentum'
            write(lun8,*) 'is violated. ??????????????????? '
         else if(jerror.eq.2) then
            write(lun8,*) 'jerror=2 in lupos'
         end if
      end if
      return
      end
      function  kresm(jqqb,igfix,idn,minv,maxv,kfmes,emmes)
#include "amsrqmd.h"
       common /ludat1s/ mst(40),par(80)
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       if(idn.lt.0.or.idn.gt.8)
     a      call errex('kresm: wrong input idn')
       if(maxv.lt.0.or.maxv.gt.mxmsta(idn))
     a      call errex('kresm: wrong input maxv')
       if(minv.gt.maxv)
     a      call errex('kresm: minv>maxv')
       vmin=float(minv)
       vmax=float(maxv+1)
       itry=0
   33  continue
       itry=itry+1
       if(itry.gt.100)  then
         write(lun8,*) jqqb,igfix,idn,minv,maxv,kfmes
         call errex('kresm abort: itry>100')
       end if
       if(maxv.eq.minv) then
         kmult=maxv
       else
         kmult=minv+int((vmax-vmin)*ranf(0))
         if(kmult.gt.maxv) kmult=maxv
       end if
       if(idn.le.4) then
         strrat=0.2*(jspmes(kmult,idn)+1.)
       else
         strrat=0.333333*(jspmes(kmult,idn)+1.)
       end if
       if(ranf(0).gt.strrat)  go to 33
       if(jqqb.eq.0) then
         if(idn.le.4) then
           angmx=anglmx(kmult,1)/180.0*par(71)
         else
           angmx=anglmx(kmult,2)/180.0*par(71)
         end if
         kfmold=kfmes
         if(kfmes.eq.24.or.kfmes.eq.25) then
           probch=0.66667*(cos(angmx)+sin(angmx)/sqrt(2.0))**2
           if(ranf(0).lt.probch) kfmes=24+25-kfmes
         else if(kfmes.eq.34.or.kfmes.eq.35) then
           probch=0.66667*(sin(angmx)-cos(angmx)/sqrt(2.0))**2
           if(ranf(0).lt.probch) kfmes=34+35-kfmes
         end if
         if(kfmold.ne.kfmes) then
           if(kfmes.eq.24) then
             idn=2
           else if(kfmes.eq.25) then
             idn=3
           else if(kfmes.eq.34) then
             idn=6
           else if(kfmes.eq.35) then
             idn=7
           end if
         end if
       end if
       if(kmult.eq.0) then
         emmes=ulmass(1,kfmes)
       else
         emres=emmesr(kmult,idn)
         widres=gammes(kmult,idn)
         emmin=emmmin(idn)
         cr=2.*(emmin-emres)/widres
         cr1=atan(cr)
         cr2=par(71)/2.-cr1
         emmx=2.8
         if(emmx.lt.emmin)
     a           call errex('too low maximum m mass in kresm')
         xmax=(atan(2.*(emmx-emres)/widres)-cr1)/ cr2
         xmax=min(1.0,xmax)
         mtry=0
   10    continue
         xx=xmax*ranf(0)
         t=tan(xx*cr2)
         emmes=emres+.5*widres*(cr+t)/(1.-cr*t)
         if(igfix.eq.1) then
           prbmxa=3.*widres/((emmes-emres)**2+0.25*widres**2)
           gamr=dcrm(kmult,kfmes,emmes)
           if(gamr.le.0.0) go to 10
           prbact=gamr/((emmes-emres)**2+0.25*gamr**2)
           mtry=mtry+1
           if(mtry.lt.30.and.ranf(0).gt.prbact/prbmxa) go to 10
           if(mtry.eq.30)
     a         write(lun8,*) 'warning:mtry=30,kresm'
         end if
       end if
       kresm=kmult
      return
      end
      function kresb(igfix,idn,minv,maxv,kfbar,embar)
#include "amsrqmd.h"
       common /ludat1s/ mst(40),par(80)
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       if(idn.le.0.or.idn.gt.8)
     a      call errex('kresb: wrong input idn')
       if(minv.gt.maxv)
     a      call errex('kresb: minv>maxv')
       vmax=float(maxv+1)
       vmin=float(minv)
       itry=0
   33  continue
       itry=itry+1
       if(itry.gt.100)  call errex('kresb abort: itry>100')
       if(maxv.eq.minv) then
         kmult=maxv
       else
         kmult=minv+int((vmax-vmin)*ranf(0))
         if(kmult.gt.maxv) kmult=maxv
       end if
       if(kmult.lt.minv.or.kmult.gt.min(maxv,mxbsta(idn)))
     a      call errex('kresb: wrong kmult')
       strrat=0.125*(jspbar(kmult,idn)+1.)
       if(ranf(0).gt.strrat)  go to 33
       if(kmult.eq.0) then
         embar=ulmass(1,kfbar)
       else
         emres=embarr(kmult,idn)
         widres=gambar(kmult,idn)
         emmin=embmin(idn)
         emmin=max(emmin,emres-2.*widres)
         emmx=2.8
         if(emmx.lt.emmin)
     a           call errex('too low maximum b mass in kresb')
         cr=2.*(emmin-emres)/widres
         cr1=atan(cr)
         cr2=par(71)/2.-cr1
         xmax=(atan(2.*(emmx-emres)/widres)-cr1)/ cr2
         xmax=min(1.0,xmax)
         mtry=0
   10    continue
         xx=xmax*ranf(0)
         t=tan(xx*cr2)
         embar=emres+.5*widres*(cr+t)/(1.-cr*t)
         if(igfix.eq.1) then
           prbmxa=3.*widres/((embar-emres)**2+0.25*widres**2)
           gamr=dcr(kmult,kfbar,embar)
           if(gamr.le.0.0) then
             call errex('kresb:dcr abort')
           end if
           prbact=gamr/((embar-emres)**2+0.25*gamr**2)
           mtry=mtry+1
           if(mtry.lt.30.and.ranf(0).gt.prbact/prbmxa) go to 10
           if(mtry.eq.30)
     a         write(lun8,*) 'warning:mtry=30,kresb'
         end if
       end if
       kresb=kmult
      return
      end
      subroutine kfindb(kswi,ifla,iflb,iflc,ifld,kfbar)
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
#include "amsrqmd.h"
       common /wghblk/ flvwgh(8)
       parameter (kbart=18)
       dimension icon(kbart),iwgh(kbart)
       dimension ip(4),iq(3)
       data icon/
     a           41,42,43,44,45,46,47,57,61,
     b           62,63,64,65,66,67,68,69,70
     c           /
       data iwgh/
     a           2,2,4,4,4,5,5,3,1,1,1,1,6,6,6,7,7,8/
       dimension  iba(4)
       mfla=ifla
       mflb=iflb
       mflc=iflc
       if(mfla.lt.0) then
          mfla=-mfla
          mflb=-mflb
          mflc=-mflc
          ivz=-1
       else
          ivz=1
       end if
       kfbar=0
       mtry=0
  402  continue
       mtry=mtry+1
       if(mtry.gt.600) then
         call errex('kfindb abort: mtry.gt.300')
       end if
       lb=min(kbart,int(ranf(0)*kbart)+1)
       ilb=icon(lb)
       call luiflv(ilb,ilbfla,ilbflb,ilbflc,ksp)
       istart=int(ranf(0)*3.0)
       isucc=0
       iqnew=0
       probqp=0.0
       do 401 ieff=istart,istart+2
        ifl=mod(ieff,3)+1
        iq(1)=ilbfla
        iq(2)=ilbflb
        iq(3)=ilbflc
        ip(1)=ifl
        ip(2)=mfla
        ip(3)=mflb
        ip(4)=mflc
        do 397 k=1,4
        do 397 j=1,3
         if(ip(k).eq.iq(j)) then
           ip(k)=0
           iq(j)=0
         end if
  397   continue
        if(iq(1)+iq(2)+iq(3).eq.0) then
          if(kswi.ne.1.and.(ip(2)+ip(3).ne.0
     a                      .or.ip(1).ne.0))go to 401
          kfbar=ilb
          if(ip(1).ne.0) then
            if(ifl.eq.3.and.ranf(0).gt.ssbdif) go to 401
            nflb=10*mfla+mflb
            nfla=ifl
            iqnew=ifl
            probqp=probqp+1.0
            iflc=1
          else if(ip(2).ne.0) then
            nfla=mfla
            nflb=10*mflb+mflc
            iqnew=ifl
            probqp=probqp+1.0
            iflc=0
          else if(ip(3).ne.0) then
            nfla=mflb
            nflb=10*mfla+mflc
            iqnew=ifl
            probqp=probqp+1.0
            iflc=0
          else if(ip(4).ne.0) then
            nflb=10*mfla+mflb
            nfla=mflc
            iqnew=ifl
            probqp=probqp+1.0
            iflc=0
          else
            call errex('garbage in kfindb')
          end if
          isucc=1
        end if
  401  continue
       if(isucc.eq.0) go to 402
       if(ranf(0).gt.probqp*flvwgh(iwgh(lb))) go to 402
       if(kfbar.eq.0)  call errex('kfindb:kfbar=0')
       kfbar=ivz*kfbar
       ifla=ivz*nfla
       iflb=ivz*nflb
       ifld=ivz*iqnew
      return
      end
      function idnbar(kf)
#include "amsrqmd.h"
        kfbabs=iabs(kf)
        if(kfbabs.ge.41.and.kfbabs.le.42) then
          idnbar=2
        else if(kfbabs.ge.61.and.kfbabs.le.64) then
          idnbar=1
        else if(kfbabs.eq.57) then
          idnbar=3
        else if(kfbabs.ge.43.and.kfbabs.le.45) then
          idnbar=4
        else if(kfbabs.ge.46.and.kfbabs.le.47) then
          idnbar=5
        else if(kfbabs.ge.65.and.kfbabs.le.67) then
          idnbar=6
        else if(kfbabs.ge.68.and.kfbabs.le.69) then
          idnbar=7
        else if(kfbabs.eq.70) then
          idnbar=8
        else
          idnbar=0
        end if
      return
      end
      function idnmes(kf)
#include "amsrqmd.h"
       kfa=iabs(kf)
       if(kfa.eq.17.or.kfa.eq.23) then
         idnmes=1
       else if(kf.eq.24) then
         idnmes=2
       else if(kf.eq.25) then
         idnmes=3
       else if(kfa.eq.18.or.kfa.eq.19) then
         idnmes=4
       else if(kfa.eq.27.or.kfa.eq.33) then
         idnmes=5
       else if(kf.eq.34) then
         idnmes=6
       else if(kf.eq.35) then
         idnmes=7
       else if(kfa.eq.28.or.kfa.eq.29) then
         idnmes=8
       else
         call errex('wrong input in idnmes')
       end if
      return
      end
      subroutine notsto(iswi,
     a            kfbar,kfmes,kmltba,kmltme,
     b            iflb,ifla,ifl3,kdfr,embar,emmes)
        save
     a            lfbar,lfmes,lmltba,lmltme,
     b            jflb,jfla,jfl3,ldfr,fmbar,fmmes
#include "amsrqmd.h"
       data lfbar /0/
       if(iswi.ne.0) then
         lfbar=kfbar
         lfmes=kfmes
         lmltba=kmltba
         lmltme=kmltme
         jflb=iflb
         jfla=ifla
         jfl3=ifl3
         ldfr=kdfr
         fmbar=embar
         fmmes=emmes
       else
         if(lfbar.eq.0) call errex('notsto-abort')
         kfbar=lfbar
         kfmes=lfmes
         kmltba=lmltba
         kmltme=lmltme
         iflb=jflb
         ifla=jfla
         ifl3=jfl3
         kdfr=ldfr
         embar=fmbar
         emmes=fmmes
         lfbar=0
       end if
      return
      end
      block data resdat
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       data embarr /
     a  1.23,1.60,1.62,1.70,1.90,1.905,1.910,1.92,1.93,1.95,2*0.0,
     b  0.938,1.44,1.52,1.535,1.65,1.675,1.680,1.7,1.71,1.72,1.99,0.0,
     c  1.116,1.407,1.52,1.60,1.675,1.69,1.80,1.81,1.82,1.83,1.89,1.90,
     d  1.192,1.66,1.67,1.75,1.775,1.80,1.85,1.86,1.87,1.915,2*0.0,
     e  1.318,1.74,1.82,1.835,1.945,1.95,2.00,2.01,2.02,2.040,2*0.0,
     f  1.385,1.75,1.77,1.94,2.03,2.05,2.055,2.06,2.07,2.08,2*0.0,
     g  1.533,1.90,1.92,2.00,2.13,2.20,2.205,2.21,2.22,2.23,2*0.0,
     h  1.672,2.05,2.07,2.15,2.35,2.355,2.36,2.37,2.38,2.40,2*0.0
     i             /
       data gambar /
     a   0.12,0.25,0.16,0.280,0.15,0.300,0.220,0.22,0.25,0.24,2*0.0,
     b   -1.0,0.20,0.125,0.15,0.15,0.155,0.125,0.1,0.11,0.20,0.29,0.0,
     c   -1.0,.050,.0155,.15,.045,.046,.30,.15,.062,.095,.10,.085,
     d   -1.0,0.10,0.06,0.09,0.12,0.127,0.085,0.093,0.170,0.120,2*0.0,
     e   -1.0,0.124,.025,.076,.084,.093,.062,.068,.124,.059,2*0.0,
     f   0.036,0.212,0.136,0.22,0.18,0127,0.255,0.187,0.212,0.212,2*0.0,
     g   0.0095,0.155,.099,.174,.046,.093,.186,.136,.155,.155,2*0.0,
     h   .054,.112,.072,.126,.067,.135,.099,.112,.112,.108,2*0.0
     i             /
       data embmin /1.079,1.079,1.340,1.340,1.460,1.340,1.460,1.820/
       data nstatb /
     a               4,8,10,14,16,22,24,28,34,42,2*0,
     b               2,4, 8,10,12,18,24,28,30,34,42,0,
     c               2,4,8,10,12,16,18,20,26,32,36,40,
     d               2,4,8,10,16,18,22,24,28,34,2*0,
     e               2,4,8,10,16,18,22,24,28,34,2*0,
     f               4,8,10,14,22,24,30,32,36,42,2*0,
     g               4,8,10,14,22,24,30,32,36,42,2*0,
     h               4,8,10,14,16,22,24,28,34,42,2*0
     i             /
       data mxbsta /9,9,11,9,9,9,9,9/
       data jspbar /
     a               3,3,1,3,1,5,1,3,5,7,2*0,
     b               1,1,3,1,1,5,5,3,1,3,7,0,
     c               1,1,3,1,1,3,1,1,5,5,3,3,
     d               1,1,3,1,5,1,3,1,3,5,2*0,
     e               1,1,3,1,5,1,3,1,3,5,2*0,
     f               3,3,1,3,7,1,5,1,3,5,2*0,
     g               3,3,1,3,7,1,5,1,3,5,2*0,
     h               3,3,1,3,1,5,1,3,5,7,2*0
     i             /
       data emmesr /
     a   0.138,0.980,1.260,1.318,8*0.0,
     b   0.550,1.400,1.420,1.270,8*0.0,
     c   0.958,0.975,1.510,1.525,8*0.0,
     d   0.495,1.430,1.270,1.430,8*0.0,
     e   0.770,-1.0, 1.233, -1.0,8*0.0,
     f   0.783,-1.0, 1.170, -1.0,8*0.0,
     g   1.020,-1.0, 1.510, -1.0,8*0.0,
     h   0.895,-1.0, 1.400, -1.0,8*0.0
     i             /
       data gammes /
     a   -1.0,   0.057,0.138,0.110,8*0.0,
     b   -1.0,   0.600,0.055,0.185,8*0.0,
     c   2.8e-4, 0.053,0.035,0.076,8*0.0,
     d   -1.0,   0.287,0.090,0.098,8*0.0,
     e   0.154,  -1.0, 0.150, -1.0,8*0.0,
     f   0.0099, -1.0, 0.311, -1.0,8*0.0,
     g   0.00421,-1.0, 0.035, -1.0,8*0.0,
     h   0.0508, -1.0, 0.174, -1.0,8*0.0
     i             /
       data emmmin /0.69,0.4,1.0,0.64,0.69,0.4,1.0,1.1/
       data nstatm /
     a               1,2,5,10,8*0,
     b               1,2,5,10,8*0,
     c               1,2,5,10,8*0,
     d               1,2,5,10,8*0,
     e               3,3,6,6,8*0,
     f               3,3,6,6,8*0,
     g               3,3,6,6,8*0,
     h               3,3,6,6,8*0
     i             /
       data mxmsta /3,3,3,3,2,2,2,2/
       data jspmes /
     a               0, 0, 2, 4,8*0,
     b               0, 0, 2, 4,8*0,
     c               0, 0, 2, 4,8*0,
     d               0, 0, 2, 4,8*0,
     e               2,-1, 2,-1,8*0,
     f               2,-1, 2,-1,8*0,
     g               2,-1, 2,-1,8*0,
     h               2,-1, 2,-1,8*0
     i             /
       data anglmx /
     a          -18.0,-54.74,-54.74,-54.74,8*0.0,
     b           41.0, 0.0 ,35.26,  0.0,8*0.0
     c             /
       data qqbdif,ssbdif /0.0,0.3/
      end
      function prcms(a,b,c)
#include "amsrqmd.h"
       if(b+c.gt.a)
     a      call errex('prcms-abort')
       prcms=sqrt((a**2-(b+c)**2)*(a**2-(b-c)**2))/(2.*a)
      return
      end
      function pssbar(ida55,pr)
#include "amsrqmd.h"
       if(ida55.eq.0) then
         pssbar=0.2
       else
         pssbar=0.3
       end if
      return
      end
      subroutine bresdc(imany,
     a                   iflfb,iflfa,ichobr,nbfix,
     b                   kswi,ida53,ida55,klbol,klmol,emstr,emda,emdb,
     c                   kfbar,kfmes,kmltba,kmltme,
     d                   iflb,ifla,ifl3,kdfr,embar,emmes,ptx,pty
     e                 )
#include "amsrqmd.h"
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
        common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       common /ludat1s/ mst(40),par(80)
       dimension  jentbx(8),jentmx(8),flwwgh(8)
       common /wghblk/ flvwgh(8)
       dimension imbout(5,8)
       data  (imbout(1,i),i=1,8) /
     a         1,1,2,2,0,2,0,0/
       data  (imbout(2,i),i=1,8) /
     b         2,2,3,1,2,1,2,0/
       data  (imbout(3,i),i=1,8) /
     b         2,2,1,1,2,1,2,0/
       data  (imbout(4,i),i=1,8) /
     c         0,0,2,2,1,2,1,2/
       data  (imbout(5,i),i=1,8) /
     d         0,0,0,0,2,0,2,1/
       dimension icho(6)
       data icho / 1,1,2,3,4,5 /
        mbfix=nbfix
        klmold=klmol
        klbold=klbol
        if(ida55.gt.0) then
          if(emda+emdb.gt.emstr) then
            write(lun8,*) 'bresdc-warning:imag.prold',emstr,emda,emdb
            ida55=0
            mbfix=0
            klbold=0
            klmold=0
            write(lun8,*) 'ida55,mbfix,klbold,klmold',
     a                  ida55,mbfix,klbold,klmold,'set to 0'
            prold=0.0
          else
            prold=prcms(emstr,emda,emdb)
          end if
        else
          prold=-1.0
        end if
        imany=0
        em2nur=2.8
        jgfix=1
        if(ichobr.le.2) then
          mflt=0
        else if(ichobr.eq.3.or.ichobr.eq.4) then
          mflt=1
        else if(ichobr.eq.5) then
          mflt=2
        else if(ichobr.eq.6) then
          mflt=3
        end if
        em2nur=em2nur+mflt*0.15
        if(ichobr.eq.2.or.ichobr.eq.5) then
          isotot=1
        else if(ichobr.eq.1) then
          isotot=3
        else if(ichobr.eq.3) then
          isotot=0
        else if(ichobr.eq.4) then
          isotot=2
        else if(ichobr.eq.6) then
          isotot=0
        end if
        nscod=0
        if(mbfix.gt.0) then
          nscod=mbfix/100
          mbfix=mod(mbfix,100)
          idnfix=mbfix/10
          jdnfix=mod(mbfix,10)
        else if(-mbfix.ge.5.and.-mbfix.le.9.and.
     a                           emstr.lt.1.55) then
          if(-mbfix.eq.5) then
            mbfix=61
            idnfix=6
            jdnfix=1
          else
            idnfix=9
            jdnfix=9
          end if
        else
          idnfix=0
          jdnfix=0
        end if
        do 105 idn=1,8
         jentbx(idn)=-1
         if(idnfix.eq.9) then
           jentbx(idn)=0
           go to 105
         end if
         if(mbfix.gt.0) then
           embam=emstr
         else if(imbout(icho(ichobr),idn).eq.0) then
           embam=0.0
         else if(imbout(icho(ichobr),idn).eq.1) then
           embam=emstr-0.14
         else if(imbout(icho(ichobr),idn).eq.2) then
           embam=emstr-0.496
         else if(imbout(icho(ichobr),idn).eq.3) then
           embam=emstr-0.55
         end if
         do 104 ms=0,mxbsta(idn)
          if(embarr(ms,idn).gt.embam) go to 105
          jentbx(idn)=ms
  104    continue
  105   continue
        stamax=0.0
        do 106 idn=1,8
         if(jentbx(idn).eq.-1) go to 106
         staidn=float(nstatb(jentbx(idn),idn))
         if(staidn.gt.stamax) then
           stamax=staidn
         end if
  106   continue
        if(stamax.eq.0.0)  then
          call errex('bresdc:stamax=0, abort')
        end if
        stamax=3.*stamax
        do 107 idn=1,8
         if(jentbx(idn).eq.-1) then
           flvwgh(idn)=0.0
           go to 107
         end if
         staidn=float(nstatb(jentbx(idn),idn))
         flvwgh(idn)=staidn/stamax
         if(idnfix.gt.0.and.idnfix.le.8) then
           if(idn.ne.idnfix) then
             flvwgh(idn)=0.0
           else
             flvwgh(idn)=0.333333
             jentbx(idn)=0
           end if
         end if
  107   continue
        if(ichobr.eq.5) then
          emmam=emstr-1.16
        else if(ichobr.eq.6) then
          emmam=emstr-1.32
        else
          emmam=emstr-0.94
        end if
        do 203 jdn=1,8
         jentmx(jdn)=0
         if(jdnfix.eq.9) go to 203
         do 204 ms=0,mxmsta(jdn)
          if(emmesr(ms,jdn)
     a                                    .gt.emmam) go to 203
          jentmx(jdn)=ms
  204   continue
  203   continue
        jentmx(2)=max(jentmx(2),jentmx(3))
        jentmx(3)=jentmx(2)
        jentmx(6)=max(jentmx(6),jentmx(7))
        jentmx(7)=jentmx(6)
        do 205 jdn=1,8
         flwwgh(jdn)=nstatm(jentmx(jdn),jdn)
         if(jdnfix.gt.0.and.jdnfix.le.8) then
           if(jdn.ne.jdnfix) then
             flwwgh(jdn)=0.0
           else
             flwwgh(jdn)=1.0
             jentmx(jdn)=0
           end if
         end if
  205   continue
        if(jentmx(2).ne.jentmx(3).or.
     a           jentmx(6).ne.jentmx(7)) then
          call errex('bresdc:different no. of meson states')
        end if
        do 208 jdn=1,4
  208   flwwgh(jdn)=flwwgh(jdn)+flwwgh(4+jdn)
        stamax=flwwgh(1)
        do 206 jdn=2,4
         stajdn=flwwgh(jdn)
         if(stajdn.gt.stamax) then
           stamax=stajdn
         end if
  206   continue
        do 207 jdn=1,4
         flwwgh(jdn)=flwwgh(jdn)/stamax
         flwwgh(jdn+4)=flwwgh(jdn+4)/stamax
  207   continue
        para8=par(8)
        para9=par(9)
        par(8)=0.
        par(9)=0.
        notst=0
        mtry=0
  102   continue
        mtry=mtry+1
        if(mtry.gt.800) then
          if(notst.eq.0) then
            if(klbold.eq.0.and.kswi.eq.1) then
              if(ichobr.eq.3.and.emstr.gt.1.34) then
                newchr=int(3.*ranf(0))-1
                klbold=44+newchr
                klbold=isign(1,iflfa)*klbold
                klmold=isign(1,iflfa)*newchr*17+(1-iabs(newchr))*23
                write(lun8,*) 'not:',klbold, klmold,newchr
              end if
            end if
            if(klbold.ne.0) then
              write(lun8,*)'bresdc102:infinite loop????? ',notst
              kfbar=isign(1,iflfa)*mod(iabs(klbold),100)
              kfmes=isign(1,klmold)*mod(iabs(klmold),100)
              if(kfmes.ne.23.and.kfmes.ne.24.and.kfmes.ne.25
     a                    .and.kfmes.ne.34.and.kfmes.ne.35) then
                kfmes=isign(1,iflfa)*kfmes
              end if
              mmtry=0
 1102         continue
              mmtry=mmtry+1
              if(mmtry.gt.200) then
                write(lun8,*)
     a                   iflfb,iflfa,ichobr,nbfix,
     b                   kswi,ida53,ida55,klbol,klmol,emstr,emda,emdb
                call errex('bresdc:mmtry abort')
              end if
              emmes=getms4(0,kfmes,jgfix,emstr)
              embar=getms4(0,kfbar,jgfix,emstr)
              if(abs(embar)+abs(emmes).ge.emstr) go to 1102
              kmltba=0
              kmltme=0
              kdfr=0
              call luiflv(kfbar,mfla,mflb,mflc,ksp)
              iflb=10*mfla+mflb
              call luiflv(kfmes,mfla,mflb,mflc,ksp)
              if(mfla*iflb.gt.0) then
                ifla=mfla
                ifl3=mflb
              else
                ifla=mflb
                ifl3=mfla
              end if
            else
              if(kswi.eq.2) then
                write(lun8,*)'bresdc102:infinite loop????? ',notst
                write(lun8,*) 'kswi=2'
                kswi=1
                mtry=0
                go to 102
              end if
              write(lun8,*)
     a          iflfb,iflfa,nbfix,emstr,
     b          kswi,ichobr,ida53,ida55,klbol ,klmol ,prol
              call errex('bresdc102:infinite loop?? ')
            end if
          else
            write(lun8,*)'bresdc102:infinite loop????? ',notst
            call notsto(0,
     a                kfbar,kfmes,kmltba,kmltme,
     b                iflb,ifla,ifl3,kdfr,embar,emmes)
          end if
          par(8)=para8
          par(9)=para9
          pr4=prcms(emstr,emmes,embar)
          pt=pr4*sqrt(1.-ranf(0)**2)
          phi=par(72)*ranf(0)
          ptx=pt*cos(phi)
          pty=pt*sin(phi)
          return
        end if
        mfla=iflfb/10
        mflb=iflfb-10*mfla
        mflc=iflfa
        call kfindb(kswi,mfla,mflb,mflc,mfld,kfbar)
        kfbabs=iabs(kfbar)
        mfld=-mfld
        iflb=mflb
        ifla=mfla
        ifl3=mfld
        kdfr=mflc
        if(iabs(mfld).eq.3.and.ranf(0).gt.0.3) then
          go to 102
        end if
        call luifld(mfla,0,mfld,ifldmp,kfmes)
        if(kfmes.eq.26)  go to 102
        if(iabs(mfla).eq.3) then
          if(kfmes.eq.24) kfmes=25
        else
          if(kfmes.eq.25) kfmes=24
        end if
        kfmesa=iabs(kfmes)
        iso1=isosp(kfbabs)
        i31=isign(1,kfbar)*isosp3(kfbabs)
        iso2=isosp(kfmesa)
        i32=isign(1,kfmes)*isosp3(kfmesa)
        punis=cgks(iso1,iso2,isotot,i31,i32)
        if(ranf(0).gt.punis) go to 102
        jdn=idnmes(kfmes)
        if(jdn.gt.4)  then
          write(lun8,*) 'bresdc,iop7=1, unknown meson code',jdn,mfla,mfl
          if(jdn.le.8)  then
            jdn=jdn-4
            kfmes=isign(1,kfmes)*(kfmesa-10)
            kfmesa=iabs(kfmes)
          end if
        end if
        if(ranf(0).gt.flwwgh(jdn)) go to 102
        if(ranf(0).lt.flwwgh(jdn+4)/flwwgh(jdn)) then
          jdn=jdn+4
          kfmes=isign(1,kfmes)*(kfmesa+10)
        end if
        maxw=jentmx(jdn)
        minw=0
        igfix=0
        kmltme=kresm(0,igfix,jdn,minw,maxw,kfmes,emmes)
        idn=idnbar(kfbabs)
        if(nscod.ne.0) then
          minv=nscod
          maxv=nscod
        else if(idn.gt.0) then
          minv=0
          maxv=jentbx(idn)
        else
          minv=0
          maxv=0
        end if
        kmltba=kresb(igfix,idn,minv,maxv,kfbar,embar)
        if(notst.ne.1) then
          emme0=getms4(0,kfmes,jgfix,emstr)
          emba0=getms4(0,kfbar,jgfix,emstr)
          if(abs(emba0)+abs(emme0).lt.emstr) then
            notst=2
            call notsto(1,
     a           kfbar,kfmes,0,0,
     b           iflb,ifla,ifl3,kdfr,emba0,emme0)
          end if
        end if
        if(emstr.lt.emmes+embar+0.001) go to 102
        pr4=prcms(emstr,emmes,embar)
        prmb=pr4
        irgs23=0
        if(mbfix.le.0.and.ida55.gt.0) then
          kfms=100*isign(kmltme,kfmes)+kfmes
          kfbr=100*isign(kmltba,kfbar)+kfbar
          rgs=regsup(ida55,kfms,kfbr,klmold,klbold,mfld,kex,
     a                       prmb,prold,emstr,pr0reg,spower,iscons)
          if(rgs.lt.1.0) then
            if(ranf(0).gt.rgs) then
              if(emstr.le.em2nur) then
                go to 102
              else
                if(em2nur.gt.emmes+embar
     a                 .and.em2nur.gt.emda+emdb) then
                  prol1=prcms(em2nur,emda,emdb)
                  prmb1=prcms(em2nur,emmes,embar)
                  ida55d=-1000
                  rgs1=regsup(ida55d,kfms,kfbr,klmold,klbold,mfld,kex,
     a                        prmb1,prol1,em2nur,pr0reg,spower,iscons)
                else
                  rgs1=rgs
                end if
                prb2n3=rgs1-rgs
                if(prb2n3.lt.-1.e-4) then
                  write(lun8,*) 'rgs,rgs1=',rgs,rgs1,emstr,prmb,prold
                  write(lun8,*)
     a               kfms,kfbr,klmold,klbold,mfld,kex,
     b                      prmb1,prol1,em2nur,spower
                  call errex('rgs increasing with energy')
                end if
                if(ranf(0).lt.prb2n3) then
                  irgs23=1
                else
                  go to 102
                end if
              end if
            end if
          end if
        end if
        if(mbfix.lt.0) then
          mbfi=-mbfix
          idnjdn=10*idn+jdn
          if(mbfi.eq.5) then
            if(kmltme.eq.0.and.kmltba.eq.0.and.
     a         (idnjdn.eq.24.or.((idnjdn.eq.31.or.
     b                              idnjdn.eq.41)
     c                            .and.emstr.lt.2.50
     d                                              )
     e                                             )) go to 102
          else if(mbfi.eq.6) then
            if(kmltme.eq.0.and.kmltba.eq.0.and.
     a                               idnjdn.eq.24) go to 102
          else if(mbfi.eq.11) then
            if(kmltme.eq.0.and.kmltba.eq.0.and.
     a                               idnjdn.eq.21) go to 102
          else if(mbfi.eq.13) then
            if(kmltme.eq.0.and.idnjdn.eq.21
     b                                      ) go to 102
          else if(mbfi.eq.15) then
            if(kmltme.eq.0.and.
     a         (idnjdn.eq.21
     a           .or.(idnjdn.eq.44.and.kmltba.eq.0))) go to 102
          else
            call errex('uninitialized mbfi in bresdc')
          end if
        end if
        if(ida55.eq.0.and.iabs(mfld).eq.3) then
          ratz=pssbar(ida55,pr4)/0.3
          if(ranf(0).gt.ratz) go to 102
        end if
        notst=1
        call notsto(1,
     a         kfbar,kfmes,kmltba,kmltme,
     b         iflb,ifla,ifl3,kdfr,embar,emmes)
        if(ida53.eq.0.or.mbfix.gt.0) then
          mttry=0
  302     continue
          par12=par(12)
          if(mbfix.gt.0) then
            par(12)=min(par(12),
     a          sqrt(0.66667*prcms(emstr,emmes,embar)**2))
          end if
          call luptdi(ifla,ptx,pty)
          par(12)=par12
          ptsq=ptx**2+pty**2
          ksuff=0
          if(emstr.lt.sqrt(emmes**2+ptsq)+
     a                sqrt(embar**2+ptsq)+0.001) ksuff=1
          if(mtry.le.400) then
            if(ksuff.eq.1) go to 102
          else
            mttry=mttry+1
            if(mttry.lt.50) then
              if(ksuff.eq.1)  go to 302
            else
              if(ksuff.eq.1)  go to 102
            end if
          end if
        else if(ida53.eq.1) then
          avan=1.2
          kvan=2
          emtmx=2.5
          probmx=(0.5*kvan/avan)**kvan/exp(float(kvan))
          if(emstr.gt.2.*emtmx) then
            emtm1=emtmx
            emtm2=emtmx
            probmx=min(probmx,prcms(emstr,emtm1,emtm2)**kvan*
     a             exp(-avan*sqrt(emstr**2-4.*emtmx**2)))
          end if
          probmx=max((0.5*emstr)**kvan*exp(-avan*emstr),probmx)
          probac=prcms(emstr,emmes,embar)**kvan*
     a             exp(-avan*sqrt(emstr**2-(emmes+embar)**2))
          if(probac.gt.probmx)
     a        call errex('bresdc: probac>probmx')
          if(ranf(0).gt.probac/probmx) go to 102
        end if
        if(mbfix.le.0) then
          ltry=0
  202     ltry=ltry+1
          if(ltry.gt.200) call errex('bresdc202: infinite loop? ')
          par12=par(12)
          par(12)=min(par(12),
     a          sqrt(0.66667*prcms(emstr,emmes,embar)**2))
          call luptdi(ifla,ptx,pty)
          par(12)=par12
          ptsq=ptx**2+pty**2
          if(emstr.lt.sqrt(emmes**2+ptsq)+
     a                sqrt(embar**2+ptsq)+0.001) go to 202
        end if
        if(kmltme.gt.0) then
          emmax=sqrt((emstr-sqrt(embar**2+ptsq))**2-ptsq)
          emmes=getms4(kmltme,kfmes,jgfix,emmax)
          if(emmes.lt.0.0) go to 102
        end if
        if(kmltba.gt.0) then
          emmax=sqrt((emstr-sqrt(emmes**2+ptsq))**2-ptsq)
          embar=getms4(kmltba,kfbar,jgfix,emmax)
          if(embar.lt.0.0) go to 102
        end if
        par(8)=para8
        par(9)=para9
        if(mbfix.le.0.and.ida55.gt.0) then
          if(irgs23.eq.1) then
            imany=1
            kfbar=0
            kfmes=0
            return
          end if
        end if
      return
      end
      function regsup(ida55,kfms,kfbr,klmold,klbold,mfld,kex,
     a                    prnew,prold,emstr,pr0reg,spower,iscons)
       common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
#include "amsrqmd.h"
       data p0rgm,p0rgk,p0rgb,p0rgy
     a      /0.80, 0.80, 1.40, 1.40/
       data scons /0.5/
        if(ida55.eq.-1000) go to 44
        regsup=1.0
        spower=0.0
        iscons=0
        if(ida55.eq.0) return
        if(ida55.eq.2) then
        else
          call errex('regsup: no valid ida55 parametrization')
        end if
        if(mod(iabs(klmold),100).ge.40)
     a  call errex('regsup: wrong klmold')
          kgmes=isign(1,kfms)*mod(iabs(kfms),100)
          kgbar=isign(1,kfbr)*mod(iabs(kfbr),100)
          if(kgmes.eq.23.or.kgmes.eq.24.or.kgmes.eq.25.or.
     a                      kgmes.eq.33.or.kgmes.eq.34) then
            iskfb=1
          else
            iskfb=isign(1,kgbar)
          end if
          kfmeso=iskfb*kfms
          inepsv=imspin(kfmeso)
          imepsv=imspin(klmold)
          klqa=iskfb*kgmes
          klqb=isign(1,klmold)*mod(iabs(klmold),100)
          iqmm=luchge(klqa)-luchge(klqb)
          s0srat=1.0
          ime10=imepsv/10
          ine10=inepsv/10
          imcode=mod(imepsv,10)
          incode=mod(inepsv,10)
          spower=-1.0
          if((ime10+ine10.eq.3.and.
     a                 min(ime10,ine10).gt.0)
     b       .or.(ime10+ine10.eq.2.and.
     c                 min(ime10,ine10).eq.0
     d                            .and.iabs(iqmm).ge.6)
     e                                              ) then
            kex=1
            pr0reg=p0rgy
            spower=spower+3.8
          else if(iabs(iqmm).ge.6) then
            kex=2
            pr0reg=p0rgb
            spower=spower+2.8
            iscons=1
          else
            if(iabs(mfld).eq.3.and.ine10.eq.0) ine10=3
            if(iabs(mfld).ne.3.and.ine10.eq.3) ine10=0
            if(ime10.eq.ine10) then
              pr0reg=p0rgm
              if(ime10.eq.0) then
                if(isosp(iabs(klqa)).eq.0.and.
     a                         isosp(iabs(klqb)).eq.0) then
                  ig=0
                else
                  ig=10
                end if
                if(mgpar(iabs(klqa))*
     a                       mgpar(iabs(klqb)).eq.-1) then
                  ig=ig+1
                end if
                if(ig.eq.10.or.ig.eq.1) then
                  spower=spower+1.0
                else
                  spower=spower+2.0
                end if
              else if(ime10.eq.1.or.ime10.eq.2) then
                if(imcode+incode.eq.0) then
                  spower=spower+1.0
                else if(imcode+incode.eq.1) then
                  spower=spower+2.0
                else
                  spower=spower+1.5
                end if
              else
                pr0reg=p0rgb
                spower=spower+3.8
              end if
              kex=3
            else if(ime10+ine10.eq.2.or.
     a              ime10+ine10.eq.4) then
              pr0reg=p0rgm
              if(imcode+incode.eq.0) then
                spower=spower+1.6
              else if(imcode+incode.eq.1) then
                spower=spower+2.4
              else
                spower=spower+2.0
              end if
              kex=5
            else if(ime10+ine10.eq.3.and.
     a                 min(ime10,ine10).eq.0) then
              pr0reg=p0rgb
              spower=spower+3.8
              kex=7
            else
              pr0reg=p0rgk
              kgb1=mod(iabs(kgbar),100)
              kgb2=mod(iabs(klbold),100)
              kgbsum=kgb1+kgb2
              kgb1=max(kgb1,kgb2)
              kgb2=kgbsum-kgb1
              ihyp=0
              if(kgb2.eq.41.or.kgb2.eq.42) then
                if(kgb1.eq.57) then
                  ihyp=1
                else if((kgb1.ge.43.and.kgb1.le.45).or.
     a                  (kgb1.ge.65.and.kgb1.le.67)) then
                  ihyp=2
                end if
              end if
              if(ihyp.eq.0) then
                spower=spower+2.0
              else if(ihyp.eq.1) then
                spower=spower+2.4
              else if(ihyp.eq.2) then
                spower=spower+1.6
              end if
              kex=8
              iscons=1
            end if
          end if
          if(prold.lt.0.0.or.prnew.le.0.0)
     a           call errex('regsup: abort,wrong prold/new')
   44     continue
          s0srat=1./(1.+prold*prnew/pr0reg**2)
          regsup=s0srat**spower
          if(iscons.eq.1)  regsup=scons*regsup
      return
      end
      function  cqpfrc(icho)
#include "amsrqmd.h"
       common /zdisbk/ paraqq,paraq,paraqs
       common /ludat1s/ mst(40),par(80)
        par51=par(51)
        par52=par(52)
        if(icho.gt.0) then
          if(icho.eq.1) then
            par(51)=paraqs
            par(52)=paraqs
          else if(icho.eq.2) then
            par(51)=paraqq
            par(52)=paraq
          end if
          call luzdis(0,1,0.,z)
          par(51)=par51
          par(52)=par52
          cqpfrc=z
        else
          cqpfrc=1.0
        end if
      return
      end
      function iqqrnd(iflqq)
#include "amsrqmd.h"
       iqqrnd=iflqq
       isig=isign(1,iflqq)
       jflqq=iabs(iflqq)
       if(jflqq.lt.10) return
       ifl1=mod(jflqq,10)
       ifl2=jflqq/10
       if(ifl1.eq.ifl2) return
       zrand=ranf(0)
       if((ifl1.gt.ifl2.and.zrand.gt.0.75)
     a          .or.(ifl1.lt.ifl2.and.zrand.le.0.75) ) then
         iqqrnd=isig*(10*ifl2+ifl1)
       end if
      return
      end
      function mlt810(kfbar,embar)
#include "amsrqmd.h"
       common /ludat1s/ mst(40),par(80)
       mlt810=-1
       prboct=par(77)
       w1385=par(78)
       kfbabs=iabs(kfbar)
       idn=idnbar(kfbabs)
       if(kfbabs.gt.60) then
         maxv=0
       else
         maxv=int((1.+prboct)*ranf(0))
         if(idn.eq.3.and.maxv.eq.1) maxv=2
       end if
       if(idn.eq.6.and.maxv.eq.0.and.ranf(0).gt.w1385) then
         if(kfbar.eq.66) then
           kfbar=isign(1,kfbar)*57
           maxv=1
         else
           return
         end if
       end if
       minv=maxv
       embar=getms4(maxv,kfbabs,1,-1.0)
       mlt810=maxv
      return
      end
CPAT,FRITIOF  .
      subroutine bele(ifla,iflb,j)
#include "amsrqmd.h"
      spin=ranf(0)
      iabj=iabs(j)
      isgj= isign(1,j)
      if(iabj.eq.17.or.iabj.eq.27) then
        if(spin.lt..5) then
          ifla=isgj
          iflb=-isgj* 2
        else
          ifla=-isgj*2
          iflb=isgj
        endif
      elseif(iabj.eq.18.or.iabj.eq.28) then
        if(spin.lt..5) then
          ifla=isgj
          iflb=-isgj*3
        else
          ifla=-isgj*3
          iflb=isgj
        endif
      elseif(iabj.eq.19.or.iabj.eq.29) then
        if(spin.lt..5) then
          ifla=isgj*2
          iflb=-isgj*3
        else
          ifla=-isgj*3
          iflb=isgj*2
        endif
      else if((iabj.eq.23).or.(iabj.eq.33)
     a                                    .or.(iabj.eq.34) ) then
        if(spin.lt.0.25) then
          ifla=1
          iflb=-1
        else if(spin.lt..5) then
          ifla=-1
          iflb= 1
        else if(spin.lt..75) then
          ifla=-2
          iflb= 2
        else
          ifla= 2
          iflb=-2
        endif
      else if( iabj.eq.24) then
        if(spin.lt.0.1667) then
          ifla=1
          iflb=-1
        else if(spin.lt.0.3333) then
          ifla=-1
          iflb= 1
        else if(spin.lt.0.5) then
          ifla=-2
          iflb= 2
        else if(spin.lt.0.6667) then
          ifla= 2
          iflb=-2
        else if(spin.lt.0.8333) then
          ifla= 3
          iflb=-3
        else
          ifla=-3
          iflb= 3
        endif
      else if(iabj.eq.25) then
        if(spin.lt.0.0833) then
          ifla=1
          iflb=-1
        else if(spin.lt.0.1667) then
          ifla=-1
          iflb= 1
        else if(spin.lt.0.25) then
          ifla=-2
          iflb= 2
        else if(spin.lt.0.3333) then
          ifla= 2
          iflb=-2
        else if(spin.lt.0.6667) then
          ifla= 3
          iflb=-3
        else
          iflb=-3
          ifla= 3
        endif
      else if( iabj.eq.35 ) then
        if(spin.lt.0.5) then
          ifla= 3
          iflb=-3
        else
          ifla=-3
          iflb= 3
        end if
      elseif(iabj.eq.40) then
        ntry=0
    7   call luifld(1,0,0,iflsea,kdump)
        iflsea=iabs(iflsea)
        ntry=ntry+1
        if(iflsea.eq.0.or.iflsea.gt.100) then
          if(ntry.lt.10) then
            goto 7
          else
            call errex('bele  7: infinite loop? ')
          end if
        end if
        if(spin.lt.0.5) then
          ifla=iflsea
          iflb=-iflsea
        else
          ifla=-iflsea
          iflb=iflsea
        end if
      elseif(iabj.eq.41) then
        if(spin.lt.0.167) then
          ifla=isgj*1
          iflb=isgj*21
        elseif(spin.lt.0.5) then
          ifla=isgj*2
          iflb=isgj*11
        else
          ifla=isgj*1
          iflb=isgj*12
        endif
      elseif(iabj.eq.42) then
        if(spin.lt.0.167) then
          ifla=isgj*2
          iflb=isgj*21
        elseif(spin.lt.0.5) then
          ifla=isgj
          iflb=isgj*22
        else
          ifla=isgj*2
          iflb=isgj*12
        endif
      elseif(iabj.eq.43) then
        if(spin.lt.0.167) then
          ifla=isgj
          iflb=isgj*31
        elseif(spin.lt.0.5) then
          ifla=isgj*3
          iflb=isgj*11
        else
          ifla=isgj
          iflb=isgj*13
        endif
      elseif(iabj.eq.45) then
        if(spin.lt.0.167) then
          ifla=isgj*2
          iflb=isgj*32
        elseif(spin.lt.0.5) then
          ifla=isgj*3
          iflb=isgj*22
        else
          ifla=isgj*2
          iflb=isgj*23
        endif
      elseif(iabj.eq.44) then
        if(spin.lt.0.0833) then
          ifla=isgj*2
          iflb=isgj*31
        else if(spin.lt.0.167) then
          ifla=isgj
          iflb=isgj*32
        elseif(spin.lt.0.5) then
          ifla=isgj*3
          iflb=isgj*21
        elseif(spin.lt.0.75) then
          ifla=isgj*2
          iflb=isgj*13
        else
          ifla=isgj
          iflb=isgj*23
        endif
      elseif(iabj.eq.46) then
        if(spin.lt.0.167) then
          ifla=isgj*3
          iflb=isgj*31
        elseif(spin.lt.0.5) then
          ifla=isgj*1
          iflb=isgj*33
        else
          ifla=isgj*3
          iflb=isgj*13
        endif
      elseif(iabj.eq.47) then
        if(spin.lt.0.167) then
          ifla=isgj*3
          iflb=isgj*32
        elseif(spin.lt.0.5) then
          ifla=isgj*2
          iflb=isgj*33
        else
          ifla=isgj*3
          iflb=isgj*23
        endif
      elseif(iabj.eq.57) then
        if(spin.lt.0.0833) then
          ifla=isgj*2
          iflb=isgj*13
        else if(spin.lt.0.167) then
          ifla=isgj
          iflb=isgj*23
        elseif(spin.lt.0.5) then
          ifla=isgj*3
          iflb=isgj*12
        elseif(spin.lt.0.75) then
          ifla=isgj*2
          iflb=isgj*31
        else
          ifla=isgj
          iflb=isgj*32
        endif
      elseif(iabj.eq.61) then
          ifla=isgj
          iflb=isgj*11
      elseif(iabj.eq.62) then
        if(spin.lt.0.333) then
          ifla=isgj*2
          iflb=isgj*11
        else
          ifla=isgj
          iflb=isgj*21
        end if
      elseif(iabj.eq.63) then
        if(spin.lt.0.333) then
          ifla=isgj
          iflb=isgj*22
        else
          ifla=isgj*2
          iflb=isgj*21
        end if
      elseif(iabj.eq.64) then
          ifla=isgj*2
          iflb=isgj*22
      elseif(iabj.eq.65) then
        if(spin.lt.0.333) then
          ifla=isgj*3
          iflb=isgj*11
        else
          ifla=isgj
          iflb=isgj*31
        end if
      elseif(iabj.eq.66) then
        if(spin.lt.0.333) then
          ifla=isgj*3
          iflb=isgj*21
        else if(spin.lt.0.666) then
          ifla=isgj*2
          iflb=isgj*31
        else
          ifla=isgj
          iflb=isgj*32
        end if
      elseif(iabj.eq.67) then
        if(spin.lt.0.333) then
          ifla=isgj*3
          iflb=isgj*22
        else
          ifla=isgj*2
          iflb=isgj*32
        end if
      elseif(iabj.eq.68) then
        if(spin.lt.0.333) then
          ifla=isgj*1
          iflb=isgj*33
        else
          ifla=isgj*3
          iflb=isgj*31
        end if
      elseif(iabj.eq.69) then
        if(spin.lt.0.333) then
          ifla=isgj*2
          iflb=isgj*33
        else
          ifla=isgj*3
          iflb=isgj*32
        end if
      elseif(iabj.eq.70) then
          ifla=isgj*3
          iflb=isgj*33
      else
        igb=0
        write(lun8,*) 'iabj=',iabj
        ifla=1/igb
        call errex('particle typ cannot be treated in bele')
      endif
      return
      end
      subroutine torsts(w, id, izpl, izmi, x1, x3, kt)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 pmas,pwid,cfr,ulmass
       common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       dimension nssb(70)
       data nssb /
     a            17*0,2*1,5*0,2,2*0,2*1,5*0,2,7*0,3*1,2*2,9*0,1,3*0,
     b            4*0,3*1,2*2,3/
       data alit /6./
       ktbeg=kt
       iabid=iabs(id)
       if(iabid.eq.40) then
         framin=1.0
       else if(iabid.ge.17.and.iabid.le.70) then
         emupp=100.0
         call emexc(iabid,emupp,framin,epdum,emdumm)
         if(framin.lt.1.3+0.15*nssb(iabid))
     a                framin=1.3+0.15*nssb(iabid)
       else
         call errex('torsts input-abort')
       end if
       if(w.le.framin) then
         kt=-1
         return
       else
         kt=2
       end if
       if(ktbeg.eq.-1) return
       slu=ranf(0)
       pete=sqrt(alit*((w**2/(16.*alit)+1.)**slu-1.))
       if(pete.lt.0.5) then
          kt=2
       else
          kt=3
          iflag=0
          fakt=ranf(0)
          y=2.*(fakt-.5)*log(w/(2.*pete)+sqrt(w**2/(4.*pete**2)-1.))
          x1=1.-(pete/w)*exp(y)
          x3=1.-(pete/w)*exp(-y)
          zpmass =ulmass(2,izpl)
          zmmass =ulmass(2,izmi)
          pa1=(0.5*x1*w)**2-zpmass**2
          pa3=(0.5*x3*w)**2-zmmass**2
          pa2=0.5*(2.-x1-x3)*w
          if(pa1.lt.0.0.or.pa3.lt.0.0) then
            iflag=1
            goto 13
          endif
          arg1=(pa3-pa1-pa2**2)/(2.*sqrt(pa1)*pa2)
          arg2=(pa2**2-pa1-pa3)/(2.*sqrt(pa1*pa3))
          if(abs(arg1).gt.1.0.or.abs(arg2).gt.1.0) iflag=1
   13     if(iflag.eq.1) kt=2
       endif
      return
      end
      block data ludata
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      common /ludat4/ chag(50),chaf(100)
      character chag*4,chaf*4
      data prtgam/ 18*-1.,   -1.,1.e-6,
     a     2*1.e-6,-1.,-1.,2.8e-4,0.01,0.154,2*0.0508,0.004,
     b     0.002,1.e-6,0.154,0.0099,0.00421,6.3e-4,1.e-6,2*-1.,1.e+30,
     c     2*-1.,5*-1.,3*1.e-6,6*1.e-6,-1.,3*1.e-6,
     d     4*0.12,0.036,0.036,0.039,0.009,0.010,-1.,
     e     10*1.e-6,
     f     2*-1.,8*1.e-6,10*-1.,20*1.e-6/
      data isosp / 16*-1,2,1,1,1,  1,0,2,0,0, 0,2,1,1,1,
     a    1,0,2,0,0, 0,0,0,-1,-1,  1,1,2,2,2, 1,1,2,2,2,
     b    5*-1,      -1,0,0,2*-1,  3,3,3,3,2, 2,2,1,1,0,
     c                                     50*-1/
      data isosp3/16*-1,2,1,-1,-1,   1,0,0,0,0,  0,2,1,-1,-1,
     a     1,0,0,0,0, 0,0,0,-1,-1,  1,-1,2,0,-2, 1,-1,2,0,-2,
     b     5*-1,      -1,0,0,2*-1,  3,1,-1,-3,2, 0,-2,1,-1,0,
     c                                     50*-1/
      data mgpar/16*0,-1,0,0,0,   0,0,-1,1,1,  0,1,0,0,0,
     a     0,0,1,-1,-1, 85*0/
      data mst/0,0,0,1,1,0,1,0,0,1,0,1,10,5*0,1,8,1,0,1,0,0,0,3*0,
     &2000,10*0/
      data par/0.10,0.30,0.4,0.05,0.5,0.5,0.5,0.5,0.6,0.75,1.,0.40,
     &1.,1.,0.,1.,1.,2.,2*0.,0.1,1.0,1.1,1.5,1.1,2.0,0.2,1.0,0.6,1.0,
     &1.0,0.7,1.0,0.7,0.5,0.7,1.,3*0.,3*0.77,5*0.,1.,0.77,1.,1.,0.,1.,
     &0.,0.,2*0.,0.09,0.01,10*0.,3.1415927,6.2831854,0.,0.001,6*0./
 
      data ktyp/0,10,23,3*0,1,2,1,2,1,2,1,2,2*0,2*3,2*2,2*3,4*0,33,43,
     &52,2,2*3,60,70,80,5*0,3,2,3,2,1,2,1,4,3,2,3,2*2,4,2*3,2,2*3,2,94,
     &103,112,121,133,142,151,162,171,1,4,3,2,3,2*2,4,2*3,4,20*0,6,2*5,
     &6,5,6,5,6,12*0/
      data pmas/0.,94.,83.,15.,2*0.,.00051,0.,.106,0.,1.784,0.,60.,
     &3*0.,.138,.494,.498,1.865,1.869,1.971,.138,.550,.958,2.981,.770,
     &.892,.898,2.007,2.01,2.11,.770,.783,1.02,3.097,2*.498,2*0.,.938,
     &.938,
     &    1.189,1.192,1.197,1.315,1.321,3*2.44,2*2.55,2.74,2*3.63,3.81,
     &1.116,2.282,2*2.46,1.23,1.231,1.232,1.233,2*1.382,1.387,1.532,
     &1.535,1.672,3*2.5,2*2.63,2.8,2*3.69,3.85,4.9,2*0.,9.4,77.99,118.,
     &397.,9.46,78.,118.,397.,10*0.,2*.325,.5,1.6,5.,40.,60.,200.,2*0.,
     &.2,.1,0.,.11,.16,.048,4*0./
      data pwid/2.8,20.,2.8,20.,.148,.4,.05,.2,.052,.2,.154,.4,.01,.1,
     &.004,.015,.115,.14,.115,.14,.115,.14,.115,.14,4*.035,2*.04,.009,
     &.05,.01,.05,26*0./
      data kfr/0,16,17,19,100,104,109,115,0,26,27,29,122,126,131,137,
     &0,40,42,47,144,158,178,205,0,1,3,6,10,15,21,28,0,0,56,57,240,
     &246,256,271,0,0,1,3,6,10,15,21,60,61,64,70,292,307,328,356,
     &0,1,3,6,10,15,21,28,16*0/
      data cfr/0.5,0.25,0.5,0.25,1.,0.5,0.5,0.,0.5,0.,1.,1.,0.75,0.,
     &0.5,0.,0.,1.,0.1667,0.3333,0.0833,0.6667,0.1667,0.3333,-3.,1.,
     &-2.,-2.,1.,0.,0.,-3.,1.,1.,1.,5*0./
 
      data dpar/2.,5.,15.,60.,250.,1500.,1.2e4,1.2e5,150.,16.,4.5,0.7,
     &0.,0.003,0.5,5*0./
      data idb/0,1,13,19,6*0,23,0,30,0,36,3*0,37,39,65,83,87,89,94,99,
     &100,101,103,105,107,110,111,112,115,119,122,5*0,124,126,127,128,
     &129,130,131,132,133,134,135,138,141,144,147,149,154,157,161,162,
     &164,166,167,170,173,176,178,180,183,184,185,186,187,188,189,190,
     &191,192,2*0,195,196,197,198,200,208,220,233,10*0,235,242,3*243,
     &5*250,5*257,5*264/
      data (cbr(j),j=1,200)/.03,.088,.118,.176,.206,.264,.375,.518,
     &.661,.772,.915,1.,.08,.16,.24,.5,.76,1.,.82,.91,.99,1.,.175,.35,
     &.453,.674,.687,.704,1.,.1,.2,.3,.6,.9,2*1.,.5,1.,.06,.12,.162,
     &.177,.182,.184,.244,.304,.384,.404,.424,.454,.469,.484,.489,.494,
     &.514,.544,.551,.558,.568,.571,.574,.579,.85,1.,.17,.34,.368,.375,
     &.38,.425,.47,.53,.54,.542,.545,.55,.557,.561,.566,.571,.577,1.,
     &.1,.2,.7,1.,.988,1.,.391,.709,.946,.995,1.,.427,.653,.953,.981,
     &3*1.,.667,1.,.667,1.,.55,1.,.64,.92,3*1.,.899,.986,1.,.493,.84,
     &.988,1.,.074,.148,1.,.686,1.,.516,10*1.,.15,.3,1.,.15,.3,1.,.15,
     &.3,1.,.15,.3,1.,.642,1.,.05,.1,.6,.8,1.,.15,.3,1.,.05,.1,.6,2*1.,
     &.67,1.,.33,2*1.,.88,.94,1.,.88,.94,1.,.88,.94,1.,.33,1.,.67,1.,
     &.686,.92,10*1.,.15,.3,4*1.,.5,1.,.03/
      data (cbr(j),j=201,400)/.06,.09,.135,.15,.165,.21,1.,.02,.04,.06,
     &.08,.1,.12,.17,.22,.27,.32,.37,1.,.02,.04,.06,.08,.1,.12,.17,.22,
     &.27,.32,.37,.42,1.,.5,1.,.112,.224,.274,.77,.85,.99,2*1.,.112,
     &.224,.274,.77,.85,.99,1.,.12,.24,.34,.67,.93,.97,1.,.11,.22,.33,
     &.64,.94,.97,2*1.,136*0./
      data (kdp(j),j=1,320)/7,-7,2*0,8,-8,2*0,9,-9,2*0,10,-10,2*0,11,
     &-11,2*0,12,-12,2*0,501,-501,2*0,502,-502,2*0,503,-503,2*0,504,
     &-504,2*0,505,-505,2*0,506,-506,2*0,-7,8,2*0,-9,10,2*0,-11,12,2*0,
     &501,-502,2*0,504,-503,2*0,506,-505,2*0,505,-505,2*0,11,-11,2*0,
     &504,-504,2*0,503,-503,2*0,-12008,7,12,0,-12010,9,12,0,12,-17,2*0,
     &12,-27,2*0,12,-18,2*0,12,-28,2*0,-13501,502,12,0,-12008,7,14,0,
     &-12010,9,14,0,-12012,11,14,0,-12501,502,14,0,-12504,503,14,0,
     &-12506,505,14,0,6591,592,2*0,37,3*0,38,3*0,-12007,8,503,-501,
     &-12009,10,503,-501,-18,17,2*0,-19,23,2*0,-18,18,2*0,17,-17,2*0,
     &-28,17,2*0,-18,27,2*0,-28,27,2*0,-29,23,2*0,-19,33,2*0,-29,33,
     &2*0,-19,24,2*0,-29,24,2*0,-19,25,2*0,-29,25,2*0,-19,34,2*0,-29,
     &34,2*0,-28,18,2*0,-18,28,2*0,-28,28,2*0,27,-17,2*0,17,-27,2*0,27,
     &-27,2*0,7501,-502,503,-501,7503,-502,2*0,-12007,8,503,-502,
     &-12009,10,503,-502,-19,17,2*0,35,17,2*0,2*17,-17,0,-29,17,2*0,
     &-19,27,2*0,-29,27,2*0,35,27,2*0,24,17,2*0,24,27,2*0,25,17,2*0,25,
     &27,2*0,18,-19,2*0,18,-29,2*0,28,-19,2*0/
      data (kdp(j),j=321,640)/28,-29,2*0,7501,-502,503,-502,-12007,8,
     &503,-503,-12009,10,503,-503,6501,-502,503,-503,6501,-502,2*0,2*1,
     &2*0,1,7,-7,0,2*1,2*0,3*23,0,17,-17,23,0,1,17,-17,0,1,7,-7,0,17,
     &-17,24,0,2*23,24,0,1,33,2*0,1,34,2*0,2*1,2*0,8591,592,2*0,3017,
     &23,2*0,3019,17,2*0,3018,23,2*0,3018,-17,2*0,3019,23,2*0,3020,23,
     &2*0,20,1,2*0,3020,17,2*0,3021,23,2*0,21,1,2*0,22,1,2*0,3017,-17,
     &2*0,1017,-17,23,0,1,23,2*0,3017,-17,2*0,3018,-18,2*0,3019,-19,2*0,
     &1017,-17,23,0,1,24,2*0,7,-7,2*0,9,-9,2*0,8591,592,2*0,17,-17,2*0,
     &2*23,2*0,41,23,2*0,42,17,2*0,57,1,2*0,42,-17,2*0,57,23,2*0,57,
     &-17,2*0,58,17,2*0,58,23,2*0,58,-17,2*0,59,1,2*0,60,1,2*0,-12007,
     &8,503,533,-12009,10,503,533,6501,-502,503,533,-12007,8,503,541,
     &-12009,10,503,541,6501,-502,503,541,-12007,8,503,542,-12009,10,
     &503,542,6501,-502,503,542,-12007,8,503,543,-12009,10,503,543,
     &6501,-502,503,543,41,-17,2*0,42,23,2*0,-12007,8,503,512,-12009,
     &10,503,512,6501,-502,503,512,6531,501,2*0,6513,501,2*0,-12007,8,
     &503,513,-12009,10,503,513,6501,-502,503,513,-12007,8,503,523,
     &-12009,10,503,523,6501,-502,503,523,6533,501,2*0/
      data (kdp(j),j=641,960)/41,17,2*0,41,23,2*0,42,17,2*0,41,-17,2*0,
     &42,23,2*0,42,-17,2*0,57,17,2*0,43,23,2*0,44,17,2*0,57,23,2*0,43,
     &-17,2*0,45,17,2*0,57,-17,2*0,44,-17,2*0,45,23,2*0,46,23,2*0,47,
     &17,2*0,46,-17,2*0,47,23,2*0,57,-18,2*0,46,-17,2*0,47,23,2*0,58,
     &17,2*0,58,23,2*0,58,-17,2*0,59,1,2*0,60,1,2*0,53,1,2*0,54,1,2*0,
     &55,1,2*0,56,1,2*0,-12007,8,503,544,-12009,10,503,544,6501,-502,
     &503,544,2*500,2*0,2*500,2*0,2*500,2*0,5003,507,-508,0,-5003,-507,
     &508,0,7,-7,2*0,9,-9,2*0,11,-11,2*0,501,-501,2*0,502,-502,2*0,503,
     &-503,2*0,504,-504,2*0,2*500,2*0,7,-7,2*0,8,-8,2*0,9,-9,2*0,10,
     &-10,2*0,11,-11,2*0,12,-12,2*0,501,-501,2*0,502,-502,2*0,503,-503,
     &2*0,504,-504,2*0,505,-505,2*0,2*500,2*0,7,-7,2*0,8,-8,2*0,9,-9,
     &2*0,10,-10,2*0,11,-11,2*0,12,-12,2*0,501,-501,2*0,502,-502,2*0,
     &503,-503,2*0,504,-504,2*0,505,-505,2*0,506,-506,2*0,2*500,2*0,
     &5003,507,-508,0,-5003,-507,508,0,-12008,7,504,590,-12010,9,504,
     &590,-12012,11,504,590,-13501,502,504,590,-13501,504,502,590,
     &-13504,503,504,590/
      data (kdp(j),j=961,1280)/-13504,504,503,590,6001,505,590,0,
     &-12008,7,504,590,-12010,9,504,590,-12012,11,504,590,-13501,502,
     &504,590,-13501,504,502,590,-13504,503,504,590,-13504,504,503,590,
     &-11007,8,505,590,-11009,10,505,590,-11011,12,505,590,-11502,501,
     &505,590,-11503,504,505,590,-11502,505,501,590,-11503,505,504,590,
     &-11008,7,506,590,-11010,9,506,590,-11012,11,506,590,-11501,502,
     &506,590,-11504,503,506,590,-11501,506,502,590,-11504,506,503,590,
     &5003,507,590,225*0/
      data (kdp(j),j=1281,1600)/320*0/
 
      data chag/' ','ha','la','ta','ba','ca','sa','da','ua','g','u','d',
     &'s','c','b','t','l','h','spec','qra','qbra','jet','b--','b-','b',
     &'b+',' ','-','0','+','++','1','0','*',' ','dfbv','jq','iq',
     &' ',' ','stab','unst',8*' '/
      data chaf/'gamm','z0','w','higg','ga/z',' ','e','nue','mu',
     &'numu','tau','nuta','chi','nuch','phas',' ','pi',2*'k',2*'d','f',
     &'pi0','eta','etap','etac','rho',2*'k*',2*'d*','f*','rho0','omeg',
     &'phi','jpsi','k0s','k0l',2*' ','p','n',3*'sig',2*'xi',3*'sic',
     &'csu1','csd1','css1','ccu1','ccd1','ccs1','lam','lamc','csu0',
     &'csd0',4*'delt',3*'sig*',2*'xi*','ome*',3*'sic*','csu*','csd*',
     &'css*','ccu*','ccd*','ccs*','ccc*',2*' ','etab','etat','etal',
     &'etah','upsi','phit','phil','phih',10*' '/
 
      end
CPAT,HIT      .
      logical function hit(iorig,i1,i2,srt,sig,sigel,thit)
        include 'scatter7'
#include "amsrqmd.h"
        dimension ifind(6)
        include 'partblk7'
        include 'sigmasx'
        common /ierdum/ierr
        dimension plk(0:3),qlk(0:3),qtlk(0:3),xdot(0:3),icoll(70)
        data ifind/  1,  0, 0 ,0  ,0  ,  0/
        data icoll / 16*0,1,1,1,3*0,1,1,
     a         1,0,1,1,1,3*0,3*1,0,1,1,2*0,7*2,9*0,2,3*0,10*2/
       ikey=0
       if(i1.eq.i2) goto 22
       itp1=ityp(i1)
       itp2=ityp(i2)
       if(itp1.eq.-9999) goto 22
       if(itp2.eq.-9999) goto 22
       ident1=issn(i1)
       ident2=issn(i2)
       if(mod(ida(40),2).eq.1) then
         deltz=zlast(ident1)-zlast(ident2)
         delty=ylast(ident1)-ylast(ident2)
         if(deltz*delty.gt.3.0) go to 22
         if(min(deltz,delty).gt.1.0) goto22
         if(max(deltz,delty).lt.-1.0) goto22
       end if
       if(ichbig(i1).eq.3) go to 22
       if(ichbig(i2).eq.3) go to 22
       if(ida(23).ne.0) then
         if(qdot(0,i1).eq.0.0.or.qdot(0,i2).eq.0.0) go to 22
       end if
      if(lastcl(i1).eq.lastcl(i2).and.lastcl(i1).ne.0) go to 22
      npid1= npidec(i1)
      npid2= npidec(i2)
      if(itp1.ge.85.and.itp1.le.99) then
        if(itp1.lt.98) call substi(itp1,npid1)
        if(itp1.ge.98) then
          if(iabs(npid1).gt.70.or.
     a            icoll(iabs(npid1)).eq.0) then
            go to 22
          end if
        end if
      end if
      if(itp2.ge.85.and.itp2.le.99) then
        if(itp2.lt.98) call substi(itp2,npid2)
        if(itp2.ge.98) then
          if(iabs(npid2).gt.70.or.
     a            icoll(iabs(npid2)).eq.0) then
            go to 22
          end if
        end if
      end if
       do 18 i=0,3
       plk(i)= p(i,i1)+p(i,i2)
       qlk(i)= x(i,i1)-x(i,i2)
   18 continue
      dqlksq= qlk(0)*qlk(0)
      splksq= plk(0)*plk(0)
      dqsplk= qlk(0)*plk(0)
      plkvc2=0.
      do 19 i=1,3
      dqlksq= dqlksq-qlk(i)*qlk(i)
      dqsplk= dqsplk-qlk(i)*plk(i)
      plkvc2= plkvc2+plk(i)*plk(i)
   19 continue
      splksq=splksq-plkvc2
      if(ida(2).eq.1.and.splksq.lt.16.) go to 22
      arg=(-dqlksq+dqsplk*dqsplk/splksq)*da(8)
      if(arg.lt.0.) then
         write(lun8,*) 'hit: arg=',arg,'  ??????????? '
         write(lun8,*) dqlksq,dqsplk,splksq
         write(lun8,*) issn(i1),issn(i2)
         write(lun8,*) (p(i,i1),i=0,3),(x(i,i1),i=0,3)
         write(lun8,*)  (p(i,i2),i=0,3),(x(i,i2),i=0,3)
         arg=0.
      end if
      dtc=x(0,i1)-tlast(i1)
      dtmax1=min(qdot(0,i1)*dt,dtc)
      dtc=x(0,i2)-tlast(i2)
      dtmax2=min(qdot(0,i2)*dt,dtc)
      if(iorig.eq.0) then
         if(sqrt(arg)-
     a       (plk(0)+sqrt(plkvc2))/sqrt(splksq)*(dtmax1+dtmax2)
     b                                              .gt.5.5) then
            go to 22
         end if
      end if
       if(ikey.eq.2) then
          ihopp=1
       end if
      do 20 i=0,3
      xdot(i)= qdot(i,i1)-qdot(i,i2)
      qlk(i)= qlk(i)- xdot(i) *dt
   20 continue
      dqlksq= qlk(0)*qlk(0)
      dqsplk= qlk(0)*plk(0)
      do 25 i=1,3
      dqlksq= dqlksq-qlk(i)*qlk(i)
      dqsplk= dqsplk-qlk(i)*plk(i)
   25 continue
       if(ikey.eq.2) then
          ihopp=2
       end if
      zlk= dqlksq- dqsplk*dqsplk/splksq
      do 26 i=0,3
      qtlk(i)= qlk(i)- dqsplk/splksq*plk(i)
   26 continue
      xdotsp= xdot(0)*plk(0)
      xdotsq=xdot(0)*xdot(0)
      xtxdot= qtlk(0)*xdot(0)
      do 27 i=1,3
      xdotsp= xdotsp-xdot(i)*plk(i)
      xdotsq=xdotsq-xdot(i)*xdot(i)
      xtxdot= xtxdot-qtlk(i)*xdot(i)
   27 continue
      if(xtxdot.lt.0.) go to 22
       if(ikey.eq.2) then
          ihopp=3
       end if
      denum=xdotsp*xdotsp/splksq-xdotsq
      if(denum.lt.1.e-5) go to 22
       if(ikey.eq.2) then
          ihopp=4
       end if
      dtau= xtxdot/denum
      if(dtau.gt.dt.and.iorig.eq.0) go to 22
       if(ikey.eq.2) then
          ihopp=5
       end if
      if(dtau.lt.0.) then
        write(lun8,*)'numerical error in hit dtau=',dtau,' .lt.0.'
        dtau=0.
      end if
      ttrue=time+dtau
      if(ttrue.le.tlstev) go to 22
       if(ikey.eq.2) then
          ihopp=6
       end if
      tcol1=x(0,i1)+qdot(0,i1)*(dtau-dt)
      tcol2=x(0,i2)+qdot(0,i2)*(dtau-dt)
      if((tlast(i1).ne.0..and.tcol1.lt.tlast(i1)).or.
     a            (tlast(i2).ne.0..and.tcol2.lt.tlast(i2)))then
          go to 22
      end if
       if(ikey.eq.2) then
          ihopp=7
       end if
      do 30 i=0,3
      qlk(i)= qlk(i)+xdot(i)*dtau
   30 continue
      dqlksq= qlk(0)*qlk(0)
      dqsplk= qlk(0)*plk(0)
      do 35 i=1,3
      dqlksq= dqlksq-qlk(i)*qlk(i)
      dqsplk= dqsplk-qlk(i)*plk(i)
   35 continue
      zlk=dqlksq-dqsplk*dqsplk/splksq
      bsq=-zlk*da(8)
      s=splksq
      srt=sqrt(splksq)
      iii=max0(itp1,itp2)
      jjj=min0(itp1,itp2)
      icltyp=(iii*(iii-1))/2+jjj
       if((icltyp.ge.3571).and.(icltyp.le.4950)) then
           icltyp=maxtyp+1
       end if
      if((icltyp.le.0).or.(icltyp.gt.maxtyp+1) ) then
        call errex('wrong icltyp in hit')
      end if
      if(splksq.gt.25.) then
         xm2=1.6
      else
         xm2=seacut(icltyp)*seacut(icltyp)
      end if
      if(icltyp.le.3) then
      else if(icltyp.ge.79.and.icltyp.le.80) then
      else if(icltyp.ge.91.and.icltyp.le.92) then
      else
        if(srt-em(i1)-em(i2).lt.0.4) then
           xm2=3.*xm2*0.4/max(0.5*cvalu3,srt-em(i1)-em(i2))
        end if
      end if
      ncoli1=nclcnt(ident1)
      ncoli2=nclcnt(ident2)
      if(nt.gt.2.and.((itripl.eq.1.and..not.switch(17))
     a              .or.ida(34).gt.0.or.switch(23).or.switch(6)).and.
     b                                (ncoli1.eq.0.or.ncoli2.eq.0))then
         ifreez=1
         xm2=1.5*xm2
      else
         ifreez=0
      end if
      if(bsq.gt.xm2) go to 22
       if(ikey.eq.2) then
          ihopp=8
       end if
      if(icltyp.le.3.and.s.lt.(em(i1)+em(i2)+ekinmi)**2) then
        goto 22
      end if
       if(ikey.eq.2) then
          ihopp=9
       end if
        pi1sq=p(0,i1)*p(0,i1)
        do 38 i=1,3
   38   pi1sq=pi1sq-p(i,i1)*p(i,i1)
        pi2sq=p(0,i2)*p(0,i2)
        do 39 i=1,3
   39   pi2sq=pi2sq-p(i,i2)*p(i,i2)
        if(srt.le.sqrt(pi1sq)+sqrt(pi2sq)) then
           write(lun8,*) 'hit warning: sqrt(s)<em1+em2(eff)'
           write(lun8,*) 'hit', issn(i1),srt,sqrt(pi1sq)
           write(lun8,*) 'hit', issn(i2),srt,sqrt(pi2sq)
           goto 22
        end if
        prel=pcmsr(srt,sqrt(pi1sq),sqrt(pi2sq))
        em1=em(i1)
        em2=em(i2)
        if(em1+em2+ekinmi.gt.srt) go to 22
        enlrge=1.0
        if(ifreez.eq.1) then
          call frzcor(enlrge,i1,i2)
        else if(.not.switch(6)) then
          pfree=pcmsr(srt,em1,em2)
          enlrge=pfree/prel
        end if
        sigact=10.*pi*bsq
        if(ida(40).eq.2.or.ida(40).eq.3) then
           sig=sigact/enlrge
        else
           call cross1(1,srt,prel,icltyp,sig,em1,em2,
     a                           itp1,itp2,npid1,npid2)
           if(sig.eq.0.) go to 22
           sigact=sigact/enlrge
           if(sigact.gt.sig) goto 22
        end if
      hit=.true.
      thit=ttrue
      return
   22 hit=.false.
      return
      end
      function pcmsr(a,b,c)
      include 'scatter7'
#include "amsrqmd.h"
      if(a.ge.b+c) then
        pcmsr=sqrt((a**2-(b+c)**2)*(a**2-(b-c)**2))/(2.*a)
      else
        pcmsr=0.
        idiv=0
        adiv=1./idiv
        write(lun8,*) 'adiv=',adiv
        write(lun8,*) 'illegal call of pcmsr'
      end if
      return
      end
      subroutine hit34(iorig,i1,i2,sig,thit,iclyes)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
        logical hit
        dimension xind(0:3),pind(0:3),plk(0:3),qlk(0:3)
        real*4 bxj,byj,bzj
        real*4 plund,par
        common /lujets/ nlund,k(2000,2),plund(2000,5)
        common/ludat1s/mst(40),par(80)
       real*4 radius(1)
       equivalence (radius(1),datsto(1))
        iclyes=0
        if(iorig.ne.0) then
         write(lun8,*) 'iorig=',iorig
         call errex('iorig not allowed in hit34')
        end if
        if(ida(34).ne.2) then
         write(lun8,*) 'ida(34)=',ida(34)
         call errex('ida(34).ne.2 not allowed in hit34')
        end if
        if(ichbig(i1).eq.3) return
        if(qdot(0,i1).eq.0.) return
        do 8 i=0,3
         pind(i)=p(i,i1)
         xind(i)=x(i,i1)-qdot(i,i1)*dt
    8   continue
        gamta=1./sqrt(1.-betata*betata)
        ti1=gamta*(xind(0)-betata*xind(3))
        xind(3)=gamta*(xind(3)-betata*xind(0))
        xind(0)=ti1
        p0i1=gamta*(pind(0)-betata*pind(3))
        pind(3)=gamta*(pind(3)-betata*pind(0))
        pind(0)=p0i1
        drsq=(xind(1)+bplus)**2+xind(2)**2+
     a         (xind(3)-gamta*0.5*(zmxta+zmnta))**2
        dr=sqrt(drsq)
        vlab=sqrt(pind(1)**2+pind(2)**2+pind(3)**2)/pind(0)
        sigmax=400.
        rhoeff=rho0/(exp((dr-rr2)/da(2))+1.)
        if(rhoeff.lt.0.05*rho0) return
        dpmax= 0.1*sigmax*rhoeff*dt*vlab
        zrand=ranf(0)
        if(zrand.gt.dpmax) return
        i2=0
        radmin=10000.
        do 10 ib=iofset+1,iofset+nrbar(kclst)+nrmes(kclst)
           if(prop(ib)) go to 10
           if (i1.eq.ib) goto 10
           if(ichbig(ib).eq.3) go to 10
           if(lastcl(i1).eq.lastcl(ib).and.lastcl(i1).ne.0) go to 10
           identb=issn(ib)
           ncolib=nclcnt(identb)
           if(identb.gt.n1.and.identb.le.nt.and.ncolib.eq.0) then
           else
               go to 10
           end if
           drel=abs(radius(identb)-dr)
           if(drel.lt.radmin) then
             radmin=drel
             i2=ib
           end if
   10   continue
        if(i2.eq.0) return
        itp1=ityp(i1)
        itp2=ityp(i2)
        if(itp1.eq.-9999) return
        if(itp2.eq.-9999) return
        ncoli1=nclcnt(issn(i1))
        ncoli2=nclcnt(issn(i2))
        npid1=npidec(i1)
        npid2=npidec(i2)
        iii=max0(itp1,itp2)
        jjj=min0(itp1,itp2)
        icltyp=(iii*(iii-1))/2+jjj
        if((icltyp.ge.3571).and.(icltyp.le.4950)) then
           icltyp=maxtyp+1
       end if
       if((icltyp.le.0).or.(icltyp.gt.maxtyp+1)) then
         call errex('wrong icltyp in hit34')
       end if
       do 18 i=0,3
       plk(i)= p(i,i1)+p(i,i2)
   18 continue
      splksq= plk(0)*plk(0)
      do 19 i=1,3
      splksq=splksq-plk(i)*plk(i)
   19 continue
      if(ida(2).eq.1.and.splksq.lt.16.) return
      if(nt.gt.2.and.((itripl.eq.1.and..not.switch(17))
     a             .or.ida(34).gt.0.or.switch(23).or.switch(6)).and.
     b                              (ncoli1.eq.0.or.ncoli2.eq.0))then
         ifreez=1
      else
         ifreez=0
      end if
      s=splksq
      if (splksq.lt.(em(i1)+em(i2)+ekinmi)**2) return
        srt=sqrt(s)
        pi1sq=p(0,i1)*p(0,i1)
        do 38 i=1,3
   38   pi1sq=pi1sq-p(i,i1)*p(i,i1)
        pi2sq=p(0,i2)*p(0,i2)
        do 39 i=1,3
   39   pi2sq=pi2sq-p(i,i2)*p(i,i2)
        prel=pcmsr(srt,sqrt(pi1sq),sqrt(pi2sq))
        em1=em(i1)
        em2=em(i2)
        call cross1(1,srt,prel,icltyp,sig,em1,em2,
     a                           itp1,itp2,npid1,npid2)
        enlrge=1.
        if(ifreez.eq.1) call frzcor(enlrge,i1,i2)
      sig=enlrge*sig
      if(dpmax.gt.1.) then
         sigmax=sigmax/dpmax
      end if
      if(sig.gt.sigmax) then
         write(lun8,*) 'hit34 warning:sig>sigmax'
      else
         if(ranf(0).gt.sig/sigmax) return
      end if
      i3=0
      drmin=10000.
      do 50 ib=iofset+1,iofset+nrbar(kclst)+nrmes(kclst)
       if(prop(ib)) go to 50
       if (i1.eq.ib) goto 50
       if(ichbig(ib).eq.3) go to 50
       identb=issn(ib)
       ncolib=nclcnt(identb)
       if(identb.gt.n1.and.identb.le.nt.and.ncolib.eq.0) then
       else
        go to 50
       end if
       do 48 i=0,3
       plk(i)= p(i,i1)+p(i,ib)
       qlk(i)= x(i,i1)-x(i,ib)-(qdot(i,i1)-qdot(i,ib))*dt
   48 continue
       dqlksq= qlk(0)*qlk(0)
       splksq= plk(0)*plk(0)
       dqsplk= qlk(0)*plk(0)
       plkvc2=0.
       do 49 i=1,3
        dqlksq= dqlksq-qlk(i)*qlk(i)
        dqsplk= dqsplk-qlk(i)*plk(i)
        plkvc2= plkvc2+plk(i)*plk(i)
   49  continue
       splksq=splksq-plkvc2
       zlk= dqlksq- dqsplk*dqsplk/splksq
       if(sqrt(-zlk).lt.drmin) then
         i3=ib
         drmin=sqrt(-zlk)
       end if
   50 continue
      if(i3.eq.0) then
         write(lun8,*) 'i3=0 in hit34 '
         return
      end if
      do 51 i=0,3
   51 x(i,i3)=x(i,i2)
      do 52 i=0,3
       xind(i)=x(i,i1)-0.5*qdot(i,i1)*dt
       pind(i)=qdot(i,i1)
       qdot(i,i2)=0.
       plk(i)=p(i,i1)+p(i,i2)
   52 continue
      tlast(i2)=0.
      tlast(i1)=x(0,i1)-qdot(0,i1)*dt-0.1
      bxj=plk(1)/plk(0)
      byj=plk(2)/plk(0)
      bzj=plk(3)/plk(0)
      nsave=nlund
      if(nsave+2.gt.2000) then
         call errex('nsave too large in hit34')
      end if
      mst1=mst(1)
      mst2=mst(2)
      mst(1)=nsave+1
      mst(2)=nsave+2
      nlund=nlund+2
      do 53 i=1,3
       plund(nsave+1,i)=pind(i)
       plund(nsave+2,i)=xind(i)
   53 continue
      plund(nsave+1,4)=pind(0)
      plund(nsave+2,4)=xind(0)
      call lurobo(0.,0.,-bxj,-byj,-bzj)
      costet=1-2.*ranf(0)
      sintet=sqrt(1.-costet*costet)
      phi=pi2*ranf(0)
      xind(1)=costet
      xind(2)=sintet*sin(phi)
      xind(3)=sintet*cos(phi)
      xprel=0.
      prelsq=0.
      do 55 i=1,3
      xprel=xprel+plund(nsave+1,i)*xind(i)
      prelsq=prelsq+plund(nsave+1,i)**2
   55 continue
      xnorm=0.
        do 56 i=1,3
         xind(i)=xind(i)-xprel/prelsq*plund(nsave+1,i)
         xnorm=xnorm+xind(i)**2
   56   continue
      sigt=min(sig,10.*pi*seacut(icltyp)**2)
      dr2=0.99*sigt/pi*0.1*(ranf(0))**0.5
      do 57 i=1,3
       xind(i)=xind(i)/sqrt(xnorm/dr2)
       plund(nsave+2,i)=plund(nsave+2,i)+xind(i)
   57 continue
      call lurobo(0.,0.,bxj,byj,bzj)
      do 58 i=1,3
       x(i,i2)=plund(nsave+2,i)
   58 continue
      x(0,i2)=plund(nsave+2,4)
      nlund=nsave
      mst(1)=mst1
      mst(2)=mst2
      iorig=0
      if(hit(iorig,i1,i2,srt,sig,sigel,thit)) then
         iclyes=1
      else
         call errex('hit=f in hit34')
      end if
      return
      end
      subroutine frzcor(enlrge,i1,i2)
           include 'scatter7'
#include "amsrqmd.h"
           include 'partblk7'
          enlrge=1.
          ident1=issn(i1)
          ncoli1=nclcnt(ident1)
          ident2=issn(i2)
          ncoli2=nclcnt(ident2)
          identa=min(ident1,ident2)
          identb=ident1+ident2-identa
          if(identa.eq.ident1) then
            ncola=ncoli1
            ncolb=ncoli2
          else
            ncola=ncoli2
            ncolb=ncoli1
          end if
          if(ident1.le.nt.and.ident2.le.nt) then
            if(ident1.le.n1.and.ident2.le.n1) then
              if(ncoli1+ncoli2.eq.0) then
                identb=identa
              else if(ncolb.eq.0) then
                identa=identb
                identb=ident1+ident2-identa
              end if
            else if(ident1.gt.n1.and.ident2.gt.n1) then
              if(ncoli1+ncoli2.eq.0) then
                identb=identa
              else if(ncola.eq.0) then
                identa=identb
                identb=ident1+ident2-identa
              end if
            end if
          else if(identa.gt.nt) then
            identb=identa
          else
            if(identa.gt.n1) then
              identa=identb
              identb=ident1+ident2-identa
            end if
          end if
          if(identa.eq.identb) then
          else if(identa.eq.ident1) then
            ia=i1
            ib=i2
            ncola=ncoli1
            ncolb=ncoli2
          else
            ia=i2
            ib=i1
            ncola=ncoli2
            ncolb=ncoli1
          end if
          if(identa.eq.identb) then
          else if(ncolb.eq.0.and.identb.le.nt.and.identb.gt.n1+1) then
            bx=p(1,ia)/p(0,ia)
            by=p(2,ia)/p(0,ia)
            bz=p(3,ia)/p(0,ia)
            b2= max(cvalu7,bx*bx+by*by+bz*bz)
            gam=1./sqrt(1.-b2)
            pb=bx*p(1,ib)+by*p(2,ib)+bz*p(3,ib)
            gg=(gam-1.)*pb/b2-gam*p(0,ib)
            p1=gg*bx+p(1,ib)
            p2=gg*by+p(2,ib)
            p3=gg*bz+p(3,ib)
            p0=gam*(p(0,ib)-pb)
            pabs=sqrt(p1**2+p2**2+p3**2)
            veff=pabs/p0
            if(veff.lt.0. .or.veff.ge.1.) then
                veff=min(cvalu1,max(cvalu0,veff))
            end if
            if(ncola.eq.0.and.identa.le.n1) then
               vcomp=(betata*betata+betapr*betapr
     a                         -2.*betata*betapr)/(1.-betata*betapr)**2
               vcomp=sqrt(vcomp)
            else
               gamta=1./(1.-betata*betata)
               pb=bz*betata*gamta
               gg=(gam-1.)*pb/b2-gam*gamta
               p1=gg*bx
               p2=gg*by
               p3=gg*bz+betata*gamta
               p0=gam*(gamta-pb)
               pabs=sqrt(p1**2+p2**2+p3**2)
               vcomp=pabs/p0
               if(vcomp.lt.0. .or.vcomp.gt.1.) then
                  vcomp=min(cvalu1,max(cvalu0,vcomp))
               end if
            end if
            enlrge=veff/vcomp
          else if(ncola.eq.0.and.identa.le.n1) then
            bx=p(1,ib)/p(0,ib)
            by=p(2,ib)/p(0,ib)
            bz=p(3,ib)/p(0,ib)
            b2=max(cvalu7,bx*bx+by*by+bz*bz)
            gam=1./sqrt(1.-b2)
            pb=bx*p(1,ia)+by*p(2,ia)+bz*p(3,ia)
            gg=(gam-1.)*pb/b2-gam*p(0,ia)
            p1=gg*bx+p(1,ia)
            p2=gg*by+p(2,ia)
            p3=gg*bz+p(3,ia)
            p0=gam*(p(0,ia)-pb)
            pabs=sqrt(p1**2+p2**2+p3**2)
            veff=pabs/p0
            if(veff.lt.0. .or.veff.gt.1.) then
                veff=min(cvalu1,max(cvalu0,veff))
            end if
               gamta=1./(1.-betapr*betapr)
               pb=bz*betapr*gamta
               gg=(gam-1.)*pb/b2-gam*gamta
               p1=gg*bx
               p2=gg*by
               p3=gg*bz+betapr*gamta
               p0=gam*(gamta-pb)
               pabs=sqrt(p1**2+p2**2+p3**2)
               vcomp=pabs/p0
               if(vcomp.lt.0. .or.vcomp.gt.1.) then
                  vcomp=min(cvalu1,max(cvalu0,vcomp))
               end if
            enlrge=veff/vcomp
          end if
      return
      end
      subroutine substi(ityp,npid)
#include "amsrqmd.h"
       if(ityp.lt.85.or.ityp.gt.97)
     a       call errex('wrong input in substi')
       npida=iabs(npid)
       if(npid.ge.61.and.npid.le.64) then
         ityp=7-mod(npid,60)
         npid=3
       else if(npida.eq.23.or.npida.eq.17.or.
     a                         npida.eq.33.or.npida.eq.27) then
         ityp=8+isign(1,npid)*(mod(npida,10)-3)/4
         if(npida.eq.23.or.npida.eq.17) then
           npid=3
         else
           npid=4
         end if
       else if(npid.ge.41.and.npid.le.42) then
         ityp=12-mod(npid,40)
         npid=3
       else if(-npid.ge.41.and.-npid.le.42) then
       else if(-npid.ge.61.and.-npid.le.64) then
       else if(npid.eq.24) then
         ityp=12
         npid=3
       else if(npid.eq.57) then
         ityp=13
         npid=0
       else if(npida.ge.18.and.npida.le.19) then
         ityp=14
         npid=isign(1,npid)*(20-npida)
       else if(npid.ge.43.and.npid.le.45) then
         ityp=15
         npid=44-npid
       else
         ityp=98
       end if
      return
      end
      subroutine subst2(idir,ityp,npid)
#include "amsrqmd.h"
       if(idir.eq.1) then
         npida=-npid
         if(ityp.ge.3.and.ityp.le.6) then
           if(npida.ge.1.and.npida.le.10) then
             npid=67-ityp
             ityp=84+npida
           end if
         else if(ityp.ge.10.and.ityp.le.11) then
           if(npida.ge.1.and.npida.le.10) then
             npid=52-ityp
             ityp=84+npida
           end if
         end if
       else
         npida=npid
         if(ityp.ge.85.and.ityp.le.97) then
           if(npid.ge.61.and.npid.le.64) then
             npid=-(ityp-84)
             ityp=67-npida
           else if(npid.ge.41.and.npid.le.42) then
             npid=-(ityp-84)
             ityp=52-npida
           end if
         end if
       end if
      return
      end
      function redcqi(imeso,iexpon)
       include 'scatter7'
#include "amsrqmd.h"
        if(imeso.eq.1) then
          vcq=2.
        else if(imeso.eq.0) then
          vcq=3.
        else
          call errex('redcqi:wrong imeso')
        end if
        iqid=mod(iabs(iexpon),100)
        iqid1=iqid/10
        iqid2=mod(iqid,10)
        if(iqid1.eq.1.or.iqid1.eq.2) then
          rqsum=1.0
        else if(iqid1.eq.3) then
          rqsum=0.6
        else
          rqsum=0.
        end if
        if(iqid2.eq.3) then
          rqsum=rqsum+0.6
        else
          rqsum=rqsum+1.0
        end if
        redcqi=rqsum/vcq
      return
      end
CPAT,INIT     .
      subroutine initev
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      dimension qlk(0:3),plk(0:3),ptot(0:3)
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version  rqmd 2.2 --- 21-mar-95'/
      data pronam /'i n i t  initializes the particles coordinates'/
      data ttvers/.true./
      data rhc/0.6/
      save z01,z02,tfix,x0p,x0t
      real*4  radius(1)
      equivalence (radius(1),datsto(1))
      real*4 force,dcoef
      common/blocal/ ngbor(ntotma),force(0:3,ntotma),dcoef(ntotma)
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
       sphepr=4.*(4.*pi/3.)**2
       pfm=hc/(da(3)*sphepr**.333333333)
       gampr=1./sqrt(1.-betapr*betapr)
       gamta=1./sqrt(1.-betata*betata)
        n1=n1old
        iz1=iz1old
        n2=n2old
        iz2=iz2old
        nt=n1+n2
      if(ida(17).eq.0) then
         rap=da(3)*n1**0.333333333
         rat=da(3)*n2**0.333333333
      else
         rap=1.19* n1**0.3333-1.61* n1**(-0.3333)
         rat=1.19* n2**0.3333-1.61* n2**(-0.3333)
      end if
      if(n1.eq.1) rap=0.
      if(n2.eq.1) rat=0.
       z01=1.+rap
       z02=-1.-rat
        delt1=2.0
        delt2=2.0
        tfix=1./betann
     a          * min(z01-gamnn*rap-delt1,-z02-gamnn*rat-delt2)
        if(tfix.gt.0.) tfix=0.
        x0p=tfix/gamnn +betann*z01
        x0t=tfix/gamnn -betann*z02
      if(da(11).lt.0.) then
          if(da(11).le.-99.0)then
            bmax=rap+rat+3.
          else
            bmax=-da(11)
          end if
          x0=bmax*sqrt(ranf(0))/2.
          b=2.*x0
      else
          x0=0.5*b
      end if
      bplus=x0
      rhomx1=1./(1.+exp(-rap/da(2)))
      rhomx2=1./(1.+exp(-rat/da(2)))
      if(ida(34).gt.0) then
       if(ref.eq.'lab') then
         pnorm(0)=1.
         pnorm(1)=0.
         pnorm(2)=0.
         pnorm(3)=0.
       else
         pnorm(0)=gamnn
         pnorm(1)=0.
         pnorm(2)=0.
         pnorm(3)=gamnn*betann
       end if
      else
       if(ref.eq.'lab') then
         pnorm(0)=gamnn
         pnorm(1)=0.
         pnorm(2)=0.
         pnorm(3)=-gamnn*betann
       else
         pnorm(0)=1.
         pnorm(1)=0.
         pnorm(2)=0.
         pnorm(3)=0.
       end if
      end if
       nprtcl=0
        pfmold=pfm
        if(n1.eq.1) pfm=0.
        if(iz1.ge.0) then
            ibas1=0
            ibas2=0
        else
            ibas1=n2
            ibas2=-n1
        end if
        do 106 i =ibas1+1,ibas1+n1
          nprtcl=nprtcl+1
          itry=0
   31     continue
          ktry=0
          itry=itry+1
          if(rap.eq.0.) then
              r=0.
          else if(ida(17).eq.0) then
              r=rap*ranf(0)**0.3333
          else
              r=(rap+2.5)*ranf(0)**0.3333
              if(ranf(0).gt.(1./(1.+exp((r-rap)/da(2))))/rhomx1) then
                 if(itry.gt.200)then
                    write(lun8,*) 'infinite loop in init,31? '
                 else
                    go to 31
                 end if
              end if
          end if
   29     ktry=ktry+1
          if(ktry.gt.60) then
             go to 31
          end if
          cth=1.-2.*ranf(0)
          sth=sqrt(1.-cth**2)
          phi=pi2*ranf(0)
          x(0,i)=x0p
          x(1,i)=r*sth*cos(phi)+x0
          x(2,i)=r*sth*sin(phi)
          x(3,i)=r*cth+z01
          if(ida(6).eq.1.or.ida(31).eq.1)then
           denspp(nprtcl)=0.
           do 506 k=ibas1+1,i-1
            drsq=(x(1,i)-x(1,k))**2+(x(2,i)-x(2,k))**2+
     a                                           (x(3,i)-x(3,k))**2
            if(ida(31).eq.1.and.drsq.lt.rhc*rhc)then
               go to 29
            end if
            if(ida(6).eq.1)then
              arg=exp(-drsq/alpot)
              denspp(nprtcl)=denspp(nprtcl)+arg
              denspp(issn(k))=denspp(issn(k))+arg
            end if
  506      continue
          end if
          if(switch(21)) then
            dsq=(x(1,i)+bplus)**2+x(2,i)**2 - rtasq
            if(dsq.gt.0.) then
               ityp(i)=-9999
               go to 106
            end if
          end if
          lastcl(i)=0
          ichbig(i)=0
          issn(i)=nprtcl
          decay(i)=1.e35
          pr=pfm*ranf(0)**(1./3.)
          cth=1.-2.*ranf(0)
          sth=sqrt(1.-cth**2)
          phi=pi2*ranf(0)
          p(0,i)=sqrt(emproj**2+pr**2)
          p(3,i)=pr*cth
          p(1,i)=pr*sth*cos(phi)
          p(2,i)=pr*sth*sin(phi)
          npidec(i)=0
          if (iz1.lt.0) then
            itypld=ityppr
            call transl(1,itp,npid,itypld)
            ityp(i)=itp
            npidec(i)=npid
            em(i)=emproj
          else if (i .le. iz1) then
            ityp(i)=2
            em(i)=emnuc
          else
            ityp(i)=1
            em(i)=emnuc
          end if
 106    continue
        pfm=pfmold
        if(n2.eq.1) pfm=0.
        do 107 i =n1+1+ibas2,nt+ibas2
          nprtcl=nprtcl+1
          itry=0
   32     continue
          ktry=0
          itry=itry+1
          if(rat.eq.0.) then
              r=0.
          else if(ida(17).eq.0) then
              r=rat*ranf(0)**0.3333
          else
              r=(rat+2.5)*ranf(0)**0.3333
              if(ranf(0).gt.(1./(1.+exp((r-rat)/da(2))))/rhomx2) then
                 if(itry.gt.200)then
                   write(lun8,*) 'infinite loop in init,32? '
                 else
                   go to 32
                 end if
              end if
          end if
   30     ktry=ktry+1
          if(ktry.gt.60) then
             go to 32
          end if
          cth=1.-2.*ranf(0)
          sth=sqrt(1.-cth**2)
          phi=pi2*ranf(0)
          x(0,i)=x0t
          x(1,i)=r*sth*cos(phi)-x0
          x(2,i)=r*sth*sin(phi)
          x(3,i)=r*cth+z02
          if(ida(34).eq.2) then
             radius(nprtcl)=r
          end if
          if(ida(6).eq.1.or.ida(31).eq.1)then
           denspp(nprtcl)=0.
           do 507 k=n1+1+ibas2,i-1
            drsq=(x(1,i)-x(1,k))**2+(x(2,i)-x(2,k))**2+
     a                                           (x(3,i)-x(3,k))**2
            if(ida(31).eq.1.and.drsq.lt.rhc*rhc)then
               go to 30
            end if
            if(ida(6).eq.1)then
              arg=exp(-drsq/alpot)
              denspp(nprtcl)=denspp(nprtcl)+arg
              denspp(issn(k))=denspp(issn(k))+arg
            end if
  507      continue
          end if
          if(switch(21)) then
            dsq=(x(1,i)-bplus)**2+x(2,i)**2 - rprsq
            if(dsq.gt.0.) then
               ityp(i)=-9999
               go to 107
            end if
          end if
          lastcl(i)=0
          ichbig(i)=0
          issn(i)=nprtcl
          decay(i)=1.e35
          pr=pfm*ranf(0)**(1./3.)
          cth=1.-2.*ranf(0)
          sth=sqrt(1.-cth**2)
          phi=pi2*ranf(0)
          p(0,i)=sqrt(emnuc**2+pr**2)
          p(3,i)=pr*cth
          p(1,i)=pr*sth*cos(phi)
          p(2,i)=pr*sth*sin(phi)
          if ((i-n1-ibas2) .le. iz2) then
            ityp(i)=2
            em(i)=emnuc
          else
            ityp(i)=1
            em(i)=emnuc
          end if
          npidec(i)=0
 107    continue
      if(switch(11))then
          nrbar(1)=n1
          do 1052 i =ibas1+1,ibas1+n1
            ininew=0
 1053       continue
            ntag=0
            call paulin(i,ntag)
            if(ntag.lt.0)then
              r=rap*ranf(0)**0.3333
              cth=1.-2.*ranf(0)
              sth=sqrt(1.-cth**2)
              phi=pi2*ranf(0)
              x(3,i)=r*cth+z01
              x(1,i)=r*sth*cos(phi)+x0
              x(2,i)=r*sth*sin(phi)
              pr=pfm*ranf(0)**(1./3.)
              cth=1.-2.*ranf(0)
              sth=sqrt(1.-cth**2)
              phi=pi2*ranf(0)
              p(0,i)=sqrt(emproj**2+pr**2)
              p(3,i)=pr*cth
              p(1,i)=pr*sth*cos(phi)
              p(2,i)=pr*sth*sin(phi)
              ininew=ininew+1
              xininw=xininw+1.
              if(ininew.le.15) goto 1053
              call errex('nucleon initially in occupied state')
           end if
 1052    continue
          if(iz1.ge.0) then
             iofset=n1
             nrbar(1)=n2
           else
             iofset=0
             nrbar(1)=n2
           end if
          do 1054 i =1+n1+ibas2,nt+ibas2
            ininew=0
 1055       continue
            ntag=0
            call paulin(i,ntag)
            if(ntag.lt.0)then
              r=rat*ranf(0)**0.3333
              cth=1.-2.*ranf(0)
              sth=sqrt(1.-cth**2)
              phi=pi2*ranf(0)
              x(3,i)=r*cth+z02
              x(1,i)=r*sth*cos(phi)-x0
              x(2,i)=r*sth*sin(phi)
              pr=pfm*ranf(0)**(1./3.)
              cth=1.-2.*ranf(0)
              sth=sqrt(1.-cth**2)
              phi=pi2*ranf(0)
              p(0,i)=sqrt(emnuc**2+pr**2)
              p(3,i)=pr*cth
              p(1,i)=pr*sth*cos(phi)
              p(2,i)=pr*sth*sin(phi)
              ininew=ininew+1
              xininw=xininw+1.
              if(ininew.le.15)goto1055
              call errex('nucleon initially in occupied state')
           end if
 1054    continue
          nrbar(1)=0
          iofset=0
      end if
      if(ida(6).gt.0) then
          do 21 l=ibas1+1,ibas1+n1
           identl=issn(l)
           if(ida(6).eq.1) then
              denspp(identl)=denspp(identl)/salpot*(n1+1)/max(1,n1)
           else if(ida(6).eq.2) then
              dr=sqrt((x(1,l)-x0)**2+x(2,l)**2+(x(3,l)-z01)**2)
              rhol=1./(1.+exp((dr-rap)/da(2)))/rhomx1
              denspp(identl)=rhol
           end if
           expon=denspp(identl)**0.33333
           do 23 i=1,3
             p(i,l)=p(i,l)*expon
  23       continue
           p(0,l)=sqrt(emproj**2+p(1,l)**2+p(2,l)**2+p(3,l)**2)
  21      continue
          do 22 l=1+n1+ibas2,nt+ibas2
           identl=issn(l)
           if(ida(6).eq.1) then
              denspp(identl)=denspp(identl)/salpot*(n2+1)/max(1,n2)
           else if(ida(6).eq.2) then
              dr=sqrt((x(1,l)+x0)**2+x(2,l)**2+(x(3,l)-z02)**2)
              rhol=1./(1.+exp((dr-rat)/da(2)))/rhomx2
              denspp(identl)=rhol
           end if
           expon=denspp(identl)**0.33333
           do 24 i=1,3
             p(i,l)=p(i,l)*expon
  24       continue
           p(0,l)=sqrt(emnuc**2+p(1,l)**2+p(2,l)**2+p(3,l)**2)
  22      continue
      end if
      if(switch(21))then
         il=0
         n1new=0
         iz1new=0
         n2new=0
         iz2new=0
         ipro=0
         do 130  l=1,nt
            if(ityp(l).eq.-9999) go to 130
            if(l-ibas1.le.n1.and.l-ibas1.gt.0) then
               inc=1
               ipro=1
            else
               inc=2
            end if
            il=il+1
            call store(il,l)
            if(inc.eq.1) then
              n1new=n1new+1
              if(iz1.ge.0)
     a           iz1new=iz1new+(ityp(il)-1)
            else
              n2new=n2new+1
              iz2new=iz2new+(ityp(il)-1)
            end if
  130    continue
         if(ipro.eq.0.or.iz1.ge.0) then
            iz1=iz1new
         end if
         iz2=iz2new
         n1=n1new
         n2=n2new
         nt=n1+n2
         if(n1+n2.ne.il) then
            call errex(
     a         'incorrect number of participants for sw(21) in init')
         end if
         if(iz1.ge.0) then
            ibas1=0
            ibas2=0
         else
            ibas1=n2
            ibas2=-n1
         end if
      else
        call shift(ibas1,n1)
        if(n2.gt.0)  call shift(n1+ibas2,n2)
      end if
      iloop=0
  199 continue
      if(n1.le.1) go to 217
      if(n1.eq.2.and.iloop.ge.1)  go to 217
      do 210 l=1+ibas1,n1+ibas1
      identl=issn(l)
      dcoef(l)=0.
      denspp(identl)=0.
      force(1,l)=0.
      chi(l)=0.
      pp=0.
      do 211 i=1,3
  211 pp=pp+p(i,l)*p(i,l)
      force(0,l)=emproj**2+pp
      h(l)=p(0,l)*p(0,l) -(emproj**2 +pp)
      do 209 k=1+ibas1,l-1
      identk=issn(k)
      do 208 i=0,3
      qlk(i)= x(i,l)-x(i,k)
      plk(i)= p(i,l)+p(i,k)
  208 continue
      dqlksq =qlk(0) *qlk(0)
      splksq =plk(0) *plk(0)
      dqsplk =qlk(0) *plk(0)
      qplkvc =0.
      do  207 i=1,3
      dqlksq =dqlksq - qlk(i) *qlk(i)
      splksq =splksq - plk(i) *plk(i)
      qplkvc =qplkvc + qlk(i) *plk(i)
  207 continue
      dqsplk =dqsplk - qplkvc
      if(-dqlksq.lt. dstint) then
         zlk=dqlksq - dqsplk*dqsplk/splksq
         if(ida(14).eq.1)then
            cofact=-exp(dqlksq/al)*(al/dqlksq) *emnuc**4
            chi(l)=chi(l) + cofact * dqsplk/sqrt(splksq)
            chi(k)=chi(k) - cofact * dqsplk/sqrt(splksq)
            dcoef(l)=dcoef(l)+
     a            cofact*(plk(0)*x(0,k)+qplkvc)/sqrt(splksq)
            dcoef(k)=dcoef(k)+
     a            cofact*(plk(0)*x(0,l)-qplkvc)/sqrt(splksq)
            force(1,l)=force(1,l)+cofact*plk(0)/sqrt(splksq)
            force(1,k)=force(1,k)+cofact*plk(0)/sqrt(splksq)
         else
            cofact=-exp(dqlksq/al)*(al/dqlksq)
            chi(l)=chi(l) + cofact * dqsplk
            chi(k)=chi(k) - cofact * dqsplk
            dcoef(l)=dcoef(l)+
     a            cofact*(plk(0)*x(0,k)+qplkvc)
            dcoef(k)=dcoef(k)+
     a            cofact*(plk(0)*x(0,l)-qplkvc)
            force(1,l)=force(1,l)+(cofact*plk(0))
            force(1,k)=force(1,k)+cofact*plk(0)
         end if
         if(iz1.ge.0) then
           denspp(identl)=denspp(identl)+(exp(zlk/alpot))
           denspp(identk)=denspp(identk)+(exp(zlk/alpot))
         end if
      end if
  209 continue
  210 continue
      if(iz1.lt.0) then
          write(lun8,*) 'this part is not usable at the moment'
          call errex('change source text')
      end if
      do 220 l=1+ibas1,n1+ibas1
      identl=issn(l)
      force(0,l)=force(0,l)+
     a        coef1*denspp(identl)+
     b            coef2*(denspp(identl)/salpot)**gamma
      h(l)=h(l)-coef1*denspp(identl)-
     a        coef2*(denspp(identl)/salpot)**gamma
      p(0,l)=sqrt(force(0,l))
      if(force(1,l).ne.0.0) then
        x(0,l)=dcoef(l)/force(1,l)
      end if
  220 continue
  217 continue
      if(n2.le.1) go to 317
      if(n2.eq.2.and.iloop.ge.1)  go to 317
      do 310 l=n1+1+ibas2,nt+ibas2
      identl=issn(l)
      dcoef(l)=0.
      denspp(identl)=0.
      force(1,l)=0.
      chi(l)=0.
      pp=0.
      do 311 i=1,3
  311 pp=pp+p(i,l)*p(i,l)
      force(0,l)=emnuc**2+pp
      h(l)=p(0,l)*p(0,l) -(emnuc**2 +pp)
      do 309 k=n1+1+ibas2,l-1
      identk=issn(k)
      do 308 i=0,3
      qlk(i)= x(i,l)-x(i,k)
      plk(i)= p(i,l)+p(i,k)
  308 continue
      dqlksq =qlk(0) *qlk(0)
      splksq =plk(0) *plk(0)
      dqsplk =qlk(0) *plk(0)
      qplkvc =0.
      do  307 i=1,3
      dqlksq =dqlksq - qlk(i) *qlk(i)
      splksq =splksq - plk(i) *plk(i)
      qplkvc =qplkvc + qlk(i) *plk(i)
  307 continue
      dqsplk =dqsplk - qplkvc
      if(-dqlksq.lt. dstint) then
         zlk=dqlksq - dqsplk*dqsplk/splksq
         if(ida(14).eq.1)then
            cofact=-exp(dqlksq/al)*(al/dqlksq) *emnuc**4
            chi(l)=chi(l)+cofact*dqsplk/sqrt(splksq)
            chi(k)=chi(k)-cofact*dqsplk/sqrt(splksq)
            dcoef(l)=dcoef(l)+
     a            cofact*(plk(0)*x(0,k)+qplkvc)/sqrt(splksq)
            dcoef(k)=dcoef(k)+
     a            cofact*(plk(0)*x(0,l)-qplkvc)/sqrt(splksq)
            force(1,l)=force(1,l)+cofact*plk(0)/sqrt(splksq)
            force(1,k)=force(1,k)+cofact*plk(0)/sqrt(splksq)
         else
            cofact=-exp(dqlksq/al)*(al/dqlksq)
            chi(l)=chi(l)+cofact*dqsplk
            chi(k)=chi(k)-cofact*dqsplk
            dcoef(l)=dcoef(l)+
     a            cofact*(plk(0)*x(0,k)+qplkvc)
            dcoef(k)=dcoef(k)+
     a            cofact*(plk(0)*x(0,l)-qplkvc)
            force(1,l)=force(1,l)+cofact*plk(0)
            force(1,k)=force(1,k)+cofact*plk(0)
         end if
         denspp(identl)=denspp(identl)+(exp(zlk/alpot))
         denspp(identk)=denspp(identk)+(exp(zlk/alpot))
      end if
  309 continue
  310 continue
      do 320 l=n1+1+ibas2,nt+ibas2
      identl=issn(l)
      force(0,l)=force(0,l)+
     a     coef1*denspp(identl)+coef2*(denspp(identl)/salpot)**gamma
      h(l)=h(l)-coef1*denspp(identl)-
     a            coef2*(denspp(identl)/salpot)**gamma
      p(0,l)=sqrt(force(0,l))
      if(force(1,l).ne.0.0) then
        x(0,l)=dcoef(l)/force(1,l)
      end if
  320 continue
  317 continue
      iloop=iloop+1
      if(iloop.lt.9) go to 199
      emefpr=0.
      do 340 l=1+ibas1,n1+ibas1
      ct  =x(0,l)
      x(0,l)=gamnn*(ct - betann*x(3,l) )
      x(3,l)=gamnn*(x(3,l)- betann*ct  )
      p0=p(0,l)
      emefpr=emefpr+p0
      p(0,l)=gamnn*(p0- betann*p(3,l) )
      p(3,l)=gamnn*(p(3,l)- betann*p0 )
  340 continue
      if(n1.gt.0) emefpr=emefpr/n1
      emefta=0.
      do 341 l=n1+1+ibas2,nt+ibas2
      ct  =x(0,l)
      x(0,l)=gamnn*(ct+ betann*x(3,l) )
      x(3,l)=gamnn*(x(3,l)+ betann*ct )
      p0=p(0,l)
      emefta=emefta+p0
      p(0,l)=gamnn*(p0+ betann*p(3,l) )
      p(3,l)=gamnn*(p(3,l)+ betann*p0 )
  341 continue
      if(n2.gt.0) emefta=emefta/n2
      write(lun8,*) 'eff. mass of proj/target=',emefpr,emefta
      dq3mx=0.
      do 525 l=1+ibas1,n1+ibas1
      do 524 k=n1+1+ibas2,nt+ibas2
      do 522 i=0,3
      qlk(i)= x(i,l)-x(i,k)
  522 continue
      dqlksq =qlk(0) *qlk(0)
      do  523 i=1,3
      dqlksq =dqlksq - qlk(i) *qlk(i)
  523 continue
      if(dqlksq.gt.-dstint) then
        dq3=-qlk(3)+sqrt(dstint+dqlksq +qlk(3)*qlk(3))
        dq3mx=max(dq3mx,dq3)
      end if
  524 continue
  525 continue
      if(dq3mx.gt.0.) then
          do 526 l=1+ibas1,n1+ibas1
          x(3,l)=x(3,l)+dq3mx
  526     continue
      end if
       zmnpr=((z01-rap)+gamnn*dq3mx)/gampr
       zmxpr=((z01+rap)+gamnn*dq3mx)/gampr
       zmnta=(z02-rat)/gamta
       zmxta=(z02+rat)/gamta
       zproj=0.5*(zmxpr+zmnpr)
       tkoll=(zmxta-zmnpr)/(betapr-betata)
       zkoll=zmnpr+betapr*tkoll
       zmxpr=zmxpr-zmnpr
       zmnta=zmnta-zmxta
       zmnpr=0.0
       zmxta=0.0
       tcoll=cvalu0
       zcoll=cvalu0
      do 739 l=1,nt
       x(0,l)=x(0,l)-tkoll
       x(3,l)=x(3,l)-zkoll
  739 continue
      if(ida(27).eq.1)  call initfa
      if(ref.eq.'lab') then
        do 740 l=1,nt
        ct=x(0,l)
        x(0,l)=gamnn*(ct-betann*x(3,l))
        x(3,l)=gamnn*(x(3,l)-betann*ct)
        p0=p(0,l)
        p(0,l)=gamnn*(p0- betann*p(3,l))
        p(3,l)=gamnn*(p(3,l)-betann*p0)
  740   continue
      end if
       do 741 l=1,nt
        tlast(l)=x(0,l)
        identl=issn(l)
        zlast(identl)=x(3,l)-(pnorm(0)*x(0,l)-pnorm(3)*x(3,l))*pnorm(3)
        if(identl.le.n1old) then
          ylast(identl)=yproj
        else
          ylast(identl)=ytarg
        end if
  741  continue
      do 818 i=0,3
  818 pcorr(i)=0.
      do 819 i=0,3
  819 psyst(i)=0.
      do 821 l=1,nt
      do 820 i=0,3
      psyst(i)=psyst(i)+p(i,l)
  820 continue
  821 continue
      write(lun8,*) 'total momentum after initialization'
      write(lun8,*) (psyst(i),i=0,3)
      return
      end
      subroutine shift(ind,n)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       cpx=0.
       cpy=0.
       cpz=0.
       do 100 ie=1,n
        i=ind+ie
        cpx=cpx+p(1,i)
        cpy=cpy+p(2,i)
        cpz=cpz+p(3,i)
 100   continue
       cpx=-cpx/float(n)
       cpy=-cpy/float(n)
       cpz=-cpz/float(n)
       do 101 ie=1,n
        i=ind+ie
        p(1,i)=p(1,i)+cpx
        p(2,i)=p(2,i)+cpy
        p(3,i)=p(3,i)+cpz
 101   continue
      return
      end
      subroutine spctat(ianf,jcl,ispc)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
        logical hit
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'ver   rqmd7 -- 18-jun-89,18:25:20'/
      data pronam /'spctat transfers partcls. to spectator region'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      lloop=ianf
      idelte=0
      ibar=ianf+nrbar(jcl)
      iend=ibar+nrmes(jcl)
      do 10 l=ianf+1,iend
          if(ispc.eq.0) then
            ispctr=ispect(l)
            if(ispctr.gt.2) then
             iorig=1
             do 11 k=ianf+1,iend
               if( hit(iorig,k,l,srt,sig,sigel,thit) ) then
                  ispctr=0
                  go to 12
               end if
   11        continue
             ispctr=mod(ispctr,3)
   12        continue
            end if
          else
             ispctr=0
             ytl=0.5*alog((p(0,l)-p(3,l))/(p(0,l)+p(3,l)))+ytarg
             ypl=0.5*alog((p(0,l)+p(3,l))/(p(0,l)-p(3,l)))-yproj
             if(ytl.lt.1.5) ispctr=2
             if(ypl.lt.1.5.and.ispctr.eq.0) ispctr=1
             if(ispctr.eq.0.and.decay(l).ne.1.e+35) ispctr=2
          end if
          if(ispctr.ne.0) then
             if(l.le.ibar)then
                 nrbar(jcl)=nrbar(jcl)-1
             else
                 nrmes(jcl)=nrmes(jcl)-1
             endif
             idelte=idelte+1
             nspect=nspect+1
             if(ispctr.eq.1) then
                 nsppr=nsppr+1
             else
                 nspta=nspta+1
             end if
             ind=ntotma+1-nspect
             if(ind.le.lmax)
     a             call errex('too many spectators in spctat')
              call store(ind,l)
              lastcl(ind)=-ispctr*100000-lastcl(ind)
              go to 10
          end if
          lloop=lloop+1
          if(idelte.eq.0)go to 10
          do 30 i=0,3
                qdot(i,lloop)=qdot(i,l)
                x(i,lloop)=x(i,l)
                p(i,lloop)=p(i,l)
   30         continue
              em(lloop)=em(l)
              ityp(lloop)=ityp(l)
              decay(lloop)=decay(l)
              lastcl(lloop)=lastcl(l)
              issn(lloop)=issn(l)
              npidec(lloop)=npidec(l)
              tlast(lloop)=tlast(l)
              ichbig(lloop)=ichbig(l)
   10 continue
      if(lloop-ianf.ne.nrbar(jcl)+nrmes(jcl))
     a        call errex('particle lost in spectat')
      return
      end
      function ispect(il)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      if(ityp(il).eq.-9999) then
         ispect=0
         return
      end if
      ilike=0
      dpsq=(x(1,il)-bplus)**2+x(2,il)**2 - rprsq
      dtsq=(x(1,il)+bplus)**2+x(2,il)**2 - rtasq
      if(dpsq.le.0.) ilike=ilike+1
      if(dtsq.le.0.) ilike=ilike+2
      if(ilike.eq.0) then
         ispect=0
         return
      else if(ilike.eq.3) then
         deltzp=x(3,il)-  betapl *x(0,il)
         if(deltzp.gt.zmxpr) then
          if(nspta.gt.0) then
            deltz=x(3,il)- betata*x(0,il)
            yil=0.5*alog( (p(0,il)-p(3,il))/(p(0,il)+p(3,il)) ) +
     a                 ytarg
            if(yil.lt.1.1 .and. deltz.ge.zmnta.and.
     a                                      deltz.le.zmxta) then
                 ispect=5
                 return
            end if
          end if
          ispect=0
          return
         end if
         deltzp=x(3,il)-betatl*x(0,il)
         if(deltzp.lt.zmnta) then
          if(nsppr.gt.0) then
            yil=0.5*alog( (p(0,il)+p(3,il))/(p(0,il)-p(3,il)) ) -
     a                 yproj
            deltz=x(3,il)- betapr*x(0,il)
            if(yil.lt.1.1 .and. deltz.ge.zmnpr.and.
     a                                      deltz.le.zmxpr) then
                 ispect=4
                 return
            end if
          end if
         end if
      else if(ilike.eq.1) then
         deltz=x(3,il)- betapr*x(0,il)
         if(deltz.ge.zmnpr.and.
     a        deltz.le.zmxpr) then
            ispect=1
            return
         end if
      else if(ilike.eq.2) then
         deltz=x(3,il)- betata*x(0,il)
         if(deltz.ge.zmnta.and.
     a        deltz.le.zmxta) then
            ispect=2
            return
         end if
      endif
      ispect=0
      return
      end
      subroutine initfa
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      dimension qlk(0:3),plk(0:3)
      ztamx=zmxta* sqrt(1./(1.-betata*betata))/gamnn
      zprmn=zmnpr* sqrt(1./(1.-betapr*betapr))/gamnn
      tprop=0.5*(zprmn-ztamx)/betann
      if(n1.eq.1.or.n2.eq.1) then
         tprop=tprop-0.1
      end if
      if(iz1.ge.0) then
            ibas1=0
            ibas2=0
      else
            ibas1=n2
            ibas2=-n1
      end if
      do 20 l=1+ibas1,n1+ibas1
       x(3,l)=x(3,l)-betann*(tprop-x(0,l))
       x(0,l)=tprop
   20 continue
      do 30 l=n1+1+ibas2,nt+ibas2
       x(3,l)=x(3,l)+betann*(tprop-x(0,l))
       x(0,l)=tprop
   30 continue
      do   23 l=1,nt
   23 chi(l)=0.
      do   13 l=1,nt
      do   12 k=l+1,nt
        do 10 i=0,3
         plk(i)=p(i,l)+p(i,k)
         qlk(i)=x(i,l)-x(i,k)
   10   continue
        dqlksq=0.
        splksq=plk(0)*plk(0)
        dqsplk=qlk(0)*plk(0)
        do   11 i=1,3
         dqlksq=dqlksq- qlk(i)*qlk(i)
         splksq=splksq- plk(i)*plk(i)
         dqsplk=dqsplk- qlk(i)*plk(i)
   11   continue
        if(-dqlksq.lt. dstint) then
          if(-dqlksq.lt.0.000001) then
              dqlksq=-0.000001
          end if
          if(dqlksq.gt. 0.)then
            call errex('initfa:dqlksq>0. not allowed')
          end if
          if(ida(14).eq.1) then
            cofact=exp(dqlksq/al)*abs(al/dqlksq)*em(l)**2 *em(k)**2
     a                              * dqsplk/sqrt(splksq)
          else
             cofact=exp(dqlksq/al)*abs(al/dqlksq) *dqsplk
          end if
          chi(l)=chi(l) + cofact
          chi(k)=chi(k) - cofact
        end if
   12  continue
       if(chi(l).gt. 10.)   ichbig(l)=1
   13 continue
      return
      end
      subroutine store(j,k)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
                    do 111 i=0,3
                     x(i,j)=x(i,k)
                     qdot(i,j)=qdot(i,k)
                     p(i,j)=p(i,k)
  111               continue
                    em(j)=em(k)
                    ityp(j)=ityp(k)
                    decay(j)=decay(k)
                    lastcl(j)=lastcl(k)
                    issn(j)=issn(k)
                    npidec(j)=npidec(k)
                    tlast(j)=tlast(k)
                    ichbig(j)=ichbig(k)
      return
      end
      function ictype(ityp1,ityp2)
#include "amsrqmd.h"
       if(ityp1.gt.ityp2) then
         iii=ityp1
         jjj=ityp2
       else
         iii=ityp2
         jjj=ityp1
       end if
       ictype=(iii*(iii-1))/2+jjj
      return
      end
      subroutine emuls(izta,nta)
#include "amsrqmd.h"
      zrand=ranf(0)
      if (zrand.lt..123804) then
        nta=1
        izta=1
      elseif (zrand.lt..278765) then
        nta=12
        izta=6
      elseif (zrand.lt..316723) then
        nta=14
        izta=7
      elseif (zrand.lt..436329) then
        nta=16
        izta=8
      elseif (zrand.lt..438570) then
        nta=32
        izta=16
      elseif (zrand.lt..697722) then
        nta=80
        izta=35
      elseif (zrand.lt..998168) then
        nta=108
        izta=47
      else
        nta=127
        izta=53
      endif
      return
      end
CPAT,JETSET1  .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine lupart(ip,kf,pe,the,phi)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
 
      if(mst(19).ge.1) call lulist(-1)
      if(ip.ge.mst(30)-5-mst(31)) mst(26)=1
      ir=max(ip,1)
      k(ir,1)=0
      k(ir,2)=kf
      if(mst(9).eq.0) p(ir,5)=ulmass(1,kf)
      p(ir,4)=max(pe,p(ir,5))
      pa=sqrt(p(ir,4)**2-p(ir,5)**2)
      p(ir,1)=pa*sin(the)*cos(phi)
      p(ir,2)=pa*sin(the)*sin(phi)
      p(ir,3)=pa*cos(the)
      n=ir
      if(ip.eq.0) call luexec
 
      return
      end
 
 
      subroutine lu1jet(ip,ifl,iflj,ifli,pe,the,phi)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
 
      if(iabs(ifl).gt.100) mst(26)=2
      ir=max(iabs(ip),1)
      call lupart(ir,ifl+isign(500,2*ifl+1),pe,the,phi)
      if(ip.lt.0) k(n,1)=10000
 
      if(iflj.ne.0.or.ifli.ne.0) then
        if(iabs(iflj).gt.10.or.iabs(ifli).gt.10.or.(iflj.ne.0.and.
     &  iabs(ifl).lt.10).or.ifl*iflj.lt.0.or.(ifli.ne.0.and.ifl.eq.0).
     &  or.ifl*(10-iabs(ifl))*ifli.gt.0) mst(26)=2
        n=ir+1
        k(n,1)=60000+ir
        k(n,2)=isign(600+10*iabs(iflj)+iabs(ifli),iflj+ifli)
        do 100 j=1,5
  100   p(n,j)=0.
      endif
      if(ip.eq.0) call luexec
 
      return
      end
 
 
      subroutine lu2jet(ip,ifl1,ifl2,ecm)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
 
      if(iabs(ifl1).gt.100.or.iabs(ifl2).gt.100.or.(ifl1.eq.0.and.
     &ifl2.ne.0).or.(ifl1.ne.0.and.ifl2.eq.0).or.ifl1*(10-
     &iabs(ifl1))*ifl2*(10-iabs(ifl2)).gt.0) mst(26)=2
      ir=max(iabs(ip),1)
      if(mst(9).eq.0) p(ir,5)=ulmass(2,ifl1)
      if(mst(9).eq.0) p(ir+1,5)=ulmass(2,ifl2)
      if(ecm.le.p(ir,5)+p(ir+1,5)) mst(26)=4
      pe1=0.5*(ecm+(p(ir,5)**2-p(ir+1,5)**2)/ecm)
      mst(9)=mst(9)+1
      call lupart(ir,ifl1+isign(500,2*ifl1+1),pe1,0.,0.)
      k(n,1)=10000
      call lupart(ir+1,ifl2+isign(500,2*ifl2+1),ecm-pe1,par(71),0.)
      mst(9)=mst(9)-1
      if(ip.eq.0) call luexec
 
      if(ip.lt.0) then
        k(ir+2,1)=k(ir+1,1)
        k(ir+2,2)=k(ir+1,2)
        do 100 j=1,5
  100   p(ir+2,j)=p(ir+1,j)
        do 110 i=ir+1,ir+3,2
        k(i,1)=70000+i-1
        k(i,2)=1000+i-1
        p(i,3)=0.
        p(i,4)=0.
  110   p(i,5)=0.
        p(ir+1,1)=ir+2
        p(ir+1,2)=ir+2
        p(ir+3,1)=ir
        p(ir+3,2)=ir
        n=n+2
      endif
 
      return
      end
 
 
      subroutine lu3jet(ip,ifl1,ifl3,ecm,x1,x3)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      if(iabs(ifl1).gt.100.or.iabs(ifl3).gt.100.or.(ifl1.eq.0.and.
     &ifl3.ne.0).or.(ifl1.ne.0.and.ifl3.eq.0).or.ifl1*(10-
     &iabs(ifl1))*ifl3*(10-iabs(ifl3)).gt.0) mst(26)=2
      ir=max(ip,1)
      if(mst(9).eq.0) p(ir,5)=ulmass(2,ifl1)
      if(mst(9).eq.0) p(ir+1,5)=ulmass(2,0)
      if(mst(9).eq.0) p(ir+2,5)=ulmass(2,ifl3)
      if(0.5*x1*ecm.le.p(ir,5).or.0.5*(2.-x1-x3)*ecm.le.p(ir+1,5).or.
     &0.5*x3*ecm.le.p(ir+2,5)) mst(26)=4
      pa1=sqrt((0.5*x1*ecm)**2-p(ir,5)**2)
      pa2=sqrt((0.5*(2.-x1-x3)*ecm)**2-p(ir+1,5)**2)
      pa3=sqrt((0.5*x3*ecm)**2-p(ir+2,5)**2)
 
      cthe2=(pa3**2-pa1**2-pa2**2)/(2.*pa1*pa2)
      if(abs(cthe2).ge.1.001) mst(26)=4
      if(abs(cthe2).le.1.001) cthe2=max(-1.,min(1.,cthe2))
      the2=-acos(cthe2)
      cthe3=(pa2**2-pa1**2-pa3**2)/(2.*pa1*pa3)
      if(abs(cthe3).ge.1.001) mst(26)=4
      if(abs(cthe3).le.1.001) cthe3=max(-1.,min(1.,cthe3))
      the3=acos(cthe3)
      mst(9)=mst(9)+1
      call lupart(ir,ifl1+isign(500,2*ifl1+1),0.5*x1*ecm,0.,0.)
      k(n,1)=10000
      call lupart(ir+1,500,0.5*(2.-x1-x3)*ecm,the2,0.)
      k(n,1)=10000
      call lupart(ir+2,ifl3+isign(500,2*ifl3+1),0.5*x3*ecm,the3,0.)
      mst(9)=mst(9)-1
      if(ip.eq.0) call luexec
 
      return
      end
 
 
      subroutine lu4jet(ip,ifl1,ifl2,ifl3,ifl4,ecm,x1,x2,x4,x12,x14)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
 
      if(iabs(ifl1).gt.100.or.iabs(ifl2).gt.100.or.iabs(ifl3).gt.100.
     &or.iabs(ifl4).gt.100) mst(26)=2
      if(ifl2.eq.0.and.(ifl3.ne.0.or.(ifl1.eq.0.and.ifl4.ne.0).or.
     &(ifl1.ne.0.and.ifl4.eq.0).or.ifl1*(10-iabs(ifl1))*ifl4*
     &(10-iabs(ifl4)).gt.0)) mst(26)=2
      if(ifl2.ne.0.and.(ifl1.eq.0.or.ifl1*(10-iabs(ifl1))*ifl2*
     &(10-iabs(ifl2)).gt.0.or.(ifl3.eq.0.and.ifl4.ne.0).or.
     &(ifl3.ne.0.and.ifl4.eq.0).or.ifl3*(10-iabs(ifl3))*ifl4*
     &(10-iabs(ifl4)).gt.0)) mst(26)=2
      ir=max(ip,1)
      if(mst(9).eq.0) p(ir,5)=ulmass(2,ifl1)
      if(mst(9).eq.0) p(ir+1,5)=ulmass(2,ifl2)
      if(mst(9).eq.0) p(ir+2,5)=ulmass(2,ifl3)
      if(mst(9).eq.0) p(ir+3,5)=ulmass(2,ifl4)
      if(0.5*x1*ecm.le.p(ir,5).or.0.5*x2*ecm.le.p(ir+1,5).or.
     &0.5*(2.-x1-x2-x4)*ecm.le.p(ir+2,5).or.0.5*x4*ecm.le.
     &p(ir+3,5)) mst(26)=4
      pa1=sqrt((0.5*x1*ecm)**2-p(ir,5)**2)
      pa2=sqrt((0.5*x2*ecm)**2-p(ir+1,5)**2)
      pa3=sqrt((0.5*(2.-x1-x2-x4)*ecm)**2-p(ir+2,5)**2)
      pa4=sqrt((0.5*x4*ecm)**2-p(ir+3,5)**2)
 
      x24=x1+x2+x4-1.-x12-x14+(p(ir+2,5)**2-p(ir,5)**2-
     &p(ir+1,5)**2-p(ir+3,5)**2)/ecm**2
      cthe4=(x1*x4-2.*x14)*ecm**2/(4.*pa1*pa4)
      if(abs(cthe4).ge.1.002) mst(26)=4
      if(abs(cthe4).le.1.002) cthe4=max(-1.,min(1.,cthe4))
      the4=acos(cthe4)
      cthe2=(x1*x2-2.*x12)*ecm**2/(4.*pa1*pa2)
      if(abs(cthe2).ge.1.002) mst(26)=4
      if(abs(cthe2).le.1.002) cthe2=max(-1.,min(1.,cthe2))
      the2=acos(cthe2)
      cthe3=-(pa1+pa2*cthe2+pa4*cthe4)/pa3
      if(abs(cthe3).ge.1.002) mst(26)=4
      if(abs(cthe3).le.1.002) cthe3=max(-1.,min(1.,cthe3))
      the3=acos(cthe3)
      sgn=(-1.)**int(rlu(0)+0.5)
      cphi2=((x2*x4-2.*x24)*ecm**2-4.*pa2*cthe2*pa4*cthe4)/
     &(4.*pa2*sin(the2)*pa4*sin(the4))
      if(abs(cphi2).ge.1.05) mst(26)=4
      if(abs(cphi2).le.1.05) cphi2=max(-1.,min(1.,cphi2))
      phi2=sgn*acos(cphi2)
      cphi3=-(pa2*sin(the2)*cphi2+pa4*sin(the4))/(pa3*sin(the3))
      if(abs(cphi3).ge.1.05) mst(26)=4
      if(abs(cphi3).le.1.05) cphi3=max(-1.,min(1.,cphi3))
      phi3=-sgn*acos(cphi3)
 
      mst(9)=mst(9)+1
      call lupart(ir,ifl1+isign(500,2*ifl1+1),0.5*x1*ecm,0.,0.)
      k(n,1)=10000
      call lupart(ir+1,ifl2+isign(500,2*ifl2+1),0.5*x2*ecm,the2,phi2)
      if(ifl2.eq.0) k(n,1)=10000
      call lupart(ir+2,ifl3+isign(500,2*ifl3+1),0.5*(2.-x1-x2-x4)*ecm,
     &the3,phi3)
      k(n,1)=10000
      call lupart(ir+3,ifl4+isign(500,2*ifl4+1),0.5*x4*ecm,the4,0.)
      mst(9)=mst(9)-1
      if(ip.eq.0) call luexec
 
      return
      end
 
 
      function klu(i,j)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
 
      klu=0
      if(i.lt.0.or.j.le.0) return
      if(i.eq.0.and.j.le.1) then
        klu=n
      elseif(i.eq.0) then
        do 100 i1=1,n
        if(j.eq.2.and.k(i1,1).lt.20000) klu=klu+1
        if(j.eq.3.and.k(i1,1).lt.20000) klu=klu+luchge(k(i1,2))
        if(j.ne.3.or.k(i1,1)/10000.ne.6) goto 100
        if(k(i1-1,1).lt.20000) klu=klu+luchge(k(i1,2))
  100   if(j.eq.4.and.k(i1,1).lt.40000.and.iabs(k(i1,2)).ge.500) klu=
     &  klu+1
 
      elseif(j.le.2) then
        klu=k(i,j)
      elseif(j.le.4) then
        if(j.eq.3) klu=luchge(k(i,2))
 
        if(j.eq.4) klu=mod(k(i,1),10000)
      elseif(j.le.7) then
        i2=i
        i1=i
  110   klu=klu+1
        i3=i2
        i2=i1
        i1=mod(k(i1,1),10000)
        if(i1.gt.0.and.k(i1,1).lt.40000) goto 110
        if(j.eq.6) klu=i2
        if(j.eq.7) then
          klu=0
          do 120 i1=i2+1,i3
  120     if(mod(k(i1,1),10000).eq.i2.and.k(i1,1).lt.40000) klu=klu+1
        endif
 
      elseif(j.le.9) then
        if(j.eq.8.and.k(i,1).lt.60000.and.iabs(k(i,2)).lt.500) klu=
     &  k(i,2)
        if(j.eq.9) klu=1000
        if(j.eq.9.and.k(i,1).lt.60000.and.iabs(k(i,2)).ge.500) klu=
     &  mod(k(i,2),500)
 
      elseif(j.le.13) then
        if(k(i,1).lt.60000) klu=k(i,2)
        if(j.ge.11.and.k(i,1).ge.20000) klu=0
        kfa=iabs(k(i,2))
        if(j.ge.12.and.(kfa.eq.8.or.kfa.eq.10.or.kfa.eq.12.or.kfa.eq.
     &  14)) klu=0
        if(j.ge.13.and.luchge(kfa).eq.0) klu=0
 
      elseif(j.eq.14) then
        call luiflv(k(i,2),ifla,iflb,iflc,ksp)
        if(ksp.ge.0) klu=ifla
      endif
 
      return
      end
 
 
      function plu(i,j)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      dimension psum(4)
 
      plu=0.
      if(i.lt.0.or.j.le.0.or.(i.eq.0.and.j.gt.6)) return
      if(i.eq.0.and.j.le.4) then
        do 100 i1=1,n
  100   if(k(i1,1).lt.20000) plu=plu+p(i1,j)
      elseif(i.eq.0.and.j.eq.5) then
        do 110 j1=1,4
        psum(j1)=0.
        do 110 i1=1,n
  110   if(k(i1,1).lt.20000) psum(j1)=psum(j1)+p(i1,j1)
        plu=sqrt(max(0.,psum(4)**2-psum(1)**2-psum(2)**2-psum(3)**2))
      elseif(i.eq.0) then
        do 120 i1=1,n
        if(k(i1,1)/10000.ne.6) goto 120
        if(k(i1-1,1).lt.20000) plu=plu+luchge(k(i1,2))/3.
  120   if(k(i1,1).lt.20000) plu=plu+luchge(k(i1,2))/3.
      elseif(j.le.5) then
        plu=p(i,j)
 
      elseif(j.le.12) then
        if(j.eq.6) plu=luchge(k(i,2))/3.
        if(j.eq.7.or.j.eq.8) plu=p(i,1)**2+p(i,2)**2+p(i,3)**2
        if(j.eq.9.or.j.eq.10) plu=p(i,1)**2+p(i,2)**2
        if(j.eq.11.or.j.eq.12) plu=p(i,5)**2+p(i,1)**2+p(i,2)**2
        if(j.eq.8.or.j.eq.10.or.j.eq.12) plu=sqrt(plu)
 
      elseif(j.le.16) then
        if(j.le.14) plu=ulangl(p(i,3),sqrt(p(i,1)**2+p(i,2)**2))
        if(j.ge.15) plu=ulangl(p(i,1),p(i,2))
        if(j.eq.14.or.j.eq.16) plu=plu*180./par(71)
 
      elseif(j.le.19) then
        pmr=0.
        if(j.eq.17) pmr=p(i,5)
        if(j.eq.18) pmr=ulmass(0,17)
        pr=max(1e-20,pmr**2+p(i,1)**2+p(i,2)**2)
        plu=sign(alog(min((sqrt(pr+p(i,3)**2)+abs(p(i,3)))/sqrt(pr),
     &  1e20)),p(i,3))
 
      elseif(j.le.25) then
        if(j.eq.20) plu=2.*sqrt(p(i,1)**2+p(i,2)**2+p(i,3)**2)/par(75)
        if(j.eq.21) plu=2.*p(i,3)/par(75)
        if(j.eq.22) plu=2.*sqrt(p(i,1)**2+p(i,2)**2)/par(75)
        if(j.eq.23) plu=2.*p(i,4)/par(75)
        if(j.eq.24) plu=(p(i,4)+p(i,3))/par(75)
        if(j.eq.25) plu=(p(i,4)-p(i,3))/par(75)
      endif
 
      return
      end
 
 
      subroutine lurobo(the,phi,bex,bey,bez)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      dimension rot(3,3),pv(3)
      double precision dp(4),dbex,dbey,dbez,dga,dbep,dgabep
 
      imax=n
      if(mst(2).gt.0) imax=mst(2)
      if(the**2+phi**2.gt.1e-20) then
        rot(1,1)=cos(the)*cos(phi)
        rot(1,2)=-sin(phi)
        rot(1,3)=sin(the)*cos(phi)
        rot(2,1)=cos(the)*sin(phi)
        rot(2,2)=cos(phi)
        rot(2,3)=sin(the)*sin(phi)
        rot(3,1)=-sin(the)
        rot(3,2)=0.
        rot(3,3)=cos(the)
        do 120 i=max(1,mst(1)),imax
        if(mod(k(i,1)/10000,10).ge.6) goto 120
        do 100 j=1,3
  100   pv(j)=p(i,j)
        do 110 j=1,3
  110   p(i,j)=rot(j,1)*pv(1)+rot(j,2)*pv(2)+rot(j,3)*pv(3)
  120   continue
      endif
 
      if(bex**2+bey**2+bez**2.gt.1e-20) then
        dbex=bex
        dbey=bey
        dbez=bez
        dga=1d0/dsqrt(1d0-dbex**2-dbey**2-dbez**2)
        do 140 i=max(1,mst(1)),imax
        if(mod(k(i,1)/10000,10).ge.6) goto 140
        do 130 j=1,4
  130   dp(j)=p(i,j)
        dbep=dbex*dp(1)+dbey*dp(2)+dbez*dp(3)
        dgabep=dga*(dga*dbep/(1d0+dga)+dp(4))
        p(i,1)=dp(1)+dgabep*dbex
        p(i,2)=dp(2)+dgabep*dbey
        p(i,3)=dp(3)+dgabep*dbez
        p(i,4)=dga*(dp(4)+dbep)
  140   continue
      endif
 
      return
      end
 
 
      subroutine luedit(medit)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
 
      if(medit.ge.0.and.medit.le.3) then
        imax=n
        if(mst(2).gt.0) imax=mst(2)
        mnot=0
        i1=max(1,mst(1))-1
        do 120 i=max(1,mst(1)),imax
        if(mnot.eq.1.and.k(i,1)/20000.eq.3) goto 100
        mnot=0
        if(k(i,1).ge.40000) goto 120
        if(medit.ge.1.and.k(i,1).ge.20000) goto 120
        kfa=iabs(k(i,2))
        if(medit.ge.2.and.(kfa.eq.8.or.kfa.eq.10.or.kfa.eq.12.or.
     &  kfa.eq.14)) goto 120
        if(medit.ge.3.and.kfa.le.499.and.luchge(kfa).eq.0) goto 120
        if(kfa.ge.500) mnot=1
 
  100   i1=i1+1
        k(i1,1)=10000*(k(i,1)/10000)
        k(i1,2)=k(i,2)
        do 110 j=1,5
  110   p(i1,j)=p(i,j)
  120   continue
        n=i1
 
      elseif(medit.eq.-1) then
        if(2*n.ge.mst(30)) then
          mst(26)=1
          return
        endif
        do 130 i=1,n
        k(mst(30)-i,1)=k(i,1)
        k(mst(30)-i,2)=k(i,2)
        do 130 j=1,5
  130   p(mst(30)-i,j)=p(i,j)
        mst(31)=n
 
      elseif(medit.eq.-2) then
        do 140 i=1,mst(31)
        k(i,1)=k(mst(30)-i,1)
        k(i,2)=k(mst(30)-i,2)
        do 140 j=1,5
  140   p(i,j)=p(mst(30)-i,j)
        n=mst(31)
 
      elseif(medit.eq.-3) then
        i1=0
        do 150 i=1,n
        kh=mod(k(i,1),10000)
        if(kh.ge.1) then
          if(k(kh,1)/20000.eq.2) kh=0
        endif
        if(k(i,1).ge.60000) kh=0
        if(kh.ne.0) goto 160
        i1=i1+1
  150   if(k(i,1)/20000.eq.1) k(i,1)=k(i,1)-20000
  160   n=i1
      endif
 
      return
      end
 
 
      subroutine lulist(mlist)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      common /ludat4/ chag(50),chaf(100)
      character chag*4,chaf*4,chap*8,chan*8,chad(4)*8
      dimension ps(6)
      mst(20)=6
      if((mlist.ge.0.and.mlist.le.2).or.(mlist.ge.10.and.mlist.le.12))
     &then
        if(mlist.le.2) write(mst(20),1000)
        if(mlist.ge.10) write(mst(20),1100)
        imax=n
        if(mst(2).gt.0) imax=mst(2)
        do 100 i=max(1,mst(1)),imax
        call luname(k(i,2),chap)
        mlc=0
        if(k(i,1)/20000.eq.1) mlc=1
        if(mlc.eq.1.and.iabs(k(i,2)).ge.500) mlc=2
        if(k(i,1)/20000.eq.2) mlc=k(i,1)/10000-1
        if(mlc.ne.0) chap(8:8)=chag(36)(mlc:mlc)
        if(k(i,1).ge.70000) mlc=10
        if(mlist.le.2.and.mlc.lt.10) write(mst(20),1200) i,
     &  mod(k(i,1),10000),chap,(p(i,j),j=1,5)
        if(mlist.ge.10.and.mlc.lt.10) write(mst(20),1300) i,k(i,1),
     &  k(i,2),chap,(p(i,j),j=1,5)
        if(mlist.le.2.and.mlc.eq.10) write(mst(20),1400) i,k(i,1),
     &  k(i,2),(p(i,j),j=1,5)
  100   if(mlist.ge.10.and.mlc.eq.10) write(mst(20),1500) i,k(i,1),
     &  k(i,2),(p(i,j),j=1,5)
 
        if(mlist.eq.1.or.mlist.eq.11) then
          do 110 j=1,6
  110     ps(j)=plu(0,j)
          if(mlist.eq.1) write(mst(20),1600) ps(6),(ps(j),j=1,5)
          if(mlist.eq.11) write(mst(20),1700) ps(6),(ps(j),j=1,5)
        elseif(mlist.eq.2.or.mlist.eq.12) then
          do 120 i=n+1,n+mst(3)
          if(mlist.eq.2) write(mst(20),1400) i,k(i,1),k(i,2),
     &    (p(i,j),j=1,5)
  120     if(mlist.eq.12) write(mst(20),1500) i,k(i,1),k(i,2),
     &    (p(i,j),j=1,5)
        endif
 
      elseif(mlist.eq.3) then
        write(mst(20),1800)
        kf=max(1,mst(1))-1
  130   kf=kf+1
        write(mst(20),1900)
 
  140   call luname(kf,chap)
        call luname(-kf,chan)
        kfa=kf
        if(kf.gt.100) call luiflv(kf,ifla,iflb,iflc,ksp)
        if(kf.gt.100) kfa=100+ifla
        pm=ulmass(0,kf)
        kty=ktyp(kfa)
        if(kty.lt.10) write(mst(20),2000) kf,chap,chan,kty,pm
        if(kty.ge.10) write(mst(20),2000) kf,chap,chan,kty,pm,
     &  pwid(2*(kty/10)-1),pwid(2*(kty/10))
 
        if(kf.gt.100.and.(mst(2).le.0.or.kf.lt.mst(2))) then
          call luiflv(kf+1-50*(kf/392),ifla1,iflb1,iflc1,ksp1)
          if(ifla1.eq.ifla) kf=kf+1
          if(ifla1.eq.ifla) goto 140
          kfa=76+5*ifla+ksp
        endif
 
        if(idb(kfa).eq.0) goto 170
        idc=idb(kfa)-1
  150   idc=idc+1
        mmat=iabs(kdp(4*idc-3))/1000
        if(idc.eq.idb(kfa)) br=100.*cbr(idc)
        if(idc.ne.idb(kfa)) br=100.*(cbr(idc)-cbr(idc-1))
        do 160 j=1,4
  160   call luname(mod(kdp(4*idc-4+j),1000),chad(j))
        write(mst(20),2100) idc,mmat,br,(chad(j),j=1,4)
        if(cbr(idc).le.0.99999) goto 150
  170   if((mst(2).le.0.and.kf.lt.392).or.(mst(2).gt.0.and.kf.lt.
     &  mst(2))) goto 130
 
      elseif(mlist.eq.4) then
        write(mst(20),2200)
        ifl=max(0,mst(1))-1
  180   ifl=ifl+1
        if(ifl.gt.0.and.mod(ifl-1,10).ge.8) goto 180
        call luname(ifl+500,chap)
        call luname(-ifl-500,chan)
        pmc=ulmass(2,ifl)
        pma=ulmass(3,ifl)
        kty=ktyp(100+max(ifl/10,mod(ifl,10)))
        if(kty.lt.10) write(mst(20),2300) ifl+500,ifl,chap,chan,kty,
     &  pmc,pma
        if(kty.ge.10) write(mst(20),2300) ifl+500,ifl,chap,chan,kty,
     &  pmc,pma,pwid(2*(kty/10)-1),pwid(2*(kty/10))
        if((mst(2).le.0.and.ifl.lt.88).or.(mst(2).gt.0.and.ifl.lt.
     &  mst(2).and.(mod(ifl,10).ne.8.or.mst(2)-ifl.ge.3))) goto 180
 
      elseif(mlist.eq.5) then
        write(mst(20),2400)
        do 190 l=1,20
  190   write(mst(20),2500) l,mst(l),mst(l+20),par(l),par(l+20),
     &  par(l+40),par(l+60),dpar(l)
 
      elseif(mlist.eq.-1) then
        write(mst(20),2600)
        mst(19)=0
      endif
 
 1000 format(///20x,'event listing'//5x,'i     ori   part/jet',7x,
     &'px',9x,'py',9x,'pz',9x,'e',10x,'m'/)
 1100 format(///20x,'event listing (extended)'//5x,'i  k(i,1)  k(i,2)',
     &3x,'part/jet',7x,'p(i,1)',7x,'p(i,2)',7x,'p(i,3)',7x,'p(i,4)',
     &7x,'p(i,5)'/)
 1200 format(2x,i4,1x,i7,3x,a8,5(1x,f10.3))
 1300 format(2x,i4,2(1x,i7),3x,a8,5(1x,f12.5))
 1400 format(2x,i4,1x,i7,4x,i7,5(1x,f10.3))
 1500 format(2x,i4,2(1x,i7),11x,5(1x,f12.5))
 1600 format(10x,'sum:',6(1x,f10.3))
 1700 format(16x,'sum:',6(1x,f12.5))
 1800 format(///20x,'particle data table'//4x,'kf    particle   ',
     &'antipart  ktyp      mass     width     w-cut'/19x,
     &'idc    mat    b.r.   decay products')
 1900 format(10x)
 2000 format(1x,i5,4x,a8,3x,a8,1x,i5,3(1x,f9.3))
 2100 format(17x,i5,3x,'(',i2,')',1x,f7.1,4(3x,a8))
 2200 format(///20x,'parton/jet data table'//4x,'kf   ifl     parton',
     &'    antipar  ktyp    m-cons    m-c.a.     width     w-cut')
 2300 format(/1x,i5,1x,i5,4x,a8,3x,a8,1x,i4,4(1x,f9.3))
 2400 format(///20x,'parameter value table'//5x,'l',4x,'mst(l)',
     &3x,'&(l+20)',7x,'par(l)',6x,'&(l+20)',6x,'&(l+40)',6x,
     &'&(l+60)',6x,'dpar(l)'/)
 2500 format(1x,i5,2(1x,i9),5(1x,f12.4))
 2600 format(///20x,'the lund monte carlo - jetset version 6.2'/
     &23x,'last date of change : 30 march 1986')
 
      return
      end
 
 
      subroutine luupda(mupda,lfn)
#include "amsrqmd.h"
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      common /ludat4/ chag(50),chaf(100)
      character chag*4,chaf*4,cli*72,cut*12,cwr*12,csa*12,cre*12
 
      if(mupda.eq.1) then
        do 120 kf=1,120
        if(idb(kf).eq.0) then
          ndc=0
        else
          idc=idb(kf)-1
  100     idc=idc+1
          if(cbr(idc).le.0.99999) goto 100
          ndc=idc+1-idb(kf)
          if(kf.ge.2) then
            if(idb(kf).eq.idb(kf-1)) ndc=-1
          endif
        endif
        kty=ktyp(kf)-10*(ktyp(kf)/10)
        pwi=0.
        pcu=0.
        if(ktyp(kf).ge.10) pwi=pwid(2*(ktyp(kf)/10)-1)
        if(ktyp(kf).ge.10) pcu=pwid(2*(ktyp(kf)/10))
        if(kf.le.100) write(lfn,1000) kf,ndc,kty,pmas(kf),pwi,pcu,
     &  chaf(kf)
        if(kf.gt.100) write(lfn,1000) kf,ndc,kty,pmas(kf),pwi,pcu
        do 110 idc=idb(kf),idb(kf)+ndc-1
        mmat=iabs(kdp(4*idc-3))/1000
  110   write(lfn,1100) cbr(idc),mmat,(mod(kdp(4*idc-4+j),1000),j=1,4)
  120   continue
 
      elseif(mupda.eq.2) then
        do 130 i=1,60
  130   pwid(i)=0.
        do 140 i=1,400
  140   cbr(i)=0.
        do 150 i=1,1600
  150   kdp(i)=0
        iwis=0
        idbs=0
        do 170 kf=1,120
        if(kf.le.100) read(lfn,1000) kfa,ndc,ktyp(kf),pmas(kf),pwi,pcu,
     &  chaf(kf)
        if(kf.gt.100) read(lfn,1000) kfa,ndc,ktyp(kf),pmas(kf),pwi,pcu
        if(pwi.ge.0.0005) then
          pwid(2*iwis+1)=pwi
          pwid(2*iwis+2)=pcu
          iwis=iwis+1
          ktyp(kf)=ktyp(kf)+10*iwis
        endif
        if(ndc.eq.0) then
          idb(kf)=0
        elseif(ndc.eq.-1) then
          idb(kf)=idb(kf-1)
        else
          idb(kf)=idbs+1
          do 160 idc=idbs+1,idbs+ndc
          read(lfn,1100) cbr(idc),mmat,(kdp(4*idc-4+j),j=1,4)
  160     kdp(4*idc-3)=kdp(4*idc-3)+isign(1000*mmat,kdp(4*idc-3))
          idbs=idbs+ndc
        endif
  170   continue
 
      elseif(mupda.eq.3) then
        do 210 ic=1,12
        ne=120
        if(ic.eq.3) ne=60
        if(ic.eq.5.or.ic.eq.6) ne=200
        if(ic.ge.7.and.ic.le.11) ne=320
        if(ic.eq.12) ne=100
        cli=' '
        if(ic.eq.1) cli(7:16)='data ktyp/'
        if(ic.eq.2) cli(7:16)='data pmas/'
        if(ic.eq.3) cli(7:16)='data pwid/'
        if(ic.eq.4) cli(7:15)='data idb/'
        if(ic.eq.5) cli(7:28)='data (cbr(j),j=1,200)/'
        if(ic.eq.6) cli(7:30)='data (cbr(j),j=201,400)/'
        if(ic.eq.7) cli(7:28)='data (kdp(j),j=1,320)/'
        if(ic.eq.8) cli(7:30)='data (kdp(j),j=321,640)/'
        if(ic.eq.9) cli(7:30)='data (kdp(j),j=641,960)/'
        if(ic.eq.10) cli(7:31)='data (kdp(j),j=961,1280)/'
        if(ic.eq.11) cli(7:32)='data (kdp(j),j=1281,1600)/'
        if(ic.eq.12) cli(7:16)='data chaf/'
        lct=16
        if(ic.eq.4) lct=15
        if(ic.eq.5.or.ic.eq.7) lct=28
        if(ic.eq.6.or.ic.eq.8.or.ic.eq.9) lct=30
        if(ic.eq.10) lct=31
        if(ic.eq.11) lct=32
        csa='start'
        do 200 ie=1,ne
        if(ic.eq.1) write(cut,1200) ktyp(ie)
        if(ic.eq.2) write(cut,1300) pmas(ie)
        if(ic.eq.3) write(cut,1300) pwid(ie)
        if(ic.eq.4) write(cut,1200) idb(ie)
        if(ic.eq.5) write(cut,1300) cbr(ie)
        if(ic.eq.6) write(cut,1300) cbr(200+ie)
        if(ic.eq.7) write(cut,1200) kdp(ie)
        if(ic.eq.8) write(cut,1200) kdp(320+ie)
        if(ic.eq.9) write(cut,1200) kdp(640+ie)
        if(ic.eq.10) write(cut,1200) kdp(960+ie)
        if(ic.eq.11) write(cut,1200) kdp(1280+ie)
        if(ic.eq.12) cut=chaf(ie)
        cwr=' '
        la=1
        lb=1
        do 180 ll=1,12
        if(cut(13-ll:13-ll).ne.' ') la=13-ll
  180   if(cut(ll:ll).ne.' ') lb=ll
        lon=1+lb-la
        cwr(1:lon)=cut(la:lb)
        if(ic.eq.12) then
          cut=cwr
          cwr(1:lon+2)=''''//cut(1:lon)//''''
          lon=lon+2
        elseif(ic.eq.2.or.ic.eq.3.or.ic.eq.5.or.ic.eq.6) then
          lon=lon+1
  190     lon=lon-1
          if(cwr(lon:lon).eq.'0') goto 190
          if(lon.eq.1) cwr(1:2)='0.'
          if(lon.eq.1) lon=2
        endif
        if(cwr.ne.csa) then
          iag=1
          csa=cwr
        else
          lex=lon+1
          if(iag.ge.2) lex=lon+3
          if(iag.ge.10) lex=lon+4
          if(iag.ge.100) lex=lon+5
          lct=lct-lex
          iag=iag+1
          write(cre,1200) iag
          lex=1
          if(iag.ge.10) lex=2
          if(iag.ge.100) lex=3
          cut=cwr
          cwr(1:lex+1+lon)=cre(13-lex:12)//'*'//cut(1:lon)
          lon=lon+lex+1
        endif
        if(lct+lon.gt.70) then
          cli(lct+1:72)=' '
          write(lfn,1400) cli
          cli=' '
          cli(6:6)='&'
          lct=6
        endif
        cli(lct+1:lct+lon)=cwr(1:lon)
        lct=lct+lon+1
        if(ie.lt.ne) cli(lct:lct)=','
  200   if(ie.eq.ne) cli(lct:lct)='/'
  210   write(lfn,1400) cli
      endif
 
 1000 format(3i5,3f12.5,2x,a4)
 1100 format(5x,f12.5,5i5)
 1200 format(i12)
 1300 format(f12.5)
 1400 format(a72)
 
      return
      end
 
 
      subroutine luexec
#include "amsrqmd.h"
 
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      common/prinbk/ iprin
      dimension psum(2,5)
      ierror_dum=0
      if(mst(19).ge.1) call lulist(-1)
      mst(2)=0
      mst(3)=0
      nerr=mst(24)
      mst(20)=6
      mst(25)=0
      mst(32)=0
      mst(34)=mst(34)+1
      par(75)=0.
      do 100 i=1,n
  100 if(mod(k(i,1),10000).eq.0) par(75)=par(75)+p(i,4)
 
      do 110 i=1,2
      do 110 j=1,5
  110 psum(i,j)=0.
      icon=0
      do 130 i=1,n
      if(k(i,1).ge.20000) goto 130
      do 120 j=1,4
  120 psum(1,j)=psum(1,j)+p(i,j)
      psum(1,5)=psum(1,5)+luchge(k(i,2))
      if(i.eq.n) goto 130
      if(k(i+1,1)/10000.eq.6) psum(1,5)=psum(1,5)+luchge(k(i+1,2))
  130 continue
 
      call luprep
      mst(1)=0
      if(mst(23).eq.1.and.mst(26).ne.0.and.mst(35).lt.5) then
        mst(35)=mst(35)+1
        if(mst(26).ne.3)
     a  write(mst(20),1000) mst(34)
        if(mst(26).eq.1) write(mst(20),1100)
        if(mst(26).eq.2) write(mst(20),1200)
        if(mst(26).eq.4) write(mst(20),1400)
        mst(26)=0
      endif
 
      ip=0
  140 ip=ip+1
      if(k(ip,1).ge.20000) then
      elseif(iabs(k(ip,2)).lt.500) then
        kfa=iabs(k(ip,2))
        if(kfa.gt.100) call luiflv(kfa,ifla,iflb,iflc,ksp)
        if(kfa.gt.100) kfa=76+5*ifla+ksp
        if(mst(7).eq.1.and.idb(kfa).ge.1) call ludecy(ip)
      elseif(iabs(k(ip,2)).le.600) then
        mos=min(mst(5),2)
        if(mos.eq.2.and.mst(6).gt.0) mos=3
        if(mst(5).eq.1.and.k(ip,1).lt.10000) mos=2
        if(mos.eq.1) call lusysj(ip)
        if(mos.eq.2) call luonej(ip)
        if(mos.eq.3) call lucons(ip)
        if(mos.eq.2) icon=1
        if(mos.eq.3.and.(mst(6).le.0.or.mod(mst(6),5).eq.0)) icon=1
      endif
 
      if(n.ge.mst(30)-20-mst(31).and.ip.lt.n.and.mst(24).eq.nerr)
     &then
        mst(24)=mst(24)+1
        mst(25)=1
      endif
      if((mst(23).eq.1.and.mst(24).gt.nerr).or.(mst(23).ge.2.and.
     &mst(24).ge.2)) then
        write(mst(20),1500) mst(24),mst(34)
        if(mst(25).eq.1) write(mst(20),1100)
        if(mst(25).eq.2) write(mst(20),1200)
        if(mst(25).eq.3) write(mst(20),1300)
        if(mst(25).eq.4) write(mst(20),1600)
        if(mst(25).eq.5) write(mst(20),1700)
      endif
      if((mst(23).eq.1.and.mst(24).ge.5).or.(mst(23).ge.2.and.
     &mst(24).ge.2)) then
        write(mst(20),1800)
        mst(1)=0
        mst(2)=0
        mst(24)=0
        call lulist(11)
        write(lun14,*)'stop in lulist 1',mst(23)
c          ierror_dum=1
          return
c        stop
      elseif(mst(23).ge.1.and.mst(24).gt.nerr) then
        return
      endif
      if(ip.lt.n) goto 140
 
      do 160 i=1,n
      if(k(i,1).ge.20000) goto 160
      do 150 j=1,4
  150 psum(2,j)=psum(2,j)+p(i,j)
      psum(2,5)=psum(2,5)+luchge(k(i,2))
      if(i.eq.n) goto 160
      if(k(i+1,1)/10000.eq.6) psum(2,5)=psum(2,5)+luchge(k(i+1,2))
  160 continue
      pdev=(abs(psum(2,1)-psum(1,1))+abs(psum(2,2)-psum(1,2))+
     &abs(psum(2,3)-psum(1,3))+abs(psum(2,4)-psum(1,4)))/
     &(1.+abs(psum(2,4))+abs(psum(1,4)))
      if(icon.eq.0.and.(pdev.gt.par(74).or.abs(psum(2,5)-psum(1,5)).
     &gt.0.25)) then
        mst(24)=mst(24)+1
        mst(25)=6
      endif
      if((mst(23).eq.1.and.mst(24).gt.nerr).or.(mst(23).ge.2.and.
     &mst(24).ge.2)) then
        write(mst(20),1500) mst(24),mst(34)
        write(mst(20),1900) ((psum(i,j),j=1,4),psum(i,5)/3.,i=1,2)
      endif
      if((mst(23).eq.1.and.mst(24).ge.5).or.(mst(23).ge.2.and.
     &mst(24).ge.2)) then
        write(mst(20),1800)
        call lulist(11)
        ierror_dum=1
        mst(24)=0
        write(*,*)'stop in lulist 2'
c        stop
        return
      endif
 
 1000 format(/5x,'warning  mst(26) flag was set at luexec ',
     &'call no',i8,'; error type is')
 1100 format(5x,'1: not enough memory available in commonblock lujets')
 1200 format(5x,'2: unphysical flavour setup of jet system')
 1300 format(5x,'3: not enough energy available in jet system ',
     &'(string fragmentation)')
 1400 format(5x,'4: inconsistent kinematics for definition of jet ',
     &'configuration')
 1500 format(/5x,'warning  error no',i2,' has occured in luexec ',
     &'call no',i8,'; error type is')
 1600 format(5x,'4: not enough energy available in jet system ',
     &'(independent fragmentation)')
 1700 format(5x,'5: no kinematically allowed decays are found for ',
     &'this particle')
 1800 format(5x,'execution will be stopped after printout of ',
     &'event listing')
 1900 format(5x,'6: momentum, energy and/or charge were not conserved'/
     &5x,'sum of',9x,'px',11x,'py',11x,'pz',11x,'e',8x,'charge'/
     &5x,'before',2x,4(1x,f12.5),1x,f8.2/5x,'after',3x,4(1x,f12.5),1x,
     &f8.2)
 
      return
      end
 
 
      subroutine luprep
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      dimension ps(5),pc(5),ue(3)
 
      ns=n
      do 120 iqg=1,2
      do 120 i=1,ns-1
      if(k(i+1,1)/10000.ne.7.or.k(i,1).ge.20000.or.iabs(k(i,2)).lt.
     &500.or.(iqg.eq.1.and.iabs(k(i,2)).eq.500)) goto 120
 
      kcs=(3-isign(1,k(i,2)*(510-iabs(k(i,2)))))/2
      ia=i
      nl=0
  100 nl=nl+1
      if(nl.gt.2*ns) then
        mst(26)=2
        return
      endif
      if(k(ia,1).lt.20000) then
        n=n+1
        if(n.ge.mst(30)-5-mst(31)) then
          mst(26)=1
          return
        endif
        k(n,1)=10000
        if(nl.ge.2.and.iabs(k(ia,2)).gt.500) k(n,1)=0
        k(n,1)=k(n,1)+max(0,k(ia+1,2)-1000)
        k(n,2)=k(ia,2)
        do 110 j=1,5
  110   p(n,j)=p(ia,j)
        k(ia,1)=k(ia,1)+20000
        if(k(n,1).lt.10000) goto 120
      endif
 
      ib=ia
      if(p(ib+1,kcs+2).gt.0.5) then
        ia=nint(p(ib+1,kcs+2))
        p(ib+1,kcs+2)=-p(ib+1,kcs+2)
        mm=0
      else
        if(p(ib+1,kcs).lt.0.5) kcs=3-kcs
        ia=nint(p(ib+1,kcs))
        p(ib+1,kcs)=-p(ib+1,kcs)
        mm=1
      endif
      if(ia.le.0.or.ia.gt.min(ns,mst(30)-mst(31))) then
        mst(26)=2
        return
      endif
      if(nint(p(ia+1,1)).eq.ib.or.nint(p(ia+1,2)).eq.ib) then
        if(mm.eq.1) kcs=3-kcs
        if(nint(p(ia+1,kcs)).ne.ib) kcs=3-kcs
        p(ia+1,kcs)=-p(ia+1,kcs)
      else
        if(mm.eq.0) kcs=3-kcs
        if(nint(p(ia+1,kcs+2)).ne.ib) kcs=3-kcs
        p(ia+1,kcs+2)=-p(ia+1,kcs+2)
      endif
      if(ia.ne.i) goto 100
      k(n,1)=k(n,1)-10000
  120 continue
 
      if(mst(21).ge.1) then
        i1=0
        do 140 i=1,n
        ks=k(i,1)/10000
        if(ks.eq.7.or.(mst(21).ge.3.and.ks.ge.2.and.ks.le.5)) goto 140
        if(ks.ge.2.and.i.lt.n.and.k(i+1,1)/10000.eq.7) then
          if(mst(21).ge.2.and.ks.ne.6) goto 140
          if(ks.le.3.and.i.gt.mst(1)) goto 140
          if(ks.le.3) k(i,1)=40000
        endif
        i1=i1+1
        k(i1,1)=k(i,1)
        k(i1,2)=k(i,2)
        do 130 j=1,5
  130   p(i1,j)=p(i,j)
  140   continue
        n=i1
      endif
 
      if(mst(12).le.0) goto 310
      ns=n
  150 nsin=n-ns
      pdm=1.+par(22)
      ic=0
      do 200 i=1,ns
      if(k(i,1).ge.20000.or.iabs(k(i,2)).lt.500) goto 200
      if(k(i,1).ge.10000.and.ic.eq.0) then
        nsin=nsin+1
        ic=i
        do 160 j=1,4
  160   ps(j)=p(i,j)
        ps(5)=ulmass(0,k(i,2))
      elseif(k(i,1).ge.10000) then
        do 170 j=1,4
  170   ps(j)=ps(j)+p(i,j)
      elseif(ic.ne.0) then
        do 180 j=1,4
  180   ps(j)=ps(j)+p(i,j)
        ps(5)=ps(5)+ulmass(0,k(i,2))
        pd=sqrt(max(0.,ps(4)**2-ps(1)**2-ps(2)**2-ps(3)**2))-ps(5)
        if(pd.lt.pdm) then
          pdm=pd
          do 190 j=1,5
  190     pc(j)=ps(j)
          icl=ic
          icu=i
        endif
        ic=0
      endif
  200 continue
      if(pdm.ge.par(22).or.nsin.eq.1) goto 310
 
      pcm=sqrt(max(0.,pc(4)**2-pc(1)**2-pc(2)**2-pc(3)**2))
      k(n+1,1)=icl
      k(n+2,1)=icu
      if(k(icl+1,1)/10000.eq.6.or.(icu.lt.n.and.k(icu+1,1)/10000.
     &eq.6)) then
        goto 310
      elseif(iabs(k(icl,2)).gt.500) then
        if(mod(k(icl,2),500)*mod(k(icu,2),500)*(510-iabs(k(icl,2)))*
     &  (510-iabs(k(icu,2))).ge.0) goto 310
  210   call luifld(mod(k(icl,2),500),0,0,ifln,k(n+1,2))
        if(iabs(ifln).ge.100.or.(iabs(ifln).gt.10.and.iabs(k(icu,2)).
     &  gt.510)) goto 210
        call luifld(mod(k(icu,2),500),0,-ifln,ifldmp,k(n+2,2))
      else
        if(iabs(k(icu,2)).ne.500) goto 310
  220   call luifld(1+int((2.+par(2))*rlu(0)),0,0,ifln,kdump)
        if(iabs(ifln).ge.100) goto 220
        call luifld(ifln,0,0,iflm,k(n+1,2))
        if(iabs(iflm).ge.100) goto 220
        call luifld(-ifln,0,-iflm,ifldmp,k(n+2,2))
      endif
      p(n+1,5)=ulmass(1,k(n+1,2))
      p(n+2,5)=ulmass(1,k(n+2,2))
      if(p(n+1,5)+p(n+2,5)+dpar(14).ge.pcm) goto 260
 
      if(pcm.ge.0.02*pc(4)) then
        pa=sqrt((pcm**2-(p(n+1,5)+p(n+2,5))**2)*(pcm**2-
     &  (p(n+1,5)-p(n+2,5))**2))/(2.*pcm)
        ue(3)=2.*rlu(0)-1.
        phi=par(72)*rlu(0)
        ue(1)=sqrt(1.-ue(3)**2)*cos(phi)
        ue(2)=sqrt(1.-ue(3)**2)*sin(phi)
        do 230 j=1,3
        p(n+1,j)=pa*ue(j)
  230   p(n+2,j)=-pa*ue(j)
        p(n+1,4)=sqrt(pa**2+p(n+1,5)**2)
        p(n+2,4)=sqrt(pa**2+p(n+2,5)**2)
        mst1s=mst(1)
        mst(1)=n+1
        n=n+2
        call lurobo(0.,0.,pc(1)/pc(4),pc(2)/pc(4),pc(3)/pc(4))
        mst(1)=mst1s
      else
        np=0
        do 240 i=icl,icu
  240   if(k(i,1).lt.20000) np=np+1
        ha=p(icl,4)*p(icu,4)-p(icl,1)*p(icu,1)-p(icl,2)*p(icu,2)-
     &  p(icl,3)*p(icu,3)
        if(np.ge.3.or.ha.le.1.25*p(icl,5)*p(icu,5)) goto 260
        hd1=0.5*(p(n+1,5)**2-p(icl,5)**2)
        hd2=0.5*(p(n+2,5)**2-p(icu,5)**2)
        hr=sqrt(max(0.,((ha-hd1-hd2)**2-(p(n+1,5)*p(n+2,5))**2)/
     &  (ha**2-(p(icl,5)*p(icu,5))**2)))-1.
        hc=p(icl,5)**2+2.*ha+p(icu,5)**2
        hk1=((p(icu,5)**2+ha)*hr+hd1-hd2)/hc
        hk2=((p(icl,5)**2+ha)*hr+hd2-hd1)/hc
        do 250 j=1,4
        p(n+1,j)=(1.+hk1)*p(icl,j)-hk2*p(icu,j)
  250   p(n+2,j)=(1.+hk2)*p(icu,j)-hk1*p(icl,j)
        n=n+2
      endif
      goto 290
 
  260 if(iabs(k(icl,2)).gt.510.and.iabs(k(icu,2)).gt.510) then
        goto 310
      elseif(iabs(k(icl,2)).gt.500) then
        call luifld(mod(k(icl,2),500),0,mod(k(icu,2),500),
     &  ifldmp,k(n+1,2))
      else
        ifln=1+int((2.+par(2))*rlu(0))
        call luifld(ifln,0,-ifln,ifldmp,k(n+1,2))
      endif
      p(n+1,5)=ulmass(1,k(n+1,2))
 
      ir=0
      ha=0.
      do 270 i=1,n
      if(k(i,1).ge.20000.or.(i.ge.icl.and.i.le.icu).or.
     &(iabs(k(i,2)).lt.500.and.i.le.ns)) goto 270
      pcr=pc(4)*p(i,4)-pc(1)*p(i,1)-pc(2)*p(i,2)-pc(3)*p(i,3)
      if(pcr.gt.ha) then
        ir=i
        ha=pcr
      endif
  270 continue
 
      hb=pcm**2+ha
      hc=p(n+1,5)**2+ha
      hd=p(ir,5)**2+ha
      hk2=0.5*(hb*sqrt(((hb+hc)**2-4.*(hb+hd)*p(n+1,5)**2)/
     &(ha**2-(pcm*p(ir,5))**2))-(hb+hc))/(hb+hd)
      hk1=(0.5*(p(n+1,5)**2-pcm**2)+hd*hk2)/hb
      do 280 j=1,4
      p(n+1,j)=(1.+hk1)*pc(j)-hk2*p(ir,j)
  280 p(ir,j)=(1.+hk2)*p(ir,j)-hk1*pc(j)
      n=n+1
 
  290 do 300 i=icl,icu
  300 if(k(i,1).le.20000.and.iabs(k(i,2)).ge.500) k(i,1)=k(i,1)+20000
      if(n.lt.mst(30)-5-mst(31)) goto 150
 
  310 np=0
      kfn=0
      kfs=0
      do 320 j=1,5
  320 ps(j)=0.
      do 350 i=1,n
      if(k(i,1).ge.20000.or.iabs(k(i,2)).lt.500) goto 350
      np=np+1
      if(iabs(k(i,2)).gt.500) then
        kfn=kfn+1
        kfs=kfs+isign(1,k(i,2)*(510-iabs(k(i,2))))
        if(n.gt.i.and.k(i+1,1)/10000.eq.6) kfs=kfs+isign(1,
     &  mod(k(i+1,2),10))
        ps(5)=ps(5)+ulmass(0,k(i,2))
      endif
      do 330 j=1,4
  330 ps(j)=ps(j)+p(i,j)
      if(k(i,1).lt.10000) then
        if(np.ne.1.and.(kfn.eq.1.or.kfn.ge.3.or.kfs.ne.0)) mst(26)=2
        if(np.ne.1.and.ps(4)**2-ps(1)**2-ps(2)**2-ps(3)**2.lt.(par(22)+
     &  ps(5))**2) mst(26)=3
        np=0
        kfn=0
        kfs=0
        do 340 j=1,5
  340   ps(j)=0.
      endif
  350 continue
 
      return
      end
 
 
      subroutine lucons(ip)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      dimension ps1(4),ps2(4),nfl(3),ifet(3),iflf(3),te(3),td(3,3)
 
      ntry=0
  100 ntry=ntry+1
      if(ntry.gt.200) then
        mst(24)=mst(24)+1
        mst(25)=4
        if(mst(23).ge.1) return
      endif
      do 110 j=1,3
      nfl(j)=0
      ifet(j)=0
  110 iflf(j)=0
      if(ntry.eq.1) then
        do 120 j=1,4
  120   ps1(j)=0.
        in=ip-1
        njet=0
  130   in=in+1
        if(in.gt.min(n,mst(30)-mst(31))) then
          mst(24)=mst(24)+1
          mst(25)=2
          if(mst(23).ge.1) return
        endif
        if(k(in,1).ge.20000.or.iabs(k(in,2)).lt.500) goto 130
        njet=njet+1
        do 140 j=1,4
  140   ps1(j)=ps1(j)+p(in,j)
        if(k(in,1).ge.10000.or.(mst(6).le.4.and.n.gt.in.and.
     &  k(in+1,1)/10000.eq.1)) goto 130
        nsys=1+in-ip
        mst(1)=ip
        mst(2)=in
        call lurobo(0.,0.,-ps1(1)/ps1(4),-ps1(2)/ps1(4),-ps1(3)/ps1(4))
 
        if(n+nsys.ge.mst(30)-5-mst(31)) then
          mst(24)=mst(24)+1
          mst(25)=1
          if(mst(23).ge.1) return
        endif
        ecm=0.
        do 150 i=ip,in
        if(k(i,1).lt.20000.and.iabs(k(i,2)).ge.500) ecm=ecm+p(i,4)
        do 150 j=1,5
  150   p(n+1+i-ip,j)=p(i,j)
        n=n+nsys
        nsav=n
      else
        n=nsav
        do 160 i=ip,in
        if(k(i,1).ge.100000) k(i,1)=k(i,1)-120000
        do 160 j=1,5
  160   p(i,j)=p(nsav+i-in,j)
      endif
 
      if(mst(6).ge.10.and.ntry.eq.1.and.njet.ge.3) then
        phi=ulangl(p(ip,1),p(ip,2))
        call lurobo(0.,-phi,0.,0.,0.)
        the=ulangl(p(ip,3),p(ip,1))
        call lurobo(-the,0.,0.,0.,0.)
        chi=ulangl(p(ip+1,1),p(ip+1,2))
        call lurobo(0.,-chi,0.,0.,0.)
        nbal=0
  170   nbal=nbal+1
        do 180 j1=1,3
        te(j1)=0.
        do 180 j2=1,3
  180   td(j1,j2)=0.
        do 200 i=ip,in
        if(k(i,1).ge.20000.or.iabs(k(i,2)).lt.500) goto 200
        pa=sqrt(p(i,1)**2+p(i,2)**2+p(i,3)**2)
        ten=min(1.,pa/par(18))
        if(iabs(k(i,2)).eq.500) ten=par(17)*ten
        do 190 j1=1,3
        te(j1)=te(j1)+ten*p(i,j1)/pa
        td(j1,j1)=td(j1,j1)+ten*p(i,4)/pa
        do 190 j2=1,3
  190   td(j1,j2)=td(j1,j2)-ten*p(i,4)*p(i,j1)*p(i,j2)/pa**3
  200   continue
        if(te(1)**2+te(2)**2+te(3)**2.lt.1e-3) goto 220
        if(nbal.ge.mst(13)) goto 100
        do 210 jl=1,2
        do 210 j1=jl+1,3
        te(j1)=te(j1)-(td(j1,jl)/td(jl,jl))*te(jl)
        do 210 j2=jl+1,3
  210   td(j1,j2)=td(j1,j2)-(td(j1,jl)/td(jl,jl))*td(jl,j2)
        te(3)=te(3)/td(3,3)
        te(2)=(te(2)-td(2,3)*te(3))/td(2,2)
        te(1)=(te(1)-td(1,2)*te(2)-td(1,3)*te(3))/td(1,1)
        ter=1.+sqrt(te(1)**2+te(2)**2+te(3)**2)
        call lurobo(0.,0.,-te(1)/ter,-te(2)/ter,-te(3)/ter)
        goto 170
      endif
 
  220 mst(1)=0
      mst(2)=0
      kfsum=0
      do 230 i=ip,in
      kfa=iabs(k(i,2))
      if(k(i,1).ge.20000.or.kfa.lt.500) goto 230
      if(kfa.ge.501) kfsum=kfsum+isign(1,k(i,2)*(510-kfa))
      ifl=mod(kfa,10)
      if(ifl.ne.0.and.ifl.le.3) nfl(ifl)=nfl(ifl)+isign(1,k(i,2))
      ifl=mod(kfa,100)/10
      if(ifl.ne.0.and.ifl.le.3) nfl(ifl)=nfl(ifl)+isign(1,k(i,2))
      ifl=mod(iabs(k(i+1,2)),10)
      if(n.gt.i.and.k(i+1,1)/10000.eq.6.and.ifl.ne.0) then
        kfsum=kfsum+isign(1,ifl)
        nfl(ifl)=nfl(ifl)+isign(1,k(i+1,2))
      endif
      call luonej(i)
      k(i,1)=k(i,1)+100000
  230 continue
      if(kfsum.ne.0) then
        mst(24)=mst(24)+1
        mst(25)=2
        if(mst(23).ge.1) return
      endif
      if(mod(mst(6),5).ne.0.and.n-nsav.lt.2) goto 100
 
      if(mst(6).ge.10.and.ntry.eq.1.and.njet.ge.3) then
        do 240 j=1,4
        ps2(j)=0.
        do 240 i=ip,in
  240   if(k(i,1).ge.100000) ps2(j)=ps2(j)+p(i,j)
        mst(1)=ip
        mst(2)=in
        call lurobo(0.,0.,-ps2(1)/ps2(4),-ps2(2)/ps2(4),-ps2(3)/ps2(4))
        phir=ulangl(p(ip,1),p(ip,2))
        call lurobo(0.,-phir,0.,0.,0.)
        ther=ulangl(p(ip,3),p(ip,1))
        call lurobo(-ther,0.,0.,0.,0.)
        chir=ulangl(p(ip+1,1),p(ip+1,2))
        call lurobo(0.,-chir,0.,0.,0.)
        call lurobo(0.,chi,0.,0.,0.)
        call lurobo(the,phi,0.,0.,0.)
        mst(1)=nsav+1
        mst(2)=0
        call lurobo(0.,0.,-ps2(1)/ps2(4),-ps2(2)/ps2(4),-ps2(3)/ps2(4))
        call lurobo(0.,-phir,0.,0.,0.)
        call lurobo(-ther,0.,0.,0.,0.)
        call lurobo(0.,-chir,0.,0.,0.)
        call lurobo(0.,chi,0.,0.,0.)
        call lurobo(the,phi,0.,0.,0.)
        mst(1)=0
      endif
 
      if(mod(mst(6),10).ne.0) then
        do 250 i=nsav+1,n
        call luiflv(k(i,2),ifla,iflb,iflc,ksp)
        if(iabs(ifla).le.3) nfl(iabs(ifla))=nfl(iabs(ifla))-isign(1,
     &  ifla)
        if(iabs(iflb).le.3) nfl(iabs(iflb))=nfl(iabs(iflb))-isign(1,
     &  iflb)
  250   if(iflc.ne.0) nfl(iabs(iflc))=nfl(iabs(iflc))-isign(1,iflc)
        nreq=(iabs(nfl(1))+iabs(nfl(2))+iabs(nfl(3))-iabs(nfl(1)+
     &  nfl(2)+nfl(3)))/2+iabs(nfl(1)+nfl(2)+nfl(3))/3
        if(nreq.eq.0) goto 330
 
        nrem=0
  260   irem=0
        p2min=ecm**2
        do 270 i=nsav+1,n
        p2=p(i,1)**2+p(i,2)**2+p(i,3)**2
        if(k(i,1).lt.100000.and.p2.lt.p2min) irem=i
  270   if(k(i,1).lt.100000.and.p2.lt.p2min) p2min=p2
        if(irem.eq.0) goto 100
        k(irem,1)=k(irem,1)+100000
        call luiflv(k(irem,2),ifla,iflb,iflc,ksp)
        if(iabs(ifla).ge.4) k(irem,1)=k(irem,1)+100000
        if(iabs(ifla).ge.4) goto 260
        nfl(iabs(ifla))=nfl(iabs(ifla))+isign(1,ifla)
        nfl(iabs(iflb))=nfl(iabs(iflb))+isign(1,iflb)
        if(iflc.ne.0) nfl(iabs(iflc))=nfl(iabs(iflc))+isign(1,iflc)
        nrem=nrem+1
        nreq=(iabs(nfl(1))+iabs(nfl(2))+iabs(nfl(3))-iabs(nfl(1)+
     &  nfl(2)+nfl(3)))/2+iabs(nfl(1)+nfl(2)+nfl(3))/3
        if(nreq.gt.nrem) goto 260
        do 280 i=nsav+1,n
  280   if(k(i,1).ge.200000) k(i,1)=k(i,1)-200000
 
  290   nfet=2
        if(nfl(1)+nfl(2)+nfl(3).ne.0) nfet=3
        if(nreq.lt.nrem) nfet=1
        if(iabs(nfl(1))+iabs(nfl(2))+iabs(nfl(3)).eq.0) nfet=0
        do 300 j=1,nfet
        ifet(j)=1+(iabs(nfl(1))+iabs(nfl(2))+iabs(nfl(3)))*rlu(0)
        iflf(j)=isign(1,nfl(1))
        if(ifet(j).gt.iabs(nfl(1))) iflf(j)=isign(2,nfl(2))
  300   if(ifet(j).gt.iabs(nfl(1))+iabs(nfl(2))) iflf(j)=isign(3,nfl(3))
        if(nfet.eq.2.and.(ifet(1).eq.ifet(2).or.iflf(1)*iflf(2).gt.0))
     &  goto 290
        if(nfet.eq.3.and.(ifet(1).eq.ifet(2).or.ifet(1).eq.ifet(3).or.
     &  ifet(2).eq.ifet(3).or.iflf(1)*iflf(2).lt.0.or.iflf(1)*iflf(3).
     &  lt.0.or.iflf(1)*(nfl(1)+nfl(2)+nfl(3)).lt.0)) goto 290
        if(nfet.eq.0) iflf(1)=1+int((2.+par(2))*rlu(0))
        if(nfet.eq.0) iflf(2)=-iflf(1)
        if(nfet.eq.1) iflf(2)=isign(1+int((2.+par(2))*rlu(0)),-iflf(1))
        if(nfet.le.2) iflf(3)=0
        call luifld(iflf(1),iflf(3),iflf(2),ifldmp,kf)
        if(kf.eq.0) goto 290
        do 310 j=1,max(2,nfet)
  310   nfl(iabs(iflf(j)))=nfl(iabs(iflf(j)))-isign(1,iflf(j))
        npos=min(1+int(rlu(0)*nrem),nrem)
        do 320 i=nsav+1,n
        if(k(i,1).ge.100000) npos=npos-1
        if(k(i,1).lt.100000.or.npos.ne.0) goto 320
        k(i,1)=k(i,1)-100000
        k(i,2)=kf
        p(i,5)=ulmass(1,k(i,2))
        p(i,4)=sqrt(p(i,1)**2+p(i,2)**2+p(i,3)**2+p(i,5)**2)
  320   continue
        nrem=nrem-1
        nreq=(iabs(nfl(1))+iabs(nfl(2))+iabs(nfl(3))-iabs(nfl(1)+
     &  nfl(2)+nfl(3)))/2+iabs(nfl(1)+nfl(2)+nfl(3))/3
        if(nrem.gt.0) goto 290
      endif
 
  330 if(mod(mst(6),5).ne.0.and.mod(mst(6),5).ne.4) then
        do 340 j=1,3
        ps2(j)=0.
        do 340 i=nsav+1,n
  340   ps2(j)=ps2(j)+p(i,j)
        ps2(4)=ps2(1)**2+ps2(2)**2+ps2(3)**2
        pds=0.
        do 350 i=nsav+1,n
        if(mod(mst(6),5).eq.1) pds=pds+p(i,4)
        if(mod(mst(6),5).eq.2) pds=pds+sqrt(p(i,5)**2+(ps2(1)*p(i,1)+
     &  ps2(2)*p(i,2)+ps2(3)*p(i,3))**2/ps2(4))
  350   if(mod(mst(6),5).eq.3) pds=pds+1.
        do 370 i=nsav+1,n
        if(mod(mst(6),5).eq.1) pdm=p(i,4)
        if(mod(mst(6),5).eq.2) pdm=sqrt(p(i,5)**2+(ps2(1)*p(i,1)+
     &  ps2(2)*p(i,2)+ps2(3)*p(i,3))**2/ps2(4))
        if(mod(mst(6),5).eq.3) pdm=1.
        do 360 j=1,3
  360   p(i,j)=p(i,j)-ps2(j)*pdm/pds
  370   p(i,4)=sqrt(p(i,1)**2+p(i,2)**2+p(i,3)**2+p(i,5)**2)
 
      elseif(mod(mst(6),5).eq.4) then
        do 380 i=n+1,n+nsys
        k(i,1)=0
        do 380 j=1,5
  380   p(i,j)=0.
        do 400 i=nsav+1,n
        ir1=k(i,1)
        ir2=n+1+ir1-ip
        k(ir2,1)=k(ir2,1)+1
        pls=(p(i,1)*p(ir1,1)+p(i,2)*p(ir1,2)+p(i,3)*p(ir1,3))/
     &  (p(ir1,1)**2+p(ir1,2)**2+p(ir1,3)**2)
        do 390 j=1,3
  390   p(ir2,j)=p(ir2,j)+p(i,j)-pls*p(ir1,j)
        p(ir2,4)=p(ir2,4)+p(i,4)
  400   p(ir2,5)=p(ir2,5)+pls
        hss=0.
        do 410 i=n+1,n+nsys
  410   if(k(i,1).ne.0) hss=hss+p(i,4)/(ecm*(0.8*p(i,5)+0.2))
        do 430 i=nsav+1,n
        ir1=k(i,1)
        ir2=n+1+ir1-ip
        pls=(p(i,1)*p(ir1,1)+p(i,2)*p(ir1,2)+p(i,3)*p(ir1,3))/
     &  (p(ir1,1)**2+p(ir1,2)**2+p(ir1,3)**2)
        do 420 j=1,3
  420   p(i,j)=p(i,j)-p(ir2,j)/k(ir2,1)+(1./(p(ir2,5)*hss)-1.)*pls*
     &  p(ir1,j)
  430   p(i,4)=sqrt(p(i,1)**2+p(i,2)**2+p(i,3)**2+p(i,5)**2)
      endif
 
      if(mod(mst(6),5).ne.0) then
        pms=0.
        pes=0.
        pqs=0.
        do 440 i=nsav+1,n
        pms=pms+p(i,5)
        pes=pes+p(i,4)
  440   pqs=pqs+p(i,5)**2/p(i,4)
        if(pms.ge.ecm) goto 100
        neco=0
  450   neco=neco+1
        fac=(ecm-pqs)/(pes-pqs)
        pes=0.
        pqs=0.
        do 470 i=nsav+1,n
        do 460 j=1,3
  460   p(i,j)=fac*p(i,j)
        p(i,4)=sqrt(p(i,1)**2+p(i,2)**2+p(i,3)**2+p(i,5)**2)
        pes=pes+p(i,4)
  470   pqs=pqs+p(i,5)**2/p(i,4)
        if(neco.lt.10.and.abs(ecm-pes).gt.2e-6*ecm) goto 450
      endif
 
      do 480 i=ip,in
  480 if(k(i,1).ge.100000) k(i,1)=k(i,1)-100000
      mst(1)=ip
      mst(2)=in
      call lurobo(0.,0.,ps1(1)/ps1(4),ps1(2)/ps1(4),ps1(3)/ps1(4))
      mst(1)=nsav+1
      mst(2)=0
      call lurobo(0.,0.,ps1(1)/ps1(4),ps1(2)/ps1(4),ps1(3)/ps1(4))
      mst(1)=0
      do 490 i=nsav+1,n
      k(i-nsys,1)=k(i,1)
      k(i-nsys,2)=k(i,2)
      do 490 j=1,5
  490 p(i-nsys,j)=p(i,j)
      n=n-nsys
 
      return
      end
 
 
      subroutine luonej(ip)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      dimension iflf(3),iflo(2),pxo(2),pyo(2),zo(2),wo(2)
 
      mst(1)=n+1
      iflf(1)=mod(k(ip,2),500)
      iflf(2)=0
      iflf(3)=0
      iflo(2)=0
      wf=p(ip,4)+sqrt(p(ip,1)**2+p(ip,2)**2+p(ip,3)**2)
      zj=0.
      zi=0.
 
  100 if(iflf(1).eq.0.and.mst(5).le.2) then
        ns=2
        i=n+1
        k(i,1)=ip
        call luifld(int(1.+(2.+par(2))*rlu(0)),0,0,iflo(1),kdump)
        call luifld(-int(1.+(2.+par(2))*rlu(0)),0,0,iflo(2),kdump)
        if(iabs(iflo(2)).lt.100) iflo(2)=-mod(iflo(1),100)
        if(iabs(iflo(2)).gt.100) iflo(1)=-mod(iflo(2),100)
        call luifld(iflo(1),0,0,ifl1,k(i,2))
        iflo(1)=-ifl1
        p(i,5)=ulmass(1,k(i,2))
        call luptdi(iflo(1),pxo(1),pyo(1))
        call luptdi(iflo(2),pxo(2),pyo(2))
        pr=p(i,5)**2+(pxo(1)+pxo(2))**2+(pyo(1)+pyo(2))**2
        prdiv=rlu(0)*pr
        do 110 jt=1,2
        call luzdis(iflo(jt),0,0.6*((2-jt)*pr+(2*jt-3)*prdiv),zo(jt))
  110   wo(jt)=0.5*(1.-zo(jt))*wf
 
        p(i,1)=-(pxo(1)+pxo(2))
        p(i,2)=-(pyo(1)+pyo(2))
        p(i,3)=0.25*(zo(1)+zo(2))*wf-pr/((zo(1)+zo(2))*wf)
        p(i,4)=0.25*(zo(1)+zo(2))*wf+pr/((zo(1)+zo(2))*wf)
        if(mst(5).ge.2.and.mst(6).ge.0.and.p(i,3).lt.0.) i=i-1
        n=i
 
      elseif(iflf(1).eq.0.and.(mst(5).eq.3.or.mst(5).eq.4)) then
        ns=1
        if(mst(5).eq.4) mst(32)=1
        iflo(1)=int(1.+(2.+par(2))*rlu(0))*(-1)**int(rlu(0)+0.5)
        call luptdi(93,pxo(1),pyo(1))
        wo(1)=wf
 
      elseif(iflf(1).eq.0.and.mst(5).ge.5) then
        ns=2
        if(mst(5).eq.6) mst(32)=1
        iflo(1)=int(1.+(2.+par(2))*rlu(0))*(-1)**int(rlu(0)+0.5)
        iflo(2)=-iflo(1)
        call luptdi(93,pxo(1),pyo(1))
        pxo(2)=-pxo(1)
        pyo(2)=-pyo(1)
        wo(1)=wf*rlu(0)**(1./3.)
        wo(2)=wf-wo(1)
 
      else
        ns=1
        iflo(1)=iflf(1)
        call luptdi(93,pxo(1),pyo(1))
        wo(1)=wf
 
        if(mod(mst(10),2).eq.1.and.iabs(iflf(1)).gt.10) then
          ifla=iflf(1)/10
          iflb=iflf(1)-10*ifla
          iflf(2)=ifla+int(rlu(0)+0.5)*(iflb-ifla)
          if(n.gt.ip.and.k(ip+1,1)/10000.eq.6.and.iabs(k(ip+1,2)).ge.
     &    610) iflf(2)=mod(k(ip+1,2)/10,10)
          iflo(1)=ifla+iflb-iflf(2)
          call luzdis(0,1,0.,zj)
          if(n.gt.ip.and.k(ip+1,1)/10000.eq.6) p(ip+1,1)=zj
        endif
 
        if(n.gt.ip.and.k(ip+1,1)/10000.eq.6) iflf(3)=mod(k(ip+1,2),10)
        if(iflf(3).ne.0) then
          call luzdis(0,2+(90+iabs(iflf(1)))/100,0.,zi)
          if(iabs(iflf(1)).gt.10.and.mod(mst(10),2).eq.1) zi=zi*zj
          p(ip+1,3)=zi
        endif
      endif
 
      do 140 jt=1,ns
  120 i=n
      lrk=0
      ifl1=iflo(jt)
      iflj=iflf(2)
      ifli=iflf(3)
      if(iflj.eq.0) then
        px1=pxo(jt)
        py1=pyo(jt)
        pxj=0.
        pyj=0.
      else
        call luptdi(94,pxr,pyr)
        px1=0.5*pxo(jt)+pxr
        py1=0.5*pyo(jt)+pyr
        pxj=0.5*pxo(jt)-pxr
        pyj=0.5*pyo(jt)-pyr
        if(n.gt.ip.and.k(ip+1,1)/10000.eq.6) p(ip+1,2)=0.
      endif
      if(iflf(3).ne.0) p(ip+1,4)=0.
      w=wo(jt)
 
  130 i=i+1
      if(i.ge.mst(30)-5-mst(31)) then
        mst(24)=mst(24)+1
        mst(25)=1
        if(mst(23).ge.1) return
      endif
      lrk=lrk+1
      k(i,1)=ip
      call luptdi(ifl1,px2,py2)
      mqj=0
      mqi=0
 
      if(iflj.ne.0.or.ifli.ne.0) then
        prji=par(37)**2+(px1+px2)**2+(py1+py2)**2
        call luzdis(ifl1,iflj+ifli,prji,z)
        if(iflj.ne.0.and.(1.-z)*w.le.zj*wf) mqj=1
        if(mqj.eq.1.and.iabs(ifl1).gt.10) goto 120
        if(mqj.eq.1.and.lrk.eq.1) ifl1=iflf(1)
        if(ifli.ne.0.and.(1.-z)*w.le.zi*wf) mqi=1
        if(mqi.eq.1.and.iabs(ifl1).gt.100) goto 120
      endif
      call luifld(ifl1,mqj*iflj,mqi*ifli,ifl2,k(i,2))
      if(k(i,2).eq.0) goto 120
      p(i,5)=ulmass(1,k(i,2))
      pr=p(i,5)**2+(px1+px2+mqj*pxj)**2+(py1+py2+mqj*pyj)**2
 
      if(iflj.eq.0.and.ifli.eq.0) then
        call luzdis(ifl1,0,pr,z)
      elseif(mst(4).eq.1.or.mst(4).eq.3) then
        gamji=(1.+par(35))/par(36)
        zbc=(pr-prji-z*gamji+prji/z)/(2.*gamji)
        z=sqrt(zbc**2+pr/gamji)-zbc
      endif
      p(i,1)=px1+px2+mqj*pxj
      p(i,2)=py1+py2+mqj*pyj
      p(i,3)=0.5*(z*w-pr/(z*w))
      p(i,4)=0.5*(z*w+pr/(z*w))
      if(mod(mst(6),10).gt.0.and.lrk.eq.1.and.max(mod(iabs(iflf(1)),
     &10),iabs(iflf(1))/10).ge.4.and.p(i,3).le.0.001) then
        if(w.ge.p(i,5)+0.5*par(22)) goto 120
        p(i,3)=0.0001
        p(i,4)=sqrt(pr)
        z=p(i,4)/w
      endif
      if(mst(5).ge.2.and.mst(6).ge.0.and.p(i,3).lt.0.) i=i-1
      if(i.eq.n+lrk.and.mqj*n.gt.ip.and.k(ip+1,1)/10000.eq.6)
     &p(ip+1,2)=i
      if(i.eq.n+lrk.and.mqi.eq.1) p(ip+1,4)=i
 
      ifl1=-ifl2
      if(mqi.eq.1) call luifld((-1)**int(rlu(0)+0.5),0,0,ifl1,kdump)
      if(mqj.eq.1) iflj=0
      if(mqi.eq.1) ifli=0
      px1=-px2
      py1=-py2
      w=(1.-z)*w
      if(mst(10).le.1.and.w.gt.par(21)) goto 130
      if(mst(10).ge.2.and.(iflj.ne.0.or.ifli.ne.0)) goto 130
  140 n=i
 
      if(mod(mst(6),5).eq.4.and.mst(1).eq.n+1) wf=wf+0.1*par(22)
      if(mod(mst(6),5).eq.4.and.mst(1).eq.n+1) goto 100
      the=ulangl(p(ip,3),sqrt(p(ip,1)**2+p(ip,2)**2))
      phi=ulangl(p(ip,1),p(ip,2))
      call lurobo(the,phi,0.,0.,0.)
      mst(1)=0
      mst(32)=0
      k(ip,1)=k(ip,1)+20000
 
      return
      end
 
 
 
      function ulmass(mmass,kf)
#include "amsrqmd.h"
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
 
      kfa=iabs(kf)
      ulmass=0.
      kty=0
 
      if(mmass.le.1.and.kfa.le.100) then
        ulmass=pmas(kfa)
        kty=ktyp(kfa)/10
 
      elseif(mmass.le.1.and.kfa.lt.500) then
        call luiflv(kfa,ifla,iflb,iflc,ksp)
        if(ksp.eq.2.and.ifla.eq.iflb) then
          ifld=ifla
          ifla=iflc
          iflc=ifld
        endif
        pma=pmas(100+ifla)
        pmb=pmas(100+iabs(iflb))
        pmc=pmas(100+iflc)
        if(ksp.le.1) ulmass=pmas(113)+pma+pmb+pmas(115)*pmas(101)**2*
     &  cfr(25+ksp)/(pma*pmb)
        if(ksp.ge.2) ulmass=pmas(114)+pma+pmb+pmc+pmas(116)*
     &  pmas(101)**2*(cfr(21+3*ksp)/(pma*pmb)+cfr(22+3*ksp)/(pma*pmc)+
     &  cfr(23+3*ksp)/(pmb*pmc))
        kty=ktyp(100+ifla)/10
 
      else
        kfa=mod(kfa,100)
        if(kfa.ge.1.and.kfa.le.10) then
          ulmass=pmas(100+kfa)
          if(mmass.eq.3) ulmass=ulmass-pmas(111)
          kty=ktyp(100+kfa)/10
        elseif(kfa.gt.10) then
          ksp=0
          if(kfa/10.ge.mod(kfa,10)) ksp=1
          pma=pmas(100+kfa/10)
          pmb=pmas(100+mod(kfa,10))
          ulmass=pma+pmb
          if(mmass.eq.3) ulmass=ulmass-pmas(112)+pmas(116)*pmas(101)**2*
     &    cfr(25+ksp)/(pma*pmb)
          kty=ktyp(100+max(kfa/10,mod(kfa,10)))/10
        endif
      endif
 
      if(mst(8).eq.1.and.mmass.ge.1.and.kty.ge.1) ulmass=ulmass+0.5*
     &pwid(2*kty-1)*tan((2.*rlu(0)-1.)*atan(2.*pwid(2*kty)/
     &pwid(2*kty-1)))
 
      return
      end
 
 
      subroutine luptdi(ifl,px,py)
#include "amsrqmd.h"
      common /ludat1s/ mst(40),par(80)
 
      ifla=iabs(ifl)
      pt=par(12)*sqrt(-alog(max(1e-10,rlu(0))))
      if(mst(32).eq.1) pt=par(13)*pt
      if(ifla.ge.4.and.ifla.lt.10.and.abs(par(16)-1.).gt.0.1) pt=
     &sqrt(par(16))*pt
      if(ifla.eq.93.and.mst(11).eq.1) pt=par(14)*pt
      if(ifla.eq.93.and.mst(11).ne.1) pt=0.
      if(ifla.eq.94) pt=par(15)*pt/par(12)
      phi=par(72)*rlu(0)
      px=pt*cos(phi)
      py=pt*sin(phi)
 
      return
      end
 
 
      subroutine luzdis(ifl1,ifl3,pr,z)
#include "amsrqmd.h"
      common /ludat1s/ mst(40),par(80)
 
      ifla=max(mod(iabs(ifl1),100)/10,mod(iabs(ifl1),10))
      if(ifla.ne.0.and.(mst(4).eq.1.or.(mst(4).eq.3.and.ifla.le.3)))
     &then
        fa=par(31)
        fb=par(32)*pr
        if(ifl3.ne.0) fa=par(35)
        if(ifl3.ne.0) fb=par(36)*pr
        if(mst(32).eq.1) fa=par(33)
        if(mst(32).eq.1) fb=par(34)*pr
        if(fa.le.0.01) zmax=min(1.,fb)
        if(fa.gt.0.01.and.abs(fa-1.)/fb.le.0.01) zmax=fb/(1.+fb)+
     &  (1.-fa)*fb**2/(1.+fb)**3
        if(fa.gt.0.01.and.abs(fa-1.)/fb.gt.0.01) zmax=0.5*(1.+fb-
     &  sqrt((1.-fb)**2+4.*fa*fb))/(1.-fa)
        if(zmax.lt.0.1) zdiv=2.75*zmax
        if(zmax.gt.0.85) zdiv=zmax-0.6/fb**2+(fa/fb)*alog((0.01+fa)/fb)
  100   z=rlu(0)
        idiv=1
        fpre=1.
        if(zmax.lt.0.1) then
          if(1..lt.rlu(0)*(1.-alog(zdiv))) idiv=2
          if(idiv.eq.1) z=zdiv*z
          if(idiv.eq.2) z=zdiv**z
          if(idiv.eq.2) fpre=zdiv/z
        elseif(zmax.gt.0.85) then
          if(1..lt.rlu(0)*(fb*(1.-zdiv)+1.)) idiv=2
          if(idiv.eq.1) z=zdiv+alog(z)/fb
          if(idiv.eq.1) fpre=exp(fb*(z-zdiv))
          if(idiv.eq.2) z=zdiv+z*(1.-zdiv)
        endif
        if(z.le.fb/(50.+fb).or.z.ge.1.) goto 100
        fval=(zmax/z)*exp(fb*(1./zmax-1./z))
        if(fa.gt.0.01) fval=((1.-z)/(1.-zmax))**fa*fval
        if(fval.lt.rlu(0)*fpre) goto 100
 
      elseif(ifl1.ne.0) then
        fc=par(40+ifla)
        if(mst(32).eq.1) fc=par(49)
        if(ifl3.ne.0) fc=par(50)
  110   z=rlu(0)
        if(fc.ge.0..and.fc.le.1.) then
          if(fc.gt.rlu(0)) z=1.-z**(1./3.)
        elseif(fc.gt.-1.) then
          if(-4.*fc*z*(1.-z)**2.lt.rlu(0)*((1.-z)**2-fc*z)**2) goto 110
        else
          if(fc.gt.0.) z=1.-z**(1./fc)
          if(fc.lt.0.) z=z**(-1./fc)
        endif
 
      else
  120   z=rlu(0)**(1./(1.+max(par(49+2*ifl3),par(50+2*ifl3))))
        if((1.-z)**min(par(49+2*ifl3),par(50+2*ifl3)).lt.rlu(0))
     &  goto 120
        if(par(50+2*ifl3).gt.par(49+2*ifl3)) z=1.-z
      endif
 
      return
      end
 
 
      subroutine luiflv(kf,ifla,iflb,iflc,ksp)
#include "amsrqmd.h"
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
 
      kfa=iabs(kf)
      kfs=isign(1,kf)
      ifla=0
      iflb=0
      iflc=0
 
      ksp=-1
      if((kfa.ge.17.and.kfa.le.26).or.kfa.eq.37.or.kfa.eq.38.or.
     &(kfa.ge.83.and.kfa.le.86).or.kfa.ge.101) ksp=0
      if((kfa.ge.27.and.kfa.le.36).or.(kfa.ge.87.and.kfa.le.90).or.
     &kfa.ge.123) ksp=1
      if((kfa.ge.41.and.kfa.le.56).or.kfa.ge.145) ksp=2
      if((kfa.ge.57.and.kfa.le.60).or.kfa.ge.241) ksp=3
      if((kfa.ge.61.and.kfa.le.80).or.kfa.ge.293) ksp=4
      if(kfa.ge.393) ksp=-1
 
      if((kfa.ge.23.and.kfa.le.26).or.(kfa.ge.33.and.kfa.le.36).or.
     &(kfa.ge.83.and.kfa.le.90)) then
        if(kfa.le.40) ifla=kfa-22-10*ksp
        if(kfa.ge.80) ifla=kfa-78-4*ksp
        iflb=-ifla
      elseif(kfa.eq.37.or.kfa.eq.38) then
        ifla=isign(3,(-1)**int(rlu(0)+0.5))
        iflb=isign(2,-ifla)
      elseif(ksp.eq.0.or.ksp.eq.1) then
  100   ifla=ifla+1
        if(ifla.lt.8.and.kfr(8*ksp+ifla+1).lt.kfa) goto 100
        iflb=-(kfa-kfr(8*ksp+ifla))
        if(ifla.le.3) iflb=-iflb
        if(ifla.le.3) ifla=-ifla
 
      elseif(ksp.ge.2.and.ksp.le.4) then
  110   ifla=ifla+1
        if(ifla.lt.8.and.kfr(16*ksp+ifla-15).lt.kfa) goto 110
  120   iflb=iflb+1
        if(iflb.lt.8.and.kfr(16*ksp+iflb-7).lt.kfa-kfr(16*ksp+ifla-16))
     &  goto 120
        iflc=kfa-kfr(16*ksp+ifla-16)-kfr(16*ksp+iflb-8)
      endif
 
      ifla=kfs*ifla
      iflb=kfs*iflb
      iflc=kfs*iflc
 
      return
      end
 
 
      function luchge(kf)
#include "amsrqmd.h"
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
 
      kfa=iabs(kf)
      luchge=0
 
      if(kfa.le.100) then
        kty=mod(ktyp(kfa),10)
        if(kty.ge.1) luchge=3*kty-6
 
      elseif(kfa.lt.500) then
        call luiflv(kfa,ifla,iflb,iflc,ksp)
        luchge=3*mod(ktyp(100+ifla),10)-16+
     &  (3*mod(ktyp(100+iabs(iflb)),10)-16)*isign(1,iflb)
        if(iflc.ne.0) luchge=luchge+3*mod(ktyp(100+iflc),10)-16
 
      elseif(kfa.le.600) then
        if(mod(kfa,10).ne.0) luchge=3*mod(ktyp(100+mod(kfa,10)),10)-16
        if(kfa.gt.510) luchge=luchge+3*mod(ktyp(50+kfa/10),10)-16
 
      elseif(kfa.le.700) then
        if(mod(kfa,10).ne.0) luchge=3*mod(ktyp(100+mod(kfa,10)),10)-16
      endif
 
      luchge=luchge*isign(1,kf)
 
      return
      end
 
 
      subroutine luname(kf,chau)
#include "amsrqmd.h"
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
      common /ludat4/ chag(50),chaf(100)
      character chau*8,chag*4,chaf*4
 
      chau=chag(1)//chag(1)
      kfa=iabs(kf)
      kfs=isign(1,kf)
 
      if(kfa.eq.0) then
      elseif(kfa.le.100) then
        chau=chaf(kfa)//chag(27+kfs*mod(ktyp(kfa),10))
      elseif(kfa.lt.500) then
        call luiflv(kfa,ifla,iflb,iflc,ksp)
        if(iflc.eq.0) chau=chag(10+ifla)(1:1)//chag(10-iflb)(1:2)//
     &  chag(35-ksp)(1:1)//chag(27+kfs*(luchge(kfa)/3+2))
        if(iflc.ne.0) chau=chag(10+ifla)(1:1)//chag(10+iflb)(1:1)//
     &  chag(10+iflc)(1:1)//chag(30+ksp)(1:1)//chag(27+kfs*
     &  (luchge(kfa)/3+2))
 
      elseif(kfa.lt.590) then
        ifla=max(kfa/10-50,kfa-10*(kfa/10))
        iflb=min(kfa/10-50,kfa-10*(kfa/10))
        if(iflb.eq.0) chau=chag(10+kfs*ifla)//chag(22)
        ksp=32
        if(kfa/10-50.lt.ifla) ksp=33
        if(iflb.ne.0) chau=chag(10+ifla)(1:1)//chag(10+kfs*iflb)(1:2)//
     &  chag(ksp)(1:1)//chag(22)
      elseif(kfa.le.600) then
        chau=chag(kfa-571)//chag(22)
 
      elseif(kfa.lt.700) then
        ifla=isign(kfa/10-60,kf)
        iflb=isign(mod(kfa,10),kf)
        if(ifla.ne.0) chau(1:4)=chag(10+ifla)(1:2)//chag(37)(1:2)
        if(iflb.ne.0) chau(5:8)=chag(10+iflb)(1:2)//chag(38)(1:2)
      endif
 
      return
      end
 
 
      function ulangl(x,y)
#include "amsrqmd.h"
      common /ludat1s/ mst(40),par(80)
 
      ulangl=0.
      r=sqrt(x**2+y**2)
      if(r.lt.1e-20) return
      if(abs(x)/r.lt.0.8) then
        ulangl=sign(acos(x/r),y)
      else
        ulangl=asin(y/r)
        if(x.lt.0..and.ulangl.ge.0.) then
          ulangl=par(71)-ulangl
        elseif(x.lt.0.) then
          ulangl=-par(71)-ulangl
        endif
      endif
 
      return
      end
 
 
      function rlu(idum)
      rlu=ranf(0)
      return
      end
CPAT,JETSET3  .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine ludecy(ip)
#include "amsrqmd.h"
      common /lujets/ n,k(2000,2),p(2000,5)
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      dimension iflo(4),ifl1(4),pv(10,5),rord(10),ue(3),be(3)
      common /prinbk/ iprin
 
      pawt(a,b,c)=sqrt((a**2-(b+c)**2)*(a**2-(b-c)**2))/(2.*a)
      four(i,j)=p(i,4)*p(j,4)-p(i,1)*p(j,1)-p(i,2)*p(j,2)-p(i,3)*p(j,3)
 
      ntry=0
      nsav=n
      kfa=iabs(k(ip,2))
      kfs=isign(1,k(ip,2))
      if(kfa.le.100) then
        idcold=idb(kfa)-1
      else
        call luiflv(kfa,ifla,iflb,iflc,ksp)
        idcold=idb(76+5*ifla+ksp)-1
      endif
  120 ntry=ntry+1
      idc=idcold
  100 rbr=rlu(0)
  110 idc=idc+1
      if(rbr.gt.cbr(idc)) goto 110
      mmat=iabs(kdp(4*idc-3))/1000
      if(ntry.gt.1000) then
        mst(24)=mst(24)+1
        mst(25)=5
        if(mst(23).ge.1) return
      endif
      i=n
      np=0
      nq=0
      mbst=0
      if(mmat.ge.5.and.p(i,4).gt.20.*p(i,5)) mbst=1
      do 130 j=1,4
      pv(1,j)=0.
  130 if(mbst.eq.0) pv(1,j)=p(ip,j)
      if(mbst.eq.1) pv(1,4)=p(ip,5)
      pv(1,5)=p(ip,5)
      ps=0.
      psq=0.
      nm=0
 
      do 140 i1=4*idc-3,4*idc
      kp=mod(kdp(i1),1000)
      if(kp.eq.0) goto 140
      if(iabs(kp).le.100) then
        kfp=kfs*kp
        if(mod(ktyp(iabs(kp)),10).eq.0) kfp=kp
      elseif(iabs(kp).lt.590) then
        kfp=kfs*kp
        if(kp.eq.500) kfp=kp
      elseif(iabs(kp).eq.590) then
        if(ksp.le.1) kfp=kfs*(-500+iflb)
        if(ksp.eq.3) kfp=kfs*(500+10*iflc+iflb)
        if(ksp.eq.2.or.ksp.eq.4) kfp=kfs*(500+10*iflb+iflc)
      elseif(iabs(kp).eq.591) then
        call luifld(-kfs*int(1.+(2.+par(2))*rlu(0)),0,0,kfp,kdump)
        if(pv(1,5).lt.par(22)+2.*ulmass(2,kfp)) goto 120
        kfp=mod(kfp,100)+isign(500,kfp)
      elseif(iabs(kp).eq.592) then
        kfp=-kfp
      endif
      if(mmat.ge.6.and.mmat.le.8.and.iabs(kfp).ge.500) then
        nq=nq+1
        iflo(nq)=mod(kfp,500)
        psq=psq+ulmass(3,iflo(nq))
      elseif(mmat.ge.12.and.np.eq.3) then
        nq=nq-1
        ps=ps-p(i,5)
        k(i,1)=ip
        call luifld(mod(kfp,500),0,mod(k(i,2),500),ifldmp,k(i,2))
        p(i,5)=ulmass(1,k(i,2))
        ps=ps+p(i,5)
      else
        i=i+1
        np=np+1
        if(iabs(kfp).ge.500) nq=nq+1
        k(i,1)=ip+10000*(nq-2*(nq/2))
        k(i,2)=kfp
        p(i,5)=ulmass(1+2*(iabs(kfp)/500),kfp)
        ps=ps+p(i,5)
      endif
  140 continue
 
  150 if(mmat.ge.6.and.mmat.le.8) then
        psp=ps
        cnde=dpar(11)*alog(max((pv(1,5)-ps-psq)/dpar(12),1.1))
        if(mmat.eq.8) cnde=cnde+dpar(13)
  160   ntry=ntry+1
        if(ntry.gt.1000) then
          mst(24)=mst(24)+1
          mst(25)=5
          if(mst(23).ge.1) return
        endif
        gauss=sqrt(-2.*cnde*alog(rlu(0)))*sin(par(72)*rlu(0))
        nd=0.5+0.5*np+0.25*nq+cnde+gauss
        if(nd.lt.np+nq/2.or.nd.lt.2.or.nd.gt.10) goto 160
        if(mmat.eq.7.and.nd.eq.2) goto 160
 
        do 170 jt=1,4
  170   ifl1(jt)=iflo(jt)
        if(nd.eq.np+nq/2) goto 190
        do 180 i=n+np+1,n+nd-nq/2
        jt=1+int((nq-1)*rlu(0))
        call luifld(ifl1(jt),0,0,ifl2,k(i,2))
  180   ifl1(jt)=-ifl2
  190   jt=2+2*(nq/4)*int(rlu(0)+0.5)
        if(min(iabs(ifl1(1)),iabs(ifl1(jt))).gt.10.or.(nq.eq.4.and.
     &  min(iabs(ifl1(3)),iabs(ifl1(6-jt))).gt.10)) goto 160
        if(max(iabs(ifl1(1)),iabs(ifl1(jt))).gt.100.or.(nq.eq.4.and.
     &  max(iabs(ifl1(3)),iabs(ifl1(6-jt))).gt.100)) goto 160
        call luifld(ifl1(1),0,ifl1(jt),ifldmp,k(n+nd-nq/2+1,2))
        if(nq.eq.4) call luifld(ifl1(3),0,ifl1(6-jt),ifldmp,k(n+nd,2))
 
        ps=psp
        do 200 i=n+np+1,n+nd
        k(i,1)=ip
        p(i,5)=ulmass(1,k(i,2))
  200   ps=ps+p(i,5)
        if(ps+dpar(14).gt.pv(1,5)) goto 160
 
      elseif(mmat.eq.5.or.mmat.eq.11) then
        ps=ps-p(n+np,5)
        pqt=(p(n+np,5)+dpar(15))/pv(1,5)
        do 210 j=1,5
        p(n+np,j)=pqt*pv(1,j)
  210   pv(1,j)=(1.-pqt)*pv(1,j)
        nd=np-1
 
      else
        if(np.ge.2.and.ps+dpar(14).gt.pv(1,5)) goto 120
        nd=np
      endif
 
      if(nd.eq.1) then
        do 220 j=1,4
  220   p(n+1,j)=p(ip,j)
        goto 430
      endif
 
      pv(nd,5)=p(n+nd,5)
      if(nd.eq.2) goto 280
      wtmax=1./dpar(nd-2)
      pmax=pv(1,5)-ps+p(n+nd,5)
      pmin=0.
      do 230 il=nd-1,1,-1
      pmax=pmax+p(n+il,5)
      pmin=pmin+p(n+il+1,5)
  230 wtmax=wtmax*pawt(pmax,pmin,p(n+il,5))
 
  240 rord(1)=1.
      do 260 il1=2,nd-1
      rsav=rlu(0)
      do 250 il2=il1-1,1,-1
      if(rsav.le.rord(il2)) goto 260
  250 rord(il2+1)=rord(il2)
  260 rord(il2+1)=rsav
      rord(nd)=0.
      wt=1.
      do 270 il=nd-1,1,-1
      pv(il,5)=pv(il+1,5)+p(n+il,5)+(rord(il)-rord(il+1))*(pv(1,5)-ps)
  270 wt=wt*pawt(pv(il,5),pv(il+1,5),p(n+il,5))
      if(wt.lt.rlu(0)*wtmax) goto 240
 
  280 do 300 il=1,nd-1
      pa=pawt(pv(il,5),pv(il+1,5),p(n+il,5))
      ue(3)=2.*rlu(0)-1.
      phi=par(72)*rlu(0)
      ue(1)=sqrt(1.-ue(3)**2)*cos(phi)
      ue(2)=sqrt(1.-ue(3)**2)*sin(phi)
      do 290 j=1,3
      p(n+il,j)=pa*ue(j)
  290 pv(il+1,j)=-pa*ue(j)
      p(n+il,4)=sqrt(pa**2+p(n+il,5)**2)
  300 pv(il+1,4)=sqrt(pa**2+pv(il+1,5)**2)
 
      do 310 j=1,4
  310 p(n+nd,j)=pv(nd,j)
      do 340 il=nd-1,1,-1
      do 320 j=1,3
  320 be(j)=pv(il,j)/pv(il,4)
      ga=pv(il,4)/pv(il,5)
      do 340 i=n+il,n+nd
      bep=be(1)*p(i,1)+be(2)*p(i,2)+be(3)*p(i,3)
      do 330 j=1,3
  330 p(i,j)=p(i,j)+ga*(ga*bep/(1.+ga)+p(i,4))*be(j)
  340 p(i,4)=ga*(p(i,4)+bep)
 
      if(mmat.eq.1) then
        wt=(p(n+1,5)*p(n+2,5)*p(n+3,5))**2-(p(n+1,5)*four(n+2,n+3))**2
     &  -(p(n+2,5)*four(n+1,n+3))**2-(p(n+3,5)*four(n+1,n+2))**2
     &  +2.*four(n+1,n+2)*four(n+1,n+3)*four(n+2,n+3)
        if(max(wt*dpar(9)/p(ip,5)**6,0.001).lt.rlu(0)) goto 240
 
      elseif(mmat.eq.3) then
        if(nm.ne.2) then
          im=mod(k(ip,1),10000)
          if(im.eq.0) goto 360
          do 350 il=max(ip-2,im+1),min(ip+2,n)
  350     if(mod(k(il,1),10000).eq.im) nm=nm+1
          call luiflv(k(im,2),iflam,iflbm,iflcm,kspm)
          if(nm.ne.2.or.kspm.ne.0) goto 360
        endif
        if((p(ip,5)**2*four(im,n+1)-four(ip,im)*four(ip,n+1))**2.le.
     &  rlu(0)*(four(ip,im)**2-(p(ip,5)*p(im,5))**2)*(four(ip,n+1)**2-
     &  (p(ip,5)*p(n+1,5))**2)) goto 280
  360   nm=0
 
      elseif(mmat.ge.11) then
        wt=four(ip,n+1)*four(n+2,n+3)
        if(wt.lt.rlu(0)*p(ip,5)*pv(1,5)**3/dpar(10)) goto 240
      endif
 
      if(mmat.eq.5.or.mmat.eq.11) then
        do 370 j=1,5
  370   pv(1,j)=pv(1,j)/(1.-pqt)
        nd=nd+1
      endif
 
      if(mmat.eq.5) then
        if(p(n+2,5)**2+p(n+3,5)**2+2.*four(n+2,n+3).ge.
     &  (par(22)+ulmass(0,k(n+2,2))+ulmass(0,k(n+3,2)))**2) goto 430
        k(n+2,1)=ip
        call luifld(mod(k(n+2,2),500),0,mod(k(n+3,2),500),ifldmp,
     &  k(n+2,2))
        p(n+2,5)=ulmass(1,k(n+2,2))
        ps=p(n+1,5)+p(n+2,5)
        pv(2,5)=p(n+2,5)
        mmat=0
        nd=2
        goto 280
      elseif(mmat.eq.11) then
        if(p(n+3,5)**2+p(n+4,5)**2+2.*four(n+3,n+4).ge.
     &  (par(22)+ulmass(0,k(n+3,2))+ulmass(0,k(n+4,2)))**2) goto 400
        k(n+3,1)=ip
        call luifld(mod(k(n+3,2),500),0,mod(k(n+4,2),500),ifldmp,
     &  k(n+3,2))
        p(n+3,5)=ulmass(1,k(n+3,2))
        do 380 j=1,3
  380   p(n+3,j)=p(n+3,j)+p(n+4,j)
        p(n+3,4)=sqrt(p(n+3,1)**2+p(n+3,2)**2+p(n+3,3)**2+p(n+3,5)**2)
        ha=p(n+1,4)**2-p(n+2,4)**2
        hb=ha-(p(n+1,5)**2-p(n+2,5)**2)
        hc=(p(n+1,1)-p(n+2,1))**2+(p(n+1,2)-p(n+2,2))**2+
     &  (p(n+1,3)-p(n+2,3))**2
        hd=(pv(1,4)-p(n+3,4))**2
        he=ha**2-2.*hd*(p(n+1,4)**2+p(n+2,4)**2)+hd**2
        hf=hd*hc-hb**2
        hg=hd*hc-ha*hb
        hh=(sqrt(hg**2+he*hf)-hg)/(2.*hf)
        do 390 j=1,3
        pcor=hh*(p(n+1,j)-p(n+2,j))
        p(n+1,j)=p(n+1,j)+pcor
  390   p(n+2,j)=p(n+2,j)-pcor
        p(n+1,4)=sqrt(p(n+1,1)**2+p(n+1,2)**2+p(n+1,3)**2+p(n+1,5)**2)
        p(n+2,4)=sqrt(p(n+2,1)**2+p(n+2,2)**2+p(n+2,3)**2+p(n+2,5)**2)
        nd=nd-1
      endif
 
  400 if(mmat.ge.11.and.iabs(k(n+1,2)).ge.500) then
        pmr=sqrt(max(0.,p(n+1,5)**2+p(n+2,5)**2+2.*four(n+1,n+2)))
        if(pmr.gt.par(22)+ulmass(0,k(n+1,2))+ulmass(0,k(n+2,2)))
     &  goto 410
        call luifld(mod(k(n+1,2),500),0,-isign(1,k(n+1,2)),ifldmp,kf1)
        call luifld(mod(k(n+2,2),500),0,-isign(1,k(n+2,2)),ifldmp,kf2)
        psm=ulmass(0,kf1)+ulmass(0,kf2)
        if(mmat.le.12.and.pmr.gt.0.2*par(22)+psm) goto 410
        if(mmat.eq.13.and.pmr.gt.dpar(14)+psm) goto 410
        if(nd.eq.4.or.kfa.eq.11) goto 120
        k(n+1,1)=ip
        call luifld(mod(k(n+1,2),500),0,mod(k(n+2,2),500),ifldmp,
     &  k(n+1,2))
        p(n+1,5)=ulmass(0,k(n+1,2))
        k(n+2,2)=k(n+3,2)
        p(n+2,5)=p(n+3,5)
        ps=p(n+1,5)+p(n+2,5)
        pv(2,5)=p(n+3,5)
        mmat=0
        nd=2
        goto 280
      endif
 
  410 if(mmat.eq.13) then
        iflo(1)=mod(k(n+1,2),500)
        iflo(2)=mod(k(n+2,2),500)
        k(n+1,1)=k(n+3,1)
        k(n+1,2)=k(n+3,2)
        do 420 j=1,5
        pv(1,j)=p(n+1,j)+p(n+2,j)
  420   p(n+1,j)=p(n+3,j)
        pv(1,5)=pmr
        n=n+1
        np=0
        nq=2
        ps=0.
        psq=ulmass(3,iflo(1))+ulmass(3,iflo(2))
        mmat=6
        goto 150
      endif
 
  430 n=n+nd
      if(mbst.eq.1) then
        do 440 j=1,3
  440   be(j)=p(ip,j)/p(ip,4)
        ga=p(ip,4)/p(ip,5)
        do 460 i=nsav+1,n
        bep=be(1)*p(i,1)+be(2)*p(i,2)+be(3)*p(i,3)
        do 450 j=1,3
  450   p(i,j)=p(i,j)+ga*(ga*bep/(1.+ga)+p(i,4))*be(j)
  460   p(i,4)=ga*(p(i,4)+bep)
      endif
      k(ip,1)=k(ip,1)+20000
      return
      end
 
      subroutine luifld(ifl1,ifl2,ifl3,ifl4,kf)
#include "amsrqmd.h"
      common /ludat1s/ mst(40),par(80)
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
      common /prinbk/ iprin
      ifla=iabs(ifl1)
      iflb=iabs(ifl2)
      iflc=iabs(ifl3)
      par1=par(1)
      par2=par(2)
      par3=par(3)
      par4=3.*par(4)
      if(ifla.ge.4.and.ifla.lt.10.and.abs(par(16)-1.).gt.0.1) then
        par1=2.5*(0.4*par(1))**(1./par(16))
        par2=par(2)**(1./par(16))
        par3=par(3)**(1./par(16))
        par4=3.*par(4)**(1./par(16))
      endif
        par4m=1./(3.*sqrt(par(4)))
 
      iflg=0
      ifli=0
      ifl4=0
      kf=0
      mb=1
      if(ifla.gt.10.or.iflc.gt.10) mb=2
      if(ifla.lt.10.and.iflb.eq.0.and.iflc.eq.0.and.
     &(1.+par1)*rlu(0).lt.1.) mb=0
      if(ifla.lt.10.and.iflb.eq.0.and.(iflc+9)/10.eq.1) mb=0
 
      if((ifla.gt.100.or.mb.eq.1).and.par(5).gt.0.) then
        par3m=sqrt(par(3))
        pardm=par(7)/(par(7)+par3m*par(6))
        pars0=par(5)*(2.+(1.+par2*par3m*par(7))*(1.+par4m))
        pars1=par(7)*pars0/(2.*par3m)+par(5)*(par(6)*(1.+par4m)+
     &  par2*par3m*par(6)*par(7))
        pars2=par(5)*2.*par(6)*par(7)*(par2*par(7)+(1.+par4m)/par3m)
        parsm=max(pars0,pars1,pars2)
        par4=par4*(1.+parsm)/(1.+parsm/(3.*par4m))
      endif
 
      if(mb.eq.0.or.ifla.gt.100) then
        if(mb.eq.0) then
          if(iflc.eq.0) ifl4=isign(1+int((2.+par2)*rlu(0)),-ifl1)
          ifld=max(ifla,iflc+iabs(ifl4))
          ifle=min(ifla,iflc+iabs(ifl4))
 
        else
  100     iflg=mod(ifla,10)+int(rlu(0)+0.5)*((ifla-100)/10-mod(ifla,10))
          iflh=mod(ifla,10)+(ifla-100)/10-iflg
          if((iflg.eq.3.and.rlu(0).gt.pardm).or.(iflh.eq.3.and.rlu(0).
     &    lt.pardm)) then
            ifli=iflg
            iflg=iflh
            iflh=ifli
          endif
          ifli=1+int((2.+par2*par3m*par(7))*rlu(0))
          if((iflh.ne.ifli.and.rlu(0).gt.(1.+par4m)/max(2.,1.+par4m)).
     &    or.(iflh.eq.ifli.and.rlu(0).gt.2./max(2.,1.+par4m))) goto 100
          ifld=max(iflg,ifli)
          ifle=min(iflg,ifli)
          ifl4=isign(10*min(ifli,iflh)+max(ifli,iflh)+9*int(rlu(0)+
     &    1./(1.+par4m))*iabs(ifli-iflh),-ifl1)
          mst(33)=ifli
        endif
 
        ksp=int(par(8)+rlu(0))
        if(ifld.eq.3.and.ifld.ne.ifle)
     a                      ksp=int(par(9)+rlu(0))
        if(ifld.ge.4) ksp=int(par(10)+rlu(0))
        if(ifld.ne.ifle) then
          kf=isign(kfr(8*ksp+ifld)+ifle,(ifl1+ifl3+ifl4)*(2*ifld-7))
          if(ifla.gt.100.and.ifli.gt.iflg) kf=-kf
        else
          rfr=rlu(0)
          if(ifld.le.3) kf=23+10*ksp+int(rfr+cfr(6*ksp+2*ifld-1))+
     &    int(rfr+cfr(6*ksp+2*ifld))
          if(ifld.eq.4) kf=26+10*ksp
          if(ifld.ge.5) kf=78+4*ksp+ifld
        endif
 
      else
  110   if(ifla.lt.10.and.iflb.eq.0.and.iflc.eq.0) then
          mb=3
          ifld=ifla
  120     ifle=1+int((2.+par2*par3)*rlu(0))
          iflf=1+int((2.+par2*par3)*rlu(0))
          if(ifle.ge.iflf.and.par4.lt.rlu(0)) goto 120
          if(ifle.lt.iflf.and.par4*rlu(0).gt.1.) goto 120
          ifl4=isign(10*ifle+iflf,ifl1)
 
        elseif(ifla.lt.10.and.iflb.eq.0) then
          ifld=ifla
          ifle=iflc/10
          iflf=mod(iflc,10)
 
        elseif(ifla.lt.10) then
          ifld=iflb
          if(iflc.eq.0) ifl4=isign(1+int((2.+par2)*rlu(0)),ifl1)
          ifle=ifla+int(rlu(0)+0.5)*(iflc+iabs(ifl4)-ifla)
          iflf=ifla+iflc+iabs(ifl4)-ifle
 
        else
          if(iflc.eq.0) ifl4=isign(1+int((2.+par2)*rlu(0)),ifl1)
          ifld=iflc+iabs(ifl4)
          ifle=ifla/10
          iflf=mod(ifla,10)
        endif
 
        lfr=3+2*((2*(ifle-iflf))/(1+iabs(ifle-iflf)))
        if(ifld.ne.ifle.and.ifld.ne.iflf) lfr=lfr+1
        wt=cfr(2*lfr+11)+par(11)*cfr(2*lfr+12)
        if(mb.eq.1.and.ifle.lt.iflf) wt=wt/3.
        if(mb.eq.1.and.iflb.ne.0) wt=0.75*wt
        if(mb.eq.3.and.par(5).gt.0.) then
          wtdq=pars0
          if(max(ifle,iflf).eq.3) wtdq=pars1
          if(min(ifle,iflf).eq.3) wtdq=pars2
          if(ifle.lt.iflf) wtdq=wtdq/(3.*par4m)
          if((1.+wtdq)*rlu(0).gt.1.) ifl4=ifl4+isign(100,ifl1)
          if(ifle.ge.iflf) wt=wt*(1.+wtdq)/(1.+parsm)
          if(ifle.lt.iflf) wt=wt*(1.+wtdq)/(1.+parsm/(3.*par4m))
        endif
        if(iflb.ne.0.and.wt.lt.rlu(0)) return
        if(iflb.eq.0.and.iflc.eq.0.and.wt.lt.rlu(0)) goto 110
 
        iflg=max(ifld,ifle,iflf)
        ifli=min(ifld,ifle,iflf)
        iflh=ifld+ifle+iflf-iflg-ifli
        ksp=2+2*int(1.-cfr(2*lfr+11)+(cfr(2*lfr+11)+par(11)*
     &  cfr(2*lfr+12))*rlu(0))
 
        if(ksp.eq.2.and.iflg.gt.iflh.and.iflh.gt.ifli) then
          if(ifle.gt.iflf.and.ifld.ne.iflg) ksp=2+int(0.75+rlu(0))
          if(ifle.lt.iflf.and.ifld.eq.iflg) ksp=3
          if(ifle.lt.iflf.and.ifld.ne.iflg) ksp=2+int(0.25+rlu(0))
        endif
 
        kf=isign(kfr(16*ksp-16+iflg)+kfr(16*ksp-8+iflh)+ifli,ifl1)
      endif
 
      return
      end
 
 
CPAT,KMASS    .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine kmass(s,pr,em1,em2,em3,em4,ityp1,ityp2,ityp3,ityp4,
     a      ichank,npid1,npid2,npid3,npid4,ic,icltyp,nop,nscop,nonstr)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
      logical jets
      dimension sigstr(mxchan)
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      real*4 cgks
      data vernum/'version  rqmd 1.09 -- 25-jan-94'/
      data pronam/'k m a s s treats flavor changing channels '/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      if(s.lt. em1+em2 +ekinmi) then
          ic=0
          return
      end if
      nop=2
      em1old=em1
      em2old=em2
      ityp1o=ityp1
      ityp2o=ityp2
      npid1o=npid1
      npid2o=npid2
      call  retcgk(ityp1,npid1,j1,m1,-1,cgks)
      call  retcgk(ityp2,npid2,j2,m2,-1,cgks)
      goto (
     >  20, 20, 20, 20, 20,
     >  20, 20, 20, 20, 20,
     >  20, 20, 20, 20, 20,
     >  20, 20, 20, 20, 20,
     >  20, 30, 30, 30, 30,
     >  30, 30, 10, 30, 30,
     >  30, 30, 30, 30, 10,
     >  10, 30, 30, 30, 30,
     >  30, 30, 10, 10, 10,
     >  20, 20, 20, 20, 20,
     >  20, 30, 30, 30, 20,
     >  20, 20, 20, 20, 20, 20, 30, 30, 30, 20,
     >  20, 30, 30, 30, 30,30 ,30 ,10 ,10 ,10 ,
     >  30, 30, 10, 10, 10,10 ,10 ,10 ,10 ,30 ,
     >  30, 30, 10, 10, 10,10,30 ,30 ,10 ,10 ,
     >  10, 10, 10, 10, 10,10 ,10 ,10 ,30 ,10 ,
     >  10, 10, 10, 10, 10,10 ,30 ,30 ,30 ,10 ,
     >  10, 10, 10, 10, 10
     & ) , icltyp
   10 continue
      call errex('wrong icltyp in kmass')
      return
   20 continue
      if(ic.le.nscop) then
        icn=ic-nonstr
         ktot=0
         iflag=1
         ikinp=icn
         call getbb(s,sigstr,ktot,ityp1,ityp2,npid1,npid2,em1,em2,
     &                 itp1,itp2,itp3,npd1,npd2,npd3,emb,emy,emk,
     &                 iflag,ikinp,
     &                 vkkb,arat)
         em1=emb
         em2=emy
         em3=emk
         em4=0.
         ityp1=itp1
         ityp2=itp2
         ityp3=itp3
         ityp4=0
         npid1=npd1
         npid2=npd2
         npid3=npd3
         npid4=0
         nop=3
      else
     & if (ic.gt.nscop.and.ic.le.ichank-1) then
        nop=4
        ikinp=ic
        k=nscop
        iflg=1
         arat=0.0
         par=0.0
         call gpair(icltyp,ityp1,npid1,em1,ityp2,npid2,em2,
     &               itp1,npd1,e1,
     &               itp2,npd2,e2,
     &               itp3,npd3,e3,
     &               itp4,npd4,e4,
     &               ikinp,iflg,
     &               sigstr,k,nscop,s,par,arat)
         em1=e1
         em2=e2
         em3=e3
         em4=e4
         ityp1=itp1
         ityp2=itp2
         ityp3=itp3
         ityp4=itp4
         npid1=npd1
         npid2=npd2
         npid3=npd3
         npid4=npd4
      else
        call errex('wrong ic in kmass bb')
      end if
      if(s.le.em1+em2+em3+em4+ekinmi) then
        ic=0
        nop=2
        goto 5000
      end if
      if (ranf(0).lt.0.5) then
         call swap(em1,em2)
         call iswap(ityp1,ityp2)
         call iswap(npid1,npid2)
      end if
      if (ranf(0).lt.0.5.and.nop.eq.4) then
         call swap(em3,em4)
         call iswap(ityp3,ityp4)
         call iswap(npid3,npid4)
      end if
       if (nop.eq.3) then
          if (ityp1.ge.3.and.ityp1.le.6) npid1=1
          if (ityp2.ge.3.and.ityp2.le.6) npid2=1
       end if
        if(ityp1.eq.1.or.ityp1.eq.2) then
        else
          if((ityp1.ge.3.and.ityp1.le.6).and.em1.gt.emmnd2) then
            npid1=-mbafnd(1,em1)
          else if((ityp1.ge.10.and.ityp1.le.11).and.em1.gt.emmnn2) then
            npid1=-mbafnd(2,em1)
          end if
          if(npid1.lt.0) then
            if(jets(ityp1,npid1,em1,0)) then
              npid1=npid1-1000
            end if
          end if
        end if
        if(ityp2.eq.1.or.ityp2.eq.2) then
        else
          if((ityp2.ge.3.and.ityp2.le.6).and.em2.gt.emmnd2) then
            npid2=-mbafnd(1,em2)
          else if((ityp2.ge.10.and.ityp2.le.11).and.em2.gt.emmnn2) then
            npid2=-mbafnd(2,em2)
          end if
          if(npid2.lt.0) then
            if(jets(ityp2,npid2,em2,0)) then
              npid2=npid2-1000
            end if
          end if
        end if
      go to 50
   30 continue
      icn=ic-nonstr
      goto (
     >  12 , 12 , 12 , 12 , 12 ,
     >  12 , 12 , 12 , 12 , 12 ,
     >  12 , 12 , 12 , 12 , 12 ,
     >  12 , 12 , 12 , 12 , 12 ,
     >  12 , 12 , 12 ,12  , 12 ,
     >   12, 12 ,12  , 12 , 12 ,
     >   12, 12 , 12 , 12 ,12  ,
     >  12 , 12 , 12 , 12 , 12 ,
     >   12,12  ,12  ,12  ,12  ,
     >  12 ,12  ,12  ,12  ,12  ,
     >  12 , 12 , 12 , 12 ,12  ,
     >  12 ,12  ,12  ,12  ,12  ,12 , 12, 12, 12,12 ,
     >  12, 311 ,311 , 12 , 12 , 12, 12,12 ,12 ,12 ,
     >  311,311, 12,  12  ,12  ,12 ,12 ,12 ,12 ,315,
     >  315,315 ,12  ,12  ,12  ,12 ,316,316,12 ,12 ,
     >  12 ,12  ,12  ,12  ,12  ,12 ,12 ,12 ,311,12 ,
     >  12 ,12  ,12  ,12  ,12  ,12 ,315,315,315,12 ,
     >  12 ,12  ,12  ,12  ,12
     & ) , icltyp
   12 continue
      call errex('wrong icltyp in kmass')
      return
  311 continue
      call
     a     enlk(icltyp,ityp1,npid1,ityp2,npid2,em1,em2,s,pr,ic)
      if(ic.eq.0) then
        goto 5000
      else
        goto 50
      end if
  315 continue
      goto 5000
  316 continue
      isw=0
      if ((ityp2.ge.1).and.(ityp2.le.2)) then
                    call swap(em1,em2)
                    call iswap(npid1,npid2)
                    call iswap(ityp1,ityp2)
                    call iswap(j1,j2)
                    call iswap(m1,m2)
                    isw=1
      end if
      if(((ityp1.eq.14).and.(npid1.lt.0).and.(ityp2.le.2))
     &  .or.((ityp2.eq.14).and.(npid2.lt.0).and.(ityp1.le.2)))
     &                                                    then
        goto 5000
      else
     &   if (((ityp1.eq.14).and.(npid1.gt.0).and.(ityp2.le.2))
     &    .or.((ityp2.eq.14).and.(npid2.gt.0).and.(ityp1.le.2)))
     &                                                        then
        if(m1+m2.eq.0) then
          if(icn.eq.1) then
            if (npid2.eq.1) then
                               em1=emnuc
                               em2=emkap
                               ityp1=1
                               ityp2=14
                               npid1=0
                               npid2=2
            else if (npid2.eq.2) then
                               em1=emnuc
                               em2=emka0
                               ityp1=2
                               ityp2=14
                               npid1=0
                               npid2=1
            else
                   call errex('wrong npid in kmass -')
            end if
          end if
        else
          if(icn.eq.1.and.m1+m2.ne.0) then
                         if (ranf(0).ge.0.5) then
                               em1=emdelt
                               ityp1=3+npid2
                               npid1=1
                               em2=em2
                               ityp2=14
                               npid2=npid2
                         else
                               ityp1=3*npid2
                               npid1=1
                               em1=emdelt
                               ityp2=14
                               npid2=(3-npid2)
                                if (npid2.eq.1) then
                                  em2=emka0
                                else
                                  em2=emkap
                                end if
                         end if
          else if(icn.eq.2) then
                             if (npid2.eq.1) then
                               ityp2=99
                               npid2=29
                               em2=getmas(0,npid2,1,-1.0)
                             else
                               ityp2=99
                               npid2=28
                               em2=getmas(0,npid2,1,-1.0)
                             end if
          else if(icn.eq.3) then
                         if (ranf(0).ge.0.5) then
                            em1=emdelt
                            ityp1=3+npid2
                            npid1=1
                            ityp2=99
                            npid2=30-npid2
                            em2=getmas(0,npid2,1,-1.0)
                         else
                            ityp1=3*npid2
                            npid1=1
                            em1=emdelt
                            ityp2=99
                            npid2=27+npid2
                            em2=getmas(0,npid2,1,-1.0)
                         end if
 
          else
                write (8,*) 'wrong icn in kmass'
                ic=0
                goto 5000
          end if
        end if
      end if
      if(s.lt. em1 + em2+ekinmi) then
           ic=0
           goto 5000
      end if
  310 continue
      if(isw.eq.1) then
        call swap(em1,em2)
        call iswap(npid1,npid2)
        call iswap(ityp1,ityp2)
      end if
      if(em1+em2.gt.s) call errex('wrong masses selected in kmass30')
   50 continue
      return
 5000 continue
      ic=0
      em1=em1old
      em2=em2old
      ityp1=ityp1o
      ityp2=ityp2o
      npid1=npid1o
      npid2=npid2o
      return
      end
CPAT,LMASS    .
      subroutine lmass(kdiffr,itag1,itag2,iexpn1,iexpn2,nchain,ipin,
     a      sigt,sigel,cme,pr,em1,em2,cmeff,ityp1,ityp2,iann,
     b      kmult1,kmult2,istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     c      ltyp1,ltyp2,iflvch,idecis,npid1,npid2,ic,pi1sqo,pi2sqo)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       include 'sigmasx'
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       real*4 pmas,pwid,cfr
       common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       real*4 cgk2
       real*4 cqpfrc
       character*33 vernum
       character*46 pronam
       logical*1 ttvers
       data vernum/'version rqmd 2.3  -- 23-sep-96'/
       data pronam/'module: l m a s s lets hadrons collide        '/
       data ttvers/.true./
       if(ttvers) then
         write(lun8,*)' version number report -------------'
         write(lun8,*)pronam
         write(lun8,*)vernum
         write(lun8,*)'------'
         ttvers=.false.
       end if
       iflvch=0
       if(cme.lt.em1+em2+ekinmi) then
          ic=0
          return
       end if
       em1o=em1
       em2o=em2
       if(ibry1*ibry2.lt.0) then
         if(ida(19).eq.0) then
           snew=cme
         else
           snew=2.*sqrt(emnuc**2+pr**2)
         end if
         sann=sppban(snew)
         if(sigt-sigel.lt.sann-2.) then
           write(lun8,*)  ityp1,npid1,ityp2,npid2,sigt,sigel,snew
           write(lun8,*)  sann
           write(lun8,*) 'sigt-sigel.lt.sann in lmass??????? '
         end if
         if(ranf(0).lt.sann/(sigt-sigel)) then
           if(ida(49).eq.2) then
             ic=0
           else
             if(ida(19).eq.2) then
               cgk2s=0.0
               do 12 i=0,2
                call retcgk(ityp1,npid1,ityp2,npid2,i,cgk2)
                cgk2s=cgk2s+cgk2
   12          continue
               if(cgk2s.gt.1.001)
     a           call errex('lmass: wrong sum of cgcoefficients')
               if(ranf(0).gt.cgk2s) then
                 ic=0
               else
                 ic=-3
               end if
             else
               ic=-3
             end if
           end if
           return
         end if
       end if
       assign 11 to label
       if(ipin.eq.0.and.
     a            ((ida(26).eq.0.and.cme.le.tblhig).or.
     b                           (ida(26).gt.0.and.cme.le.snnlim)))then
         idecis=0
       else if(ibry1.eq.1.and.ibry2.eq.1) then
         if(ida(26).eq.0.and.cme.le.tblhig)  idecis=0
       end if
       if(switch(6)) then
         srt=cme
       else
         srt=cmeff
       end if
       call emexc(ltyp1,em1,epdmin,epmin,em1min)
       call emexc(ltyp2,em2,etdmin,etmin,em2min)
       ltyp1a=iabs(ltyp1)
       ltyp2a=iabs(ltyp2)
       iresex=0
       ibrod=ibry1*ibry2
       if(ibrod.ge.2) then
         if(istra1+istra2.gt.1) iresex=1
       else if(ibrod.lt.0) then
         iresex=1
       else if(ibry1.eq.0.and.ibry2.eq.0) then
       else if(ibrod.eq.0) then
         if(iann.eq.0) iresex=1
       end if
       pplus=srt
       pminus=srt
       if(srt.le.epmin+etmin) then
         ic=0
         return
       end if
       noexc1=0
       noexc2=0
       pl=pcmsr(srt,epmin,etmin)
       plsq=pl*pl
       p1pl=sqrt(epmin**2+plsq)+pl
       p1mi=sqrt(epmin**2+plsq)-pl
       p2mi=sqrt(etmin**2+plsq)+pl
       p2pl=sqrt(etmin**2+plsq)-pl
       if(srt.le.etdmin+epdmin) then
         em1new=em1min
         em2new=em2min
         prbas=pcmsr(srt,em1min,em2min)
         go to label
       end if
       if(iresex.eq.0) then
         if(srt.gt.epdmin+em2min) then
           prbas=pcmsr(srt,epdmin,em2min)
         else
           prbas=cvalu0
         end if
         if(srt.gt.etdmin+em1min) then
           prtes=pcmsr(srt,etdmin,em1min)
           prbas=max(prbas,prtes)
         end if
       else
         prbas=pcmsr(srt,em1min,em2min)
       end if
       if(kmult1.ge.0.and.kmult2.ge.0.and.
     a                 srt.gt.etdmin+epdmin+ekinmi) then
         pdfrle=((etdmin+epdmin)/srt)**2
         if(ranf(0).lt.pdfrle) then
           if(kmult1.eq.0.or.kmult2.eq.0) then
             if(ranf(0).gt.0.5) then
               noexc1=1
               em1new=em1min
               embase=etdmin
               emcase=em1min
             else
               noexc2=1
               em2new=em2min
               embase=epdmin
               emcase=em2min
             end if
             mtry=0
   19        mtry=mtry+1
             if(mtry.gt.50)
     a       call errex('lmass19:mtry abort')
             emdase=srt-(ekinmi+emcase)
             if(emdase.le.embase) call errex('lmass19 abort')
             emtes=sqrt(embase**2+ranf(0)*(emdase**2-embase**2))
             prtes=pcmsr(srt,emcase,embase)
             if(ranf(0).gt.
     a               (pcmsr(srt,emcase,emtes)/prtes)**2) go to 19
             if(noexc1.eq.1) then
               em2new=emtes
             else
               em1new=emtes
             end if
             go to 11
           else
             noexc1=2
             noexc2=2
           end if
         end if
       end if
       go to 60
   11  continue
       em1=em1new
       em2=em2new
       npink1=0
       npink2=0
       ltypa1=ltyp1
       ltypa2=ltyp2
       if(ltyp1a.eq.41.or.ltyp1a.eq.42.or.
     a       (ltyp1a.ge.61.and.ltyp1a.le.64)) then
         if(ltyp1a.le.42) then
           ihad1=2
         else
           ihad1=1
         end if
         if(em1.ge.epdmin) then
           kmuln1=mbafnd(ihad1,em1)
           if(ltyp1.gt.0.and.idecis.eq.0.and.kmuln1.gt.0)
     a                                       npink1=-100
         else
           kmuln1=0
         end if
       else
         if(ibry1.ne.0) then
           ihad1=idnbar(ltyp1a)
         else
           ihad1=idnmes(ltyp1a)
         end if
         if(em1.ge.epdmin) then
           if(ibry1.ne.0) then
             if(ihad1.gt.0) then
               kmuln1=mbafnd(ihad1,em1)
             else
               call errex('lmass: ibry/ibar dead end')
             end if
           else
             if(ihad1.gt.0) then
               kmuln1=mmefnd(ihad1,em1)
               if(kmuln1.eq.9999) then
                 kmuln1=0
                 em1=em1min
               end if
             else
               call errex('lmass: imes dead end')
             end if
           end if
         else
           kmuln1=0
         end if
       end if
       if(kmuln1.eq.-3) kmuln1=-1
       if(ltyp2a.eq.41.or.ltyp2a.eq.42.or.
     a       (ltyp2a.ge.61.and.ltyp2a.le.64)) then
         if(ltyp2a.le.42) then
           ihad2=2
         else
           ihad2=1
         end if
         if(em2.ge.etdmin) then
           kmuln2=mbafnd(ihad2,em2)
           if(ltyp2.gt.0.and.idecis.eq.0.and.kmuln2.gt.0)
     a                                       npink2=-100
         else
           kmuln2=0
         end if
       else
         if(ibry2.ne.0) then
           ihad2=idnbar(ltyp2a)
         else
           ihad2=idnmes(ltyp2a)
         end if
         if(em2.ge.etdmin) then
           if(ibry2.ne.0) then
             if(ihad2.gt.0) then
               kmuln2=mbafnd(ihad2,em2)
             else
               call errex('lmass: ibry/ibar dead end')
             end if
           else
             if(ihad2.gt.0) then
               kmuln2=mmefnd(ihad2,em2)
               if(kmuln2.eq.9999) then
                 kmuln2=0
                 em2=em2min
               end if
             else
               call errex('lmass: imes dead end')
             end if
           end if
         else
           kmuln2=0
         end if
       end if
       if(kmuln2.eq.-3) kmuln2=-1
       if(ibry1.eq.2.and.itag1.ne.0) then
         if(kmuln1.ge.0.and.em1.lt.2.0) then
           em1=em1o
           em2=em2o
           ic=0
           return
         end if
       end if
       if(ibry2.eq.2.and.itag2.ne.0) then
         if(kmuln2.ge.0.and.em2.lt.2.0) then
           em1=em1o
           em2=em2o
           ic=0
           return
         end if
       end if
       if(kmuln1.ge.0.and.kmuln2.ge.0.and.nchain.eq.0
     a                                .and.kdiffr.eq.0) then
         igfix=0
         jgfix=1
         mtry=0
   40    continue
         mtry=mtry+1
         if(ibry1.ne.0) then
           minw=0
           maxw=mxbsta(ihad1)
           if(noexc1.eq.1) then
             maxw=0
             minw=0
           end if
   41      if(embarr(maxw,ihad1)+em2min.gt.srt) then
             maxw=maxw-1
             if(maxw.lt.0) then
               maxw=0
             else
               go to 41
             end if
           end if
           if(minw.gt.maxw) maxw=minw
           kmula1=kresb(igfix,ihad1,minw,maxw,ltyp1a,em1a)
         else
           minw=0
           maxw=mxmsta(ihad1)
           if(noexc1.eq.1) then
             maxw=0
             minw=0
           end if
   42      if(emmesr(maxw,ihad1)+em2min.gt.srt) then
             maxw=maxw-1
             if(maxw.lt.0) then
               maxw=0
             else
               go to 42
             end if
           end if
           if(minw.gt.maxw) maxw=minw
           kmula1=kresm(1,igfix,ihad1,minw,maxw,ltyp1a,em1a)
         end if
         if(ibry2.ne.0) then
           minw=0
           maxw=mxbsta(ihad2)
           if(noexc2.eq.1) then
             maxw=0
             minw=0
           end if
   43      if(embarr(maxw,ihad2)+em1min.gt.srt) then
             maxw=maxw-1
             if(maxw.lt.0) then
               maxw=0
             else
               go to 43
             end if
           end if
           if(minw.gt.maxw) maxw=minw
           kmula2=kresb(igfix,ihad2,minw,maxw,ltyp2a,em2a)
         else
           minw=0
           maxw=mxmsta(ihad2)
           if(noexc2.eq.1) then
             maxw=0
             minw=0
           end if
   44      if(emmesr(maxw,ihad2)+em1min.gt.srt) then
             maxw=maxw-1
             if(maxw.lt.0) then
               maxw=0
             else
               go to 44
             end if
           end if
           if(minw.gt.maxw) maxw=minw
           kmula2=kresm(1,igfix,ihad2,minw,maxw,ltyp2a,em2a)
         end if
         if(mtry.gt.50) then
           kmula1=kmult1
           kmula2=kmult2
           em1a=em1o
           em2a=em2o
           go to 45
         else
           if(iresex.eq.0) then
             if(kmula1.eq.0.and.kmula2.eq.0) go to 40
           end if
         end if
         if(em1a+em2a.ge.srt) go to 40
         prnew=pcmsr(srt,em1a,em2a)
         if(ranf(0).gt.(prnew/prbas)**2) go to 40
         if(noexc1.eq.2.and.kmula1.eq.0) go to 40
         if(noexc2.eq.2.and.kmula2.eq.0) go to 40
         if(kmula1.gt.0) then
           emmax=srt-em2a
           em1a=getmas(kmula1,ltyp1a,jgfix,emmax)
           if(em1a.lt.0.0) go to 40
         end if
         if(kmula2.gt.0) then
           emmax=srt-em1a
           em2a=getmas(kmula2,ltyp2a,jgfix,emmax)
           if(em2a.lt.0.0) go to 40
         end if
         if((ltyp1.ne.ltyp2.or.kmult1.ne.kmult2).and.
     a       ltypa1.eq.ltypa2.and.kmula1.eq.kmula2) then
           if(ranf(0).gt.0.5) then
             kmula1=kmult1
             kmula2=kmult2
             em1a=em1o
             em2a=em2o
           end if
         end if
   45    continue
         kmuln1=kmula1
         kmuln2=kmula2
         em1=em1a
         em2=em2a
       end if
       call oldnew(0,ityp1,npid1,em1,kmuln1,ltyp1)
       call oldnew(0,ityp2,npid2,em2,kmuln2,ltyp2)
       if(npink1.ne.0) npid1=npid1+npink1
       if(npink2.ne.0) npid2=npid2+npink2
      return
   60 continue
      xplus=1.0
      xmins=1.0
      if(itag1.ne.0) then
        if(iabs(iexpn1).gt.10) then
          cqpf1=cqpfrc(1)
          xplus=cqpf1
        else
          cqpf1=1.0
        end if
      else if(ibry1.eq.0) then
        cqpf1=cqpfrc(1)
      else
        cqpf1=cqpfrc(2)
      end if
      if(itag2.ne.0) then
        if(iabs(iexpn2).gt.10) then
          cqpf2=cqpfrc(1)
          xmins=cqpf2
        else
          cqpf2=1.0
        end if
      else if(ibry2.eq.0) then
        cqpf2=cqpfrc(1)
      else
        cqpf2=cqpfrc(2)
      end if
       ltry=0
       if(ida(22).eq.3) then
         call diffra(ityp1,npid1,ityp2,npid2,icdl,
     a             istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     b                                             srt,em1,em2)
         if(icdl.eq.1) then
           kdiffr=1
         else if(icdl.eq.2) then
           kdiffr=2
         end if
       end if
  201  ltry=ltry+1
       if(ltry.gt.50) then
         em1new=em1min
         em2new=em2min
         go to label
       end if
       p1plus=xplus*p1pl
       p1mins=p1mi
       p2plus=p2pl
       p2mins=xmins*p2mi
       zprand=ranf(0)
       zmrand=ranf(0)
       p1mins=p1mins*(p2mins/p1mins)**zmrand
       p2plus=p2plus*(p1plus/p2plus)**zprand
       p1plus=pplus-p2plus
       p2mins=pminus-p1mins
       em1new=sqrt(p1plus*p1mins)
       em2new=sqrt(p2plus*p2mins)
       if(em1new.lt.epmin.or.em2new.lt.etmin) go to 201
       if(kdiffr.eq.2) then
         pminw=(em1min*em1min)/p1plus
         delpm=p1mins-pminw
         p1mins=pminw
         p2mins=p2mins+delpm
         em1new=em1min
         em2new=sqrt(p2plus*p2mins)
         if(em2new.lt.etdmin) go to 201
       else if(kdiffr.eq.1) then
         pplnw=(em2min*em2min)/p2mins
         delpp=p2plus-pplnw
         p2plus=pplnw
         p1plus=p1plus+delpp
         em2new=em2min
         em1new=sqrt(p1plus*p1mins)
         if(em1new.lt.epdmin) go to 201
       else if(em1new.lt.epdmin.or.em2new.lt.etdmin) then
         go to 201
       end if
       if(em1new+em2new.ge.srt-ekinmi) go to 201
       if(kdiffr.gt.0) then
       else if(ida(44).eq.1) then
         call chains(nchain,p1plus,p1mins,p2plus,p2mins,
     a                      epdmin,etdmin,pplus,pminus,
     b                      em1red,em2red,em1new,em2new,srt)
       end if
       go to label
      end
      subroutine antibb(ic,ityp1,ityp2,npid1,npid2,em1,em2,srt)
      include 'scatter7'
#include "amsrqmd.h"
      dimension ip(3),iq(3)
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 1.09 -- 14-jul-93'/
      data pronam/'module: a n t i b b - - - anti-b b collision  '/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      call transl(-1,ityp1,npid1,kl1)
      ichrgs=luchge(kl1)
      call transl(-1,ityp2,npid2,kl2)
      ichrgs=ichrgs+luchge(kl2)
      if(mod(ichrgs,3).ne.0) then
         call errex('no integer charge in antibb')
      else
         ichrgs=ichrgs/3
      end if
      if(iabs(ichrgs).gt.1) then
         ic=0
         return
      end if
      call luiflv(kl1,ifl1a,ifl1b,ifl1c,ksp)
      call luiflv(kl2,ifl2a,ifl2b,ifl2c,ksp)
      if(-ifla1.gt.-iflb1) call iswap(ifla1,iflb1)
      if(-iflb1.gt.-iflc1) call iswap(iflc1,iflb1)
      if(-ifla1.gt.-iflb1) call iswap(ifla1,iflb1)
      if(ifla2.gt.iflb2) call iswap(ifla2,iflb2)
      if(iflb2.gt.iflc2) call iswap(iflc2,iflb2)
      if(ifla2.gt.iflb2) call iswap(ifla2,iflb2)
      ssbarf=1.0
      iqstor=ifl1a
      ipstor=-iqstor
      iq(1)=ifl1a
      iq(2)=ifl1b
      iq(3)=ifl1c
      ip(1)=ifl2a
      ip(2)=ifl2b
      ip(3)=ifl2c
      do 10 i=1,3
      do 10 j=1,3
       if(ip(i)+iq(j).eq.0) then
         if(ida(19).eq.2.and.iq(j).eq.3) then
           ssbarf=ssbarf*0.2
         end if
         ip(i)=0
         iq(j)=0
       end if
   10 continue
      izero=0
      do 20 j=1,3
       if(ip(j).eq.0) then
         izero=izero+1
       else
         ipstor=ip(j)
       end if
   20 continue
      do 30 j=1,3
       if(iq(j).eq.0) then
         izero=izero+1
       else
         iqstor=iq(j)
       end if
   30 continue
      if(ida(19).eq.2.and.ssbarf.lt.1.0) then
        if(ranf(0).gt.ssbarf) then
        write(lun8,*) 'antibb:ssbar annihilation is suppressed',kl1,kl2
        ic=0
        return
        end if
      end if
      if(izero.lt.4) then
        write(lun8,*) 'antibb: annihilation is blocked for ',kl1,kl2
        ic=0
        return
      end if
      if(iqstor*ipstor.ge.0) then
         write(lun8,*) kl1,kl2,iqstor,ipstor
         call errex('error in antibb encountered')
      end if
      if(ifl1c.gt.0) then
      else
         iqst=iqstor
         iqstor=ipstor
         ipstor=iqst
      end if
      if(max(iqstor,-ipstor).le.2) then
            ityp1=8+ ichrgs
            npid1=3
      else if(min(iqstor,-ipstor).eq.3) then
            ityp1=98
            npid1=35
      else if(iqstor.eq.1.and.-ipstor.eq.3) then
            ityp1=14
            npid1=2
      else if(iqstor.eq.2.and.-ipstor.eq.3) then
            ityp1=14
            npid1=1
      else if(iqstor.eq.3.and.-ipstor.eq.1) then
            ityp1=14
            npid1=-2
      else if(iqstor.eq.3.and.-ipstor.eq.2) then
            ityp1=14
            npid1=-1
      else
         call errex('undefined iqstor/ipstor pair in antibb')
      end if
         em1=srt
         em2=0.
         ityp2=-9999
         npid2=0
      return
      end
      subroutine  diffra(ityp1,npid1,ityp2,npid2,icdl,
     a             istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     b                                          srt,em1,em2)
      include 'scatter7'
#include "amsrqmd.h"
      logical difyes
      real*4 a,b,en,c,d
      tblfit(plab,a,b,en,c,d)=a+b*plab**en+c*(log(plab))**2+
     a                              d*log(plab)
      sigsd(adum)=0.68*log(0.6+0.1*adum*adum)
      ntry=0
      icdl=0
      if(max(ityp1,ityp2).gt.2) then
        cv12=12.
        if(srt.lt.max(cv12,3.*(em1+em2))) return
      end if
      srtact=srt-0.15*(istra1+istra2)
      if(srtact.lt.2.6) then
        return
      end if
      sigsdp=sigsd(srtact)
      imeso=imeso1+imeso2
      if(max(ityp1,ityp2).gt.2) then
         sigt12=40.* 0.6666**imeso *
     a          (1.-0.4*istra1/(3.-imeso1))*(1.-0.4*istra2/(3.-imeso2))
         sige12=sigt12**1.5 *( 10./40.**1.5 )
         sigtp1=40.* 0.6666**imeso1 * (1.-0.4*istra1/(3.-imeso1))
         sigep1=sigtp1**1.5 *( 10./40.**1.5 )
         sigtp2=40.* 0.6666**imeso2 * (1.-0.4*istra2/(3.-imeso2))
         sigep2=sigtp2**1.5 *( 10./40.**1.5 )
         sigsd1=(sige12*sigsdp*sigtp1)/(sigep1*40.)
         sigsd2=(sige12*sigsdp*sigtp2)/(sigep2*40.)
      else
         sigsd1=sigsdp
         sigsd2=sigsd1
      end if
      if(srtact.gt.4.) then
        ppr=sqrt(((srtact*srtact
     a                    -2.*emnuc*emnuc)/(2.*emnuc))**2-emnuc*emnuc)
        sigt=tblfit(ppr,45.60,219.0,-4.23,0.410,-3.41)
        sigel=tblfit(ppr,11.20,25.5,-1.12,0.151,-1.62)
        sigin=sigt-sigel
      else
        sigin=30.
      end if
      idifrc=0
    1 continue
      difyes=.false.
        if(ranf(0).gt.0.5) then
         if(ranf(0).lt.sigsd1/sigin) then
            difyes=.true.
            idifrc=1
         else if(ranf(0).lt. sigsd2/sigin) then
            difyes=.true.
            idifrc=2
         end if
        else
         if(ranf(0).lt. sigsd2/sigin) then
            difyes=.true.
            idifrc=2
         else if(ranf(0).lt. sigsd1/sigin) then
            difyes=.true.
            idifrc=1
         end if
        end if
        if(difyes) then
          if(idifrc.eq.1) then
             icdl=2
          else if(idifrc.eq.2) then
             icdl=1
          end if
          if(ida(46).eq.1) then
            ntry=ntry+1
            icdl=0
            if(ntry.gt.50) then
               call errex('ntry>50 in diffra')
            end if
            go to 1
          end if
        else
          icdl=3
        end if
      return
      end
      function sppban(srt)
        include 'scatter7'
#include "amsrqmd.h"
      data pbarpa,pbarpb,sig0n/0.05,0.6,120. /
      srt0=2.*emnuc
      sppban=sig0n*(srt0/srt)**2*(pbarpb+(pbarpa*srt0)**2/
     a                           ((srt**2-srt0**2)**2+(pbarpa*srt0)**2))
      return
      end
      subroutine chains(nchain,p1plus,p1mins,p2plus,p2mins,
     a                  epdmin,etdmin,pplus,pminus,
     b                  em1red,em2red,em1new,em2new,srt)
        include 'scatter7'
#include "amsrqmd.h"
        common /seabk/kchain,iofcha,isea(18),psea(0:3,18),isoan,iqqst,
     a                emsmb
        dimension sigch(10)
        data emsect / 0.28/
        real*8 srtact
        real*8 achain
        save gamres
        data  emcstq,emgex,emscal,acoef /0.06,0.06,0.8,2.06/
        data ibegin /0/
        if(ibegin.eq.0) then
          ibegin=1
          gamres=acoef*pcmsr(emscal,empion,empion)
        endif
        nchain=0
        if(srt.le.epdmin+etdmin+0.8) return
        if(em1new.le.epdmin.or.em2new.le.etdmin) return
        srtact=srt
        do 8 n=1,10
    8   sigch(n)=0.
        do 10 k=1,30
         ak=achain(k,srtact)
         do 9 n=1,10
          if(k.ge.n) then
            fack=float(k)
            do 6 km=k-1,k-(n-1),-1
    6        fack=fack*km
             facn=1.
             do 7 nm=2,n
    7         facn=facn*nm
              sigch(n)=sigch(n)+(-1)**(n+1)*fack/facn*ak
          end if
    9    continue
   10   continue
        st=0.
        do 12 n=1,10
         st=st+sigch(n)
   12   continue
        schm1=0.
        schp1=0.
        zrand=ranf(0)
        nstor=0
        do 13 n=1,10
         sn=sigch(n)/st
         schp1=schp1+sn
         if(zrand.ge.schm1.and.zrand.lt.schp1) then
            nstor=n
         end if
         schm1=schp1
   13   continue
        if(nstor.le.1) return
        do 18 n=1,18
   18   isea(n)=0
        mtry=0
        emsum=0.
        em1n=em1new
        em2n=em2new
        nmax=1
        nno=0
        do 14 n=2,nstor
         ispr=0
         do 16 kcross=1,2
          if(kcross.eq.1) then
            nact=n-nno-1
          else
            nact=n-nno+8
          end if
          ltry=0
  141     continue
          ltry=ltry+1
          if(mtry.gt.20000) then
            call errex('chains: mtry abort')
          end if
          zprand=ranf(0)
          zmrand=ranf(0)
          ipowsq=5
          ipowg=5
          if(kcross.eq.2) then
            pplow=emgex*pplus/srt
            pmlow=emcstq*pminus/srt
            ipow1=ipowg
            ipow2=ipowsq
          else
            pplow=emcstq*pplus/srt
            pmlow=emgex*pminus/srt
            ipow1=ipowsq
            ipow2=ipowg
          end if
          if(p1plus.le.pplow.or.p2mins.le.pmlow) then
            emsch=0.0
          else
            pp=pplow*(p1plus/pplow)**zprand
            if(ranf(0).gt.((p1plus-pp)/(p1plus-pplow))**ipow1)then
              ltry=ltry-1
              mtry=mtry+1
              go to 141
            end if
            pm=pmlow*(p2mins/pmlow)**zmrand
            if(ranf(0).gt.((p2mins-pm)/(p2mins-pmlow))**ipow2)then
              ltry=ltry-1
              mtry=mtry+1
              go to 141
            end if
            emsch=sqrt(pp*pm)
          end if
          if(emsch.gt.emsect) then
            if(emsch.lt.emscal) then
              gamact=acoef*pcmsr(emsch,empion,empion)
              shpbw=0.25*gamres*gamact/
     a                         ((emsch-emscal)**2+0.25*gamact**2)
              if(ranf(0).gt.shpbw) then
                ltry=51
              end if
            end if
          else
            ltry=51
          end if
          if(ltry.eq.51) then
            pp=0.0
            pm=0.0
            emsch=0.0
          end if
          dpm=pp*p1mins/(p1plus-pp)
          dpp=pm*p2plus/(p2mins-pm)
          em1nsq=max(cvalu0,p1plus-(pp+dpp))*(p1mins+dpm)
          em2nsq=(p2plus+dpp)*max(cvalu0,p2mins-(pm+dpm))
          if(emsch.gt.emsect.and.em1nsq.gt.epdmin**2
     a                       .and.em2nsq.gt.etdmin**2) then
            em1n=sqrt(em1nsq)
            em2n=sqrt(em2nsq)
            p1plus=p1plus-(pp+dpp)
            p1mins=p1mins+dpm
            p2mins=p2mins-(pm+dpm)
            p2plus=p2plus+dpp
            emsum=emsum+emsch
            nchain=nchain+1
            isea(nact)=1
            psea(0,nact)=pp
            psea(3,nact)=pm
          else
            if(ltry.lt.50) go to 141
            ispr=ispr+1
          end if
  16     continue
         if(ispr.eq.2) nno=nno+1
         nmax=n-nno
   14    continue
        emsum=emsum+em1n+em2n
        if(emsum.gt.srt) then
          write(lun8,*) em1n,em2n,emsum,srt
          call errex('emsum>srt in chains')
        end if
        em1red=sqrt(p1plus*p1mins)
        em2red=sqrt(p2plus*p2mins)
        do 19 n=2,nmax
         if(isea(n-1).ne.0) then
           p1mins=p1mins+psea(3,n-1)
           p1plus=p1plus+psea(0,n-1)
         end if
         if(isea(n+8).ne.0) then
           p2plus=p2plus+psea(3,n+8)
           p2mins=p2mins+psea(0,n+8)
         end if
   19   continue
        do 17 n=2,nmax
         if(isea(n-1).ne.0) then
          psea(0,n-1)=psea(0,n-1)/p1plus
          psea(3,n-1)=psea(3,n-1)/p1mins
         end if
         if(isea(n+8).ne.0) then
          psea(0,n+8)=psea(0,n+8)/p2mins
          psea(3,n+8)=psea(3,n+8)/p2plus
         end if
   17   continue
        em1n=sqrt(p1plus*p1mins)
        em2n=sqrt(p2plus*p2mins)
        if(em1n.le.epdmin.or.em2n.le.etdmin) then
          nchain=0
        else if(srt-(em1n+em2n).lt.ekinmi) then
          write(lun8,*) 'chains, no kin.energy',srt,nchain
          nchain=0
        else
          em1new=em1n
          em2new=em2n
        end if
        if(em1new+em2new.gt.srt) then
          write(lun8,*) em1new,em2new,srt
          call errex('em1new+em2new>srt in chains')
        end if
      return
      end
      function achain(k,srt)
       implicit real*8(a-h,o-z)
#include "amsrqmd.h"
       data  pi /3.141526/
       data vkapp,c1,c2, c3,c4 /
     a               0.5, 32.86,0.093,1.07,0.1 /
       if(k.lt.1) then
          write(lun8,*) 'k<1 not allowed in a(k)'
          call errex('wrong k in achain')
       end if
       fack=1.
       do 4 km=2,k
    4  fack=fack*km
       ak=c1*(srt*srt)**c2*
     a ((-(1.+vkapp)*c1*(srt*srt)**c2)/(4.*pi*(c3+c4*log(srt*srt))))
     b                                                       **(k-1)/
     c                                   k/fack
       achain=ak
      return
      end
      subroutine emexc(kf,em1,epdmin,epmin,em1min)
       include 'scatter7'
#include "amsrqmd.h"
       kfa=iabs(kf)
       if(kfa.eq.0.or.kfa.gt.70)  call errex('wrong kfa in emexc')
       em1min=getmas(0,kfa,1,-1.0)
       if(kfa.eq.17.or.kfa.eq.23.or.kfa.eq.24) then
         epdmin=emrhdc
         epmin=epdmin-dltmas
       else if(kfa.eq.18.or.kfa.eq.19.or.kfa.eq.25) then
         epdmin=emkdec
         epmin=epdmin-dltmas
       else
         if(em1min.gt.em1) em1min=em1
         epdmin=em1min+dltmas
         epmin=em1min
       end if
      return
      end
CPAT,MACHIN   .
      function ranf(ix)
      common /ranfbk/iy
c      ranf=ran0(iy)
        ranf=rndm(x)
      return
      end
      subroutine seed(iseed)
#include "amsrqmd.h"
      common /ranfbk/iy
      if(iseed.le.-99) then
         mst=mstime(dum)
c         iy=mst+int(1000.*secnds(0.))+345672197
         write(lun8,*)'seed changed into ',iy
      else
         iy=iseed
         write(lun8,*)'starting seed is',iy
      end if
      return
      end
      function ran0(idum)
      integer idum,ia,im,iq,ir
      real ran0, am
      parameter (ia=16807,im=2147483647,am=1./im,
     &    iq=127773,ir=2836)
      integer k
      k = idum / iq
      idum = ia * (idum - k * iq) - ir * k
      if (idum .lt. 0) idum = idum + im
      ran0 = am * idum
       
      return
      end
      function systim(start,dum)
      call timex(start)
      systim=0.0
      return
      end
      subroutine getinp
        include 'scatter7'
        include 'partblk7'
        integer init/0/
        integer file
        character *256 filename
#include "amsrqmd.h"
c      namelist/input/ header, n1,iz1,n2,iz2,ndt,nprint,nruns,ref,elgev,
c     a  inttyp,ieos,b,dt,sepfp,sepft,switch,cutfct,iseed,
c     b  idtcl
       if(init.ne.0)return
       init=1
            lun7=-7
            lun8=-8
            lun9=-9
            lun10=-10
            lun11=-11
            lun12=-12
            lun13=-13
            lun14=6
            lun15=-15
       if(file(lun7).gt.0)then
         filename='file7'
       else
         filename='/dev/null/file7'
       endif
       if(file(lun7).ne.0)then
          open(unit=lun7,form='unformatted',file=filename,iostat=iostat)
c     +     status='SCRATCH')
       endif
 
       if(file(lun8).gt.0)then
         filename='file8'
       else
         filename='/dev/null/file8'
       endif
       if(file(lun8).ne.0)then
          open(unit=lun8,form='formatted',file=filename,
     a    status='unknown',iostat=iostat)
       endif
 
       if(file(lun9).gt.0)then
         filename='file9'
       else
         filename='/dev/null/file9'
       endif
       if(file(lun9).ne.0)then
          open(unit=lun9,form='formatted',file=filename,
     a    status='unknown',iostat=iostat)
       endif
 
       if(file(lun10).gt.0)then
         filename='file10'
       else
         filename='/dev/null/file10'
       endif
       if(file(lun10).ne.0)then
          open(unit=lun10,form='formatted',file=filename,
     a    status='unknown',iostat=iostat)
       endif
 
       if(file(lun11).gt.0)then
         filename='file11'
       else
         filename='/dev/null/file11'
       endif
       if(file(lun11).ne.0)then
          open(unit=lun11,form='unformatted',file=filename
     +     ,iostat=iostat)
c     a    status='SCRATCH')
C     a    status='unknown')
       endif
 
       if(file(lun12).gt.0)then
         filename='file12'
       else
         filename='/dev/null/file12'
       endif
       if(file(lun12).ne.0)then
          open(unit=lun12,form='unformatted',file=filename,
     +     iostat=iostat)
C     a    status='unknown')
       endif
 
       if(file(lun13).gt.0)then
         filename='file13'
       else
         filename='/dev/null/file13'
       endif
       if(file(lun13).ne.0)then
          open(unit=lun13,form='formatted',file=filename,
     a    status='unknown',iostat=iostat)
       endif
 
       if(file(lun14).gt.0)then
         filename='file14'
       else
         filename='/dev/null/file14'
       endif
       if(file(lun14).ne.0)then
          open(unit=lun14,form='formatted',file=filename,
     a    status='unknown',iostat=iostat)
       endif
 
       if(file(lun15).gt.0)then
         filename='file15'
       else
         filename='/dev/null/file15'
       endif
       if(file(lun15).ne.0)then
          open(unit=lun15,form='formatted',file=filename,
     a    status='unknown',iostat=iostat)
       endif
 
      return
      end
      integer function file(lun)
       if(lun.eq.6)then
        file=0
       else if(lun.gt.0)then
        file=1
       else
        file=-1
        lun=-lun
       endif
      end
       function jrtime(idummy)
        jrtime=999999.
       return
       end
      function mstime(dummy)
      character*8 id,it
      character*1 itb(8)
      integer tb(8),th,tm,ts
      equivalence (it,itb(1))
      call datimh(id,it)
      do 100 i=1,8
      tb(i)=ichar(itb(i))-48
 100  continue
      th=tb(1)*36000+tb(2)*3600
      tm=tb(4)*600+tb(5)*60
      ts=tb(7)*10+tb(8)
      mstime=th+tm+ts
      return
      end
cCPAT,MAINA    .
c        program rqmd
cc program: relativistic quantum molecular dynamics
cc
cc
cc author:  Heinz Sorge
cc          Nuclear Theory Group
cc          S.U.N.Y.
cc          Stony Brook, NY 11794-3800
cc          e-mail:sorge@nuclear.physics.sunysb.edu
cc
c        include 'scatter7'
c        include 'partblk7'
c        ibas=0
c        ievco=0
c        call start
c        idifr=0
c        if(iz1.le.-5) then
c           inondf=0
c        end if
c    1   continue
c        do 10 irun=ibas*nruns+1,(ibas+1)*nruns
c        if(ievco.ge.nruns) then
c            call final
c            stop
c        end if
c        call event
c        if(nruns.gt.1) rewind 8
c        idifr=idifr+1
c        if(iz1.le.-5) then
c            if(idcdif.eq.1) inondf=inondf+1
c        end if
c        if(ierror.eq.0) then
c            ievco=ievco+1
c            call endev
c            if(ierror.eq.1) ievco=ievco-1
c        end if
c        ierror=0
c   10   continue
c        if(ievco.lt.nruns) then
c            ibas=ibas+1
c            go to 1
c16
c        end if
c        call final
c        stop
c        end
        subroutine rqmd_start
c       using the code you can set switches in your input data
c       meaning of switch(i):
c       i=1  on
c       i=2  off
c       i=3  on   fix the random number initialization via iy
c       i=4  off  pauli-blocking of collisions possible
c       i=5  off
c       i=6  off  potential included (on=cascade)
c       i=7  on   emulsion target (specified in emuls)
c       i=8  on   1.collision only between proj. and targ. particle
c       i=9  on    delta's,rho's,eta's
c                   and strange hadrons are kept stable.
c       i=10 on   pauli-blocking after resonance decay possible
c       i=11 on  initialization includes possible pauli blocking
c       i=12 on  potential only, no collisions
c       i=13 on  string fusion to ropes
c       i=14 on  print phase space info on unit 7
c       i=16 off  all instable particles are forced to
c                 decay at the end of the event (see fndnxt)
c 
c       i=17 off  participant/spectator approximation: the system is
c                 clustered from the beginning into fireball and
c                 projectile/target spectators. the spectator
c                 parts are heated up by impinging hadrons.
c       i=18 on   no particle/jet system decay
c                 (see fndnxt)
c       i=19 on   no transverse motion
c       i=20 on   print only inelastic events on unit 9
c       i=21 on   only the fireball dynamics is computed, not the
c                 spectator part.
c       i=22 on   restart option. the content of the common-block
c                 partblk7 is read in from unit 11.
c                 (if cpu time is not enough phase space info is
c                  written on unit 12.)
c       i=23 on   fast cascade
c       i=24 on   one projectile in nucleus with potential
      include 'scatter7'
#include "amsrqmd.h"
      external rqmdat
c      namelist/input/ header, n1,iz1,n2,iz2,ndt,nprint,nruns,ref,elgev,
c     a  inttyp,ieos,b,dt,sepfp,sepft,switch,cutfct,iseed,
c     b  idtcl
c      namelist/output/  n1,iz1,n2,iz2,ref,elgev,
c     a                   b,iyy
        common /prinbk/ iprin
        character*2 elem
        dimension elem(108)
        real*8 s2,avirt,pproj
        real*4 pmas,pwid,cfr,dpar,cbr,x0l,x3l
        common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
        common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
        common /ranfbk/iy
        common /ierdum/ierr
        common/dnsblk/jokall,timpri,bdens,hdens,edens,t11,t22,t33
     a                   ,tb11,tb22,tb33
     b                   ,tp11,tp22,tp33,hdcent
     c                   ,rtsq(2,-5:5),drzsq(2,-5:5)
     d                   ,rvel(2,-5:5),yldet(2,-5:5)
        data  iruact,itprn,dtprn /0,1,1.0/
        logical hit
        include 'partblk7'
        include 'sigmasx'
        include 'storbig'
        logical issers
        save  dtold,pproj,xcoll, itimdt,icld,itimx,iflpr,ikdtsw,iswi17
     a        ,bmax17
        data  iclrst,irest/0,0/
        save gam1,gam2,beta1,beta2
        data elem/' p','he','li','be',' b',' c',' n',' o',
     *          ' f','ne','na','mg','al','si',' p',' s',
     *          'cl','ar',' k','ca','sc','ti',' v','cr',
     *          'mn','fe','co','ni','cu','zn','ga','ge',
     *          'as','se','br','kr','rb','sr',' y','zr',
     *          'nb','mo','te','ru','rh','pd','ag','cd',
     *          'in','sn','sb','te',' j','xe','cs','ba',
     *          'la','ce','pr','nd','pm','sm','eu','gd',
     *          'tb','dy','ho','er','tm','yb','lu','hf',
     *          'ta',' w','re','os','ir','pt','au','hg',
     *          'tl','pb','bi','po','at','rn','fr','ra',
     *          'ac','th','pa',' u','np','pu','am','cm',
     *          'bk','cf','es','fm','md','no','lw','ku',
     *          '  ','  ','  ','  '
     *         /
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 2.4  -- 30-jan-98'/
      data pronam /'relativistic quantum molecular dynamics'/
      data ttvers/.true./
      data initsuper/0/
      b=-100.
      if(initsuper.eq.0)then
        initsuper=1
        irun=1
      iprin=0
      xcnt(1)=0.
      xcnt(2)=0.
      xcnt(3)=0.
      const=2.*(emnuc+empion-emdelt)/ widdlt
      const1=atan(const)
      const2=pi/2.-const1
      dcanon=sqrt(4.2/pi)
        seacut(1)=dcanon*1.2
        seacut(2)=dcanon*1.2
        seacut(3)=dcanon*1.2
      do 102 i=4,66
        seacut(i)=sqrt(25./pi)
102   continue
      do 103 l=3,6
        iclt=l*(l-1)/2+1
        seacut(iclt)=sqrt(40./pi)
        seacut(iclt+1)=sqrt(40./pi)
103   continue
      if(ida(4).gt.0) then
         fmltp=2.0
      else
         fmltp=1.
      end if
      seacut(22)=fmltp*sqrt(21./pi)
      seacut(23)=fmltp*sqrt(7./pi)
      seacut(29)=fmltp*sqrt(16.3333/pi)
      seacut(30)=fmltp*sqrt(16.3333/pi)
      seacut(37)=fmltp*sqrt(7./pi)
      seacut(38)=fmltp*sqrt(21./pi)
      seacut(24)=sqrt(21./pi)
      seacut(25)=sqrt(21./pi)
      seacut(26)=sqrt(21./pi)
      seacut(27)=sqrt(21./pi)
      seacut(31)=sqrt(21./pi)
      seacut(32)=sqrt(21./pi)
      seacut(33)=sqrt(21./pi)
      seacut(34)=sqrt(21./pi)
      seacut(39)=sqrt(21./pi)
      seacut(40)=sqrt(21./pi)
      seacut(41)=sqrt(21./pi)
      seacut(42)=sqrt(21./pi)
      seacut(52)=sqrt(21./pi)
      seacut(53)=sqrt(21./pi)
      seacut(54)=sqrt(21./pi)
      seacut(62)=sqrt(21./pi)
      seacut(63)=sqrt(21./pi)
      seacut(64)=sqrt(21./pi)
      seacut(28)=sqrt(2.5/pi)
      seacut(35)=sqrt(12./pi)
      seacut(36)=sqrt(3.6/pi)
      seacut(43)=sqrt(15./pi)
      seacut(44)=sqrt(12./pi)
      seacut(45)=sqrt(2.5/pi)
      do 10 i=67,maxtyp +1
        seacut(i)=dcanon
 10   continue
      seacut(67)=sqrt(41./pi)
      seacut(68)=sqrt(41./pi)
      seacut(69)=sqrt(41./pi)
      seacut(70)=sqrt(41./pi)
      seacut(71)=sqrt(41./pi)
      seacut(72)=sqrt(41./pi)
      seacut(76)=sqrt(41./pi)
      seacut(77)=sqrt(41./pi)
      seacut(90)=sqrt(10./pi)
      seacut(117)=sqrt(10./pi)
      seacut(79)=sqrt(5.0/pi)
      seacut(80)=sqrt(5.0/pi)
      seacut(106)=sqrt(5.0/pi)
      seacut(107)=sqrt(5.0/pi)
      seacut(92)=sqrt(41./pi)
      seacut(93)=sqrt(41./pi)
      seacut(85)=sqrt(41./pi)
      seacut(86)=sqrt(41./pi)
      seacut(87)=sqrt(41./pi)
      seacut(112)=sqrt(41./pi)
      seacut(113)=sqrt(41./pi)
      seacut(114)=sqrt(41./pi)
      seacut(94)=sqrt(41./pi)
      seacut(95)=sqrt(41./pi)
      seacut(96)=sqrt(41./pi)
      seacut(97)=sqrt(41./pi)
      seacut(98)=sqrt(13./pi)
      seacut(99)=sqrt(13./pi)
      seacut(100)=sqrt(13./pi)
      seacut(101)=sqrt(41./pi)
      seacut(102)=sqrt(41./pi)
      seacut(104)=sqrt(10./pi)
      seacut(119)=sqrt(10./pi)
      seacut(105)=sqrt(41./pi)
      seacut(maxtyp+1)=sqrt(41./pi)
      do 30 index=1,itblsz
        snntot(index)=spptot(index)
        snnel(index)=sppel(index)
 30   continue
      ierror=0
      dt=0.2
      ref=' nn'
      sepfp=1.
      sepft=1.
      cutfct=1.0
      ieos=2
      ndt=500
      idtcl=250
      nprint=0
      header='rqmd'
      iseed=-100
c      n1=1
c      iz1=1
c      n2=1
c      iz2=1
c      elgev=1.
      nruns=2000000000
      irun=0
      do 1027 i=1,numswi
        switch(i)=.false.
 1027 continue
      ida(1)=0
      ida(2)=0
      ida(5)=0
      ida(11)=0
      ida(13)=3
      ida(27)=1
      ida(37)=0
      ida(38)=0
      ida(41)=1
      ida(42)=0
      ida(43)=0
 
      switch(8)=.true.
c      switch(9)=.true.
      switch(13)=.true.
      switch(16)=.false.
      switch(17)=.true.
      switch(23)=.true.
      endif
      irun=irun+1
      if(irun.ge.nruns)then
       write(*,*)'rqmd-E-toomanyevents,resetting'
       irun=1
      endif
      call getinp
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      if(switch(7)) then
        switch(17)=.true.
        switch(21)=.false.
        b=-100.0
        n2=300
        iz2=300
      end if
      if(iz1.ge.0) then
        if(n1.le.0 .or. n2.lt. 0 ) then
         write(lun14,*) 'wrong mass numbers',n1,n2
         ierror=1
          return
        end if
        if(n1.lt.iz1.or. n2.lt.iz2) then
         write(lun14,*) 'wrong charge numbers',iz1,iz2
         ierror=1
         return
        end if
        emproj=emnuc
      else
        ityppr=n1
        if(iabs(ityppr).lt.70.and.iabs(ityppr).gt.0) then
           emproj=pmas(iabs(ityppr))
        else
            write(lun14,*) 'iz1<0  wrong n1 n1=',n1
         ierror=1
          return
        end if
        n1=1
        call luiflv(ityppr,ifla,iflb,iflpr,ksp)
      end if
      if(n1.ge.n2+20.and.n2.ne.0) then
        write(lun14,*)
     a        'n1,n2=',n1,n2
        write(lun14,*)
     a        'rqmd abort: choose larger particle number as target'
         ierror=1
          return
      end if
      if(switch(24)) then
        if(n1.ne.1) then
          write(lun14,*)
     +    'switch(24)=t only for single projectile allowed'
         ierror=1
          return
        end if
        switch(6)=.false.
        switch(8)=.true.
        switch(17)=.true.
        switch(19)=.false.
        switch(21)=.false.
        switch(23)=.false.
        idtcl=ndt+10
        ida(23)=1
        ida(27)=1
        ida(28)=0
        ida(33)=1
        ida(34)=2
      end if
      if(n1.eq.1.and.n2.eq.1) then
        ida(4)=0
        ida(7)=0
        switch(23)=.true.
      end if
      if(elgev. lt.0.1) then
         write(lun14,*)
     + 'rqmd should not be used for such a kinetic energy'
         ierror=1
          return
 
      end if
      if(ref.eq.'cld') then
        ref=' nn'
        elab=2.*(elgev*elgev-emnuc**2)/emnuc
        icld=1
        if(n1.eq.1.and.n2.eq.1) then
          write(lun8,*) 'attention: only non single diffractive events'
          ida(46)=1
        end if
      else
        elab=elgev
        icld=0
      end if
        pproj=sqrt(elab*(2.*emproj+elab))
        s2=(elab+emnuc+emproj)**2-pproj**2
        avirt=0.5*(s2-emnuc*emnuc-emproj*emproj)/emnuc/emproj
        if(avirt.lt.1.) then
          write(lun14,*) 'numerical error avirt.lt.1.   avirt=',avirt
         ierror=1
          return
        end if
        betann=sqrt((avirt-1.)/(avirt+1.))
      gamnn=1./sqrt(1.-betann*betann)
      if(ref.eq.'lab') then
        beta1=-pproj/sqrt(emproj**2+pproj**2)
        beta2=0.
      else if((ref.eq.'nn').or.(ref.eq.' nn')) then
        beta1=-betann
        beta2=betann
      else
        write(lun14,*)' frame not implemented'
c        call errex('run aborted')
         ierror=1
          return
      end if
      if(sepfp.ne.1.) then
          da(4)=sepfp
      end if
      if(sepft.ne.1.) then
          da(9)=sepft
      end if
      da(11)=b
      if(idtcl.lt.0) then
         idtcl=ndt+10
      else
         idtcl=idtcl-mod(idtcl,5)+1
         if(ida(8).le.2) then
           write(lun14,*) 'conflicting idtcl and ida(8) specification'
c           call errex('change input data')
         ierror=1
          return
         end if
      end if
      write(lun8,8101)
 8101 format(1x,72('-'))
      nt=n1+n2
      if(nt.gt.nbarym) then
        call errex('particle number too large:nt.gt.nbarym')
         ierror=1
          return
      end if
      if(iz1.ge.0) then
         write(lun8,8100) n1,iz1,n2,iz2,nt
      else
         write(lun8,8102 )ityppr,n2,iz2,nt
      end if
 8102 format(/,' collision of hadron (type',i4,') on a,z=(',2i4,
     *       ');total=', i4)
 8100 format(/,' collision of a,z=(',2i4,') on a,z=(',2i4,');total=',
     *       i4)
      if(nruns.lt.0) then
         write(lun8,*) 'event no. should be positive. ????? nruns=',nrun
      else
         write(lun8,*) 'event no.:',nruns
      end if
      gam1=1./sqrt(1.-beta1*beta1)
      p01=emproj*gam1*beta1
      gam2=1./sqrt(1.-beta2*beta2)
      p02=emnuc*gam2*beta2
      write(lun8,8110)p01,gam1,p02,gam2
 8110 format(' proj. p,gamma: ',2f11.4,'; targ. p,gamma: ',2f11.4)
      if(nprint.eq.0) nprint=ndt+1
      if(ida(17).eq.0) then
         rr1=da(3)*n1**0.333333333
         rr2=da(3)*n2**0.333333333
      else
         rr1=1.19* n1**0.3333-1.61* n1**(-0.3333)
         rr2=1.19* n2**0.3333-1.61* n2**(-0.3333)
      end if
      if(n1.eq.1) rr1=0.
      if(n2.eq.1) rr2=0.
      write(lun8,9902)  rr1,rr2
 9902 format('radius proj, targ:',2f8.4)
      if(nt.ne.2.and.ida(46).eq.1) ida(46)=0
      if(.not.switch(23).or.dt.ne.0.2) write(lun8,9901)dt
     a 
 9901 format('timestep ',1f8.4)
      if(idtcl.le.ndt)then
        if(idtcl.lt.5) then
            write(lun8,*) 'idtcl<5 does not seem to be appropriate'
            idtcl=ndt+1
        end if
        if(.not.switch(23)) then
           write(lun8,*)
     a      'after ',idtcl,'timesteps separate evolution of clusters'
        end if
      else
         write(lun8,*) 'no separate evolution of clusters'
      end if
      inocol=0
      if(switch(7)) then
        write(lun8,*) 'emulsion target chosen:'
        write(lun8,*)'  events are  generated with targets randomly'
        write(lun8,*)'selected according probabilities in subr. emuls'
        write(lun8,*) '   impact parameter stochastically chosen,'
        write(lun8,*) '   events without collisions are discarded.'
      else if(b.ge.0.) then
         write(lun8,9911) b
 9911    format('fixed impact parameter=',1f8.4)
      else
         write(lun8,*)
     +     'impact parameter stochastically chosen between 0.',
     a             ' and ',min(-b,rr1+rr2+3.) ,' fm '
         if(b.lt.-99.) then
                write(lun8,*) 'events without collisions not  recorded'
         end if
      end if
      do 101 i=1,maxtyp+1
        seacut(i)=seacut(i)*cutfct
 101  continue
      if(cutfct.ne.1.0) then
      write(lun8,8120)(seacut(i),i=1,maxtyp+1)
 8120 format(' collision search cutoffs',
     * /,(5(1x,f7.1)))
      end if
      if(switch(3)) then
        iy=iseed
      else
        call seed(iseed)
      end if
      if(ida(15).ne.0.or.sepfp.gt.999.) then
        write(lun8,*) 'option: suppression of secondary rescattering'
        write(lun8,*) '      no collisions with hadrons from resonance'
        write(lun8,*) '      decay and string sea'
        if(ida(15).eq.0) ida(15)=1
        if(sepfp.gt.999.) da(4)=1.
      end if
      if(switch(9))then
        write(lun8,*)
     a       'delta,rho,omega and strange hadrons are kept stable.'
        ida(1)=1
        ida(41)=1
        ida(52)=0
        switch(16)=.true.
      end if
      if(switch(13)) then
        write(lun8,*) 'option: string fusion to ropes'
        ida(47)=1
      else
        ida(47)=0
      end if
      if (switch(6).or.switch(23).or.switch(19)) then
       write(lun8,*) 'cascade mode'
       ida(28)=1
      end if
      if(switch(8))then
        write(lun8,*)
     + 'first n collision with nucleon from other nucleus or'
        write(lun8,*)
     + 'a secondary, resp. a n which had a collision before.'
      end if
      if(switch(10))then
        if(switch(4))then
          write(lun14,*) 'switches 4 and 10 conflict'
         ierror=1
          return
        else
          write(lun8,*) 'pauli blocking for delta decay'
        end if
      end if
      if(switch(11))then
        if(switch(4))then
          write(lun14,*) 'switches 4 and 11 conflict'
         ierror=1
          return
        else
          write(lun8,*) 'pauli blocking for initialisation'
        end if
      end if
      if(switch(12))then
        write(lun8,*) 'no collisions'
      end if
      if(switch(14))then
         ida(42)=1
      end if
      call ldinit
      if(.not.switch(16))then
          write(lun8,*)
     a       'unstable particles are forced to decay at the end'
      end if
      if(.not.switch(17))then
        iswi17=0
        if(elab.lt. 10.)then
          write(lun8,*)'switch(17)=f does not seem to be appropriate'
          write(lun8,*) 'elab=',elab
          write(lun8,*)'switch(17) is set to true'
          switch(17)=.true.
          if(elab.lt.1.9) then
             ida(23)=1
             write(lun8,*) 'non-relativistic propagation chosen'
          end if
          iswi17=1
        end if
        if(iswi17.eq.0)then
          bmax17=0.5*(rr1+rr2)
          if((n2.lt.n1+20.and.(n2.eq.0.or.abs(b).lt.bmax17))
     a                                            .or.nt.le.20) then
            write(lun8,*)'switch(17)=f does not seem to be appropriate'
            write(lun8,*) 'n2,n1=',n2,n1,'b=',b,
     a                    '0.5*(rr1+rr2)=',bmax17
            write(lun8,*)'switch(17) is set to true'
            switch(17)=.true.
            iswi17=1
          else if(.not.switch(21).and.b.lt.0.0) then
            iswi17=2
          end if
        end if
      else
        iswi17=1
      end if
      if(iswi17.ne.1) write(lun8,*)
     a       'separated evolution of the participants and spectators'
      if(switch(18))then
          write(lun8,*)
     a       'no particle/jet sytem decay during dynamical evolution'
      end if
      if(switch(19))then
        switch(6)=.true.
        if(ida(34).eq.0)  switch(23)=.true.
          write(lun8,*)
     a       '1+1-dimensional motion in events'
          ida(23)=1
          ida(7)=0
      end if
      if(switch(20))then
          write(lun8,*)
     a       'no elastic events are written on unit 9'
      end if
      if(switch(21))then
          write(lun8,*)
     a       'only the fireball dynamics is calculated. spectators ',
     b       'are left out.'
          if(switch(17)) then
             call errex('switch(17),switch(21) conflict')
         ierror=1
          return
          end if
        switch(11)=.false.
        if(iz1.ge.0) then
           iarg=min(iz1,108)
           header(1:2)=elem(iarg)
        else
          if(ityppr.eq.41) then
           header(1:2)='p+'
          else if(ityppr.eq.42) then
           header(1:2)='n '
          else if(ityppr.eq.-41) then
           header(1:2)='p-'
          else if(iabs(ityppr).eq.17.or.ityppr.eq.23) then
           header(1:2)='pi'
          else if(ityppr.eq.18) then
           header(1:2)='k+'
          else if(ityppr.eq.-18) then
           header(1:2)='k-'
          else
           header(1:2)='hd'
          end if
        end if
        iarg=min(iz2,108)
        header(3:4)=elem(iarg)
      end if
      if(switch(22))then
          write(lun8,*)
     a       'restart option is switched on '
      end if
      if(switch(23)) then
         switch(6)=.true.
         switch(8)=.true.
         if(ida(23).eq.0)  ida(23)=1
         ida(27)=1
         ndt=1
         if(dt.eq.0.2)  dt=max(da(5)*15.*(rr1+rr2),da(5)*100.0)
         write(lun8,*) 'modified (sw(23)=t)  dt=',dt
         if(nt.eq.2) switch(21)=.true.
      end if
      if(ida(23).eq.1) then
         ida(27)=1
      end if
      if(ida(36).gt.1) then
       if(ida(38).ne.3.and.ida(38).ne.4) ida(36)=0
      end if
      write(lun8,*)'input complete'
      write(lun8,*)'switches :',switch
      write(lun8,*)'+++++++++++++++++++++++++++++++++++++++++++++++++'
      if (nt .le. 0) then
        call errex('no particles')
         ierror=1
          return
      end if
      call seteos
      xblock=0.
      xbldel=0.
      xcoll=0.
      tmcoll=0.
      tmsctr=0.
      tmpali=0.
      tmprop=0.
      tmabsr=0.
      xfirst=0.0
      xininw=0.0
      if(switch(21).or.switch(23)) then
         da(22)=2.
         if(n1.eq.1.and.elab.lt.2.) then
           da(22)=3.
         end if
      end if
      rprsq=(rr1+1.5*da(22))**2
      betapr=beta1
      rtasq=(rr2+1.5*da(22))**2
      betata=beta2
      if(n2.eq.0) rtasq=0.
      write(lun8,*)'reaction variables'
      write(lun8,*)'rprsq,rtasq,betapr,betata'
      write(lun8,*) rprsq,rtasq,betapr,betata
      yproj=0.5* log((1.+betapr)/(1.-betapr) )
      ytarg=0.5* log((1.+betata)/(1.-betata) )
      betapl=-0.9* betann
      betatl=0.9* betann
      if(ref.eq.'lab') then
         betaol=betapl
         betapl=(-betann+betapl)
         betatl=(-betann+betatl)
         gammal=(1.-betann*betaol)
         betapl=betapl/gammal
         gammal=(1.+betann*betaol)
         betatl=betatl/gammal
         if(abs(betapl).gt.1. .or. abs(betatl).gt.1.) then
            write(lun14,*)' wrong betapl, betatl=',betapl,betatl
         ierror=1
          return
         end if
      endif
      n1old=n1
      iz1old=iz1
      n2old=n2
      iz2old=iz2
      dtold=dt
      ikdtsw=0
      if(gamnn.gt.4..and.ida(30).eq.1.and.ida(23).eq.0) then
          if(ida(27).ne.1) then
              write(lun8,*) 'warning:ida(27)=0,ida(30)=1 do not fit'
          end if
          ikdtsw=int(24.*(rr1+rr2)/(dt*gamnn))+1
          write(lun8,*) 'ikdtsw=',ikdtsw
      end if
      return
      entry rqmd_event
      call rstall
      iyy=iy
      write(lun8,*) iy,'value of iy=input integer random number:',
     a               ' irun=',irun
      if(switch(7)) then
        if(irun.eq.1.or.ncollt-npaubl.gt.0) then
          call emuls(iz2old,n2old)
        else
          nruns=nruns+1
        end if
      end if
      idcntd=0
      idcntn=0
      idcntr=0
      iabspi=0
      ncollt=0
      npaubl=0
      npion=0
      ievntn=0
      ibrhig=0
      if(iz1.le.-5)  then
         idcdif=0
         inn2df=0
         ibrhig=1
      end if
        nrclst=1
        kclst=1
        iofset=0
        dtprop=0.0
         if(irun.gt.iruact) itprn=1
         if(itprn.eq.1) then
            iruact=irun
            timpri=dtprn
            jokall=0
            hdcent=0.0
            tp11=0.0
            tp22=0.0
            tp33=0.0
         end if
      if(.not.switch(22)) then
        write(lun8,*) 'irun=',irun
        call initev
        if(iswi17.eq.2) then
          if(b.gt.bmax17) then
            switch(17)=.false.
          else
            switch(17)=.true.
          end if
        end if
        if(irun.eq.1.and.ref.ne.'lab'.and.icld.eq.0) then
           betprl=pproj/sqrt(emproj**2+pproj**2)
           gampl=1./sqrt(1.- betprl*betprl)
           zmnp=zmnpr*gamnn/gampl
           zmxp=zmxpr*gamnn/gampl
           zmnt=zmnta*gamnn
           zmxt=zmxta*gamnn
           write(lun8,*) 'zmxpr,zmnpr,zmxta,zmnta in the ref.system'
           write(lun8,*)  zmxpr,zmnpr,zmxta,zmnta
           write(lun8,*)'betapl=',betapl,'betatl=',betatl
           write(lun8,*) 'first event in the lab.system: '
           write(lun8,*) 'proj/target has z coordinates',
     b               ' between  zmxp>pr.n.>zmnp,zmxt>t.n.>zmnt'
           write(lun8,*) 'zmxp,zmnp,zmxt,zmnt'
           write(lun8,*)  zmxp,zmnp,zmxt,zmnt
        end if
        if(ierror.eq.1) return
        if(iz1.ge.0) then
            iqtot=iz1+iz2
        else
            iqtot=luchge(ityppr)/3+iz2
        end if
        if(iz1.ge.0.or.iflpr.gt.0) then
           nrmes(1)=0
           nrbar(1)=nt
           ntbar=nt
        else
           nrmes(1)=1
           if(iflpr.eq.0) then
               ntbar=nt-1
           else
               ntbar=nt-2
           end if
           nrbar(1)=nt-1
        end if
        nspect=0
        nsppr=0
        nspta=0
        if(.not.switch(17)) then
          call spctat(0,1,0)
          betdif=betapr- betata
          do 411 l=ntotma+1-nspect,ntotma
              if(lastcl(l)/100000.eq.-1) then
                 tnew=-(x(3,l)- betapr*x(0,l)- zmxta)/betdif
                 if(tnew.lt. x(0,l))then
                    write(lun8,*) issn(l),l,tnew,(x(i,l),i=0,3)
                    call errex('1 wrong tnew in event??????? ')
                 else
                    x0old=x(0,l)
                    x(0,l)=tnew
                    x(3,l)=x(3,l)+betapr* (tnew-x0old)
                 end if
              else if(lastcl(l)/100000.eq.-2) then
                 tnew=(x(3,l)- betata*x(0,l)- zmnpr)/betdif
                 if(tnew.lt. x(0,l))then
                    write(lun8,*) tnew,(x(i,l),i=0,3)
                    call errex('2 wrong tnew in event??????? ')
                 else
                    x0old=x(0,l)
                    x(0,l)=tnew
                    x(3,l)=x(3,l)+betata* (tnew-x0old)
                 end if
              else
                write(lun8,*)l,'lastcl=',lastcl(l)
                call errex('lastcl not correct for spectator in event')
              endif
              tlast(l)=x(0,l)
              do 410 i=0,3
  410         qdot(i,l)=0.0
  411     continue
            itrmx=3
        else
            itrmx=1
        endif
        nspnuc=nspect
         itrmxr=0
         kdtr=0
      else
         if(.not.switch(17)) then
             itrmx=3
         else
             itrmx=1
         endif
         read(lun11) itrmxr,kdtr
      end if
      if(nt.lt.30) then
          irestl=2
      else if(nt.gt.300) then
          irestl=12
      else
          irestl=5
      end if
      do 1005 itripl=1,itrmx
      if(itripl.lt.itrmxr) then
          go to 1005
      else if(itripl.eq.itrmxr) then
          go to 126
      end if
      time=0.
      tlstev=0.
      if(itripl.eq.1) then
         iaddit=
     a    max(int(4.*(max(n1,25)*max(n2,25))**0.6666
     b                                      *0.95* log(elab +9.0)),90)
     c                                       *(1.0+0.3*log(elab+1.0))
 
         if(nrbar(1)+nrmes(1)+iaddit.ge.ntotma-nspect) then
             iadpho=max(10,nint(float(iaddit)/10.))
             iaddit=max(0,ntotma-nspect-nrbar(1)-nrmes(1)-iadpho)
         end if
      else
         iaddit=max(int(3.2*nrbar(itripl)*log(elab)),90)
      end if
      iclusz(itripl)=nrbar(itripl)+nrmes(itripl)+iaddit
      if(itripl.gt.1) then
  401    continue
        igo=0
        if(iclusz(1)+iclusz(itripl).ge.ntotma+1-nspect) then
            iclz=nrbar(itripl)+nrmes(itripl)
            idif=max(0,nint(0.4* float(ntotma-nspect-iclusz(1)-iclz)))
            iclusz(itripl)=iclz+idif
            igo=igo+1
            if(igo.eq.1) then
               go to 401
            else
               call errex(
     a                'storage garbage with nrbar,nrmes(itripl)')
            end if
        end if
      end if
      lmax=0
      do 45 lm=1,itripl
   45 lmax=lmax+iclusz(lm)
      nonrel(itripl)=.false.
      kclst=itripl
      if(ida(23).ne.0) then
         tobs=1.e+30
         tmxobs=-1.e+30
         iofset=0
         do 203 icl=1,itripl-1
 203     iofset=iofset+iclusz(icl)
         do 133 il=iofset+1,iofset+nrbar(itripl)+nrmes(itripl)
             if(qdot(0,il).eq.0.0.or.itripl.eq.1
     a                                .or..not.switch(23)) then
               tl=x(0,il)
               zl=x(3,il)
             else
               tl=tlast(il)
               dtl=tl-x(0,il)
               zl=x(3,il)+qdot(3,il)/qdot(0,il)*dtl
             end if
             tilobs=tl*pnorm(0)-zl*pnorm(3)
             tobs=min(tobs,tilobs)
             tmxobs=max(tmxobs,tilobs)
  133    continue
         tbegin=tobs
         tmxobs=max(max(tmxobs,8.*rr1),8.*rr2)
         if(switch(23).and.
     a                  itripl.gt.1) then
           do 134 il=iofset+1,iofset+nrbar(itripl)+nrmes(itripl)
            if(qdot(0,il).gt.0.0) then
              dtl=(tlast(il)-x(0,il))/qdot(0,il)
              do 136 i=0,3
  136         x(i,il)=x(i,il)+qdot(i,il)*dtl
            end if
            tilobs=x(0,il)*pnorm(0)-
     a                            x(3,il)*pnorm(3)
            dtl=(tbegin-tilobs)
            identl=issn(il)
            ncolil=nclcnt(identl)
            if(ncolil.eq.0.and.identl.le.nt) then
              if(identl.le.n1) then
                pilobs=p(0,il)*pnorm(0)-p(0,il)*betapr*pnorm(3)
              else
                pilobs=p(0,il)*pnorm(0)-p(0,il)*betata*pnorm(3)
              end if
              if(identl.le.n1) then
                x(3,il)=x(3,il)+betapr*p(0,il)/pilobs*dtl
              else
                x(3,il)=x(3,il)+betata*p(0,il)/pilobs*dtl
              end if
              x(0,il)=x(0,il)+p(0,il)/pilobs*dtl
            else
              pilobs=p(0,il)*pnorm(0)-
     a                            p(3,il)*pnorm(3)
              do 135 i=0,3
  135         x(i,il)=x(i,il)+p(i,il)/pilobs*dtl
            end if
  134      continue
         end if
         if(switch(23).and.(tbegin+ndt*dtold).lt.tmxobs)then
             dt=tmxobs+10.-tbegin
             write(lun8,*)'dt has been modified dt,tmxobs,tbegin'
             write(lun8,*)  dt,tmxobs,tbegin,'irun,itripl=',irun,itripl
         else
             dt=dtold
         end if
         nonrel(itripl)=.true.
      end if
      if(nprint.le.ndt.or.ida(42).eq.1) then
         iofs=0
         do 201 icl=1,itripl-1
 201     iofs=iofs+iclusz(icl)
            do 3058 l=iofs+1,iofs+nrbar(itripl)
             identl=issn(l)
             write(lun7)
     &           ityp(l),issn(l),npidec(l),
     &           x(0,l),x(1,l),x(2,l),x(3,l),
     &           p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &         tdtg(identl),itdth(2,identl),itdth(3,identl)
 3058       continue
      end if
      ierr=systim(timdt,dummy)
  126 do 26 kdt=1,ndt
        if(switch(22)) then
           if(kdt.lt.kdtr) go to 26
           if(iclrst.eq.0) then
              iclrst=1
              ndtold=ndt
              call rstart
              ndt=ndtold
           end if
        end if
        istop=0
        if(ida(24).eq.1) then
            iresto=irest
            irest=jrtime(idummy)
            if(.not.switch(23).or.itripl.eq.1) itimdt=iresto-irest
            if(irun.eq.0) itimx=0
            itimx=max(itimx,itimdt)
            if(irest.lt.2*itimdt.or.irest.le.irestl) istop=1
            if(switch(23).and.irest.lt.2*itimx) istop=1
        else if(ida(24).eq.2) then
            if(.not.switch(23).and.ndt.lt.500.and.kdt.eq.ndt
     a            .and.itripl.eq.1
     a                                           ) istop=2
        end if
        if(istop.ne.0) call rend(istop)
        if(kdt.le.ikdtsw.and.itripl.eq.1) then
           dt=0.5*dtold
        else
           dt=dtold
        end if
       if(itripl.gt.1 .and.switch(21))goto 259
      if(itripl.gt.1 .and. .not.switch(17).and.ncollt.eq.0)goto 259
      if(kdt.eq.idtcl) call clustr
      if(ierror.eq.1) return
      timmax=time+dt
      if(mod(kdt-1,5).eq.0) then
         itrig=0
      else
         itrig=1
      end if
      ncoll=0
      iofset=0
      do 202 icl=1,itripl-1
 202  iofset=iofset+iclusz(icl)
      do 108 kclst=itripl,nrclst
       if(iofset+iclusz(kclst).ge.ntotma+1-nspect) then
          write(lun8,*) iofset,iclusz(kclst),ntotma,nspect
          call errex('ntotma is too low, error in event')
          if(ierror.eq.1) return
       end if
       ierr=systim(strt,dummy)
       nrpion=nrmes(kclst)
       ntt=nrbar(kclst)
       ntclst=ntt+nrpion
       if(ida(11).eq.1) ntclst=ntt
       if(ntclst.eq.1) then
       else if(ntclst.eq.0) then
           go to 107
       else if((mod(kdt,10).ne.0).and.(nonrel(kclst))) then
          itrigg=-1
          call relham(itrigg,ntt,nrpion)
       else if(ntclst.gt.1) then
          call relham(itrig,ntt,nrpion)
       end if
       ierr=systim(tend,dummy)
       tmprop=tmprop+tend-strt
       if(ierror.eq.1) return
       if(kdt.eq.idtcl-1) go to 107
         if(switch(12))goto 1999
         tlstev=time
         ierr=systim(strt,dummy)
          nttot=nrbar(kclst)+nrmes(kclst)
          if(nttot.gt.1) then
            call coload
            if(ierror.eq.1) return
          else
            nument=0
          end if
          ierr=systim(tend,dummy)
          tmcoll=tmcoll+tend-strt
 1000     continue
         if(ida(36).gt.1.and.kclst.eq.itripl) then
           if(switch(23)) then
             if(itprn.le.40.and.tlstev.ge.timpri) then
               jokall=1
             end if
           else
             if(itprn.gt.40) jokall=2
           end if
           if(jokall.eq.1) then
             dtpr=tlstev-(time+dt)
             call pribd(dtpr)
             itprn=itprn+1
             jokall=0
             timpri=itprn*dtprn
           end if
         end if
          call fndnxt(ind,iwhat)
          if(ida(24).eq.1) then
            istop=0
            irest=jrtime(idummy)
            if(irest.lt.2) call errex('no cpu time left')
          end if
          if(ierror.eq.1) return
          if (iwhat.eq.0) goto 1999
          if(iwhat.eq.1) then
             i1cind=i1c(ind)
             i2cind=i2c(ind)
             ident1=issn(i1cind)
             ident2=issn(i2cind)
            call coll(ind)
          else if(iwhat.eq.2) then
            call rqmdec(ind)
          end if
          if(ierror.eq.1) return
          ntclst=nrbar(kclst)+nrmes(kclst)
          if(ida(11).eq.1) ntclst=nrbar(kclst)
          goto 1000
 1999    continue
         call  comprs(0)
         if(ierror.eq.1) return
         if(.not.switch(21).and..not.switch(17)
     a                                       .and.itripl.eq.1) then
           ianf=iofset
           kclu=kclst
           if(switch(23)) then
             ispc=1
           else
             ispc=0
           end if
           call spctat(ianf,kclu,ispc)
        end if
 107  iofset=iofset+iclusz(kclst)
 108  continue
      ncollt=ncollt+ncoll
      xcoll=xcoll+ncoll
  259 continue
      nall=nspect
      do 5057 kcl=1,nrclst
         nall=nall+nrbar(kcl)+nrmes(kcl)
 5057 continue
      if(nall.ne. nt+npion) then
        call errex('event:wrong particle number in main')
        if(ierror.eq.1) return
      end if
      kp=nprint*(kdt/nprint)
      if(kdt.eq.kp) then
            if(itripl.eq.1) then
               iofset=0
            else
               iofset=iclusz(1)
            end if
            do 4057 kcl=itripl,nrclst
               if(nrbar(kcl)+nrmes(kcl).eq.1) then
                    if(ichbig(iofset+1).eq.5) go to 4056
                    ichbig(iofset+1)=5
               end if
            do 4058 l=iofset+1,iofset+nrbar(kcl)+nrmes(kcl)
             identl=issn(l)
             write(lun7)
     &         ityp(l),issn(l),npidec(l),
     &         x(0,l),x(1,l),x(2,l),x(3,l),
     &         p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &         tdtg(identl),itdth(2,identl),itdth(3,identl)
 4058       continue
 4056       iofset=iofset+iclusz(kcl)
 4057     continue
      end if
      time=time+dt
      ierr=systim(ttotal,dummy)
      timdt=ttotal
  26  continue
      iof=iclusz(1)
      nrold=nrbar(1)+nrmes(1)
      lloop=nrold
      do 1014 icl=2,nrclst
       do 1013 l=1,nrbar(icl)+nrmes(icl)
          il=iof+l
          lloop=lloop+1
          do 1012 i=0,3
             x(i,lloop)=x(i,il)
             p(i,lloop)=p(i,il)
 1012     continue
          em(lloop)=em(il)
          ityp(lloop)=ityp(il)
          decay(lloop)=decay(il)
          lastcl(lloop)=lastcl(il)
          issn(lloop)=issn(il)
          npidec(lloop)=npidec(il)
          tlast(lloop)=tlast(il)
 1013  continue
       nrbar(1)=nrbar(1)+nrbar(icl)
       nrmes(1)=nrmes(1)+nrmes(icl)
       iof=iof+iclusz(icl)
 1014 continue
      iclusz(1)=nrbar(1)+nrmes(1)
      nrclst=1+mod(itripl,itrmx)
      if(lloop.ne. iclusz(1)) call errex('wrong lloop in event')
      if(lloop +nspect.ne.nt+npion)
     a                call errex('wrong iclusz(1)+nspect in event')
      ntt=0
      nrpion=0
      idelte=0
      do 1015 il=ntotma,ntotma-nspect+1,-1
         ispmod=-lastcl(il)/100000
         if(ispmod.lt.0.or.ispmod.gt.2) then
             write(lun8,*) 'ispmod=',ispmod
             call errex('unclear situation for spectat lastcl in event')
         end if
         if(ispmod.ne.itripl) go to 1015
           if(ityp(il) .le.6 .or.
     a            (ityp(il) .ge.10 .and.
     b                  ityp(il) .le.11 )
     c            .or. ityp(il) .eq.13
     d            .or. ityp(il) .eq.15  )then
            lloop=lloop+1
            ntt=ntt+1
            do 1016 i=0,3
              x(i,lloop)=x(i,il)
              qdot(i,lloop)=qdot(i,il)
              p(i,lloop)=p(i,il)
 1016       continue
              em(lloop)=em(il)
              ityp(lloop)=ityp(il)
              decay(lloop)=decay(il)
              lastcl(lloop)=mod(-lastcl(il),100000)
              issn(lloop)=issn(il)
              npidec(lloop)=npidec(il)
              tlast(lloop)=tlast(il)
              if(ichbig(il).ne.3) then
                 ichbig(lloop)=0
              else
                 ichbig(lloop)=3
              end if
        end if
 1015 continue
      do 2015 il=ntotma,ntotma-nspect+1,-1
         if(-lastcl(il)/100000.ne.itripl) then
           ill=il+idelte
            do 2017 i=0,3
              x(i,ill)=x(i,il)
              p(i,ill)=p(i,il)
              qdot(i,ill)=qdot(i,il)
 2017       continue
              em(ill)=em(il)
              ityp(ill)=ityp(il)
              decay(ill)=decay(il)
              lastcl(ill)=lastcl(il)
              issn(ill)=issn(il)
              npidec(ill)=npidec(il)
              tlast(ill)=tlast(il)
              ichbig(ill)=ichbig(il)
           go to 2015
         endif
         idelte=idelte+1
      if((ityp(il) .ge.7
     a                .and. ityp(il) .le.9 ).or.
     b          ityp(il) .eq.12  .or.
     c          ityp(il) .eq.14  .or.
     d          (ityp(il).ge.85.and.
     d           ityp(il).le.98).or.
     e          ityp(il) .eq.99                 )then
            lloop=lloop+1
            nrpion=nrpion+1
            do 2016 i=0,3
              x(i,lloop)=x(i,il)
              qdot(i,lloop)=qdot(i,il)
              p(i,lloop)=p(i,il)
 2016       continue
              em(lloop)=em(il)
              ityp(lloop)=ityp(il)
              decay(lloop)=decay(il)
              lastcl(lloop)=mod(-lastcl(il),100000)
              issn(lloop)=issn(il)
              npidec(lloop)=npidec(il)
              tlast(lloop)=tlast(il)
              if(ichbig(il).ne.3) then
                 ichbig(lloop)=0
              else
                 ichbig(lloop)=3
              end if
        end if
 2015 continue
      if(idelte.ne. ntt+nrpion) then
        write(lun8,*)'ntt=',ntt,'nrpion=',nrpion,'idelte=',idelte
        call errex('unidentified particle in spect.group')
      end if
      nspect=nspect-ntt-nrpion
      if(itripl.eq.itrmx.and.
     a                   ida(7).eq.1) then
               do 1509 il=1,nrbar(1)+nrmes(1)
                identl=issn(il)
                if(ida(7).eq.1) then
                  if(itdth(2,identl).ne.0) then
                      call ofshel(8,il,identl)
                  end if
                endif
 1509          continue
      end if
      if(itripl.eq.1) then
             pnorm(0)=gam1
             pnorm(1)=0.
             pnorm(2)=0.
             pnorm(3)=gam1*beta1
             nsppr=0
             nspta=nspect
      else if(itripl.eq.2) then
             pnorm(0)=gam2
             pnorm(1)=0.
             pnorm(2)=0.
             pnorm(3)=gam2*beta2
             nspta=0
      end if
      if(itripl.gt.1) then
            iclusz(itripl)=0
            nrbar(itripl)=0
            nrmes(itripl)=0
      end if
      nrbar(itripl+1)=ntt
      nrmes(itripl+1)=nrpion
      if(lloop+nspect.ne. nt+npion)
     a        call errex('error in sorting particl./event')
      if(itripl.eq.2.and.nspect.ne.0) then
              write(lun8,*) 'error at end of itripl-loop'
              do 1009 l=ntotma,ntotma+1-nspect,-1
              write(lun8,*)
     +  l,'type=',ityp(l),npidec(l),'ident=',issn(l),
     a                                       'lastcl=',lastcl(l)
 1009         continue
              call errex('error:itripl=2 spectators.ne.0/event')
      end if
 1005 continue
         call cnstst(2)
         if(iz1.ne.-7.and.(iz1.le.-6.and.iz1.ge.-9))then
           if(ncollt.eq.0) inn2df=1
           do 191 l=1,nrbar(1)+nrmes(1)
              if(issn(l).eq.1) then
                if(nclcnt(issn(l)).ne.1) then
                   ierror=1
                else
                   idcdif=1
                end if
              end if
  191      continue
         end if
      return
      entry rqmd_endev
      ntweak=nrbar(1)+nrmes(1)
      if(.not.switch(16).and.ida(1).eq.0)then
        iofset=0
        kclst=1
        kdt=ndt+1
        iclusz(1)=ntotma
        ifndnx=1
        if(ida(41).eq.0) then
            idb(19)=-idb(19)
            idb(43)=-idb(43)
            idb(44)=-idb(44)
            idb(45)=-idb(45)
            idb(57)=-idb(57)
            idb(46)=-idb(46)
            idb(47)=-idb(47)
            idb(70)=-idb(70)
        end if
        do 91 l=1,nrbar(1)+nrmes(1)
         ntag=0
         call lddec(l,ntag)
   91   continue
        if(ida(41).eq.0) then
            idb(19)=-idb(19)
            idb(43)=-idb(43)
            idb(44)=-idb(44)
            idb(45)=-idb(45)
            idb(57)=-idb(57)
            idb(46)=-idb(46)
            idb(47)=-idb(47)
            idb(70)=-idb(70)
        end if
        if(nrbar(1)+nrmes(1).ne.nt+npion) then
          write(lun8,*)'particle number not conserved in endev'
         ierror=1
          return
        end if
      else
        if(ida(5).ne.0) then
          do 92 l=1,nrbar(1)+nrmes(1)
           em1=em(l)
           call oldnew(1,ityp(l),npidec(l),em1,kmult1,kl2)
           if(kmult1.eq.0) then
             if(kl2.eq.34.or.kl2.eq.25.or.
     a                   kl2.eq.33.or.kl2.eq.35.or.
     b                     (ida(5).gt.1.and.kl2.eq.24)) then
               write(lun10,1663) kl2,p(0,l),(-p(i,l),i=1,3),em(l)
             end if
           end if
   92     continue
        end if
 1663   format(1x,i4,1x,5(f7.3,1x))
      end if
      if(ida(25).eq.1) then
        write(lun15,661) 0,0,0,0,0,0,0,0
  661   format(1x,i3,1x,i3,1x,i1,1x,i4,1x,i3,1x,i2,1x,i7,1x,i7)
      end if
      if(nprint.le.ndt.or.ida(42).eq.1) then
         if(nprint.le.ndt) then
            do 452 l=1,nrbar(1)+nrmes(1)
            identl=issn(l)
             write(lun7)
     &         ityp(l),issn(l),npidec(l),
     &         x(0,l),x(1,l),x(2,l),x(3,l),
     &         p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &         tdtg(identl),itdth(2,identl),itdth(3,identl)
  452       continue
         end if
         write(lun7)
     &            0,0,0,
     &            10*0.0,0,0
      end if
      if(iz1.lt.0) then
        n1=ityppr
      end if
      if(icld.eq.1) then
        ref='cld'
      end if
      if(iz1.eq.-5) then
        if(idcdif.eq.0) then
          ierror=1
          return
        end if
      else if(iz1.le.-6.and.iz1.ge.-9) then
        return
      end if
      if(da(11).lt.-99.) then
           if(ncollt-npaubl.eq.0) then
             inocol=inocol+1
             return
           end if
      end if
      if(switch(20)) then
        call transl(-1,ityp(nt),npidec(nt),kf)
        if(npion.eq.0.and.
     a       (iz1.ge.0.or.(kf.eq.ityppr
     b                     .and.iz1.lt.0)))then
          inocol=inocol+1
          return
        end if
      end if
      if(((ida(38).gt.0.and.ida(38).le.2)
     a              .or.ida(38).eq.7
     b                   .or.ida(38).eq.5).and.
     c                        ncollt.ne.0.and.npion.ne.0) then
        jeng=0
        do 1558 l=1,nrbar(1)+nrmes(1)
         eml=em(l)
         if(issers(jeng,ida(38),ityp(l),npidec(l),eml)) then
             ident=issn(l)
             write(lun13,890)
     a        ident,0,ityp(l),npidec(l),p(0,l),(-p(i,l),i=1,3)
             write(lun13,888) (stork(ident,i),i=1,5)
             write(lun13,889) (kstor(ident,i),i=1,7)
         end if
 1558   continue
        write(lun13,889) 0
  888   format(1x,5(f7.3,1x))
  889   format(1x,5(i7,1x),2(i4,1x))
  890   format(1x,4(i7,1x),1x,4(f7.3,1x))
      end if
      if(ncollt.ne.0.and.npion.ne.0) then
        if(ida(5).ne.0)  write(lun10,885) 0
      end if
  885 format(1x,i4)
      nonin1=0
      ionin1=0
      nonin2=0
      ionin2=0
      nonint=0
      nextra=0
      ngamma=0
      do 335 l=1,nt+npion
       if(ityp(l).eq.99.and.npidec(l).eq.1) ngamma=ngamma+1
       if(ida(52).eq.1.and.n1.eq.1) then
         if(nclcnt(issn(l)).eq.0.and.issn(l).gt.n1.and.
     a                         issn(l).le.n1old+n2old) then
           ityp(l)=-9999
           if(ityp(l).eq.2) ionin2=ionin2+1
           nonin2=nonin2+1
           nonint=nonint+1
         end if
       else if(ida(52).eq.2) then
         if((nclcnt(issn(l)).eq.0.and.
     b       issn(l).le.n1old+n2old).or.
     c       ityp(l).eq.1.or.
     d       (ityp(l).eq.8.and.npidec(l).eq.0)) then
           if(issn(l).le.n1old+n2old) then
             if(issn(l).gt.n1old) then
               if(ityp(l).eq.2) ionin2=ionin2+1
               nonin2=nonin2+1
             else
               if(ityp(l).eq.2) ionin1=ionin1+1
               nonin1=nonin1+1
             end if
           else
             nextra=nextra+1
           end if
           ityp(l)=-9999
           nonint=nonint+1
         end if
       end if
  335 continue
         if(nonint.ne.0) then
           n1ol=n1
           iz1ol=iz1
           n1=n1-nonin1
           iz1=iz1-ionin1
           n2ol=n2
           iz2ol=iz2
           n2=n2-nonin2
           iz2=iz2-ionin2
         end if
c      write(lun9,output)
         if(nonint.ne.0) then
           n1=n1ol
           iz1=iz1ol
           n2=n2ol
           iz2=iz2ol
         end if
       npitru=npion
       npion=npion-nextra
       if(iz1.lt.0) then
          n1=1
       end if
       if(icld.eq.1) then
         ref=' nn'
       end if
       write(lun9,905) npion,npitru,nspnuc,ngamma
       write(lun9,906)  ncollt-npaubl,idcntd,idcntn,idcntr,iabspi
 906   format(    5i8)
 905   format(6i6 )
       do 458 l=1,nrbar(1)+nrmes(1)
        if(ida(38).eq.3.or.ida(38).eq.4) then
          identl=issn(l)
          if(identl.le.n1old+n2old.and.
     a                     nclcnt(identl).eq.0.and.
     b                           kstor(identl,1).eq.0) then
            lastcl(l)=-1
          else if(l.gt.ntweak) then
          else
            lastcl(l)=kstor(identl,1)
          end if
        else
          lastcl(l)=0
        end if
               if((ida(38).eq.3.or.ida(38).eq.4).and.
     a                               lastcl(l).ne.0) then
                 if(lastcl(l).eq.-1) then
                   do 464 i=0,3
  464              x(i,l)=0.0
                 else
                   do 463 i=1,4
  463              x(i-1,l)=stork(identl,i)
                   pvec2=0.0
                   do 563 i=1,3
                    p(i,l)=stork(identl,i+5)
                    pvec2=pvec2+p(i,l)**2
  563              continue
                   p(0,l)=sqrt(em(l)**2+pvec2)
                 end if
               else
                 if(switch(23)) then
                   tl=tlast(l)-x(0,l)
                 else
                   tl=x(0,l)-qdot(0,l)*dt
                   tlastl=tlast(l)
                   tl=max(tlastl,tl)
                 end if
                 if(qdot(0,l).gt.0.0) then
                   do 462 i=0,3
  462              x(i,l)=x(i,l)+qdot(i,l)/qdot(0,l)*tl
                 end if
               end if
               if(npidec(l).lt.-99) then
                 npidec(l)=-mod(-npidec(l),100)
               end if
               if(nonint.ne.0) then
                 if(ityp(l).eq.-9999)  then
                   nonint=nonint-1
                   go to 458
                 end if
               end if
               write(lun9,1907)  ityp(l),npidec(l),
     &                   (x(i,l),i=0,3),
     &                   (p(i,l),i=0,3),em(l),decay(l),
     &                    nclcnt(issn(l)),lastcl(l)
 1907  format(i2,i4,1x,f11.3,2f10.3,f11.3,
     a                 f10.4,2f9.4,f11.4,f7.4,1x,1pe12.4,1x,i3,1x,i3)
  458  continue
       if(nonint.ne.0) call errex('subr. event: nonint counter wrong')
      return
      entry rqmd_final
      write(lun8,*)'final information:'
      write(lun8,*)'collisions in region: fb/fb  fb/sp    sp/sp'
      write(lun8,*)'xcnt(1)=',xcnt(1)/float(nruns),
     a          'xcnt(2)=',xcnt(2)/float(nruns),
     b                                'xcnt(3)=',xcnt(3)/float(nruns)
      if(iz1.le.-5) then
          xnondf=float(inondf)/float(idifr)
          write(lun8,*)
     +    'percentage of nondiffractive events',xnondf*100.0
      end if
      if(da(11).lt.-99.) then
          xnocol=float(inocol)/float(nruns)
          write(lun8,*)
     +   'percentage of events without particle production:'
     a                ,xnocol*100.
      end if
      if(nfrmcq.gt.0.or.nfrmhd.gt.0)
     a   write(lun8,*) 'time delay for hadron production in jet decay'
      if(nfrmcq.gt.0)
     a   write(lun8,*)  float(nfrmcq)/float(nruns),
     a            'hadrons containing constituent '
     b         , 'quarks with mean formation time',tfrmcq/nfrmcq,'fm/c'
      if(nfrmhd.gt.0)
     a   write(lun8,*)  float(nfrmhd)/float(nruns),
     a            'new hadrons ',
     b                  'with mean formation time',tfrmhd/nfrmhd,'fm/c'
      write(lun8,*)
     + 'information about the usage of the array nghbor and'
      write(lun8,*)'the arrays dimensioned on nclmx'
      write(lun8,*) 'maximum value of nttot in relham=',nttomx
      write(lun8,*) 'compared to the array size parameter nclmx=',nclmx
      write(lun8,*)
     + 'maximum value of used argument in the array nghbor=',
     a            nghbmx
      write(lun8,*) 'compared to the size of the array nghbor=',
     a            ngbrmx*nclmx
 99   write(lun8,8093) xcoll/float(nruns),
     * xblock/float(nruns),
     * xbldel/float(nruns),
     * xininw/float(nruns)
 8093 format(1x,/,'                      per run ',/,
     * '-----',/,
     * ' collisions     =',f10.4,/,
     * ' fermi blocks   =',f10.4,/,
     * ' bardec. p.block =',f10.4,/,
     * ' initial.p.block =',f10.4,/)
      ierr=systim(ttotal,dummy)
      write(lun8,8094)tmprop/float(nruns), tmcoll/float(nruns) ,
     * tmsctr/float(nruns),tmpali/float(nruns),
     * ttotal/float(nruns)
 8094 format('    timer report              sec/ensemble',//,
     * ' hamilton - propag. =',f13.6,/,
     * ' collisions   =',f13.6,/,
     * ' scattering         =',f13.6,/,
     * ' pauli blocking     =',f13.6,///,
     * ' total batch time =  ',f15.6,/)
      write(lun8,*) 'cpu-time in absorb:',tmabsr/nruns
      return
      end
CPAT,MAINB    .
      subroutine propag(i1,i2,iswprp)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      dimension qlk(0:3),plk(0:3)
      dimension pil(0:3)
      common /ierdum/ierr
      if(i1.eq.i2) call errex('i1=i2 not allowed in propag')
      il=i1
      ir=i2
    5 continue
      if(il.lt.0) go to 11
      ichbl=ichbig(il)
      ichtag=ichbl/1000
      if(ichtag.ne.0) then
        call errex('propag:dead end, ichtag.ne.0')
      end if
      ichbl=isign(1,ichbl)*mod(iabs(ichbl),1000)
      if(ichbl.eq.1.or.ichbl.eq.3) then
        if(qdot(0,il).ne.0.) then
            write(lun8,*) 'propag: ichbig=1,qdot(0).ne.0 ',irun,itripl,k
            write(lun8,*) il,issn(il),ichbig(il),qdot(0,il),
     a                                               x(0,il),tlast(il)
        end if
        go to 11
      end if
      if(ityp(il).eq.-9999) go to 11
      identl=issn(il)
      if(itdth(2,identl).ne.0  .and.
     a        tdtg(identl).gt.tlast(il)) then
        do 47 i=0,3
   47   pil(i)=qdot(i,il)
      else
        do 48 i=0,3
   48   pil(i)=p(i,il)
      end if
      if(ida(23).ne.0)then
          teprop=tbegin+kdt* dt
          tilobs=x(0,il)*pnorm(0)- x(1,il)*pnorm(1)-
     a                          x(2,il)*pnorm(2)- x(3,il)*pnorm(3)
          pilobs=pil(0)*pnorm(0)-pil(1)*pnorm(1)-
     a                       pil(2)*pnorm(2)- pil(3)*pnorm(3)
          if(tilobs.le.teprop) then
            delts=(teprop-tilobs)/pilobs
            fctr=1./pilobs
            do 57 i=0,3
             qdot(i,il)=pil(i)* fctr
   57       continue
          else
            delts=0.
            do 58 i=0,3
   58       qdot(i,il)=0.
          end if
      else
        if(ityp(il).eq.99.and.(npidec(il).eq.1.or.iabs(npidec(il))
     a                                                .eq.7)) go to 11
        chs1=0.
        chs2=0.
        deltsm=1.e+30
        do 10 ik=iofset+1,iofset+ntclst
         if(ik.eq.ir.or.ik.eq.il) go to 10
         ichbk=ichbig(ik)
         ichbk=isign(1,ichbk)*mod(iabs(ichbk),1000)
         if(ichbk.eq.1.or.ichbk.eq.3) go to 10
         if(ityp(ik).eq.-9999) go to 10
         if(ityp(ik).eq.99.and.(npidec(ik).eq.0.or.iabs(npidec(ik))
     a                                                 .eq.5)) go to 10
         if(deltsm.eq.0.) go to 10
         do 9 i=0,3
          qlk(i)=x(i,il)-x(i,ik)
          plk(i)=p(i,il)+p(i,ik)
    9    continue
         dqlksq=qlk(0)*qlk(0)
         splksq=plk(0)*plk(0)
         dqsplk=qlk(0)*plk(0)
         pisplk=p(0,il)*plk(0)
         delqp=qlk(0)*p(0,il)
         pindsq=p(0,il)*p(0,il)
         do 8  i=1,3
           dqlksq=dqlksq- qlk(i)*qlk(i)
           splksq=splksq- plk(i)*plk(i)
           dqsplk=dqsplk- qlk(i)*plk(i)
           pisplk=pisplk- p(i,il)*plk(i)
           pindsq=pindsq-p(i,il)*p(i,il)
           delqp=delqp-qlk(i)*p(i,il)
    8    continue
         if(dqlksq.gt.0.) then
             if(qlk(0).gt.0.) then
                deltsm=0.
             else
                go to 10
             end if
         else
             val=delqp/pindsq
             arg=- dqlksq/pindsq+val*val
             if(arg.lt.0.) then
                if(-arg.gt.0.01) then
                   write(lun8,*) 'arg.lt.0 in propag,33  ???????? ',arg
                   call errex('numerical problem in propag')
                end if
                arg=0.
             else
                arg=sqrt(arg)
             end if
             ds=- val+arg
             deltsm=min(deltsm,ds)
         end if
         if(-dqlksq.gt.dstint) go to 10
         if(-dqlksq.lt.0.000001) dqlksq=-0.000001
         if(da(14).eq.1.) then
            cofct1=exp(dqlksq/al)*abs(al/dqlksq)*em(il)**2 *em(ik)**2
     a                             *dqsplk/sqrt(splksq)
            cofct2=exp(dqlksq/al)*abs(al/dqlksq)*em(il)**2 *em(ik)**2
     a                             *pisplk/sqrt(splksq)
         else
            cofct1=exp(dqlksq/al)*abs(al/dqlksq) *dqsplk
            cofct2=exp(dqlksq/al)*abs(al/dqlksq) *pisplk
         end if
         chs1=chs1+cofct1
         chs2=chs2+cofct2
   10   continue
        delts=0.
        if(chs2.ne.0.) delts=max(cvalu0,-chs1/chs2)
        delts=min(delts,deltsm)
        if(deltsm.lt.-1.e-3) then
           write(lun8,*)'propag:ident=',issn(il),'deltsm=',deltsm
           write(lun8,*) irun,itripl,kdt,kclst
        end if
        deltt=max(cvalu0,time+dt-tlstev)
        if(abs(deltt).lt.1.e-3) then
          fctr=1000.*delts
        else
          fctr=delts/deltt
        end if
         tjump=0.
         ivz=1
         do 7 i=0,3
           tjump=tjump+ivz*p(i,il)*pnorm(i)
           ivz=-1
           qdot(i,il)=p(i,il)* fctr
    7    continue
         tjump=tjump*delts
         if(tjump.gt.3.*dt) then
            fmlt=3.*dt/tjump
            delts=delts*fmlt
            do 16  i=0,3
             qdot(i,il)=qdot(i,il)* fmlt
   16       continue
         end if
      end if
      if(switch(19)) then
        qdot(1,il)=0.
        qdot(2,il)=0.
        x(0,il)=x(0,il)+pil(0)* delts
        x(3,il)=x(3,il)+pil(3)* delts
      else
        do 17 i=0,3
         x(i,il)=x(i,il)+pil(i)*delts
   17   continue
      end if
      if(ida(23).eq.0.and.ida(47).eq.0) then
        tback=x(0,il)-qdot(0,il)*(time+dt-tlstev)
        if(tback+0.01.lt.tlast(il)) then
         write(lun8,*) 'propag: ',il,issn(il)
         write(lun8,*) 'x=',(x(i,il),i=0,3)
         write(lun8,*) 'qdot=',(qdot(i,il),i=0,3)
         write(lun8,*) 'p=',(p(i,il),i=0,3)
         write(lun8,*) 'tlstev,delts,deltt,tlast(il),tback'
         write(lun8,*)  tlstev,delts,deltt,tlast(il),tback
        end if
      end if
   11 continue
      if(il.eq.i1) then
        il=i2
        ir=i1
        go to 5
      end if
      if(iswprp.ne.2) then
        ierr=systim(strt,dummy)
        call cupdat(i1,i2)
        ierr=systim(tend,dummy)
        tmcoll=tmcoll+tend-strt
      end if
      return
      end
      subroutine rend(istop)
         include 'scatter7'
#include "amsrqmd.h"
         common /ranfbk/iy
         real*4 plund
         common /lujets/ nlund,k(2000,2),plund(2000,5)
         include 'partblk7'
         include 'storbig'
      write(lun8,*) 'rend is called for itripl,kdt',itripl,kdt
      write(lun12) itripl,kdt
      write(lun12) iy,nlund
      do 60 l=1,nlund
       write(lun12)
     &    (k(l,i),i=1,2),(plund(l,i),i=1,5)
   60 continue
      write(lun12)
     &        n1,iz1,n2,iz2,    nprint,nruns,
     &                         inttyp,ieos,iseed,idtcl,
     &         elgev,b,dt,sepfp,sepft,cutfct
      write(lun12)
     &         nt,npion,    kclst,iofset,nprtcl,
     &   irun,ierror,nspect,       lmax,ntclst,
     &   idcdif,inondf,idifr,inn2df,ibrhig,ievbb,inocol,
     &   nsppr,nspta,nspnuc,iyy,iqcnvt,ifndnx,nrclst
      do 10 l=1,ntotma
      write(lun12)
     &          tdtg(l),(x(i,l),i=0,3),(qdot(i,l),i=0,3),
     &          (p(i,l),i=0,3),em(l),decay(l),denspp(l),
     &          tlast(l), (frfp(i,l),i=0,3),datsto(l)
      write(lun12)
     &          h(l),chi(l),
     &          ylast(l),zlast(l),
     &          iclusz(l),nrbar(l),(itdth(i,l),i=1,5),nrmes(l),
     &          ityp(l),npidec(l),ichbig(l),nonrel(l),prop(l),
     &          nclcnt(l),lastcl(l),issn(l),(idud(i,l),i=1,1)
   10 continue
      write(lun12)
     &              al,sal, alpha,beta,gamma,dstint,glk,coef1,coef2,
     a                alpot,salpot,eosc3,coef3,
     b                eosc1,eosc2,gm1,pr2max,pnorm,elab
     &             ,ptotal,psyst,tbegin,emproj,tcoll,zcoll,pcorr
      write(lun12)
     &           ityppr,  ispcod, iqtot,ntbar,ievntn,
     a                 iz1old,n1old,iz2old,n2old,
     &              zmxpr,zmnpr,zmxta,zmnta,bplus,rprsq,rtasq,betapr,
     a              betata,yproj,ytarg,betapl,betatl,gamnn,betann,
     b              rr1,rr2
      write(lun12)
     &     tfrmcq,tfrmhd,nfrmcq,nfrmhd
      write(lun12)
     &     dtprop,time,tlstev,tnexev,timmax
      write(lun12)
     &     tmsctr,tmprop,tmupdt,tmpali,tmcoll,
     a                       tmabsr
      write(lun12)
     &      xblcut, xininw, xfirst,xbldel,xblock,
     a               xcnt,npaubl,ncollt,ncoll,
     b               iabspi,idcntd,idcntn,idcntr
      if(kdt.eq.idtcl) then
        nend=nclmx/10
        do 44 m=1,nend
         write(lun12) (ngbrnr((m-1)*10+l),l=1,10)
         write(lun12) (ngbsum((m-1)*10+l),l=1,10)
   44   continue
        do 45 l=10*nend+1,nclmx
         write(lun12) ngbsum(l),ngbrnr(l)
   45   continue
        nend=nclmx*ngbrmx/10
        do 46 m=1,nend
         write(lun12) (nghbor((m-1)*10+l),l=1,10)
   46   continue
        do 47 l=10*nend+1,nclmx*ngbrmx
         write(lun12) nghbor(l)
   47   continue
      end if
      if(istop.ne.1) then
        return
      else
        write(*,*)'rend stop rejected '
        return
c        stop
      end if
      end
      subroutine rstart
         include 'scatter7'
#include "amsrqmd.h"
         common /ranfbk/iy
         real*4 plund
         common /lujets/ nlund,k(2000,2),plund(2000,5)
         include 'partblk7'
         include 'storbig'
      write(lun8,*) 'rstart is called for itripl,kdt',itripl,kdt
      read(lun11) iy,nlund
      do 60 l=1,nlund
       read(lun11)
     &    (k(l,i),i=1,2),(plund(l,i),i=1,5)
   60 continue
      read(lun11)
     &        n1,iz1,n2,iz2,    nprint,nruns,
     &                         inttyp,ieos,iseed,idtcl,
     &         elgev,b,dt,sepfp,sepft,cutfct
      read(lun11)
     &         nt,npion,    kclst,iofset,nprtcl,
     &   irun,ierror,nspect,       lmax,ntclst,
     &   idcdif,inondf,idifr,inn2df,ibrhig,ievbb,inocol,
     &   nsppr,nspta,nspnuc,iyy,iqcnvt,ifndnx,nrclst
      do 10 l=1,ntotma
      read(lun11)
     &          tdtg(l),(x(i,l),i=0,3),(qdot(i,l),i=0,3),
     &          (p(i,l),i=0,3),em(l),decay(l),denspp(l),
     &          tlast(l), (frfp(i,l),i=0,3),datsto(l)
      read(lun11)
     &          h(l),chi(l),
     &          ylast(l),zlast(l),
     &          iclusz(l),nrbar(l),(itdth(i,l),i=1,5),nrmes(l),
     &          ityp(l),npidec(l),ichbig(l),nonrel(l),prop(l),
     &          nclcnt(l),lastcl(l),issn(l),(idud(i,l),i=1,1)
   10 continue
      read(lun11)
     &              al,sal, alpha,beta,gamma,dstint,glk,coef1,coef2,
     a                alpot,salpot,eosc3,coef3,
     b                eosc1,eosc2,gm1,pr2max,pnorm,elab
     &             ,ptotal,psyst,tbegin,emproj,tcoll,zcoll,pcorr
      read(lun11)
     &           ityppr,  ispcod, iqtot,ntbar,ievntn,
     a                 iz1old,n1old,iz2old,n2old,
     &              zmxpr,zmnpr,zmxta,zmnta,bplus,rprsq,rtasq,betapr,
     a              betata,yproj,ytarg,betapl,betatl,gamnn,betann,
     b              rr1,rr2
      read(lun11)
     &     tfrmcq,tfrmhd,nfrmcq,nfrmhd
      read(lun11)
     &     dtprop,time,tlstev,tnexev,timmax
      read(lun11)
     &     tmsctr,tmprop,tmupdt,tmpali,tmcoll,
     a                       tmabsr
      read(lun11)
     &      xblcut, xininw, xfirst,xbldel,xblock,
     a               xcnt,npaubl,ncollt,ncoll,
     b               iabspi,idcntd,idcntn,idcntr
      if(kdt.eq.idtcl) then
        nend=nclmx/10
        do 44 m=1,nend
         read(lun11) (ngbrnr((m-1)*10+l),l=1,10)
         read(lun11) (ngbsum((m-1)*10+l),l=1,10)
   44   continue
        do 45 l=10*nend+1,nclmx
         read(lun11) ngbsum(l),ngbrnr(l)
   45   continue
        nend=nclmx*ngbrmx/10
        do 46 m=1,nend
         read(lun11) (nghbor((m-1)*10+l),l=1,10)
   46   continue
        do 47 l=10*nend+1,nclmx*ngbrmx
         read(lun11) nghbor(l)
   47   continue
      end if
      rewind(11)
      return
      end
      subroutine cnstst(iw)
         include 'scatter7'
#include "amsrqmd.h"
         include 'partblk7'
            ibarys=0
            ichrgs=0
            nall=0
            do 8 i=0,3
    8       ptotal(i)=0.
            iof=0
            kcl=0
   38       kcl=kcl+1
            if(kcl.le.nrclst) then
                ncl=nrbar(kcl)+nrmes(kcl)
            else
                ncl=nspect
            end if
            nall=nall+ncl
            do 41 l=iof+1,iof+ncl
               if(ityp(l).eq.-9999) go to 41
               call transl(-1,ityp(l),npidec(l),k2l)
               ichrgs=ichrgs+luchge(k2l)
               k2labs=iabs(k2l)
               if(k2labs.le.90) then
                  if(kspin(k2labs).ge.2) then
                     ibarys=ibarys+1*isign(1,k2l)
                  endif
               else
                  write(lun8,*) 'warning: kspin not identified'
                  write(lun8,*) ityp(l),npidec(l),k2l
               endif
              if(iw.lt.2) go to 41
              do 49 i=0,3
                ptotal(i)=ptotal(i)+p(i,l)
   49         continue
   41       continue
            if(kcl.le.nrclst) then
              if(kcl.eq.nrclst) then
                iof=ntotma-nspect
              else
                iof=iof+iclusz(kcl)
              end if
              go to 38
            end if
   40       continue
            if(nall.ne.nt+npion) then
                write(lun8,*) 'nall=',nall,'total prtcl.no.=',nt+npion
                call errex(
     a             'no particle no. conservation for final particles')
            endif
            if(ibarys.ne.ntbar)then
                write(lun8,*) 'ibarys=',ibarys,'total b.no.=',ntbar
                call errex(
     a                'no baryon no. conservation for final particles')
            endif
            if(mod(ichrgs,3).ne.0) then
                write(lun8,*) 'ichrgs=',ichrgs,'total charge=',iqtot
                call errex('no integer charge sum for final particles')
            else
                ichrgs=ichrgs/3
                if(ichrgs.ne. iqtot) then
                   write(lun8,*) 'ichrgs=',ichrgs,'total charge=',iqtot
                   call errex(
     a                   'no charge conservation for final particles')
                end if
            end if
            if(iw.lt.2) return
            if(abs(psyst(0)-ptotal(0))/psyst(0).gt.0.015) then
                write(lun8,*)(psyst(i),i=0,3),'initial total momentum'
                write(lun8,*)(ptotal(i),i=0,3),'final total momentum'
                call errex('no energy conservation for final particles')
                return
            end if
            if((abs(psyst(1)-ptotal(1)).gt.1.0).or.
     a         (abs(psyst(2)-ptotal(2)).gt.1.0).or.
     b         (abs(psyst(3)).gt.1.e-3.and.
     c          abs(psyst(3)-ptotal(3)).gt.1.0 .and.
     d          abs(psyst(3)-ptotal(3)).gt.0.015*abs(psyst(3))).or.
     e         (abs(psyst(3)).le. 1.e-3    .and.
     f           abs(psyst(3)-ptotal(3)).gt.1.0 ) ) then
                  write(lun8,*)(psyst(i),i=0,3),'initial total momentum'
                  write(lun8,*)(ptotal(i),i=0,3),'final total momentum'
                  call errex(
     a                'no momentum conservation for final particles')
                return
            end if
            if(irun.eq.nruns) then
                write(lun8,*) 'momentum in the last event:'
                write(lun8,*)(psyst(i),i=0,3),'initial total momentum'
                write(lun8,*)(ptotal(i),i=0,3),'final total momentum'
            end if
      return
      end
      subroutine ofshel(isubr,il,ident)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
                do 17 i=0,3
                  p(i,il)=p(i,il)+frfp(i,ident)
   17           continue
                if(isubr.ne.1) then
                   if(isubr.ne.3)  then
                       tdtg(ident)=0.
                       itdth(1,ident)=0
                       itdth(2,ident)=0
                       itdth(4,ident)=0
                   end if
                   do 18 i=0,3
                    psyst(i)=psyst(i)+frfp(i,ident)
                    frfp(i,ident)=0.
   18              continue
                end if
                emsq=p(0,il)*p(0,il)-(p(1,il)*p(1,il)+
     a                             p(2,il)*p(2,il)+p(3,il)*p(3,il))
                if(ida(13).eq.4.and..not.switch(6)) then
                else if(abs(emsq-em(il)*em(il)).gt.0.008) then
                   write(lun8,*) 'isubr=',isubr
                   write(lun8,*) 'psyst=',(psyst(i),i=0,3)
                   write(lun8,*) 'ident=',ident,il,ityp(il),npidec(il)
                   write(lun8,*) 'p=',(p(i,il),i=0,3)
                   write(lun8,*) 'frfp=',(frfp(i,ident),i=0,3)
                   write(lun8,*) 'emsq=',emsq,'em**2=',em(il)*em(il)
                   write(lun8,*) sqrt(emsq),em(il)
                   call errex(
     a             'ofshel:wrong mass,conversion of cquark into hadron')
                end if
      return
      end
      subroutine comprs(istor)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 1.08 -- 29-nov-91'/
      data pronam /'c o m p r s --- remove absorbed particles '/
      data ttvers/.true./
      if(ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
         idelte=0
         iofbar=iofset+nrbar(kclst)
         do 110 il=iofset+1,iofbar+nrmes(kclst)
             if(ityp(il).eq.-9999) then
               idelte=idelte+1
               if(il.gt.iofbar)then
                  nrmes(kclst)=nrmes(kclst)-1
               else
                  nrbar(kclst)=nrbar(kclst)-1
               end if
               go to 110
             end if
             j=il-idelte
             if(idelte.ne.0) then
                call store(j,il)
             end if
 110        continue
            npion=npion-idelte
            if(istor.eq.0) return
            call errex('comprs(1) not ready to run')
      return
      end
      subroutine errex(text)
      include 'scatter7'
#include "amsrqmd.h"
      character*(*) text
      include 'partblk7'
  899 format(1x,'event with random no. initialization:',i12)
 912  format(3x,'time:',f8.3,2x,i4,  '. time step' )
      write(lun14,*)'errex is called with error message'
      write(lun14,*) 'start value of random integer in initev was ',iyy
      write(lun14,*) 'irun,kdt,itripl,kclst,nrbar(kclst),nrmes(kclst)'
      write(lun14,*)  irun,kdt,itripl,kclst,nrbar(kclst),nrmes(kclst)
      write(lun14,*)text
      ierror=1
      if(ida(43).eq.1) then
        write(lun14,899) iyy
        write(lun14,912) time,kdt
        write(lun14,*)'errex is called with error message'
        write(lun14,*)text
        write(lun14,*) 'irun,kdt,itripl,kclst,nrbar(kclst),nrmes(kclst)'
        write(lun14,*)  irun,kdt,itripl,kclst,nrbar(kclst),nrmes(kclst)
        if(ida(5).ne.0) write(lun10,901) -1
        if(ida(38).eq.1.or.ida(38).eq.2.or.
     a     ida(38).eq.5.or.ida(38).eq.7)  then
          write(lun13,901) -1
        end if
 901    format(1x,i4)
       if(ida(42).eq.1) then
         write(lun7)
     &           -1,0,0,
     &            10*0.0,0,0
       end if
        write(*,*)'errex-should never be here!!!'
        stop
      end if
      return
      end
      subroutine swap(x1,x2)
      include 'scatter7'
#include "amsrqmd.h"
      y=x1
      x1=x2
      x2=y
      return
      end
      subroutine iswap(ix1,ix2)
#include "amsrqmd.h"
      iy=ix1
      ix1=ix2
      ix2=iy
      return
      end
      function clphh(srt,pr,em1,em2,ika1,ika2)
       include 'scatter7'
#include "amsrqmd.h"
       data avan,kvan /1.2,2/
       if(em1+em2.gt.srt) then
          write(lun8,*) srt,em1,em2
          call errex('clphh abort:em1+em2>srt')
       end if
       if(ida(53).eq.0) then
         if(pr.lt.1.5)  then
           clphh=1.-exp(-(pr/0.4)**2)
         else
           clphh=1.
         end if
       else if(ida(53).eq.1) then
         clphh=pr**kvan*exp(-avan*sqrt(srt*srt-(em1+em2)**2))
       else if(ida(53).eq.2) then
         clphh=1.
       end if
      return
      end
      subroutine ndstar(s,pr,em1,em2,icltyp,itp1,npd1,itp2,npd2,
     a              icollc,mstr,ichd,ichn,ireco,nscod,strrat,vfspin)
      include 'scatter7'
#include "amsrqmd.h"
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       real*4 pssbar,pr4
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       mstr=0
       icollc=0
       pr4=pr
       if((icltyp.ge.22.and.icltyp.le.23).or.
     a         (icltyp.ge.29.and.icltyp.le.30).or.
     b    (icltyp.ge.37.and.icltyp.le.38)) then
         if(npd1.eq.2) then
           ireco=1
           vfspin=0.333333
           ichn=3
           ichd=3
           icollc=2
         else
           ireco=0
         end if
         str=1.0
       else if((icltyp.ge.24.and.icltyp.le.27).or.
     a         (icltyp.ge.31.and.icltyp.le.34).or.
     b          (icltyp.ge.39.and.icltyp.le.42)) then
         if((itp1.gt.6.and.npd1.ne.0).or.
     b           (itp2.le.6.and.(npd2.gt.1.or.npd2.lt.0))) then
           ireco=0
         else
           ireco=1
           vfspin=0.5
           ichn=2
           ichd=2
           icollc=1
         end if
         str=1.0
       else if((icltyp.ge.52.and.icltyp.le.54).or.
     a            (icltyp.ge.62.and.icltyp.le.64)) then
         if((itp1.le.9.and.npd1.ne.0).or.
     a               (itp2.gt.9.and.npd2.ge.0)) then
           ireco=0
         else
           ireco=1
           nscod=mod(-npd2,1000)
           if(nscod.eq.1.or.nscod.eq.3.or.
     a                 nscod.eq.4.or.nscod.eq.8) then
             vfspin=1.0
           else if(nscod.eq.2.or.nscod.eq.7.or.
     a                           nscod.eq.9) then
             vfspin=0.5
           else if(nscod.eq.5.or.nscod.eq.6) then
             vfspin=0.3333
           else
             vfspin=0.25
           end if
           ichn=-1
           ichd=0
         end if
         str=1.
       else if((icltyp.eq.104.and.npd1.gt.0).or.
     a          (icltyp.gt.120
     b           .and.((npd1.ge.28.and.npd1.le.29).or.
     c                  (itp1.eq.14.and.npd1.gt.0))
     d           .and.(itp2.eq.13))) then
         mstr=1
         if(em1.gt.0.5.or.em2.gt.1.2) then
           ireco=0
         else
           ireco=1
           vfspin=1.0
           ichn=5
           ichd=-1
         end if
         str=pssbar(ida(55),pr4)
       else if((icltyp.eq.119.and.npd1.gt.0).or.
     a          (icltyp.gt.120
     b           .and.((npd1.ge.28.and.npd1.le.29).or.
     c                  (itp1.eq.14.and.npd1.gt.0))
     d           .and.(itp2.eq.15.or.
     e                 (npd2.ge.65.and.npd2.le.67)
     f                                            ))) then
         mstr=1
         if(em1.gt.0.5.or.em2.gt.1.2) then
           ireco=0
         else
           ireco=1
           vfspin=1.0
           ichn=6
           ichd=4
         end if
         str=pssbar(ida(55),pr4)
       else if((icltyp.ge.67.and.icltyp.le.72).or.
     a         icltyp.eq.76.or.icltyp.eq.77.or.
     b         (icltyp.gt.120.and.npd1.eq.25).or.
     c         (icltyp.gt.120.and.npd1.eq.34).or.
     d         (icltyp.gt.120.and.npd1.eq.35)) then
         ichn=-1
         ichd=-1
         ireco=0
         if(icltyp.eq.67.or.icltyp.eq.68) then
           if(em1.lt.0.6) then
             ireco=1
             vfspin=1.0
             ichn=4
           end if
         end if
         if((ireco.eq.1.and.itp1.eq.12).or.
     a                (itp1.eq.99.and.npd1.eq.25)) then
           themix=pi2/360.0*anglmx(0,1)
           valmix=0.3333*(cos(themix)-sqrt(2.)*sin(themix))**2
         else if(npd1.eq.35) then
           valmix=0.
         else
           valmix=1.0
         end if
         if(npd1.eq.25) valmix=1.-valmix
         str=valmix+(1.-valmix)*ssbdif*pssbar(ida(55),pr4)
       else
         ireco=0
         str=0.0
       end if
       if(s.le.em1+em2) then
         strrat=0.0
       else if(str.ne.0.0) then
         prpin=pcmsr(s,emnuc,empion)
         emn=emnuc
         emp=empion
         strrat=str*clphh(s,pr,em1,em2,ika1,ika2)/
     a            clphh(s,prpin,emn,emp,ikan,ikap)
       else
         write(lun8,*)'ndstar: wrong icltyp as input',icltyp,
     a                                    itp1,npd1,itp2,npd2
         call errex('ndstar: wrong icltyp as input')
       end if
      return
      end
      subroutine fillca
#include "amsrqmd.h"
       common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       real*4 gemca(5),dcrat(8,5)
       common /caflbk/dcrat,gemca
       dimension emca(5)
       data emca  /1.835, 1.82, 2.04,1.945,2.130 /
       dimension lres(8,5),it1(8),it2(8)
       data lres /2*0,2*2,2*0,2*2,
     a            2*2,2*0,2*2,2*0,
     b            2*3,2*1,2*3,2*1,
     c            8*2,
     d            8*3
     e           /
       data it1 / 47,47,69,69,45,57,67,70
     a          /
       data it2 / 17,24,17,24,19,19,19,19
     a          /
       dimension alpsu3(5),acoef1(5),acoef2(5)
       data alpsu3 /-0.28,0.72,0.54,-0.16,0.0/
       data acoef1 / 5.2, 41.1, 47.7, 22.8, 51.6 /
       data acoef2 / 262.0,3.6,16.0,156.0,79.700 /
       dimension kconv(5)
       data kconv /2,1,4,3,5/
        do 10 j=1,5
         kon=kconv(j)
         emres=emca(j)
         gemca(kon)=0.0
         do 11 i=1,8
          dcrat(i,kon)=0.0
          embar=pmas(it1(i))
          emmes=pmas(it2(i))
          iusual=0
          if(emres.gt.embar+emmes) then
            prres=pcmsr(emres,embar,emmes)
          else
            embar=pmas(46)
            emmes=pmas(23)
            prres=pcmsr(emres,embar,emmes)
            iusual=1
          end if
          if(j.le.4) then
            alpha=alpsu3(j)
            acoef=acoef1(j)
            cosu3=s888(i,alpha,acoef)**2
            acoef=acoef2(j)
            cosu3=cosu3+s8108(i,acoef)**2
          else if(j.eq.5) then
            acoef=acoef1(j)
            cosu3=s1088(i,acoef)**2
            acoef=acoef2(j)
            cosu3=cosu3+s10108(i,acoef)**2
          end if
          gempar=cosu3*prres/emres*prres**(2*lres(i,j))
          dcrat(i,kon)=gempar
          if(iusual.eq.1) go to 11
          gemca(kon)=gemca(kon)+gempar
   11    continue
         if(gemca(kon).eq.0.0) go to 10
         do 12 i=1,8
   12    dcrat(i,kon)=dcrat(i,kon)/gemca(kon)
         gemca(kon)=1.e-3*gemca(kon)
   10  continue
       do 20 j=1,5
        write(6,22) (dcrat(i,j),i=1,8)
   22  format(8x,8(f5.3,',',1x))
   20  continue
       write(6,22) (gemca(j),j=1,5)
      return
      end
      function s1088(i,a1088)
       if(i.eq.3.or.i.eq.4.or.i.eq.7.or.i.eq.8) then
         s1088=0.0
       else if(i.eq.1.or.i.eq.2.or.i.eq.5) then
         s1088=0.5*a1088
       else if(i.eq.6) then
         s1088=-0.5*a1088
       else
         call errex('s1088-wrong input')
       end if
      return
      end
      function s10108(i,a10108)
       if(i.eq.1.or.i.eq.2.or.i.eq.5.or.i.eq.6) then
         s10108=0.0
       else if(i.eq.3) then
         s10108=a10108/sqrt(8.)
       else if(i.eq.4) then
         s10108=-a10108/sqrt(8.)
       else if(i.eq.7) then
         s10108=a10108/sqrt(2.)
       else if(i.eq.8) then
         s10108=-0.5*a10108
       else
         call errex('s10108-wrong input')
       end if
      return
      end
      function s8108(i,a8108)
       if(i.eq.1.or.i.eq.2.or.i.eq.5.or.i.eq.6) then
         s8108=0.0
       else if(i.eq.3.or.i.eq.4) then
         s8108=-a8108/sqrt(5.)
       else if(i.eq.7) then
         s8108=a8108/sqrt(5.)
       else if(i.eq.8) then
         s8108=a8108*sqrt(0.4)
       else
         call errex('s8108-wrong input')
       end if
      return
      end
      function s888(i,alpha,a888)
       if(i.eq.1) then
         s888=sqrt(3.)*(2.*alpha-1.)*a888
       else if(i.eq.2) then
         s888=(2.*alpha+1.)/sqrt(3.)*a888
       else if(i.eq.3.or.i.eq.4.or.i.eq.7.or.i.eq.8) then
         s888=0.0
       else if(i.eq.5) then
         s888=sqrt(3.)*a888
       else if(i.eq.6) then
         s888=(4.*alpha-1.)/sqrt(3.)*a888
       else
         call errex('s888-wrong input')
       end if
      return
      end
      subroutine fillom
#include "amsrqmd.h"
       common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       parameter (ichaom=3,irenom=1)
       real*4 gemom(irenom),dcrat(ichaom,irenom)
       common /omflbk/dcrat,gemom
       dimension emom(irenom)
       data emom  /2.230 /
       dimension lres(ichaom,irenom),it1(ichaom),it2(ichaom)
       data lres /3*3
     e           /
       data it1 / 47,69,70
     a          /
       data it2 / 19,19,24
     a          /
       dimension acoef1(irenom),acoef2(irenom)
       data acoef1 /  51.6 /
       data acoef2 /  79.700 /
        do 10 j=1,irenom
         emres=emom(j)
         kon=j
         gemom(kon)=0.0
         do 11 i=1,ichaom
          dcrat(i,kon)=0.0
          embar=pmas(it1(i))
          emmes=pmas(it2(i))
          if(emres.gt.embar+emmes) then
            prres=pcmsr(emres,embar,emmes)
          else
            go to 11
          end if
          if(i.eq.1) then
            cosu3=1.0*acoef1(j)**2
          else
            cosu3=0.5*acoef2(j)**2
          end if
          gempar=cosu3*prres/emres*prres**(2*lres(i,j))
          dcrat(i,kon)=gempar
          gemom(kon)=gemom(kon)+gempar
   11    continue
         if(gemom(kon).eq.0.0) go to 10
         do 12 i=1,ichaom
   12    dcrat(i,kon)=dcrat(i,kon)/gemom(kon)
         gemom(kon)=1.e-3*gemom(kon)
   10  continue
       do 20 j=1,irenom
        write(6,22) (dcrat(i,j),i=1,ichaom)
   22  format(8x,3(f5.3,',',1x))
   20  continue
       write(6,22) (gemom(j),j=1,irenom)
      return
      end
      subroutine hyper(s,pr,em1,em2,
     a                  sig0,sig2,ityp1,npid1,ityp2,npid2)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 cgk20,cgk22
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       real*4 pssbar,pr4
        data sbrsup /1.0/
        pr4=pr
        sig0st=sig0
        sig2st=sig2
        sig0=0.0
        sig2=0.0
        itp1=ityp1
        npd1=npid1
        itp2=ityp2
        npd2=npid2
              emn=emnuc
              emk=emkap
              prkan=pcmsr(s,emk,emn)
              if(itp1.ge.7.and.itp1.le.9.and.npd1.eq.0) then
                vfspin=1.0
                str=1.0
              else if(itp1.ge.7.and.itp1.le.9.and.npd1.ne.0) then
                vfspin=0.3333
                str=1.0
              else if(itp1.ge.98.and.itp1.le.99.and.npd1.eq.34) then
                vfspin=0.3333
                str=1.0
              else if(itp1.eq.12.or.
     b              (itp1.ge.98.and.itp1.le.99.and.npd1.eq.25)) then
                vfspin=1.0
                if(em1.lt.0.6.or.(itp1.eq.99)) then
                  themix=pi2/360.0*anglmx(0,1)
                  valmix=0.3333*(cos(themix)-sqrt(2.)*sin(themix))**2
                else
                  valmix=1.0
                end if
                if(npd1.eq.25) valmix=1.-valmix
                str=valmix+(1.-valmix)*pssbar(ida(55),pr4)
              else if(itp1.ge.98.and.itp1.le.99.and.npd1.eq.35) then
                vfspin=0.3333
                str=pssbar(ida(55),pr4)
              else if(itp1.eq.14) then
                vfspin=1.0
                if(npd1.lt.0) then
                  str=1.0
                else
                  str=pssbar(ida(55),pr4)
                end if
              else if(itp1.ge.98.and.itp1.le.99.and.
     a              (iabs(npd1).eq.28.or.iabs(npd1).eq.29)) then
                vfspin=0.3333
                if(npd1.eq.-28.or.npd1.eq.-29) then
                  str=1.0
                else if(npd1.eq.28.or.npd1.eq.29) then
                  str=pssbar(ida(55),pr4)
                end if
              else
                write(lun8,*) itp1,npd1
                call errex('hyper: unknown ingoing meson')
              end if
              if(itp2.le.2) then
              else if(itp2.le.6) then
                vfspin=0.5*vfspin
                jdcod=mod(-npd2,1000)
              else if(itp2.ge.10.and.itp2.le.11) then
                nscod=mod(-npd2,1000)
                if(nscod.eq.1.or.nscod.eq.3.or.
     a                           nscod.eq.4.or.nscod.eq.8) then
                else if(nscod.eq.2.or.nscod.eq.7.or.nscod.eq.9) then
                  vfspin=0.5*vfspin
                else if(nscod.eq.5.or.nscod.eq.6) then
                  vfspin=0.3333*vfspin
                else
                  vfspin=0.25*vfspin
                end if
              else if(itp2.eq.13) then
                if(em2.lt.1.2) str=sbrsup*str
              else if(itp2.eq.15) then
                if(em2.lt.1.2) str=sbrsup*str
              else if(itp2.ge.98.and.itp2.le.99.and.
     a                 npd2.ge.65.and.npd2.le.67) then
                vfspin=0.5*vfspin
                if(npd2.eq.99) str=sbrsup*str
              else if(itp2.ge.98.and.itp2.le.99.and.
     a                 npd2.ge.46.and.npd2.le.47) then
              else if(itp2.ge.98.and.itp2.le.99.and.
     a                  npd2.ge.68.and.npd2.le.69) then
                vfspin=0.5*vfspin
              else
                write(lun8,*) itp2,npd2
                call errex('hyper: unknown ingoing baryon')
              end if
              emn=emnuc
              emk=emkap
              strrat=str*clphh(s,pr,em1,em2,ika1,ika2)
     a                   /clphh(s,prkan,emn,emk,ikan,ikak)
         call retcgk(itp1,npd1,itp2,npd2,0,cgk20)
         call retcgk(itp1,npd1,itp2,npd2,2,cgk22)
         vf=strrat*(prkan/pr)**2
         sig0=vf*sig0st*cgk20
         sig2=vf*sig2st*cgk22
      return
      end
      subroutine casca(srt,pr,em1,em2,sigstr,sigres,xs1530,
     a                      inchan,ltp1,kmul1,ltp2,kmul2)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 cgk212
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       real*4 pssbar,pr4
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       data srtl,ema,emb,incha /2.15,1.318,0.138,1/
       data em1530,pr1530,gm1530 /1.533,0.152,0.0095/
       data emcrit,sigbwl /2.30,19.56/
       if(kmul2.ne.0.or.kmul1.ne.0) then
         if(srt.le.emcrit) then
           sigres=cvalu0
           sigstr=cvalu0
           xs1530=cvalu0
           return
         else
           vfexc=1.-(emcrit/srt)**5.0
         end if
       else
         vfexc=1.0
       end if
       ltp1a=iabs(ltp1)
       ltp2a=iabs(ltp2)
       pr4=pr
       sigstr=0.0
       sigres=0.0
       xs1530=0.0
       idcode=0
       if(ltp2a.eq.17.or.ltp2a.eq.23) then
         if(kmul2.eq.0) then
           vfspin=1.0
           str=1.0
           idcode=1
         else
           vfspin=0.3333
           str=1.0
         end if
       else if(ltp2a.eq.27.or.ltp2a.eq.33) then
         vfspin=0.3333
         str=1.0
       else if(ltp2.eq.24) then
         vfspin=1.0
         if(kmul2.eq.0) then
           themix=pi2/360.0*anglmx(0,1)
           valmix=0.3333*(cos(themix)-sqrt(2.)*sin(themix))**2
           idcode=2
         else
           valmix=1.0
         end if
         str=valmix+(1.-valmix)*pssbar(ida(55),pr4)
       else if(ltp2.eq.25) then
         vfspin=1.0
         if(kmul2.eq.0) then
           themix=pi2/360.0*anglmx(0,1)
           valmix=0.3333*(cos(themix)-sqrt(2.)*sin(themix))**2
         else
           valmix=1.0
         end if
         str=(1.-valmix)+valmix*pssbar(ida(55),pr4)
       else if(ltp2.eq.34) then
         vfspin=0.3333
         str=1.0
       else if(ltp2.eq.35) then
         vfspin=0.3333
         str=pssbar(ida(55),pr4)
       else if(ltp2a.eq.18.or.ltp2a.eq.19) then
         vfspin=1.0
         if(ltp2.lt.0) then
           if(kmul2.eq.0) idcode=3
           str=1.0
         else
           if(kmul2.eq.0) idcode=4
           str=pssbar(ida(55),pr4)
         end if
       else if(ltp2a.ge.28.and.ltp2a.le.29) then
         vfspin=0.3333
         if(ltp2.lt.0) then
           str=1.0
         else
           str=pssbar(ida(55),pr4)
         end if
       else
         write(lun8,*) 'kmul2,ltp2=',kmul2,ltp2
         call errex('casca: unknown ingoing meson')
       end if
       if(ltp1.eq.57) then
         if(kmul1.eq.0) idcode=40+idcode
       else if(ltp1.ge.43.and.ltp1.le.45) then
         if(kmul1.eq.0) idcode=30+idcode
       else if(ltp1.ge.65.and.ltp1.le.67) then
         vfspin=0.5*vfspin
         if(kmul1.eq.0) idcode=50+idcode
       else if(ltp1.ge.46.and.ltp1.le.47) then
         if(kmul1.eq.0) idcode=10+idcode
       else if(ltp1.ge.68.and.ltp1.le.69) then
         vfspin=0.5*vfspin
         if(kmul1.eq.0) idcode=20+idcode
       else if(ltp1.eq.70)  then
         vfspin=0.5*vfspin
         if(kmul1.eq.0) idcode=60+idcode
       else
         write(lun8,*) 'ltp1,kmul1=',ltp1,kmul1
         call errex('casca: unknown ingoing baryon')
       end if
       if(idcode.eq.11) then
         inchan=1
       else if(idcode.eq.12) then
         inchan=2
       else if(idcode.eq.21) then
         inchan=3
       else if(idcode.eq.22) then
         inchan=4
       else if(idcode.eq.33) then
         inchan=5
       else if(idcode.eq.43) then
         inchan=6
       else if(idcode.eq.53) then
         inchan=7
       else if(idcode.eq.64) then
         inchan=8
       else
         inchan=100
       end if
       if(inchan.eq.1) then
         vfg=(em1530/srt)*1.2/(1.+0.2*(pr/pr1530)**2)
         g1530=vfg*(pr/pr1530)**2*gm1530
         bwsum=4.*g1530**2/((srt-em1530)**2+0.25*g1530**2)
         xs1530=0.5*pi*10.0*(hc/pi2)**2/pr**2*bwsum
       end if
       if(inchan.le.8.and.srt.gt.1.46) then
         bwsum=0.0
         do 172 km=1,5
          call bwdist(5,1,srt,km,inchan,dcrat,bwig)
          bwsum=bwsum+bwig
  172    continue
         sigres=vfspin*0.5*pi*10.0*(hc/pi2)**2/pr**2*bwsum
       end if
       if(srt.lt.srtl.and.ida(58).eq.1) then
         sigstr=0.0
       else if(srt.gt.em1530) then
         sigstr=sigbwl*(srtl**2/srt/srt)**da(7)
         pin=pcmsr(srt,ema,emb)
         bwsum=0.0
         do 174 km=1,5
          call bwdist(5,1,srt,km,incha,dcrat,bwig)
          bwsum=bwsum+bwig
  174    continue
         sigbws=0.5*pi*10.0*(hc/pi2)**2/pin**2*bwsum
         sigstr=max(sigstr-sigbws,cvalu0)
         strrat=str*clphh(srt,pr,em1,em2,ika1,ika2)
     a                   /clphh(srt,pin,ema,emb,ikaa,ikab)
         sigstr=strrat*(pin/pr)**2*sigstr
       else
         sigstr=0.0
       end if
       sigstr=vfexc*sigstr
       call retcgk(99,ltp1,99,ltp2,1,cgk212)
       sigres=cgk212*sigres
       sigstr=cgk212*sigstr
       xs1530=cgk212*xs1530
       sigres=sigres+xs1530
      return
      end
      logical function issers(jeng,ida38,itp,npid,emin)
       include 'scatter7'
#include "amsrqmd.h"
       issers=.false.
       call oldnew(1,itp,npid,emin,kmult,ltyp)
       if(jeng.eq.0.and.kmult.ne.0) return
       ltypa=iabs(ltyp)
       if(ida38.eq.1) then
         if(ltypa.eq.18.or.ltypa.eq.19) then
           issers=.true.
         end if
         if(jeng.ne.0) then
           if(ltypa.eq.28.or.ltypa.eq.29) then
             issers=.true.
           end if
         end if
       else if(ida38.eq.2) then
         if(ltypa.eq.44.or.ltypa.eq.57) then
           issers=.true.
         end if
         if(jeng.ne.0) then
           if((ltypa.ge.43.and.ltypa.le.45).or.
     a        (ltypa.ge.46.and.ltypa.le.47).or.
     b        (ltypa.ge.65.and.ltypa.le.70)
     c                                          ) then
             issers=.true.
           end if
         end if
       else if(ida38.eq.5) then
         if(ltyp.eq.35) then
           issers=.true.
         end if
       else if(ida38.eq.7) then
         if(ltypa.eq.46.or.ltypa.eq.47.or.
     a            ltypa.eq.68.or.ltypa.eq.69) then
           issers=.true.
         end if
       else
         call errex('issers:undefined ida38')
       end if
      return
      end
      function gamvec(pr,id)
#include "amsrqmd.h"
       data radmes/ 1.0/
       dimension asolid(3)
       data asolid /3.5523,2.2583,2.5637/
       gctact=(pr*radmes)**2/(1.+(pr*radmes)**2)
       iabid=iabs(id)
       if(iabid.eq.27.or.iabid.eq.33) then
         ip=1
       else if(iabid.eq.28.or.iabid.eq.29) then
         ip=2
       else if(iabid.eq.35) then
         ip=3
       else
         call errex('gamvec:unknown resonance')
       end if
       gamvec=asolid(ip)*gctact*pr
      return
      end
CPAT,MESMES   .
      subroutine mesmes(jesant,
     a    srt,prel,xsect,em1,em2,ic,
     b     kmulo1,ltypo1,kmulo2,ltypo2,kmuln1,ltypn1,kmuln2,ltypn2,
     c                                                   iswave,iswi)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 s,pr,xsppv
       if(kmulo1.ne.0.or.kmulo2.ne.0) then
         if(iswi.eq.0) then
           xsect=0.0
         else
           call errex('mesmes should not be called')
         end if
         return
       end if
       s=srt
       pr=prel
       kf1=ltypo1
       kf2=ltypo2
       call luiflv(kf1,ifla1,iflb1,iflc1,ksp)
       call luiflv(kf2,ifla2,iflb2,iflc2,ksp)
       istr1=0
       if(iabs(ifla1).eq.3) istr1=isign(1,ifla1)
       if(iabs(iflb1).eq.3) istr1=istr1+isign(1,iflb1)
       istr2=0
       if(iabs(ifla2).eq.3) istr2=isign(1,ifla2)
       if(iabs(iflb2).eq.3) istr2=istr2+isign(1,iflb2)
       istr=istr1+istr2
       if(istr.eq.1) then
         iqcn=1
         kf1=kfcrev(kf1)
         kf2=kfcrev(kf2)
         istr=-1
       else
         iqcn=0
       end if
       call pspsv(s,pr,xsppv,istr,kf1,kf2,iswave,0)
       xsect=xsppv
       if(iswi.eq.1) then
         itry=0
   10    continue
         if(xsect.eq.0.0) then
           ic=0
           return
         else
           call pspsv(s,pr,xsppv,istr,kf1,kf2,iswave,iswi)
         end if
         if(kf2.eq.0) then
           em1=srt
           em2=0.0
           ic=-2
         else
           em1=getmas(0,kf1,1,-1.0)
           em2=getmas(0,kf2,1,-1.0)
         end if
         if(kf2.ne.0.and.srt-ekinmi.lt.em1+em2) then
           itry=itry+1
           if(itry.lt.10) then
             go to 10
           else
             ic=0
             return
           end if
         end if
         if(ranf(0).gt.0.5) then
           call swap(em1,em2)
           call iswap(kf1,kf2)
         end if
         kf1a=iabs(kf1)
         kf2a=iabs(kf2)
         if(kf1a/100.eq.60) then
           iyess1=1
           jesant=1
           kmuln1=-1
         else
           iyess1=0
           kmuln1=kf1a/100
         end if
         if(kf2a/100.eq.60) then
           iyess2=1
           jesant=1
           kmuln2=-1
         else
           iyess2=0
           kmuln2=kf2a/100
         end if
         kf1=isign(1,kf1)*mod(kf1a,100)
         kf2=isign(1,kf2)*mod(kf2a,100)
         if(iqcn.eq.1) then
           ltypn1=kfcrev(kf1)
           ltypn2=kfcrev(kf2)
         else
           ltypn1=kf1
           ltypn2=kf2
         end if
       end if
      return
      end
      subroutine pspsv(srt,pin,xsect,istr,itp1,itp2,iswave,iswi)
#include "amsrqmd.h"
      common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       parameter (maxcha=20,iclass=10)
       dimension sigcha(maxcha),ktpout(2,maxcha)
       logical isotro(maxcha)
       logical fndwq
       logical empiri
       dimension pjin(4),sigiso(0:2)
       common /pjbk/ pjin
       dimension fndwq(0:iclass)
       data  thetav,thetas  / 35.3 , -10.1 /
       dimension xsmmcl(9)
       data xsmmcl/
     a  9.150,15.632,16.386,14.408,12.476,20.837, 0.0,4.342,1.696
     b           /
       data  icall /1/
       data  empiri  / .false. /
       logical new
       data  new  / .false. /
       do 10 i=0,iclass
   10  fndwq(i)=.false.
       xsect=0.0
       ktp1=0
       ktp2=0
       if(itp1.eq.17) then
         ktp1=1
         i31=2
         i1=2
         igp1=-1
       else if(itp1.eq.-17) then
         ktp1=1
         i31=-2
         i1=2
         igp1=-1
       else if(itp1.eq.23) then
         ktp1=1
         i31=0
         i1=2
         igp1=-1
       else if(itp1.eq.18) then
         ktp1=2
         i31=1
         i1=1
         igp1=0
       else if(itp1.eq.-18) then
         ktp1=3
         i31=-1
         i1=1
         igp1=0
       else if(itp1.eq.19) then
         ktp1=2
         i31=-1
         i1=1
         igp1=0
       else if(itp1.eq.-19) then
         ktp1=3
         i31=1
         i1=1
         igp1=0
       else if(itp1.eq.24) then
         ktp1=4
         i31=0
         i1=0
         igp1=1
       else if(itp1.eq.27) then
         ktp1=5
         i31=2
         i1=2
         igp1=1
       else if(itp1.eq.-27) then
         ktp1=5
         i31=-2
         i1=2
         igp1=1
       else if(itp1.eq.33) then
         ktp1=5
         i31=0
         i1=2
         igp1=1
       else if(itp1.eq.28) then
         ktp1=6
         i31=1
         i1=1
         igp1=0
       else if(itp1.eq.-28) then
         ktp1=7
         i31=-1
         i1=1
         igp1=0
       else if(itp1.eq.29) then
         ktp1=6
         i31=-1
         i1=1
         igp1=0
       else if(itp1.eq.-29) then
         ktp1=7
         i31=1
         i1=1
         igp1=0
       else if(itp1.eq.34) then
         ktp1=8
         i31=0
         i1=0
         igp1=-1
       else if(itp1.eq.35) then
         ktp1=9
         i31=0
         i1=0
         igp1=-1
       end if
       if(itp2.eq.17) then
         ktp2=1
         i32=2
         i2=2
         igp2=-1
       else if(itp2.eq.-17) then
         ktp2=1
         i32=-2
         i2=2
         igp2=-1
       else if(itp2.eq.23) then
         ktp2=1
         i32=0
         i2=2
         igp2=-1
       else if(itp2.eq.18) then
         ktp2=2
         i32=1
         i2=1
         igp2=0
       else if(itp2.eq.-18) then
         ktp2=3
         i32=-1
         i2=1
         igp2=0
       else if(itp2.eq.19) then
         ktp2=2
         i32=-1
         i2=1
         igp2=0
       else if(itp2.eq.-19) then
         ktp2=3
         i32=1
         i2=1
         igp2=0
       else if(itp2.eq.24) then
         ktp2=4
         i32=0
         i2=0
         igp2=1
       else if(itp2.eq.27) then
         ktp2=5
         i32=2
         i2=2
         igp2=1
       else if(itp2.eq.-27) then
         ktp2=5
         i32=-2
         i2=2
         igp2=1
       else if(itp2.eq.33) then
         ktp2=5
         i32=0
         i2=2
         igp2=1
       else if(itp2.eq.28) then
         ktp2=6
         i32=1
         i2=1
         igp2=0
       else if(itp2.eq.-28) then
         ktp2=7
         i32=-1
         i2=1
         igp2=0
       else if(itp2.eq.29) then
         ktp2=6
         i32=-1
         i2=1
         igp2=0
       else if(itp2.eq.-29) then
         ktp2=7
         i32=1
         i2=1
         igp2=0
       else if(itp2.eq.34) then
         ktp2=8
         i32=0
         i2=0
         igp2=-1
       else if(itp2.eq.35) then
         ktp2=9
         i32=0
         i2=0
         igp2=-1
       end if
       if(iswi.eq.0) then
         if(ktp1.eq.0.or.ktp2.eq.0) then
           return
         end if
       else
         if(ktp1.eq.0.or.ktp2.eq.0) then
           return
         end if
       end if
       iii=max(ktp1,ktp2)
       jjj=min(ktp1,ktp2)
       iclcod=iii*(iii-1)/2+jjj
       if(iclcod.eq.1) then
         fndwq(0)=.true.
         fndwq(1)=.true.
         fndwq(4)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.2) then
         fndwq(2)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.3) then
       else if(iclcod.eq.4) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.5) then
         fndwq(1)=.true.
         fndwq(3)=.true.
         fndwq(6)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.6) then
       else if(iclcod.eq.7) then
         fndwq(3)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.8) then
         fndwq(5)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.9) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.10) then
         fndwq(9)=.true.
       else if(iclcod.eq.11) then
         fndwq(1)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.12) then
         fndwq(2)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.13) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.14) then
         fndwq(3)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.15) then
         fndwq(1)=.true.
         fndwq(4)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.16) then
         fndwq(9)=.true.
       else if(iclcod.eq.17) then
       else if(iclcod.eq.18) then
         fndwq(1)=.true.
         fndwq(3)=.true.
         fndwq(6)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.19) then
         fndwq(9)=.true.
       else if(iclcod.eq.20) then
         fndwq(10)=.true.
       else if(iclcod.eq.21) then
       else if(iclcod.eq.22) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.23) then
         fndwq(1)=.true.
         fndwq(3)=.true.
         fndwq(6)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.24) then
       else if(iclcod.eq.25) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.26) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.27) then
         fndwq(1)=.true.
         fndwq(3)=.true.
         fndwq(10)=.true.
       else if(iclcod.eq.28) then
       else if(iclcod.eq.29) then
         fndwq(3)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.30) then
         fndwq(2)=.true.
         fndwq(5)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.31) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.32) then
         fndwq(6)=.true.
         fndwq(10)=.true.
       else if(iclcod.eq.33) then
         fndwq(3)=.true.
         fndwq(10)=.true.
       else if(iclcod.eq.34) then
         fndwq(2)=.true.
         fndwq(5)=.true.
         fndwq(10)=.true.
       else if(iclcod.eq.35) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.36) then
         fndwq(6)=.true.
         fndwq(10)=.true.
       else if(iclcod.eq.37) then
         fndwq(9)=.true.
       else if(iclcod.eq.38) then
         fndwq(2)=.true.
         fndwq(5)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.39) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.40) then
         fndwq(6)=.true.
         fndwq(9)=.true.
       else if(iclcod.eq.41) then
         fndwq(3)=.true.
       else if(iclcod.eq.42) then
         fndwq(2)=.true.
         fndwq(5)=.true.
         fndwq(10)=.true.
       else if(iclcod.eq.43) then
         call errex('pspsv:s=-1 ingoing')
       else if(iclcod.eq.44) then
         fndwq(6)=.true.
       else if(iclcod.eq.45) then
         fndwq(6)=.true.
         fndwq(10)=.true.
       end if
       kchact=0
       if(fndwq(0)) then
         if(srt.lt.0.99) then
           srtact=srt
         else
           srtact=0.99
         end if
           zmltp=80.*3.1415927/(5.0674**2)
           sigiso(0)=0.0
           sigiso(1)=0.0
           delt02=-0.12*pin/pmas(23)
           sigiso(2)=zmltp/(pin*pin)*(sin(delt02))**2
           if(srt.gt.0.99) then
             sigiso(2)=sigiso(2)*(0.99/srt)
           end if
         itag=-100
         call isocgk(i31,i1,i32,i2,2,2,i31new,i32new,itag)
         m=i31+i32
         iabm=iabs(m)
         iff=0
         pjsum=0.
         do 95 loop=iabm,4,2
          iff=iff+1
          jtrue=loop/2
          pjin(iff)=pjin(iff)* sigiso(jtrue)
          sigiso(jtrue)=pjin(iff)
          pjsum=pjsum+pjin(iff)
          sig=sigiso(jtrue)
          xsect=xsect+sig
          if(iswi.eq.1) then
               kchact=min(kchact+1,maxcha)
               sigcha(kchact)=sig
               itag=-50
               jtot=loop
               call isonew(jtot,m,2,2,ia,ib,itag)
               ktpout(1,kchact)=ia/2*17+23*(2-iabs(ia))/2
               ktpout(2,kchact)=ib/2*17+23*(2-iabs(ib))/2
          end if
   95    continue
       end if
       if(fndwq(1)) then
         if(mod(i31,2).eq.0.and.mod(i32,2).eq.0) then
           if(iclcod.eq.1) then
             if(i31+i32.eq.0.and.empiri) then
               jfine=0
             else if(i31.eq.i32.or.iabs(i31+i32).eq.2) then
               jfine=2
             else
               jfine=1
             end if
           else if(iclcod.eq.11) then
             jfine=3
           else if(iclcod.eq.15) then
             if(i31.eq.i32.or.iabs(i31+i32).eq.2) then
               jfine=5
             else
               jfine=4
             end if
           else
             call errex('pspsv:illegal iclcod  in block1')
           end if
  100      continue
           sigred=4.*spspsv(1,jfine,srt)
           if(sigred.eq.0.0) go to 105
           if(iclcod.eq.15) then
             em1new=pmas(19)
             em2new=em1new
             if(srt.le.em1new+em2new) then
                pout=0.0
             else
                pout=prcms(srt,em1new,em2new)
             end if
             sigred=0.11111*sigred*(pout/pin)**2
           end if
           do 101 l=-1,1,2
            fiso=cgksq1(-l,i32+l)*cgksq1(-(i32+l+i31),(i32+l))
            if(fiso.ne.0.) then
              if(jfine.eq.0) fiso=0.25
              sig=sigred*fiso
              xsect=xsect+sig
              if(iswi.eq.1) then
                kchact=min(kchact+1,maxcha)
                sigcha(kchact)=sig
                j=(i32+l+i31)
                ktpout(1,kchact)=17+(3-j)/2
                ktpout(2,kchact)=-17-(3-l)/2
                if(jfine.eq.3) then
                  if(ktp1.eq.5) then
                    ktpout(2,kchact)=ktpout(2,kchact)-10
                  else
                    ktpout(1,kchact)=ktpout(1,kchact)+10
                  end if
                else if(jfine.eq.6.or.jfine.eq.7) then
                    ktpout(1,kchact)=ktpout(1,kchact)+10
                    ktpout(2,kchact)=ktpout(2,kchact)-10
                end if
              end if
            end if
  101      continue
           if((ktp1.ne.ktp2.or.i31.ne.i32).and.
     a         jfine.ne.2.and.jfine.ne.5.and.jfine.ne.7) then
             do 102 j=-1,1,2
              fiso=cgksq1(j,i32-j)*cgksq1(-(i32-j+i31),(i32-j))
              if(fiso.ne.0.) then
                if(jfine.eq.0) fiso=0.25
                sig=sigred*fiso
                xsect=xsect+sig
                if(iswi.eq.1) then
                  kchact=min(kchact+1,maxcha)
                  sigcha(kchact)=sig
                  l=-(i32-j+i31)
                  ktpout(1,kchact)=17+(3-j)/2
                  ktpout(2,kchact)=-17-(3-l)/2
                  if(jfine.eq.3) then
                    if(ktp1.eq.5) then
                      ktpout(1,kchact)=ktpout(1,kchact)+10
                    else
                      ktpout(2,kchact)=ktpout(2,kchact)-10
                    end if
                  else if(jfine.eq.6.or.jfine.eq.7) then
                    ktpout(1,kchact)=ktpout(1,kchact)+10
                    ktpout(2,kchact)=ktpout(2,kchact)-10
                  end if
                end if
              end if
  102        continue
           end if
  105      continue
           if(jfine.le.2) then
             if(jfine.eq.0) then
               if(i31.eq.i32) then
                 jfine=2
               else
                 jfine=1
               end if
             end if
             jfine=jfine+5
             go to 100
           end if
         else if(mod(iabs(i31),2).eq.1.and.mod(iabs(i32),2).eq.1) then
           do 103 i=-1,1,2
            fiso=cgksq1(i31,i)*cgksq1(i32,-i)
            if(fiso.ne.0.) then
              ib=i31+i
              ia=i32-i
              ktpo1=ib/2*17+23*(2-iabs(ib))/2
              ktpo2=ia/2*17+23*(2-iabs(ia))/2
              if(iclcod.eq.5) then
                if(i31+i32.eq.0.and.empiri) then
                  fiso=0.25
                  jfine=0
                  if(ktpo1.eq.ktpo2) then
                    symm=0.5
                  else
                    symm=1.0
                  end if
                else if(ktpo1.eq.ktpo2.or.iabs(i31+i32).eq.2) then
                  jfine=2
                  if(ktpo1.eq.ktpo2) then
                    symm=0.5
                  else
                    symm=1.0
                  end if
                else
                  jfine=1
                  symm=1.0
                end if
                em1new=pmas(23)
                em2new=em1new
              else if(iclcod.eq.27) then
                if(ktpo1.eq.ktpo2.or.iabs(i31+i32).eq.2) then
                  jfine=7
                  symm=0.5*0.11111
                else
                  jfine=6
                  symm=0.11111
                end if
                em1new=pmas(23)
                em2new=em1new
              else if(iclcod.eq.18.or.iclcod.eq.23) then
                jfine=3
                symm=1.0
                em1new=pmas(33)
                em2new=pmas(23)
              else
                call errex('pspsv103:illegal iclcod  in block1')
              end if
              if(srt.le.em1new+em2new) then
                pout=0.0
              else
                pout=prcms(srt,em1new,em2new)
              end if
              sigred=4.*spspsv(1,jfine,srt)*(pout/pin)**2*symm
              sig=sigred*fiso
              xsect=xsect+sig
              if(iswi.eq.1) then
                kchact=min(kchact+1,maxcha)
                sigcha(kchact)=sig
                ktpout(1,kchact)=ktpo1
                ktpout(2,kchact)=ktpo2
                if(jfine.eq.3) then
                  if(ktp1.eq.6.or.ktp1.eq.7) then
                    ktpout(2,kchact)=isign(1,ktpo2)*(iabs(ktpo2)+10)
                  else
                    ktpout(1,kchact)=isign(1,ktpo1)*(iabs(ktpo1)+10)
                  end if
                end if
              end if
              if(iclcod.eq.5) then
                jfine=jfine+2
                sig=4.*spspsv(1,jfine,srt)*symm
                xsect=xsect+sig
                if(iswi.eq.1) then
                  kchact=min(kchact+1,maxcha)
                  sigcha(kchact)=sig
                  ktpout(1,kchact)=isign(1,ktpo1)*(iabs(ktpo1)+10)
                  ktpout(2,kchact)=isign(1,ktpo2)*(iabs(ktpo2)+10)
                end if
              end if
              if(iabs(i31+i32).eq.2.and.
     a            (iclcod.eq.5.or.iclcod.eq.27)) go to 104
            end if
  103      continue
  104      continue
         else
           call errex('pspsv:illegal isospin entrance in block1')
         end if
       end if
       if(fndwq(2)) then
         if(iclcod.eq.2.or.iclcod.eq.4.or.
     a                 iclcod.eq.12.or.iclcod.eq.13) then
            if(mod(iclcod,10).eq.2) then
              iqrev=0
            else
              iqrev=1
            end if
            if(ktp1.eq.1.or.ktp1.eq.5) then
              ia=i31*(-1)**iqrev
              j=i32*(-1)**iqrev
            else
              ia=i32*(-1)**iqrev
              j=i31*(-1)**iqrev
            end if
            fiso=cgksq1(ia+j,-j)
            if(fiso.ne.0.) then
              if(iclcod.ge.12) then
                jfine=3
              else
                jfine=1
              end if
              sig=2.*fiso*
     a               spspsv(2,jfine,srt)*sin(thetav/360.0*6.283154)**2
              xsect=xsect+sig
              if(iswi.eq.1) then
                kchact=min(kchact+1,maxcha)
                sigcha(kchact)=sig
                i3out=ia+j
                ktpo1=17+(3-i3out)/2
                if(iclcod.lt.12) then
                  ktpo1=ktpo1+10
                end if
                ktpout(1,kchact)=(-1)**iqrev*ktpo1
                ktpout(2,kchact)=34
              end if
              jfine=jfine+1
              sig=2.*fiso*
     a               spspsv(2,jfine,srt)*cos(thetav/360.0*6.283154)**2
              xsect=xsect+sig
              if(iswi.eq.1) then
                kchact=min(kchact+1,maxcha)
                sigcha(kchact)=sig
                ktpout(1,kchact)=ktpout(1,kchact-1)
                ktpout(2,kchact)=35
              end if
            end if
         else
            if(ktp1.eq.8.or.ktp1.eq.9) then
              ikaon=ktp2
              iw8=itp1
              if(ktp2.eq.2.or.ktp2.eq.6) then
                iqrev=0
              else if(ktp2.eq.3.or.ktp2.eq.7) then
                iqrev=1
              else
                call errex('pspsv:missing k in omega/k channel')
              end if
            else if(ktp2.eq.8.or.ktp2.eq.9) then
              iw8=itp2
              ikaon=ktp1
              if(ktp1.eq.2.or.ktp1.eq.6) then
                iqrev=0
              else if(ktp1.eq.3.or.ktp1.eq.7) then
                iqrev=1
              else
                call errex('pspsv:missing k in omega/k channel')
              end if
            else
              call errex('pspsv:missing omega/phi in omega/k channel')
            end if
            l=(-1)**iqrev*(i31+i32)
            do 201 j=-1,1,2
             fiso=cgksq1(j,l)
             if(fiso.ne.0.) then
               if(ikaon.ge.6) then
                jfine=1
                em2new=pmas(23)
                spf=0.1111
               else
                jfine=3
                em2new=pmas(33)
                spf=1.0
               end if
               if(iw8.eq.35) then
                fthet=cos(thetav/360.0*6.283154)**2
                jfine=jfine+1
               else
                fthet=sin(thetav/360.0*6.283154)**2
               end if
               em1new=pmas(19)
               if(srt.le.em1new+em2new) then
                 pout=0.0
               else
                 pout=prcms(srt,em1new,em2new)
               end if
               sig=2.*fiso*spspsv(2,jfine,srt)*fthet*(pout/pin)**2*spf
               xsect=xsect+sig
               if(iswi.eq.1) then
                 kchact=min(kchact+1,maxcha)
                 sigcha(kchact)=sig
                 i3out=l+j
                 ktpo1=17+(3+j)/2
                 ktpo2=(-1)**iqrev*(i3out/2*17)+23*(2-iabs(i3out))/2
                 if(ikaon.le.3) then
                   ktpo2=isign(1,ktpo2)*(iabs(ktpo2)+10)
                 end if
                 ktpout(1,kchact)=(-1)**iqrev*ktpo1
                 ktpout(2,kchact)=ktpo2
               end if
             end if
  201       continue
         end if
       end if
       if(fndwq(3)) then
         if(i31.eq.0.or.i32.eq.0) then
           if(iclcod.eq.7) then
             proj8=cos(thetas/360.0*6.283154)**2
             jfine=1
           else if(iclcod.eq.14) then
             proj8=cos(thetas/360.0*6.283154)**2
             jfine=3
           else if(iclcod.eq.29) then
             proj8=sin(thetav/360.0*6.283154)**2
             jfine=4
           else if(iclcod.eq.33) then
             proj8=sin(thetav/360.0*6.283154)**2
             jfine=6
           else if(iclcod.eq.41) then
             proj8=cos(thetav/360.0*6.283154)**2
             jfine=7
           else
             call errex('pspsv:illegal iclcod  in block1')
           end if
           ia=i31+i32
           sigrpi=2.*spspsv(3,2,srt)*proj8
           sigred=2.*spspsv(3,jfine,srt)*proj8
           if(iclcod.eq.33.or.iclcod.eq.41) then
             em1new=pmas(19)
             em2new=em1new
             if(srt.le.em1new+em2new) then
                pout=0.0
             else
                pout=prcms(srt,em1new,em2new)
             end if
             sigred=0.11111*sigred*(pout/pin)**2
           end if
           do 301 l=-1,1,2
            fiso=cgksq1(l,ia-l)
            if(fiso.ne.0.) then
              sig=sigred*fiso
              xsect=xsect+sig
              if(iclcod.eq.7) then
                sigp=sigrpi*fiso
                xsect=xsect+sigp
              end if
              if(iswi.eq.1) then
                kchact=min(kchact+1,maxcha)
                sigcha(kchact)=sig
                ktpout(1,kchact)=17+(3-l)/2
                ktpout(2,kchact)=-17-(3+(ia-l))/2
                if(iclcod.eq.7) then
                  kchact=min(kchact+1,maxcha)
                  sigcha(kchact)=sigp
                  ktpout(1,kchact)=27+(3-l)/2
                  ktpout(2,kchact)=-27-(3+(ia-l))/2
                else if(iclcod.eq.33.or.iclcod.eq.41) then
                else
                  if(jfine.eq.3) then
                    ktpout(1,kchact)=ktpout(1,kchact)+10
                  else if(jfine.eq.4) then
                    ktpout(2,kchact)=ktpout(2,kchact)-10
                  end if
                  xsect=xsect+sig
                  kchact=min(kchact+1,maxcha)
                  sigcha(kchact)=sig
                  ktpout(1,kchact)=-17-(3+l)/2
                  ktpout(2,kchact)=17+(3-(ia-l))/2
                  if(jfine.eq.3) then
                    ktpout(1,kchact)=ktpout(1,kchact)-10
                  else if(jfine.eq.4) then
                    ktpout(2,kchact)=ktpout(2,kchact)+10
                  end if
                end if
              end if
            end if
  301      continue
         else if(mod(iabs(i31),2).eq.1.and.mod(iabs(i32),2).eq.1) then
           if(iclcod.eq.5) then
             janf=5
             jend=7
           else if(iclcod.eq.18.or.iclcod.eq.23) then
             janf=2
             jend=3
           else if(iclcod.eq.27) then
             janf=1
             jend=1
           else
             call errex('spspv:wrong iclcod in block3,detailed balance')
           end if
           do 303 j=janf,jend
            jfine=1+mod(j,7)
            sigred=2.*spspsv(3,jfine,srt)
            fiso=cgksq1(i31,i32)
            if(fiso.ne.0.) then
               i3out=i31+i32
               if(jfine.eq.1) then
                 em1new=pmas(24)
                 em2new=pmas(23)
                 spf=cos(thetas/360.0*6.283154)**2
                 ktpo1=24
                 ktpo2=(i3out/2*17+23*(2-iabs(i3out))/2)
               else if(jfine.eq.2) then
                 em1new=pmas(24)
                 em2new=pmas(23)
                 spf=0.1111*cos(thetas/360.0*6.283154)**2
                 ktpo1=24
                 ktpo2=(i3out/2*17+23*(2-iabs(i3out))/2)
               else if(jfine.eq.3) then
                 em1new=pmas(24)
                 em2new=pmas(33)
                 spf=cos(thetas/360.0*6.283154)**2
                 ktpo1=24
                 ktpo2=(i3out/2*27+33*(2-iabs(i3out))/2)
               else if(jfine.eq.4) then
                 em1new=pmas(34)
                 em2new=pmas(23)
                 spf=sin(thetav/360.0*6.283154)**2
                 ktpo1=34
                 ktpo2=(i3out/2*17+23*(2-iabs(i3out))/2)
               else if(jfine.eq.6) then
                 em1new=pmas(34)
                 em2new=pmas(33)
                 spf=sin(thetav/360.0*6.283154)**2
                 ktpo1=34
                 ktpo2=(i3out/2*27+33*(2-iabs(i3out))/2)
               else if(jfine.eq.7) then
                 em1new=pmas(35)
                 em2new=pmas(33)
                 spf=cos(thetav/360.0*6.283154)**2
                 ktpo1=35
                 ktpo2=(i3out/2*27+33*(2-iabs(i3out))/2)
               else
                 call errex('pspsv:wrong jfine in block3,det.balance')
               end if
               if(srt.le.em1new+em2new) then
                 pout=0.0
               else
                 pout=prcms(srt,em1new,em2new)
               end if
               if(jfine.eq.6.or.jfine.eq.7) then
                 sig=fiso*spf*sigred
               else
                 sig=fiso*spf*sigred*(pout/pin)**2
               end if
               xsect=xsect+sig
               if(iswi.eq.1) then
                 kchact=min(kchact+1,maxcha)
                 sigcha(kchact)=sig
                 ktpout(1,kchact)=ktpo1
                 ktpout(2,kchact)=ktpo2
               end if
            end if
  303      continue
         else
           call errex('pspsv:wrong input in block3')
         end if
       end if
       if(fndwq(4)) then
       end if
       if(fndwq(5)) then
         if(iclcod.eq.8.or.iclcod.eq.9.or.
     a                 iclcod.eq.30.or.iclcod.eq.31) then
            if(iclcod.ge.30) then
              jfine=1
              fthet=sin(thetav)**4
            else
              jfine=3
              fthet=sin(thetav)**2*cos(thetas)**2
            end if
            sig=spspsv(5,jfine,srt)*fthet
            xsect=xsect+sig
            if(iswi.eq.1) then
               kchact=min(kchact+1,maxcha)
               sigcha(kchact)=sig
               if(ktp1.eq.2.or.ktp1.eq.3) then
                 ktpo1=itp1
               else if(ktp2.eq.2.or.ktp2.eq.3) then
                 ktpo1=itp2
               else
                 call errex('pspsv:missing k/kbar in fndwq5 channel')
               end if
               if(iclcod.le.9) then
                 ktpo1=isign(1,ktpo1)*(iabs(ktpo1)+10)
               end if
               ktpout(1,kchact)=ktpo1
               ktpout(2,kchact)=34
            end if
            jfine=jfine+1
            if(iclcod.ge.30) then
              fthet=cos(thetav)**2*sin(thetav)**2
            else
              fthet=cos(thetav)**2*cos(thetas)**2
            end if
            sig=spspsv(5,jfine,srt)*fthet
            xsect=xsect+sig
            if(iswi.eq.1) then
               kchact=min(kchact+1,maxcha)
               sigcha(kchact)=sig
               ktpout(1,kchact)=ktpout(1,kchact-1)
               ktpout(2,kchact)=35
            end if
         else
            if(iclcod.le.35) then
              jfine=3
              fthet=sin(thetav)**2*cos(thetas)**2
              spf=0.111111
              em2new=pmas(24)
            else if(iclcod.le.39) then
              jfine=2
              fthet=cos(thetav)**2*sin(thetav)**2
              spf=1.
              em2new=pmas(34)
            else
              jfine=4
              fthet=cos(thetav)**2*cos(thetas)**2
              spf=0.111111
              em2new=pmas(24)
            end if
            em1new=pmas(19)
            if(srt.le.em1new+em2new) then
              pout=0.0
            else
              pout=prcms(srt,em1new,em2new)
            end if
            sig=spspsv(5,jfine,srt)*fthet*(pout/pin)**2*spf
            xsect=xsect+sig
            if(iswi.eq.1) then
               kchact=min(kchact+1,maxcha)
               sigcha(kchact)=sig
               if(ktp1.eq.9.or.ktp1.eq.8) then
                 ktpo1=itp2
               else if(ktp2.eq.9.or.ktp2.eq.8) then
                 ktpo1=itp1
               else
                 call errex('pspsv:missing phi/ome in fndwq5 channel')
               end if
               if(iclcod.ge.42.or.iclcod.le.35) then
                 ktpo1=isign(1,ktpo1)*(iabs(ktpo1)-10)
                 ktpo2=24
               else
                 ktpo2=34
               end if
               ktpout(1,kchact)=ktpo1
               ktpout(2,kchact)=ktpo2
            end if
         end if
       end if
       if(fndwq(6)) then
         if(iclcod.eq.5.or.iclcod.eq.18.or.
     a                 iclcod.eq.23) then
           if(mod(itp1,10)+mod(itp2,10).eq.0) then
            if(iclcod.eq.5) then
              jfine=1
              fthet=sin(thetav)**4
            else
              jfine=4
              fthet=sin(thetav)**2*cos(thetas)**2
            end if
            sig=spspsv(6,jfine,srt)*fthet
            xsect=xsect+sig
            if(iswi.eq.1.and.sig.ne.0.0) then
               kchact=min(kchact+1,maxcha)
               sigcha(kchact)=sig
               if(iclcod.eq.5) then
                ktpo2=34
               else
                ktpo2=24
               end if
               ktpout(1,kchact)=34
               ktpout(2,kchact)=ktpo2
            end if
            if(iclcod.eq.5) then
              fthet=sin(thetav)**2*cos(thetav)**2
            else
              fthet=cos(thetav)**2*cos(thetas)**2
            end if
            jfine=jfine+1
            sig=spspsv(6,jfine,srt)*fthet
            if(iswi.eq.1.and.sig.ne.0.0) then
               kchact=min(kchact+1,maxcha)
               sigcha(kchact)=sig
               ktpout(1,kchact)=35
               ktpout(2,kchact)=ktpout(2,kchact-1)
            end if
            if(iclcod.eq.5) then
              jfine=jfine+1
              fthet=cos(thetav)**4
              sig=spspsv(6,jfine,srt)*fthet
              if(iswi.eq.1.and.sig.ne.0.0) then
                kchact=min(kchact+1,maxcha)
                sigcha(kchact)=sig
                ktpout(1,kchact)=35
                ktpout(2,kchact)=35
              end if
            end if
           end if
         else
            if(iclcod.eq.36) then
              jfine=1
              fthet=sin(thetav)**4
              spf=0.111111
            else if(iclcod.eq.44) then
              jfine=2
              fthet=sin(thetav)**2*cos(thetav)**2
              spf=0.111111
            else if(iclcod.eq.45) then
              jfine=3
              fthet=cos(thetav)**4
              spf=0.111111
            else if(iclcod.eq.32) then
              jfine=4
              fthet=sin(thetav)**2*cos(thetas)**2
              spf=1.0
            else if(iclcod.eq.40) then
              jfine=5
              fthet=cos(thetav)**2*cos(thetas)**2
              spf=1.0
            else
              call errex('pspsv:wrong iclcod in block6,det.balance')
            end if
            em1new=pmas(19)
            if(iclcod.eq.32.or.iclcod.eq.40) then
             em2new=pmas(29)
            else
             em2new=pmas(19)
            end if
            if(srt.le.em1new+em2new) then
              pout=0.0
            else
              pout=prcms(srt,em1new,em2new)
            end if
            sig=spspsv(6,jfine,srt)*fthet*(pout/pin)**2*spf
            xsect=xsect+sig
            if(iswi.eq.1) then
             if(iclcod.eq.32.or.iclcod.eq.40) then
               ktpo1=28
             else
               ktpo1=18
             end if
             kchact=min(kchact+1,maxcha)
             sigcha(kchact)=sig
             ktpout(1,kchact)=ktpo1
             ktpout(2,kchact)=-18
             kchact=min(kchact+1,maxcha)
             sigcha(kchact)=sig
             ktpout(1,kchact)=ktpout(1,kchact-1)+1
             ktpout(2,kchact)=-19
             if(iclcod.eq.32.or.iclcod.eq.40) then
              kchact=min(kchact+1,maxcha)
              sigcha(kchact)=sig
              ktpout(1,kchact)=-28
              ktpout(2,kchact)=18
              kchact=min(kchact+1,maxcha)
              sigcha(kchact)=sig
              ktpout(1,kchact)=-29
              ktpout(2,kchact)=19
             end if
            end if
         end if
       end if
       if(fndwq(7)) then
       end if
       if(fndwq(8)) then
       end if
       do  80 kch=1,kchact
   80  isotro(kch)=.false.
       if(fndwq(9)) then
         if(iclcod.eq.5) then
           if(iabs(itp1).eq.18) isobre=1
           if(iabs(itp1).eq.19) isobre=2
         else
           isobre=0
         end if
         call mesres(iswi,
     a      identr,i1,i31,i2,i32,k1n,k2n,iclcod,isobre,istr,srt,resxs,
     b                                                         reswav)
         xsect=xsect+resxs
         if(iswi.eq.1.and.k1n.ne.0) then
           kchact=min(kchact+1,maxcha)
           sigcha(kchact)=resxs
           if(ranf(0).lt.reswav/resxs) then
             isotro(kchact)=.true.
           else
             isotro(kchact)=.false.
           end if
           ktpout(1,kchact)=k1n
           ktpout(2,kchact)=k2n
         end if
       end if
       if((fndwq(9).or.fndwq(10)).and.srt.gt.1.8) then
         do 81 jt=1,9
          if(jt.eq.2.or.jt.eq.3.or.jt.eq.7) go to 81
          if(icall.eq.0) then
            call fndxsm
            write(lun8,87)
            write(lun8,88) (xsmmcl(is),is=1,9)
            write(lun8,89)
   87       format(7x,'data xsmmcl/')
   88       format(5x,'a ',8(f5.2,',',1x),f5.2)
   89       format(5x,'b           /')
            icall=1
          end if
          call mmann(itp1,itp2,i1,i31,igp1,i2,i32,igp2,iswi,
     a                                        jt,punish,kfres)
          if(kfres.ne.0) then
            jtt=jt
            if(jt.eq.1) then
              prdef=prcms(srt,pmas(33),pmas(23))
              iclcot=11
            else if(jt.eq.4) then
              if(i1.eq.0.and.i2.eq.0) then
                prdef=prcms(srt,pmas(24),pmas(24))
                iclcot=10
              else if(i1.eq.2.and.i2.eq.2) then
                prdef=prcms(srt,pmas(23),pmas(23))
                jtt=jt-1
                iclcot=1
              else if(i1.eq.1.and.i2.eq.1) then
                prdef=prcms(srt,pmas(18),pmas(18))
                jtt=jt-2
                iclcot=5
              end if
            else if(jt.eq.5) then
              prdef=prcms(srt,pmas(23),pmas(23))
              iclcot=1
            else if(jt.eq.6) then
              prdef=prcms(srt,pmas(18),pmas(23))
              iclcot=2
            else if(jt.eq.8) then
              prdef=prcms(srt,pmas(33),pmas(23))
              iclcot=11
            else if(jt.eq.9) then
              prdef=prcms(srt,pmas(18),pmas(18))
              iclcot=5
            end if
            call mesres(-1,jt,i1,i31,i2,i32,
     a                  k1n,k2n,iclcot,isobre,istr,srt,xsmmac,
     b                                                         reswav)
            xsmman=punish*prdef**2/pin**2*
     a                           (xsmmcl(jtt)*1.8/srt-xsmmac)
            if(xsmman.lt.0.0) xsmman=0.0
            xsect=xsect+xsmman
            if(iswi.eq.1) then
              kchact=min(kchact+1,maxcha)
              sigcha(kchact)=xsmman
              ktpout(1,kchact)=kfres
              ktpout(2,kchact)=0
              isotro(kchact)=.false.
            end if
          end if
   81    continue
       end if
       if(iswi.eq.0) return
       if(kchact.ge.maxcha) then
         call errex('pspsv:kchact.ge.maxcha')
       end if
       if(xsect.eq.0.0) then
         return
       end if
       zrand=ranf(0)
       iswave=0
       zcomp=0.0
       do 800 k=1,kchact
        zcomp=zcomp+sigcha(k)/xsect
        if(zrand.lt.zcomp) then
          itp1=ktpout(1,k)
          itp2=ktpout(2,k)
          if(isotro(k)) iswave=1
          return
        end if
  800  continue
      return
      end
      function spspsv(iblock,ifine,srt)
#include "amsrqmd.h"
       data ckkbar,spipir/ 1.8,1.5/
       if(iblock.eq.1) then
          if(ifine.eq.0) then
            if(srt.gt.0.98) then
              spspsv=ckkbar*(spipir/max(spipir,srt))**2
            else
              spspsv=0.0
            end if
            return
          else if(ifine.eq.1) then
           iunit=1
          else if(ifine.eq.2) then
           iunit=2
          else if(ifine.eq.3) then
           iunit=3
          else if(ifine.eq.4) then
           iunit=4
          else if(ifine.eq.5) then
           iunit=5
          else if(ifine.eq.6) then
           iunit=6
          else if(ifine.eq.7) then
           iunit=7
          else
           call errex('sppsv:iblock=1,wrong ifine in input')
          end if
       else if(iblock.eq.2) then
          if(ifine.eq.1) then
           iunit=9
          else if(ifine.eq.2) then
           iunit=8
          else if(ifine.eq.3) then
           iunit=11
          else if(ifine.eq.4) then
           iunit=10
          else
           call errex('sppsv:iblock=2,wrong ifine in input')
          end if
       else if(iblock.eq.3) then
          if(ifine.eq.1) then
           iunit=12
          else if(ifine.eq.2) then
           iunit=18
          else if(ifine.eq.3) then
           iunit=13
          else if(ifine.eq.4) then
           iunit=15
          else if(ifine.eq.5) then
           iunit=14
          else if(ifine.eq.6) then
           iunit=17
          else if(ifine.eq.7) then
           iunit=16
          else
           call errex('sppsv:iblock=3,wrong ifine in input')
          end if
       else if(iblock.eq.4) then
          if(ifine.eq.1) then
           iunit=19
          else if(ifine.eq.2) then
           iunit=20
          else if(ifine.eq.3) then
           iunit=21
          else if(ifine.eq.4) then
           iunit=22
          else
           call errex('sppsv:iblock=4,wrong ifine in input')
          end if
       else if(iblock.eq.5) then
          if(ifine.eq.1) then
           iunit=31
          else if(ifine.eq.2) then
           iunit=23
          else if(ifine.eq.3) then
           iunit=28
          else if(ifine.eq.4) then
           iunit=26
          else
           call errex('sppsv:iblock=5,wrong ifine in input')
          end if
       else if(iblock.eq.6) then
          if(ifine.eq.1) then
           iunit=30
          else if(ifine.eq.2) then
           iunit=24
          else if(ifine.eq.3) then
           iunit=27
          else if(ifine.eq.4) then
           iunit=29
          else if(ifine.eq.5) then
           iunit=25
          else
           call errex('sppsv:iblock=6,wrong ifine in input')
          end if
       else
           call errex('sppsv:wrong iblock in input')
       end if
       spspsv=fctact(srt,iunit)
      return
      end
      function fctact(x,iunit)
#include "amsrqmd.h"
       real*4 par(31,5),xmin(31)
       data (par( 1,i),i=1,5) /
     @     0.0496,   0.9664,   0.9717,   1.5285,  -0.3368/
       data (par( 2,i),i=1,5) /
     @     0.0688,   0.9673,   0.9724,   1.5303,  -0.3296/
       data (par( 3,i),i=1,5) /
     @     0.3717,   1.2782,   1.1125,   1.4592,  -1.3680/
       data (par( 4,i),i=1,5) /
     @     1.3562,   1.5325,   1.1570,   1.6747,  -1.8971/
       data (par( 5,i),i=1,5) /
     @     1.3808,   1.4883,   1.2045,   1.6506,  -1.6213/
       data (par( 6,i),i=1,5) /
     @     1.1329,   1.3409,   1.0993,   1.4629,  -1.8432/
       data (par( 7,i),i=1,5) /
     @     1.0561,   1.0760,   1.0083,   1.3433,  -1.4162/
       data (par( 8,i),i=1,5) /
     @     1.6333,   1.6699,   1.3007,   1.9609,  -1.7665/
       data (par( 9,i),i=1,5) /
     @     2.4496,   2.1528,   1.2514,   1.8029,  -1.7880/
       data (par(10,i),i=1,5) /
     @     1.1051,   1.5724,   1.2141,   1.6655,  -2.0837/
       data (par(11,i),i=1,5) /
     @     1.4993,   1.4053,   1.1072,   1.4924,  -1.6585/
       data (par(12,i),i=1,5) /
     @     1.6303,   2.4770,   1.3499,   1.1591,  -2.4693/
       data (par(13,i),i=1,5) /
     @     1.2547,   1.4840,   1.1716,   1.5817,  -1.7916/
       data (par(14,i),i=1,5) /
     @     1.2013,   1.5627,   1.1629,   1.5581,  -1.8396/
       data (par(15,i),i=1,5) /
     @     1.2013,   1.5627,   1.1629,   1.5581,  -1.8396/
       data (par(16,i),i=1,5) /
     @     2.3714,   2.3333,   1.3555,   1.9017,  -1.8627/
       data (par(17,i),i=1,5) /
     @     3.2197,   2.3056,   1.1654,   1.7033,  -1.4781/
       data (par(18,i),i=1,5) /
     @     2.5925,   2.6074,   1.3392,   1.6376,  -1.7021/
       data (par(19,i),i=1,5) /
     @     6.4184,   6.4412,   2.3909,   1.7606,  -2.6324/
       data (par(20,i),i=1,5) /
     @     7.8194,   6.9883,   2.4196,   1.7288,  -2.7481/
       data (par(21,i),i=1,5) /
     @     3.5109,   3.3602,   2.3839,   1.0591,  -1.9918/
       data (par(22,i),i=1,5) /
     @     5.7171,   3.8840,   2.1747,   1.0108,  -2.3779/
       data (par(23,i),i=1,5) /
     @     2.6782,   2.2225,   1.2666,   1.6661,  -1.7847/
       data (par(24,i),i=1,5) /
     @     5.0686,   4.2596,   1.7766,   1.9624,  -1.5748/
       data (par(25,i),i=1,5) /
     @     2.8077,   2.6044,   1.3822,   1.5931,  -1.9576/
       data (par(26,i),i=1,5) /
     @     3.8932,   3.3462,   1.6500,   2.1747,  -1.9046/
       data (par(27,i),i=1,5) /
     @     4.3529,   3.9049,   1.7330,   2.0365,  -1.9882/
       data (par(28,i),i=1,5) /
     @     3.8845,   7.3616,   2.3917,   2.9604,  -2.2731/
       data (par(29,i),i=1,5) /
     @     3.4868,   2.7246,   1.4156,   1.5358,  -1.6490/
       data (par(30,i),i=1,5) /
     @     5.1783,   6.3326,   2.4310,   2.8886,  -1.8918/
       data (par(31,i),i=1,5) /
     @     2.5771,   2.4656,   1.3140,   2.0519,  -1.6447/
       data (xmin(i),i=1,31) /
     @     0.9900,   0.9900,   1.3900,   1.5460,   1.5460,
     @     1.7900,   1.7900,   1.9140,   1.6777,   1.5140,
     @     1.2777,   0.9900,   1.3900,   1.3900,   1.3900,
     @     1.7920,   1.5557,   1.7900,   1.5460,   1.5460,
     @     0.2760,   0.2760,   1.5140,   1.8017,   1.5676,
     @     1.9140,   2.0380,   1.6777,   1.3900,   1.5654,
     @     1.2777/
       dx=x-xmin(iunit)
       if(dx.le.0.0) then
         fctact=0.0
       else
         fctact=par(iunit,1)*
     @      (1.-exp(-par(iunit,2)*dx-par(iunit,3)*dx**2))
         if(x.gt.par(iunit,4)) then
           fctact=fctact*(x/par(iunit,4))**par(iunit,5)
         end if
         if(fctact.lt.0.0) then
           call errex('fctact gives negative x section, abort')
         end if
       end if
      return
      end
      function cgksq1(im1,im2)
#include "amsrqmd.h"
       if(iabs(im1).gt.1.or.iabs(im2).gt.1) then
         cgksq1=0.0
       else
         if(iabs(im1+im2).eq.2) then
           cgksq1=1.0
         else
           cgksq1=0.5
         end if
       end if
      return
      end
      subroutine mesres(iswi,
     a    identr,i1,i31,i2,i32,k1n,k2n,iclcod,isobre,istrin,s,resxs,
     b                                        reswav)
#include "amsrqmd.h"
      parameter (nres=28)
      parameter (maxkan=10)
      dimension lchan(0:nres),nchan(maxkan,0:nres),
     a          gchan(0:nres),em1cha(maxkan,0:nres),
     b          spin(maxkan,0:nres),em2cha(maxkan,0:nres),
     c          emr(0:nres),brchan(maxkan,0:nres),
     d          kchan(2,0:nres),prbcha(nres),
     e          jtotal(0:nres),iorbam(maxkan,0:nres),isores(0:nres)
      logical coher(0:nres)
      dimension jclas(0:nres)
      data lchan / 1,
     a             4,2,3,4,7,3,1,
     b             2,3,1,1,3,1,1,2,2,5,
     c             2,5,4,3,4,1,6,3,6,4,
     d             3
     e           /
      data (nchan(i,0),i=1,maxkan) / 1, 9*0/
      data (nchan(i,1),i=1,maxkan) /11, 7, 5,33, 6*0/
      data (nchan(i,2),i=1,maxkan) / 5,10, 8*0/
      data (nchan(i,3),i=1,maxkan) /11,18,23, 7*0/
      data (nchan(i,4),i=1,maxkan) / 5,10, 1,15, 6*0/
      data (nchan(i,5),i=1,maxkan) / 29,7,1,14,18,23,37, 3*0/
      data (nchan(i,6),i=1,maxkan) / 5,5,11,137, 6*0/
      data (nchan(i,7),i=1,maxkan) / 2, 9*0/
      data (nchan(i,8),i=1,maxkan) / 1,5, 8*0/
      data (nchan(i,9),i=1,maxkan) / 7,5,11, 7*0/
      data (nchan(i,10),i=1,maxkan) /11, 9*0/
      data (nchan(i,11),i=1,maxkan) /11, 9*0/
      data (nchan(i,12),i=1,maxkan) /1,5,15, 7*0/
      data (nchan(i,13),i=1,maxkan) /11,137, 8*0/
      data (nchan(i,14),i=1,maxkan) /11,144, 8*0/
      data (nchan(i,15),i=1,maxkan) /1,5, 8*0/
      data (nchan(i,16),i=1,maxkan) /23,18,141, 7*0/
      data (nchan(i,17),i=1,maxkan) /1,15,14,29,37, 5*0/
      data (nchan(i,18),i=1,maxkan) /23,18, 8*0/
      data (nchan(i,19),i=1,maxkan) /1,15,29,37,5,436, 4*0/
      data (nchan(i,20),i=1,maxkan) /12,16,30,38,301,138, 4*0/
      data (nchan(i,21),i=1,maxkan) /16,2,12, 7*0/
      data (nchan(i,22),i=1,maxkan) /16,12,30,38,138, 5*0/
      data (nchan(i,23),i=1,maxkan) /2, 9*0/
      data (nchan(i,24),i=1,maxkan) /2,16,20,12,30,38, 4*0/
      data (nchan(i,25),i=1,maxkan) /2,12,16, 7*0/
      data (nchan(i,26),i=1,maxkan)/12,30,16,19,38,20,437, 3*0/
      data (nchan(i,27),i=1,maxkan)/12,16, 2, 8,576, 5*0/
      data (nchan(i,28),i=1,maxkan) /5,23,18,40, 6*0/
      data (spin(i,0),i=1,maxkan) /1.,  9*0./
      data (spin(i,1),i=1,maxkan) /3.,1.,1.,9.,  6*0./
      data (spin(i,2),i=1,maxkan) /1.,1.,  8*0./
      data (spin(i,3),i=1,maxkan) /3.,3.,3.,5.,1.,  5*0./
      data (spin(i,4),i=1,maxkan) /1.,1.,1.,9.,  6*0./
      data (spin(i,5),i=1,maxkan) /1.,1.,1.,3.,3.,3.,3., 3*0./
      data (spin(i,6),i=1,maxkan) /1.,1.,3.,1.,  6*0./
      data (spin(i,7),i=1,maxkan) /1.,  9*0./
      data (spin(i,8),i=1,maxkan) /1.,1.,  8*0./
      data (spin(i,9),i=1,maxkan) /1.,1.,3.,  7*0./
      data (spin(i,10),i=1,maxkan) /3.,  9*0./
      data (spin(i,11),i=1,maxkan) /3.,  9*0./
      data (spin(i,12),i=1,maxkan) /1.,1.,9.,  7*0./
      data (spin(i,13),i=1,maxkan) /3.,1.,  8*0./
      data (spin(i,14),i=1,maxkan) /3.,3.,  8*0./
      data (spin(i,15),i=1,maxkan) /1.,1.,  8*0./
      data (spin(i,16),i=1,maxkan) /3.,3.,3.,  7*0./
      data (spin(i,17),i=1,maxkan) /1.,9.,3.,3.,3.,  5*0./
      data (spin(i,18),i=1,maxkan) /3.,3.,  8*0./
      data (spin(i,19),i=1,maxkan) /1.,9.,3.,3.,1.,5., 4*0./
      data (spin(i,20),i=1,maxkan) /3.,3.,3.,3.,1.,1.,  4*0./
      data (spin(i,21),i=1,maxkan) /3.,1.,3.,  7*0./
      data (spin(i,22),i=1,maxkan) /3.,3.,1.,3.,1.,  5*0./
      data (spin(i,23),i=1,maxkan) /1.,  9*0./
      data (spin(i,24),i=1,maxkan) /1.,3.,9.,3.,3.,3., 4*0./
      data (spin(i,25),i=1,maxkan) /1.,3.,3.,  7*0./
      data (spin(i,26),i=1,maxkan)/3.,3.,3.,3.,3.,9.,5., 3*0./
      data (spin(i,27),i=1,maxkan)/3.,3.,1.,1.,5.,  5*0./
      data (spin(i,28),i=1,maxkan)/1.,3.,3.,3.,  6*0./
      data (em1cha(i,0),i=1,maxkan)/0.138,  9*0./
      data (em2cha(i,0),i=1,maxkan)/0.138,  9*0./
      data (em1cha(i,1),i=1,maxkan)/0.770,0.550,0.498,0.783,6*0./
      data (em2cha(i,1),i=1,maxkan)/0.138,0.138,0.498,0.460,6*0./
      data (em1cha(i,2),i=1,maxkan)/0.498,0.550,  8*0./
      data (em2cha(i,2),i=1,maxkan)/0.498,0.550,  8*0./
      data (em1cha(i,3),i=1,maxkan)
     a                  /0.770,0.496,0.496,1.270,1.400, 5*0./
      data (em2cha(i,3),i=1,maxkan)
     a                  /0.138,0.892,0.892,0.138,0.138, 5*0./
      data (em1cha(i,4),i=1,maxkan)/0.498,0.550,0.138,0.770,6*0./
      data (em2cha(i,4),i=1,maxkan)/0.498,0.550,0.138,0.770,6*0./
      data (em1cha(i,5),i=1,maxkan)
     a          /0.783,0.550,0.138,0.550,0.496,0.496,1.020, 3*0./
      data (em2cha(i,5),i=1,maxkan)
     a          /0.138,0.138,0.138,0.570,0.633,0.633,0.138, 3*0./
      data (em1cha(i,6),i=1,maxkan)
     a                  /0.494,0.498,0.138,0.138,6*0./
      data (em2cha(i,6),i=1,maxkan)
     a                  /0.494,0.498,0.770,0.780,6*0./
      data (em1cha(i,7),i=1,maxkan) /0.496,  9*0./
      data (em2cha(i,7),i=1,maxkan) /0.138,  9*0./
      data (em1cha(i,8),i=1,maxkan) /0.138,0.498,  8*0./
      data (em2cha(i,8),i=1,maxkan) /0.138,0.498,  8*0./
      data (em1cha(i,9),i=1,maxkan)
     a                  /0.550,0.498,0.770,  7*0./
      data (em2cha(i,9),i=1,maxkan)
     a                  /0.138,0.498,0.138,  7*0./
      data (em1cha(i,10),i=1,maxkan) /0.770,  9*0./
      data (em2cha(i,10),i=1,maxkan) /0.138,  9*0./
      data (em1cha(i,11),i=1,maxkan) /0.770,  9*0./
      data (em2cha(i,11),i=1,maxkan) /0.138,  9*0./
      data (em1cha(i,12),i=1,maxkan)
     a                   /0.138,0.498,0.570,  7*0./
      data (em2cha(i,12),i=1,maxkan)
     a                   /0.138,0.498,0.570,  7*0./
      data (em1cha(i,13),i=1,maxkan) /0.770,0.804,  8*0./
      data (em2cha(i,13),i=1,maxkan) /0.138,0.138,  8*0./
      data (em1cha(i,14),i=1,maxkan) /0.770,0.783,  8*0./
      data (em2cha(i,14),i=1,maxkan) /0.138,0.500,  8*0./
      data (em1cha(i,15),i=1,maxkan) /0.138,0.498,  8*0./
      data (em2cha(i,15),i=1,maxkan) /0.138,0.498,  8*0./
      data (em1cha(i,16),i=1,maxkan)
     a                  /0.496,0.496,0.770, 7*0./
      data (em2cha(i,16),i=1,maxkan)
     a                  /0.800,0.800,0.555, 7*0./
      data (em1cha(i,17),i=1,maxkan)
     a                  /0.138,0.770,0.550,0.783,1.02, 5*0./
      data (em2cha(i,17),i=1,maxkan)
     a                  /0.138,0.580,0.770,0.138,0.138, 5*0./
      data (em1cha(i,18),i=1,maxkan) /0.496,0.496, 8*0./
      data (em2cha(i,18),i=1,maxkan) /0.892,0.892, 8*0./
      data (em1cha(i,19),i=1,maxkan)
     a                  /0.138,0.770,0.783,1.02,0.498,1.320, 4*0./
      data (em2cha(i,19),i=1,maxkan)
     a                  /0.138,0.770,0.138,0.138,0.498,0.138, 4*0./
      data (em1cha(i,20),i=1,maxkan)
     a                  /0.496,0.892,0.783,1.020,1.030,0.670, 4*0./
      data (em2cha(i,20),i=1,maxkan)
     a                  /0.570,0.138,0.496,0.496,0.138,0.496, 4*0./
      data (em1cha(i,21),i=1,maxkan) /0.892,0.496,0.496, 7*0./
      data (em2cha(i,21),i=1,maxkan) /0.138,0.138,0.770, 7*0./
      data (em1cha(i,22),i=1,maxkan)
     a                  /0.892,0.496,0.496,0.496,0.496, 5*0./
      data (em2cha(i,22),i=1,maxkan)
     a                  /0.138,0.770,0.783,1.020,0.806, 5*0./
      data (em1cha(i,23),i=1,maxkan) /0.496,  9*0./
      data (em2cha(i,23),i=1,maxkan) /0.138,  9*0./
      data (em1cha(i,24),i=1,maxkan)
     a                  /0.498,0.892,0.780,0.496,0.496,0.496, 4*0./
      data (em2cha(i,24),i=1,maxkan)
     a                  /0.138,0.138,0.550,0.770,0.783,1.020, 4*0./
      data (em1cha(i,25),i=1,maxkan)
     a                  /0.498,0.496,0.892, 7*0./
      data (em2cha(i,25),i=1,maxkan)
     a                  /0.138,0.770,0.138, 7*0./
      data (em1cha(i,26),i=1,maxkan)
     a             /0.496,0.496,0.892,0.892,0.496,0.892,0.496, 3*0./
      data (em2cha(i,26),i=1,maxkan)
     a             /0.770,0.783,0.138,0.550,1.020,0.770,1.170, 3*0./
      data (em1cha(i,27),i=1,maxkan)
     a                   /0.496,0.892,0.498,0.498,1.430, 5*0./
      data (em2cha(i,27),i=1,maxkan)
     a                   /0.770,0.138,0.138,0.550,0.138, 5*0./
      data (em1cha(i,28),i=1,maxkan)
     a             /0.498,0.496,0.892,1.020, 6*0./
      data (em2cha(i,28),i=1,maxkan)
     a             /0.498,0.892,0.496,0.550, 6*0./
      data emr /
     a    0.770,
     b    1.318,1.525,1.665,1.713,1.233,1.020,0.892,
     c    0.975,0.980,1.170,1.260,1.270,1.300,1.390,1.400,1.420,1.450,
     d    1.510,1.690,1.270,1.370,1.400,1.430,1.430,1.680,1.770,1.780,
     e    1.690
     f         /
      data (brchan(i,0),i=1,maxkan)
     a               /1.0,  9*0.  /
      data (brchan(i,1),i=1,maxkan)
     a               /0.701,0.145,0.049,0.105,6*0.  /
      data (brchan(i,2),i=1,maxkan)
     a               /0.713,0.287, 8*0./
      data (brchan(i,3),i=1,maxkan)
     a               /0.31,0.021,0.021,0.562,0.087, 5*0./
      data (brchan(i,4),i=1,maxkan)
     a               /0.38,0.18,0.039,0.401, 6*0./
      data (brchan(i,5),i=1,maxkan)
     a               /0.44,0.23,0.12,0.08,0.06,0.06,0.01, 3*0./
      data (brchan(i,6),i=1,maxkan)
     a               /0.495,0.344,0.129,0.032, 6*0./
      data (brchan(i,7),i=1,maxkan)
     a               /1.0, 9*0./
      data (brchan(i,8),i=1,maxkan)
     a               /1.0,-1.0, 8*0./
      data (brchan(i,9),i=1,maxkan)
     a               /0.6,-1.0,0.1, 7*0./
      data (brchan(i,10),i=1,maxkan)
     a               /1.0, 9*0./
      data (brchan(i,11),i=1,maxkan)
     a               /1.0, 9*0./
      data (brchan(i,12),i=1,maxkan)
     a               /0.851,0.047,0.102, 7*0./
      data (brchan(i,13),i=1,maxkan)
     a               /0.320,0.680, 8*0./
      data (brchan(i,14),i=1,maxkan)
     a               /0.850,0.015, 8*0./
      data (brchan(i,15),i=1,maxkan)
     a               /0.930,0.070, 8*0./
      data (brchan(i,16),i=1,maxkan)
     a               /0.35,0.35,0.3, 7*0./
      data (brchan(i,17),i=1,maxkan)
     a               /0.14,0.82,0.02,0.01,0.01, 5*0./
      data (brchan(i,18),i=1,maxkan)
     a               /0.5,0.5, 8*0./
      data (brchan(i,19),i=1,maxkan)
     a               /0.236,0.351,0.17,0.038,0.016,0.19, 4*0./
      data (brchan(i,20),i=1,maxkan)
     a               /0.42,0.16,-1.0,-1.0,0.28,0.03, 4*0./
      data (brchan(i,21),i=1,maxkan)
     a               /0.899,0.066,0.035, 7*0./
      data (brchan(i,22),i=1,maxkan)
     a               /0.94,0.03,0.01,-1.0,0.02, 5*0./
      data (brchan(i,23),i=1,maxkan)
     a               /1.0, 9*0./
      data (brchan(i,24),i=1,maxkan)
     a               /0.497,0.253,0.13,0.088,0.032,-1.0, 4*0./
      data (brchan(i,25),i=1,maxkan)
     a               /0.387,0.314,0.299, 7*0./
      data (brchan(i,26),i=1,maxkan)
     a               /0.32,0.15,0.02,0.16,0.17,0.02,0.16, 3*0./
      data (brchan(i,27),i=1,maxkan)
     a               /0.43,0.27,0.19,0.08,0.03, 5*0./
      data (brchan(i,28),i=1,maxkan)
     a               /0.201,0.268,0.268,0.263, 6*0./
      data (iorbam(i,0),i=1,maxkan) /1,  9*0/
      data (iorbam(i,1),i=1,maxkan) /2,2,2,1,  6*0/
      data (iorbam(i,2),i=1,maxkan) /2,2,  8*0/
      data (iorbam(i,3),i=1,maxkan) /1,1,1,0,2,  5*0/
      data (iorbam(i,4),i=1,maxkan) /2,2,2,0,  6*0/
      data (iorbam(i,5),i=1,maxkan) /0,2,2,0,0,0,0, 3*0/
      data (iorbam(i,6),i=1,maxkan) /1,1,1,1,  6*0/
      data (iorbam(i,7),i=1,maxkan) /1,  9*0/
      data (iorbam(i,8),i=1,maxkan) /0,0,  8*0/
      data (iorbam(i,9),i=1,maxkan) /0,0,2,  7*0/
      data (iorbam(i,10),i=1,maxkan) /0,  9*0/
      data (iorbam(i,11),i=1,maxkan) /0,  9*0/
      data (iorbam(i,12),i=1,maxkan) /2,2,0,  7*0/
      data (iorbam(i,13),i=1,maxkan) /1,0,  8*0/
      data (iorbam(i,14),i=1,maxkan) /1,0,  8*0/
      data (iorbam(i,15),i=1,maxkan) /0,0,  8*0/
      data (iorbam(i,16),i=1,maxkan) /0,0,1,  7*0/
      data (iorbam(i,17),i=1,maxkan) /1,1,1,1,1,  5*0/
      data (iorbam(i,18),i=1,maxkan) /0,0,  8*0/
      data (iorbam(i,19),i=1,maxkan) /3,1,3,3,3,2, 4*0/
      data (iorbam(i,20),i=1,maxkan) /0,0,0,0,1,1,  4*0/
      data (iorbam(i,21),i=1,maxkan) /1,1,1,  7*0/
      data (iorbam(i,22),i=1,maxkan) /0,0,0,0,1,  5*0/
      data (iorbam(i,23),i=1,maxkan) /0,  9*0/
      data (iorbam(i,24),i=1,maxkan) /2,2,0,2,2,2, 4*0/
      data (iorbam(i,25),i=1,maxkan) /1,1,1,  7*0/
      data (iorbam(i,26),i=1,maxkan)/1,1,1,1,1,1,0, 3*0/
      data (iorbam(i,27),i=1,maxkan)/3,3,3,3,2,  5*0/
      data (iorbam(i,28),i=1,maxkan)/1,1,1,1,  6*0/
      data isores/
     a            2,
     b            2,0,2,0,2,0,1,
     c            0,2,0,2,0,2,0,0,0,2,
     d            0,2,1,1,1,1,1,1,1,1,
     e            0
     f            /
      data jtotal/
     a            3,
     b            4*5,3*3,
     c            2*1,2*3,5,1,3,1,2*3,
     d            3,7,3*3,1,5,3,5,7,
     e            3
     f            /
      data gchan /
     a     0.154,
     b     0.110,0.076,0.250,0.138,0.150,0.00441,0.0498,
     c     0.053,0.057,0.311,0.400,0.185,0.400,0.224,0.600,0.055,0.237,
     d     0.035,0.215,0.090,0.114,0.174,0.287,0.098,0.454,0.222,0.164,
     e     0.220
     f     /
      data  coher /
     a     8*.false.,.true.,6*.false.,.true.,13*.false.
     e     /
      data jclas/
     a            5,
     b            1,4,1,4,5,9,6,
     c            0,0,8,1,4,1,8,4,4,5,
     d            4,5,6,6,6,6,6,6,6,6,
     e            9
     f            /
      data f0kkb,d0kkb,gampl,gammi,thetaq,thetav/
     a      2.5, 2.5, 0.82, 0.59,  33.0,  35.2
     b                                   /
      parameter ( pi=3.1415927)
      parameter (zmltp= 10.*pi/(5.0674**2))
      dimension pjin(4)
      common /pjbk/ pjin
      common /gamrbk/ gamres
      common /cohebk/ pchan(maxkan),ncha(maxkan)
       srt=s
       j2=0
       m2=0
       m1=i31+i32
       resxs=0.0
       reswav=0.0
       kentry=0
       do 50 ires=0,nres
        j1=isores(ires)
        if(iswi.le.1) then
          if(iswi.eq.-1) then
            if(identr.ne.jclas(ires)) go to 50
          end if
          iopen=0
          do 51 ic=1,lchan(ires)
   51      if(iclcod.eq.nchan(ic,ires)) iopen=1
          if(iopen.eq.0) go to 50
          if(iswi.eq.-1) then
            cgksq=1.0
          else if(iabs(m1).gt.j1) then
            go to 50
          else if(mod(i1+i2+j1,2).ne.0) then
            go to 50
          else
            cgksq=cgks(i1,i2,j1,i31,i32)
            if(cgksq.eq.0.0) go to 50
          end if
        else
          if(identr.ne.idres(ires,1)) go to 50
        end if
        jtot=jtotal(ires)
        emres=emr(ires)
        gammar=gchan(ires)
        gamt=0.0
        do 11 i=1,maxkan
          pchan(i)=0.0
          br=brchan(i,ires)
          if(br.eq.0.0) go to 11
          iorb=iorbam(i,ires)
          em1=em1cha(i,ires)
          em2=em2cha(i,ires)
          if(srt.gt.em1+em2) then
            pr=prcms(srt,em1,em2)
            gctact=1./(1.+(pr/emres)**2)**(iorb+1)
          else
            gctact=0.0
            pr=0.0
          end if
          if(br.lt.0.0) then
            if(srt.gt.em1+em2) then
              if(ires.eq.8.and.i.eq.2) then
                asol=f0kkb
              else if(ires.eq.9.and.i.eq.2) then
                asol=d0kkb
              else if(ires.eq.20.and.i.eq.3) then
                gqkom1=
     a            0.5*gampl*sin(thetav*2.*pi/360.)*
     b                      cos(thetaq*2.*pi/360.)-
     c            gammi*(sqrt(0.05)*sin(thetav*2.*pi/360.)-
     d                   sqrt(0.40)*cos(thetav*2.*pi/360.))*
     e                                     sin(thetaq*2.*pi/360.)
                asol=gqkom1**2/emres**2
              else if(ires.eq.20.and.i.eq.4) then
                gqkfi1=
     a            0.5*gampl*cos(thetav*2.*pi/360.)*
     b                      cos(thetaq*2.*pi/360.)-
     c            gammi*(sqrt(0.05)*cos(thetav*2.*pi/360.)-
     d                   sqrt(0.40)*sin(thetav*2.*pi/360.))*
     e                                     sin(thetaq*2.*pi/360.)
                asol=gqkfi1**2/emres**2
              else if(ires.eq.22.and.i.eq.4) then
                gqkfi2=
     a            0.5*gampl*cos(thetav*2.*pi/360.)*
     b                      sin(thetaq*2.*pi/360.)+
     c            gammi*(sqrt(0.05)*cos(thetav*2.*pi/360.)-
     d                   sqrt(0.40)*sin(thetav*2.*pi/360.))*
     e                                     cos(thetaq*2.*pi/360.)
                asol=gqkfi2**2/emres**2/gctact
              else if(ires.eq.24.and.i.eq.6) then
                ema=0.783
                emb=0.496
                promeg=prcms(emres,ema,emb)
                asol=(cos(thetav*2.*pi/360)
     a                 /sin(thetav*2.*pi/360.))**2*
     b                   brchan(5,ires)*gammar/promeg**(2*iorb+1)
              else
                call errex(
     a           'mesres: unknown closed channel/resonance combi')
              end if
              asol=asol*gctact
            else
              asol=0.0
            end if
          else
            pres=prcms(emres,em1,em2)
            gct=1./(1.+(pres/emres)**2)**(iorb+1)
            asol=br*gammar*gctact/(gct*pres**(2*iorb+1))
          end if
          pchan(i)=asol*pr**(2*iorb+1)
          gamt=gamt+pchan(i)
   11    continue
         if(iswi.eq.3) then
           gamres=gamt
           return
         end if
         do 49 ic=1,lchan(ires)
          if(iswi.eq.2) then
            if(ic.ne.1) go to 50
            sig=1.0
          else
            if(iclcod.ne.nchan(ic,ires)) go to 49
            if(ires.eq.6.and.ic.le.2.and.isobre.ne.ic) go to 49
            em1=em1cha(ic,ires)
            em2=em2cha(ic,ires)
            if(srt.le.em1+em2) go to 50
            pr=prcms(srt,em1,em2)
            if(iclcod.eq.1.or.iclcod.eq.10.or.
     a             iclcod.eq.15.or.
     b               iclcod.eq.36.or.iclcod.eq.45) then
              symm=2.0
            else
              symm=1.0
            end if
            if(coher(ires)) then
              idtres=idres(ires,1)
              lcha=lchan(ires)
              do 61 lch=1,lcha
   61         ncha(lch)=nchan(lch,ires)
              call cohere(
     a           iclcod,lcha,idtres,srt,pr,emres,gamt,sumtsq)
              sig=symm*cgksq*jtot*
     a                  zmltp/pr**2/spin(ic,ires)*sumtsq
            else
              sig=symm*cgksq*jtot*
     a           zmltp/pr**2/spin(ic,ires)*pchan(ic)/
     a                       ((srt-emres)**2+0.25*gamt*gamt)
              gamo=gamt
              do 13 i=lchan(ires)+1,maxkan
   13         gamo=gamo-pchan(i)
              if(gamo.lt.0.0)
     a          call errex('mesres: open gamma width < 0')
              sig=sig*gamo
            end if
            if(iorb.eq.0) reswav=reswav+sig
            resxs=resxs+sig
          end if
          probs=0.0
          do 12 i=1,lchan(ires)
   12     probs=probs+pchan(i)
          if(probs.eq.0.0) go to 50
          if(iswi.le.0) go to 50
          call mescon(ires,m1,kmult,k1)
          if(kmult.ge.0.and.iswi.ne.2) then
            k1=isign(100,k1)*kmult+k1
            k2=0
          else if(ires.le.nres) then
           zrand=ranf(0)
           inew=0
           do 15 i=1,lchan(ires)
            if(zrand.lt.pchan(i)/probs) then
             inew=i
             goto 14
            else
             zrand=zrand-pchan(i)/probs
            end if
   15      continue
   14      continue
           if(inew.eq.0) then
            call errex('mesres:inew=0?????? ')
           end if
           iclnew=nchan(inew,ires)
           if(iclnew.eq.1.or.iclnew.eq.11.or.iclnew.eq.15) then
             j1new=2
             j2new=2
           else if(iclnew.eq.2.or.iclnew.eq.12.or.iclnew.eq.16
     a                                        .or.iclnew.eq.20) then
             j1new=1
             j2new=2
           else if(iclnew.eq.5.or.iclnew.eq.18.or.iclnew.eq.23) then
             j1new=1
             j2new=1
           else if(iclnew.eq.7.or.iclnew.eq.14) then
             j1new=0
             j2new=2
           else if(iclnew.eq.8.or.iclnew.eq.19.or.iclnew.eq.30
     a                                        .or.iclnew.eq.38) then
             j1new=1
             j2new=0
           else if(iclnew.eq.10) then
             j1new=0
             j2new=0
           else if(iclnew.eq.29.or.iclnew.eq.33.or.iclnew.eq.37) then
             j1new=0
             j2new=2
           else
             call errex('mesres: this decay channel not allowed')
           end if
           itag=0
           call isocgk(m1,j1,m2,j2,j1new,j2new,m1new,m2new,itag)
           if(itag.eq.-1)
     a        call errex('mesres does not allow for decay')
           if(iclnew.eq.1) then
             k1=m1new/2*17+23*(2-iabs(m1new))/2
             k2=m2new/2*17+23*(2-iabs(m2new))/2
           else if(iclnew.eq.11) then
             k1=m1new/2*27+33*(2-iabs(m1new))/2
             k2=m2new/2*17+23*(2-iabs(m2new))/2
           else if(iclnew.eq.15) then
             k1=m1new/2*27+33*(2-iabs(m1new))/2
             k2=m2new/2*27+33*(2-iabs(m2new))/2
           else if(iclnew.eq.2.or.iclnew.eq.12.or.iclnew.eq.16
     a                                        .or.iclnew.eq.20) then
             if(iclnew.eq.2.or.iclnew.eq.12) then
               k1=17+(3-m1new)/2
             else
               k1=27+(3-m1new)/2
             end if
             if(iclnew.eq.2.or.iclnew.eq.16) then
               k2=m2new/2*17+23*(2-iabs(m2new))/2
             else
               k2=m2new/2*27+33*(2-iabs(m2new))/2
             end if
           else if(iclnew.eq.5) then
             k1=17+(3-m1new)/2
             k2=-17-(3+m2new)/2
           else if(iclnew.eq.18) then
             k1=27+(3-m1new)/2
             k2=-17-(3+m2new)/2
           else if(iclnew.eq.23) then
             k1=17+(3-m1new)/2
             k2=-27-(3+m2new)/2
           else if(iclnew.eq.7) then
             k1=24
             k2=m2new/2*17+23*(2-iabs(m2new))/2
           else if(iclnew.eq.8.or.iclnew.eq.19.or.iclnew.eq.30
     a                                        .or.iclnew.eq.38) then
             if(iclnew.eq.8.or.iclnew.eq.38.or.iclnew.eq.30) then
               k1=17+(3-m1new)/2
             else
               k1=27+(3-m1new)/2
             end if
             if(iclnew.eq.8.or.iclnew.eq.19) then
               k2=24
             else if(iclnew.eq.30) then
               k2=34
             else if(iclnew.eq.38) then
               k2=35
             end if
           else if(iclnew.eq.10) then
             k1=24
             k2=24
           else if(iclnew.eq.14) then
             k1=24
             k2=m2new/2*27+33*(2-iabs(m2new))/2
           else if(iclnew.eq.29.or.iclnew.eq.33.or.iclnew.eq.37) then
             if(iclnew.eq.29.or.iclnew.eq.33) then
               k1=34
             else
               k1=35
             end if
             if(iclnew.eq.29.or.iclnew.eq.37) then
               k2=m2new/2*17+23*(2-iabs(m2new))/2
             else
               k2=m2new/2*27+33*(2-iabs(m2new))/2
             end if
           else
             call errex('mesres: decay channel not allowed')
           end if
          else
            call errex('mesres:ires wrong')
          end if
          kentry=kentry+1
          kchan(1,kentry)=k1
          kchan(2,kentry)=k2
          prbcha(kentry)=sig
          go to 50
   49    continue
   50  continue
       if(iswi.gt.0) then
         icha=0
         probs=0.0
         do 52 i=1,kentry
          probs=probs+prbcha(i)
   52    continue
         zrand=ranf(0)
         do 53 i=1,kentry
          if(zrand.lt.prbcha(i)/probs) then
            icha=i
            goto 54
          else
            zrand=zrand-prbcha(i)/probs
          end if
   53    continue
   54    continue
         if(icha.eq.0) then
           if(kentry.ne.0)
     a        call errex('mesres:icha=0?????? ')
           k1n=0
           k2n=0
         else
           k1n=kchan(1,icha)
           k2n=kchan(2,icha)
         end if
       end if
      return
      end
      function idres(i,jswi)
#include "amsrqmd.h"
       idres=-1
       if(jswi.eq.1) then
       if(i.ge.0.and.i.le.7) then
         if(i.eq.0) then
           idres=5
         else if(i.le.5) then
           idres=29+i
         else if(i.eq.6) then
           idres=9
         else if(i.eq.7) then
           idres=6
         else
           call errex('idres:wrong i')
         end if
       else if(i.le.27) then
         idres=2+i
       else if(i.le.28) then
         idres=7+i
       else
         call errex('idres:wrong jswi/i combination')
       end if
       else if(jswi.eq.-1) then
       i=iabs(i)
       if(i.ge.1.and.i.le.7) then
         if(i.eq.5) then
           idres=0
         else if(i.eq.6) then
           idres=7
         else if(i.eq.9) then
           idres=6
         else
           call errex('idres:wrong i')
         end if
       else if(i.le.29) then
         idres=i-2
       else if(i.le.34) then
         idres=i-29
       else if(i.le.35) then
         idres=i-7
       else
         call errex('idres:wrong jswi/i combination')
       end if
       else
         call errex('idres:wrong jswi')
       end if
      return
      end
      subroutine cohere(iclcod,lcha,idtres,srt,pr,emres,gamt,sumtsq)
#include "amsrqmd.h"
      parameter (maxkan=10)
      dimension gami(maxkan)
      common /cohebk/ pchan(maxkan),ncha(maxkan)
      complex saa
      save delta,sumtot
      gamtot=gamt
      pchsum=0.0
      sumtsq=gamtot**2/
     a                 ((srt-emres)**2+0.25*gamtot*gamtot)
      gamsum=0.0
      do 10 i=1,lcha
       gami(i)=pchan(i)
       gamsum=gamsum+gami(i)
       pchsum=pchsum+pchan(i)
   10 continue
      if(abs(gamsum-gamtot).gt.1.e-4) then
        call errex(
     a       'cohere:gamma of channels adds up incorrectly')
      end if
      if(pchsum.gt.0.0) then
        do 11 i=1,lcha
   11   pchan(i)=pchan(i)/pchsum
      end if
      iblock=0
      if(idtres.eq.10.or.idtres.eq.17) then
        iblock=1
        if(idtres.eq.10) then
          delta=0.0
          sumtot=0.0
        end if
      else
        call errex('cohere should not be called')
      end if
      iel=0
      do 14 i=1,lcha
       if(ncha(i).eq.iclcod) then
         iel=i
         delta=delta+atan2(0.5*gami(i),emres-srt)
         sumtsq=pchan(i)*sumtsq
         pchael=pchan(i)
         pchan(i)=0.0
       end if
   14 continue
      if(iel.eq.0) call errex('cohere abort:iel=0')
      sumts=sumtsq
      sumtsq=0.0
      do 13 i=1,lcha
       if(iel.ne.i) then
         sumtsq=sumtsq+pchan(i)*sumts
         if(pchan(i).gt.0.0)
     a   pchan(i)=pchan(i)/(1.-pchael)
       end if
   13 continue
      sumtot=sumtot+sumtsq
      delbac=0.0
      ilast=0
      if(iblock.eq.1) then
        if(idtres.eq.17) then
          ilast=1
          if(iclcod.eq.1) then
            if(srt.gt.0.7) then
              delbac=60.0/360.0*2.*3.141592
              if(srt.gt.1.3) delbac=delbac*1.3/srt
            else
              delta=0.0
              gamsig=2.06*pr
              delbac=atan2(0.5*gamsig,0.801-srt)
            end if
          else if(iclcod.eq.5) then
            delbac=0.0
          end if
        end if
      end if
      if(ilast.eq.1) then
        delta=delta+delbac
        eta=1.-sumtot
        if(sumtot.lt.0.0) then
          call errex('cohere abort:eta**2<0')
        end if
        eta=sqrt(eta)
        saa=eta*cmplx(cos(2.*delta),sin(2.*delta))
        taasq=abs(saa-cmplx(1.0,0.0))**2
        do 15 i=1,lcha
   15   if(i.ne.iel) pchan(i)=pchan(i)*sumtsq/(sumtsq+taasq)
        sumtsq=sumtsq+taasq
        pchan(iel)=taasq/sumtsq
      end if
      return
      end
      subroutine mmann(kl1,kl2,i1,i31,igp1,i2,i32,igp2,iswi,
     a                                       jtype,punish,kfres)
#include "amsrqmd.h"
      dimension isor(9),igpar(9)
      data isor / 2,-1,-1,0,2,1,-1,0,0  /
      data igpar / -1,0,0,1,1,0,0,-1,-1  /
         if(jtype.gt.9.or.jtype.lt.1) then
           call errex('mmann: jtype out of range')
         end if
         kfres=0
         punish=0.0
         ig=igpar(jtype)
         ig12=igp1*igp2
         if(ig.eq.0.or.ig12.eq.0) then
         else if(ig.ne.ig12) then
           return
         end if
         j1=isor(jtype)
         m1=i31+i32
         if(iabs(m1).gt.j1) then
           return
         else if(mod(i1+i2+j1,2).ne.0) then
           return
         else
           punis=cgks(i1,i2,j1,i31,i32)
           if(punis.eq.0.0) return
         end if
         kl1a=iabs(kl1)
         kl2a=iabs(kl2)
         if(jtype.eq.9.or.kl1a.eq.35.or.kl2a.eq.35) then
           if(kl1a.eq.17.or.kl1a.eq.27.or.kl1a.eq.23
     a                   .or.kl1a.eq.33.or.kl1a.eq.34) then
             return
           else if(kl2a.eq.17.or.kl2a.eq.27.or.kl2a.eq.23
     a                   .or.kl2a.eq.33.or.kl2a.eq.34) then
             return
           else if(jtype.eq.8) then
             return
           end if
         end if
         itry=0
   10    itry=itry+1
         punish=punis
         if(itry.gt.50) then
           write(lun8,*)  'jtype=',jtype
           write(lun8,*)  'kl1=',kl1,ifla1,iflb1,ksp
           write(lun8,*)  'kl2=',kl2,ifla2,iflb2,ksp
           call errex('mmann:no common q/qbar-pair')
         end if
         call bele(ifla1,iflb1,kl1)
         call bele(ifla2,iflb2,kl2)
         if(mod(itry,2).eq.0) then
           call iswap(ifla1,ifla2)
           call iswap(iflb1,iflb2)
         end if
         if(ifla1*iflb1.ge.0.or.ifla2*iflb2.ge.0) then
           call errex('mmann:mm annihilation, but wrong types')
         end if
         if(ifla1*ifla2.gt.0) then
           call iswap(ifla1,iflb1)
         end if
         if(ifla1.eq.-ifla2) then
           if(iabs(ifla1).eq.3) punish=punish*0.2
           ifla3=iflb1
           iflb3=iflb2
         else if(iflb1.eq.-iflb2) then
           if(iabs(iflb1).eq.3) punish=punish*0.2
           ifla3=ifla1
           iflb3=ifla2
         else
           if(ifla1+iflb1.eq.0) then
           else if(ifla2+iflb2.eq.0) then
           else
             call errex('mmann:dead end')
           end if
           go to 10
         end if
         if(jtype.eq.9) then
           if(iabs(ifla3).ne.3) go to 10
         else if(jtype.eq.8) then
           if(iabs(ifla3).eq.3) go to 10
         end if
         if(iswi.eq.1) then
           call luifld(ifla3,0,iflb3,ifldum,kfres)
           if(kfres.eq.0) then
             call errex('mmann abort: kfres=0')
           end if
           kfresa=iabs(kfres)
           if(kfresa.eq.17.or.kfresa.eq.23) then
             if(jtype.eq.4) kfresa=24
             if(jtype.eq.5) kfresa=kfresa+10
             if(jtype.eq.8.or.jtype.eq.9)
     a                         kfresa=34+jtype-8
           else if(kfresa.eq.27.or.kfresa.eq.33) then
             if(jtype.eq.1) kfresa=kfresa-10
             if(jtype.eq.4) kfresa=24
             if(jtype.eq.8.or.jtype.eq.9)
     a                         kfresa=34+jtype-8
           else if(kfresa.eq.24.or.kfresa.eq.25) then
             if(jtype.eq.1) kfresa=23
             if(jtype.eq.5) kfresa=33
             if(jtype.eq.8.or.jtype.eq.9)
     a                         kfresa=34+jtype-8
           else if(kfresa.eq.34) then
             if(jtype.eq.1) kfresa=23
             if(jtype.eq.4) kfresa=24
             if(jtype.eq.5) kfresa=33
           else if(jtype.eq.6) then
             if(kfresa.eq.18.or.kfresa.eq.19)kfresa=kfresa+10
           end if
           kfres=isign(1,kfres)*(6000+kfresa)
         end if
      return
      end
      subroutine fndxsm
#include "amsrqmd.h"
      common /mmclbk/xsmmcl(9)
       do 10   jt=1,9
        xsmmcl(jt)=0.0
        if(jt.eq.2.or.jt.eq.3.or.jt.eq.7) go to 10
        iloop=1
        srtt=1.8
        if(jt.eq.6) srtt=1.8
        if(jt.eq.9) srtt=1.8
        istrt=0
        i1t=0
        i31t=0
        i2t=0
        i32t=0
   20   if(jt.eq.4) iloop=iloop-1
        if(jt.eq.1) then
          iclcot=11
        else if(jt.eq.4) then
          if(iloop.eq.0) then
            iclcot=10
          else if(iloop.eq.-1) then
            iclcot=1
          else if(iloop.eq.-2) then
            iclcot=5
          end if
        else if(jt.eq.5) then
          iclcot=1
        else if(jt.eq.6) then
          iclcot=2
        else if(jt.eq.8) then
          iclcot=11
        else if(jt.eq.9) then
          iclcot=5
        end if
        call mesres(-1,jt,i1t,i31t,i2t,
     a      i32t,k1n,k2n,iclcot,isobre,istrt,srtt,rescl,reswav)
        if(iloop.le.0) then
          xsmmcl(jt+iloop)=rescl
        else
          xsmmcl(jt)=rescl
        end if
        if(iloop.le.0.and.iloop.ge.-1) go to 20
   10  continue
      return
      end
      subroutine mescon(ires,m,kmult,kf)
#include "amsrqmd.h"
      parameter (nres=28)
      dimension kmcon(0:nres),idncon(0:nres)
      data kmcon /
     a            0,
     b            3, 3,-1,-1, 2, 0, 0,
     c           -1,-1, 2, 2, 3,-1,-1,-1, 2,-1,
     d            2,-1, 2,-1, 2,-1, 3,-1,-1,-1,
     e           -1
     &           /
      data idncon /
     a            5,
     b            1, 3,-1,-1, 5, 7, 8,
     c           -1,-1, 6, 1, 2,-1,-1,-1, 2,-1,
     d            7,-1, 4,-1, 8,-1, 4,-1,-1,-1,
     e           -1
     &           /
       if(ires.lt.0.or.ires.gt.nres) then
         call errex('mescon: ires input out of range')
       end if
       iabm=iabs(m)
       kmult=kmcon(ires)
       if(kmult.ge.0) then
         idn=idncon(ires)
         if(idn.eq.1.or.idn.eq.5) then
           if(iabm.gt.2.or.mod(iabm,2).ne.0)
     a              call errex('mescon abort')
           kf=m/2*17+23*(2-iabm)/2
           if(idn.eq.5) kf=kf+isign(1,kf)*10
         else if(idn.eq.2.or.idn.eq.6) then
           if(iabm.ne.0) call errex('mescon abort')
           kf=24
           if(idn.eq.6) kf=34
         else if(idn.eq.3.or.idn.eq.7) then
           if(iabm.ne.0) call errex('mescon abort')
           kf=25
           if(idn.eq.7) kf=35
         else if(idn.eq.4.or.idn.eq.8) then
           if(iabm.gt.1.or.mod(iabm,2).ne.1)
     a              call errex('mescon abort')
           kf=(37-m)/2
           if(idn.eq.8) kf=kf+10
         else
           call errex('mescon abort:wrong idn')
         end if
       else
         kf=0
       end if
      return
      end
CPAT,MSCSTR   .
      subroutine mscstr(imscst,i1,i2,isccss)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      dimension p1(0:3),p2(0:3)
      logical  potyes,poy(2)
      dimension iqq(2),ident(2)
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 2.3  -- 05-sep-96'/
      data pronam/'module: m s c s t r'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
           if(switch(6)) then
             isccss=2
             return
           end if
           isccss=0
           ident1=issn(i1)
           ident2=issn(i2)
           poy(1)=.false.
           poy(2)=.false.
           irturn=0
           if(.not.potyes(i1,iqq1)) then
             if(.not.potyes(i2,iqq2)) then
               isccss=2
               irturn=3
             else
               isccss=1
               irturn=1
             end if
           else
             poy(1)=.true.
             if(.not.potyes(i2,iqq2)) then
               irturn=2
             else
               poy(2)=.true.
             end if
           end if
           if(irturn.ne.0) then
             if(imscst.eq.0) return
             if(mod(irturn,2).eq.1) then
               if(iqq1.eq.3.or.iqq1.eq.1) return
               if(iqq2.eq.3.or.iqq2.eq.1) return
             end if
             if(irturn.eq.2) then
               if(iqq2.eq.3.or.iqq2.eq.1) return
             end if
           end if
      iqq(1)=iqq1
      iqq(2)=iqq2
      ident(1)=ident1
      ident(2)=ident2
      il=i1
      iloop=1
 8200 continue
      pp=0.
      if(iqq(iloop).eq.1) then
        pilsq=(p(0,il)+frfp(0,ident(iloop)))**2
        do 8111 i=1,3
 8111   pp=pp+(p(i,il)+frfp(i,ident(iloop)))**2
      else
        pilsq=p(0,il)**2
        do 8211 i=1,3
 8211   pp=pp+p(i,il)**2
      end if
      pilsq=pilsq-pp
      if(ityp(il).eq.99.and.npidec(il).eq.1) pilsq=0.
      if(poy(iloop)) then
        vil=vquasi(il,densa,densb,densc)
      else
        vil=0.0
      end if
      eml=em(il)
      arg=pilsq-vil
      if(arg.lt.0.) then
        emnew=-1.
      else
        emnew=sqrt(arg)
      end if
         itypl=ityp(il)
         npidl=npidec(il)
         iqql=iqq(iloop)
         newm=newmas(itypl,npidl,iqql,emnew)
         if(newm.eq.1) then
            if(iloop.eq.1) isccss=1
            em(il)=emnew
         end if
 8210 continue
      if(iloop.eq.1) then
         iloop=2
         em1eff= sqrt(em(il)*em(il)+vil)
         pi1sq=pilsq
         il=i2
         go to 8200
      else
         em2eff=sqrt(em(il)*em(il)+vil )
         pi2sq=pilsq
      end if
      if(iqq1.eq.1) then
        call ofshel(1,i1,ident1)
      end if
      if(iqq2.eq.1) then
        call ofshel(1,i2,ident2)
      end if
   33 continue
      if(abs(em1eff-sqrt(pi1sq)).lt.1.e-3.and.
     a               abs(em2eff-sqrt(pi2sq)).lt.1.e-3
     b              .and.(imscst.eq.0.or.pcorr(0).gt.0.0)
     c                                            ) then
         isccss=2
         go to 44
      end if
      do 30 i=0,3
        p1(i)=p(i,i1)
        p2(i)=p(i,i2)
   30 continue
      if(imscst.ne.0) then
        if(pcorr(0).lt.0.0) then
          p0tot=p1(0)+p2(0)
          p1tot=p1(1)+p2(1)
          p2tot=p1(2)+p2(2)
          p3tot=p1(3)+p2(3)
          deltp0=
     a       delten(2,p0tot,p1tot,p2tot,p3tot,em1eff,em2eff,srtpr)
          pcorr(0)=pcorr(0)+deltp0
          p1(0)=p1(0)-0.5*deltp0
          p2(0)=p2(0)-0.5*deltp0
        end if
      end if
      call onshel(1,isccss,em1eff,em2eff,p1(0),p1(1),p1(2),p1(3),
     a                                       p2(0),p2(1),p2(2),p2(3))
      if(isccss.eq.1) then
       do 31 i=0,3
         p(i,i1)=p1(i)
         p(i,i2)=p2(i)
   31  continue
       isccss=2
      end if
   44 continue
      if(iqq1.eq.1) then
        do 51 i=0,3
          p(i,i1)=p(i,i1)-frfp(i,ident1)
   51   continue
        pp=p(0,i1)**2
        do 52 i=1,3
   52     pp=pp-p(i,i1)**2
        if(pp.lt.0.3) call ofshel(9,i1,ident1)
      end if
      if(iqq2.eq.1) then
        do 53 i=0,3
          p(i,i2)=p(i,i2)-frfp(i,ident2)
   53   continue
        pp=p(0,i2)**2
        do 54 i=1,3
   54     pp=pp-p(i,i2)**2
        if(pp.lt.0.3) call ofshel(9,i2,ident2)
      end if
      return
      end
      logical function jets(ityp1,npid1,em1,ipot)
      include 'scatter7'
#include "amsrqmd.h"
       npida=iabs(npid1)
       npidr1=-mod(-npid1,1000)
           if((ityp1.le.11.and.(npid1.eq.3.or.npid1.eq.4)).or.
     a        (ityp1.ge.10.and.ityp1.le.11.and.-npidr1.eq.10).or.
     b        (ityp1.ge.3.and.ityp1.le.6.and.-npidr1.ge.6.and.
     c                                       -npidr1.le.9)) then
             if(em1.lt.emstrm.and.((ityp1.ge.10.and.ityp1.le.11).or.
     a            (ityp1.ge.3.and.ityp1.le.6)).and.ipot.eq.1) then
               jets=.false.
             else if(npid1.lt.-1000) then
               jets=.false.
             else
               jets=.true.
             end if
           else if(ityp1.le.15) then
             if((ityp1.eq.12.and.em1.gt.emkdec).or.
     e          (ityp1.eq.13.and.em1.gt.emlamb+empion).or.
     f          (ityp1.eq.15.and.em1.gt.emlamb+empion).or.
     g          (ityp1.eq.14.and.em1.gt.emkdec)
     h                                         ) then
               jets=.true.
             else
               jets=.false.
             end if
           else if(ityp1.ge.85.and.ityp1.le.97) then
             if((npida.ge.41.and.npida.le.42.and.
     b           ityp1.eq.94).or.
     c          (npida.ge.61.and.npida.le.64.and.
     d           ityp1.ge.90.and.ityp1.le.92).or.
     e          (npida.eq.57.and.
     f          (ityp1.ge.86
     g                                                 )).or.
     h          ((ityp1.ge.85)
     i             .and.npida.ge.43.and.npida.le.45).or.
     j          (((ityp1.ge.89.and.ityp1.le.92).or.ityp1.eq.85)
     k          .and.(npida.eq.46.or.npida.eq.47)).or.
     h          ((ityp1.ge.85)
     i             .and.npida.ge.65.and.npida.le.67).or.
     l          ((ityp1.ge.85.and.ityp1.ne.88).and.
     m             npida.ge.68.and.npida.le.69).or.
     n          (ityp1.ge.85.and.ityp1.le.94.and.npida.eq.70)) then
               jets=.true.
             else
               jets=.false.
             end if
           else if(ityp1.eq.98) then
             jets=.true.
           else
              jets=.false.
           end if
      return
      end
      subroutine onshel(iwoher,isccss,em1,em2,p0i1,px1,py1,pz1,
     a                                                p0i2,px2,py2,pz2)
        include 'scatter7'
#include "amsrqmd.h"
            p0tot= p0i1+p0i2
            p1tot=px1+px2
            p2tot=py1+py2
            p3tot=pz1+pz2
            srt=(p0tot*p0tot-p1tot*p1tot-p2tot*p2tot-p3tot*p3tot)
            if(srt.le.(em1+em2)**2) then
                isccss=0
                return
            end if
            srt=sqrt(srt)
            bx=(p1tot)/(p0tot)
            by=(p2tot)/(p0tot)
            bz=(p3tot)/(p0tot)
            gam=1./sqrt(1.-bx**2-by**2-bz**2)
            b2=max(cvalu7,bx**2+by**2+bz**2)
            pb=bx*px1+by*py1+bz*pz1
            gg=(gam-1.)*pb/b2-gam*p0i1
            pzr=gg*bz+pz1
            pxr=gg*bx+px1
            pyr=gg*by+py1
            pr=sqrt(pxr*pxr+pyr*pyr+pzr*pzr)
            if(pr.lt.1.e-9) then
                isccss=0
                return
            end if
            prnew=pcmsr(srt,em1,em2)
            pxr=pxr/pr* prnew
            pyr=pyr/pr* prnew
            pzr=pzr/pr* prnew
              pb=bx*pxr+by*pyr+bz*pzr
              ea=sqrt(em1*em1+pxr**2+pyr**2+pzr**2)
              gg=(gam-1.)*pb/b2+gam*ea
              px1=gg*bx+pxr
              py1=gg*by+pyr
              pz1=gg*bz+pzr
              pp=px1*px1+py1*py1+ pz1*pz1
              arg=em1*em1+pp
              p0i1=sqrt(arg)
              eb=sqrt(em2*em2+pxr**2+pyr**2+pzr**2)
              gg=(gam-1.)*(-pb)/b2+gam*eb
              px2=gg*bx-pxr
              py2=gg*by-pyr
              pz2=gg*bz-pzr
              pp= px2*px2+py2*py2+ pz2*pz2
              p0i2=sqrt(em2*em2+pp)
              p0out=p0i1+p0i2
              if((p0tot/ p0out .gt. 1.01).or.
     a                               (p0tot/ p0out .lt. 0.99)) then
                 write(lun8,*) p0out,p0tot,
     +          'energy after and before coll.'
                 p3out=pz1+pz2
                 write(lun8,*) p3out,p3tot,
     +     'z-mom. after and before coll.'
                 call errex('no energy conservation in onshel')
              end if
              isccss=1
      return
      end
      function vquasi(ill,densl2,densl3,denst)
      include 'scatter7'
#include "amsrqmd.h"
      real*8 plk,qlk,dqlksq,splksq,dqsplk,zlk
      logical potyes
      include 'partblk7'
      dimension qlk(0:3),plk(0:3)
      itypl=ityp(ill)
      npidl=npidec(ill)
      eml=em(ill)
      identl=issn(ill)
      denst=0.
      densl3=0.
      densl2=0.
      vil=0.
      if(.not.potyes(ill,iqql)) go to 8210
      kpotl=kpote(itypl,npidl,iqql)
      do 8209 kk=1,nrbar(kclst)
      ikk=kk+iofset
      if(ill.eq.ikk) go to 8209
      itypk=ityp(ikk)
      npidk=npidec(ikk)
      emk=em(ikk)
      identk=issn(ikk)
      if(.not.potyes(ikk,iqqk)) go to 8209
           kpotk=kpote(itypk,npidk,iqqk)
           kpot=kpotl+kpotk
           do 8208 i=0,3
            qlk(i)=x(i,ill)-x(i,ikk)+(qdot(i,ill)-qdot(i,ikk))*dtprop
            plk(i)=p(i,ill)+p(i,ikk)
 8208      continue
           if(iqql.eq.1) then
             do 8206 i=0,3
 8206        plk(i)=plk(i)+frfp(i,identl)
           end if
           if(iqqk.eq.1) then
             do 8205 i=0,3
 8205        plk(i)=plk(i)+frfp(i,identk)
           end if
           dqlksq=qlk(0)*qlk(0)
           splksq=plk(0)*plk(0)
           dqsplk=qlk(0)*plk(0)
           qplkvc=0.
           do 8207 i=1,3
            dqlksq=dqlksq-qlk(i)*qlk(i)
            splksq=splksq-plk(i)*plk(i)
            qplkvc=qplkvc+qlk(i)*plk(i)
 8207      continue
           dqsplk=dqsplk-qplkvc
           zlk=dqlksq-dqsplk*dqsplk/splksq
           if(-zlk.lt.dstint) then
             pr2=(.25*(splksq-(emk*emk+eml*eml))**2 -
     a           emk*emk*eml*eml)/splksq
             cofact=exp(zlk/alpot)
             denst=denst+cofact
              pilsq=p(0,ill)*p(0,ill)
              piksq=p(0,ikk)*p(0,ikk)
              do  427 i=1,3
               pilsq=pilsq-p(i,ill)*p(i,ill)
               piksq=piksq-p(i,ikk)*p(i,ikk)
  427         continue
              emil=sqrt(max(0.0,pilsq))
              emik=sqrt(max(0.0,piksq))
              srtlk=sqrt(splksq)
              if(srtlk.gt.emil+emik) then
               prlk=pcmsr(srtlk,emil,emik)
              else
                prlk=0.0
              end if
              valk=prlk
             if((ida(12).eq.1.and.valk.gt.pr2max).or.
     a                                    ida(12).eq.2) then
                if(kpot.eq.2.or.kpot.eq.6.or.
     a                                  kpot.eq.3) then
                  densl2=densl2+cofact*da(13)*coef3/coef1
                  densl3=densl3+cofact*da(16)
                else if(kpot.eq.1) then
                  densl2=densl2+cofact*da(14)*coef3/coef1
                  densl3=densl3+cofact
                else
                   densl2=densl2+cofact*coef3/coef1
                   densl3=densl3+cofact
                end if
             else
                densl3=densl3+cofact
                densl2=densl2+cofact
             end if
        end if
 8209 continue
      denspp(identl)=densl3
      vil=coef1*densl2+coef2*(densl3/salpot)**gamma
      vquasi=vil
      return
 8210 continue
      vquasi=vil
      return
      end
      subroutine chkmsc(betfb)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      logical  potyes
         niop=0
         nprop=0
         denslm=0.
         denstm=0.
         vilm=0.
         hilm=0.
         ptlm=0.
         edif=0.
         ntt=nrbar(kclst)
         gamfb=1./sqrt(1.-betfb*betfb)
         do 2130 l=1,ntt
          il=iofset+l
          if(.not.potyes(il,iqql)) go to 2130
          identl=issn(il)
          eml=em(il)
          pp=0.
          if(iqql.eq.1) then
            pilsq=(p(0,il)+frfp(0,identl))**2
            do 2713 i=1,3
 2713       pp=pp+(p(i,il)+frfp(i,identl))**2
          else
            pilsq=p(0,il)**2
            do 2712 i=1,3
 2712       pp=pp+p(i,il)*p(i,il)
          end if
          pilsq=pilsq-pp
          vil=vquasi(il,dens2,dens3,denst)
          hil=pilsq-em(il)**2-vil
            yl=0.5*log((p(0,il)+p(3,il))/(p(0,il)-p(3,il)))
              ptl=sqrt(p(1,il)**2+p(2,il)**2)
              niop=niop+1
              denslm=denslm+dens3/salpot/r0cor
              denstm=denstm+denst/salpot/r0cor
              vilm=vilm+vil
              hilm=hilm+abs(hil)
              ptlm=ptlm+ptl
              p0=gamfb*(p(0,il)+betfb*p(3,il))
              p3=gamfb*(p(3,il)+betfb*p(0,il))
              ed=p0-sqrt(em(il)**2+vil+p3**2+ptl*ptl)
              edif=edif+abs(ed)
 2130    continue
         if(niop.gt.0) then
           write(6,*)'chkmsc:',niop,ntt,'edif=',edif,vilm/niop,hilm/niop
           write(6,*)  't mn dns=',
     b          denstm/niop,denslm/niop
         end if
      return
      end
      logical function potyes(il,iqql)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      logical jets
       data emdumm/ 0.0/
       potyes=.false.
       iqql=0
       if(switch(6)) return
       if(il.le.0.or.il.gt.ntotma) then
         call errex('potyes: wrong input')
       end if
       itypl=ityp(il)
       npidl=npidec(il)
       call oldnew(1,itypl,npidl,emdumm,kmultl,ltypl)
       identl=issn(il)
       if(itypl.eq.-9999) then
         iqql=3
         return
       else if(itdth(2,identl).ne.0.and.
     a               tdtg(identl).gt.x(0,il)+qdot(0,il)*dtprop) then
         iqql=1
         return
       else if(kmultl.lt.0) then
         iqql=2
         return
       else if(il-iofset.gt.nrbar(kclst)) then
         iqql=4
         return
       else if(ida(13).eq.1.and.(kmultl.gt.0.or.
     a                           ltypl.lt.41.or.
     b                           (ltypl.gt.42.and.ltypl.lt.61).or.
     c                                            ltypl.gt.64)) then
         iqql=4
         return
       else if(ida(13).eq.2.and.
     a                          (ltypl.lt.41.or.
     b                           (ltypl.gt.42.and.ltypl.lt.61).or.
     c                                            ltypl.gt.64)) then
         iqql=4
         return
       end if
       potyes=.true.
      return
      end
      function newmas(itypl,npidl,iqql,emnew)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       data emdumm/ 0.0/
       call oldnew(1,itypl,npidl,emdumm,kmultl,ltypl)
       newmas=0
       if(iqql.eq.1) then
       else if(kmultl.eq.0) then
       else if(iabs(ltypl).le.40) then
       else
         idn=idnbar(ltypl)
         if(idn.gt.0) then
           embm=embmin(idn)+ekinmi
           if(emnew.gt.embm) newmas=1
         end if
       end if
      return
      end
      function kpote(itypl,npidl,iqql)
       include 'scatter7'
#include "amsrqmd.h"
       data emdumm/ 0.0/
       if(ida(35).eq.1) then
         kpote=0
         return
       end if
       call oldnew(1,itypl,npidl,emdumm,kmultl,ltypl)
       ltypa=iabs(ltypl)
       if(iqql.eq.1) then
         kpote=3
       else if(itypl.eq.41.or.itypl.eq.42) then
         kpote=0
       else if(itypl.ge.61.and.itypl.le.64) then
         kpote=1
       else if(kmultl.eq.0) then
         kpote=0
       else
         kpote=3
       end if
      return
      end
      function delten(iswi,p0tot,p1tot,p2tot,p3tot,em1,em2,srtpr)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
          srt2=(p0tot*p0tot-p1tot*p1tot-p2tot*p2tot-p3tot*p3tot)
          deltec=0.3
          if((iswi.eq.2.or.pcorr(0).lt.-0.05*psyst(0)).and.
     a                         srt2.gt.(em1+em2+deltec)**2) then
            delted=min(deltec,sqrt(srt2)-(em1+em2+deltec))
            delts=min(-pcorr(0),deltec+ranf(0)*delted)
            srtpr=sqrt(srt2)-delts
            delten=p0tot-sqrt(p0tot**2+srtpr**2-srt2)
          else
            delten=0.0
            srtpr=sqrt(srt2)
          end if
      return
      end
CPAT,N2DEC    .
      subroutine resdec(ind,lmes,ntag)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      real*4 bex,bey,bez,thetlu,philu,prtgam,par,plund
      real*4 emmres,resxs
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
      dimension prob(10)
      dimension j1cas(8),j2cas(8)
      dimension j1ome(3),j2ome(3)
      dimension ptot(0:3),pind(0:3)
      real*8 bx,by,bz,b2,gam
      dimension dr(0:3),xind(0:3)
      real*4  xform(0:3)
      logical nstyes,scayes,rhoyes,etayes,sigyes,lamyes,delyes,third,
     a        casyes,mesyes,omeyes
      logical issers
       real*4 embarr,gambar,embmin,emmesr,gammes,emmmin,anglmx,
     a        qqbdif,ssbdif
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
      logical  potyes
      data emrmin / 0.282/
      data drind / 0.3/
      data emnst,widnst,emsca,widsca/1.44,0.200,0.500,0.400/
      data j1cas /1,1,1,1,2,0,2,0/
      data j2cas /2,0,2,0,1,1,1,1/
      data j1ome /1,1,0/
      data j2ome /1,1,0/
      save  pt2max,ptgau,pt2gau,tavmax,tavgau
      character*33 vernum
      character*46 pronam
      data vernum/'version rqmd 2.4 -- 22-nov-96'/
      data pronam/'r e s d e c  -- resonance decay'/
      logical*1 ttvers
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
        pt2max=0.40**2
        ptgau=0.30
        pt2gau=ptgau**2
        tavmax=0.16
        tavgau=0.09
      end if
      if(switch(19)) then
         ntag=-1
         decay(ind)=1.e+35
         return
      end if
      id1232=0
      ievnt=lastcl(ind)
      zrand=ranf(0)
      do 20 i=0,3
      ptot(i)=p(i,ind)
   20 continue
      emold= em(ind)
      pindsq=ptot(0)*ptot(0)
      pvec2=0.0
      do 25 i=1,3
   25 pvec2=pvec2+ptot(i)**2
      pindsq=pindsq-pvec2
      eminva=sqrt(pindsq)
      npidol=npidec(ind)
      npold=npidol
      itind=ityp(ind)
      itold=itind
        call oldnew(1,itold,npold,emold,kmult,ltyp)
      ident=issn(ind)
      iqinv=0
      npabs=iabs(npidol)
      if(itind.ge.3.and.itind.le.6) then
        idn=1
        assign 15 to label2
      else if(itind.ge.10.and.itind.le.11) then
        idn=2
         assign 16 to label2
      elseif(itind.ge.85.and.itind.le.97.and.
     a           -npidol.ge.61.and.-npidol.le.64)then
        idn=1
         iqinv=1
         call qinvrt(itind,npidol,emold)
         assign 15 to label2
      elseif(itind.ge.85.and.itind.le.97.and.
     a           -npidol.ge.41.and.-npidol.le.42)then
        idn=2
         iqinv=1
         call qinvrt(itind,npidol,emold)
         assign 16 to label2
      elseif(itind.ge.85.and.itind.le.97.and.
     a                           npabs.eq.57)then
        idn=3
         if(npidol.eq.-57)then
           iqinv=1
           call qinvrt(itind,npidol,emold)
         end if
         assign 13 to label2
      elseif(itind.eq.99.and.-npidol.ge.61.and.-npidol.le.64)then
        idn=1
         iqinv=1
         call qinvrt(itind,npidol,emold)
         assign 15 to label2
      elseif(
     a        (npabs.ge.46.and.npabs.le.47).or.
     b         (npabs.ge.68.and.npabs.le.69)) then
        if(npabs.ge.46.and.npabs.le.47) then
          idn=5
        else
          idn=7
        end if
         if(npidol.lt.0) then
           iqinv=1
           call qinvrt(itind,npidol,emold)
         end if
         if(npidol.le.47) then
           kmult=min(4,itind-85)
           isoind=1-2*(npidol-46)
         else
           kmult=5
           isoind=1-2*(npidol-68)
         end if
         assign 17 to label2
      elseif(itind.ge.85.and.itind.le.97.and.
     a                           npabs.eq.70)then
        idn=8
         if(npidol.eq.-70)then
           iqinv=1
           call qinvrt(itind,npidol,emold)
         end if
         if(itind+1-85.ne.5) then
           call errex('resdec19:wrong resonance in entrance')
           kmult=0
         else
           kmult=1
         end if
         assign 19 to label2
      elseif(itind.ge.85.and.itind.le.97.and.
     a                              npabs.le.35)then
        idn=0
         assign 18 to label2
      else
        write(lun8,*) ind,issn(ind),itind,npidol
        call errex('unknown resonance in resdec')
      end if
      if(potyes(ind,iqqind)) then
        if(idn.lt.0.or.idn.gt.8)
     a    call errex('resdec:abort,wrong idn')
        emeff=eminva
        if(idn.eq.1.or.idn.eq.2) then
          embm=emnuc+empion
        else
          embm=embmin(idn)+ekinmi
        end if
        if(emeff.lt.embm) then
          dp0=ptot(0)-sqrt(emold**2+pvec2)
          ps005=0.005*psyst(0)
          if(ifndnx.eq.0) then
            emeff=emold
            if(idn.eq.1.or.idn.eq.2) then
            else if(abs(pcorr(0)+dp0).lt.ps005
     a                  .or.pcorr(0)*dp0.lt.0.0) then
              pcorr(0)=pcorr(0)+dp0
              p(0,ind)=sqrt(emold**2+pvec2)
              eminva=emold
            else
              ntag=-1
              decay(ind)=decay(ind)+ptot(0)/emold*1.0
              return
            end if
          else
            if(abs(pcorr(0)+dp0).lt.ps005
     a                  .or.pcorr(0)*dp0.lt.0.0
     b                       .or.abs(dp0).lt.0.005) then
              pcorr(0)=pcorr(0)+dp0
              emeff=emold
              eminva=emold
            else
              write(lun8,*) itind,npidol,emeff,emold,issn(ind)
              call errex('resdec: no phase space for resonance decay')
            end if
          end if
        end if
      else
        emeff=eminva
      end if
      etayes=.false.
      delyes=.false.
      rhoyes=.false.
      scayes=.false.
      nstyes=.false.
      sigyes=.false.
      lamyes=.false.
      casyes=.false.
      omeyes=.false.
      mesyes=.false.
      go to label2
   18 continue
      mesyes=.true.
      if(npidol.eq.-18.or.npidol.eq.-19
     a   .or.npidol.eq.-28.or.npidol.eq.-29)then
        iqinv=1
        call qinvrt(itind,npidol,emold)
      end if
      kmult=itind-84
      i1=isosp(npabs)
      i31=isign(1,npidol)*isosp3(npabs)
      identr=idtmes(kmult,npabs)
      emmres=emeff
      mtry=0
  182 continue
      call mesres(2,
     a   identr,i1,i31,0,0,kfb,kfm,iclcod,isobre,istrin,emmres,resxs,
     b                                                        reswav)
      if(kfm.eq.0.or.kfb.eq.0) then
        write(lun8,*)itind,npidol,kfb,kfm,emeff,identr,i1,i31
        call errex('resdec18: no decay hadrons found')
      end if
  181 mtry=mtry+1
      embar=getmas(0,kfb,1,-1.0)
      emmes=getmas(0,kfm,1,-1.0)
      kfba=iabs(kfb)
      kfma=iabs(kfm)
      if(identr.eq.14) then
        if(kfma.eq.27.or.kfma.eq.33)
     a  emmes=emmes-0.2
        if(kfba.eq.27.or.kfba.eq.33)
     a  embar=embar-0.2
      else if(identr.eq.18) then
        if(kfma.eq.28.or.kfma.eq.29) then
          emmes=emmes-0.092
        else if(kfba.eq.28.or.kfba.eq.29) then
          embar=embar-0.092
        end if
      else if(identr.eq.26) then
        if(kfma.eq.28.or.kfma.eq.29) then
          emmes=emmes-0.11
        else if(kfba.eq.28.or.kfba.eq.29) then
          embar=embar-0.11
        end if
        if(kfma.eq.27.or.kfma.eq.33) then
          emmes=emmes-0.22
        else if(kfba.eq.27.or.kfba.eq.33) then
          embar=embar-0.22
        end if
      else if(identr.eq.30.and.min(embar,emmes).gt.0.2) then
        if(kfma.eq.27.or.kfma.eq.33) then
          emmes=emmes-0.31
        else if(kfba.eq.27.or.kfba.eq.33) then
          embar=embar-0.31
        end if
      else if(identr.eq.34) then
        if(kfma.eq.28.or.kfma.eq.29) then
          emmes=emmes-0.32
        else if(kfba.eq.28.or.kfba.eq.29) then
          embar=embar-0.32
        end if
      end if
      if(mtry.gt.100) then
        assign 182 to label
      else
        assign 181 to label
      end if
      if(kfma.eq.27.or.kfma.eq.33) then
        if(emmes.lt.0.3) go to label
      else if(kfma.eq.28.or.kfma.eq.29) then
        if(emmes.lt.0.64) go to label
      end if
      if(kfba.eq.27.or.kfba.eq.33) then
        if(embar.lt.0.3) go to label
      else if(kfba.eq.28.or.kfba.eq.29) then
        if(embar.lt.0.64) go to label
      end if
      if(embar+emmes.ge.emeff) then
        if(mtry.gt.150) then
          write(lun14,*)itind,npidol,kfb,kfm,emeff,embar,emmes
          call errex('resdec181:infinite loop')
        end if
        go to label
      end if
      embr=embar
      ipi=0
      go to 1010
   19 continue
      omeyes=.true.
      mtry=0
  269 continue
      probs=0.0
      kfm=0
      do 271 ilop=1,3
       prob(ilop)=dcrato(ilop,kmult,emeff)
       probso=probs
       probs=probs+prob(ilop)
       if(prob(ilop).ne.0.0.and.zrand.gt.probso.and.
     a                                   zrand.le.probs) then
         j1=0
         m1=0
         j2=0
         m2=0
         j1new=j1ome(ilop)
         j2new=j2ome(ilop)
         itag=0
         call isocgk(m1,j1,m2,j2,j1new,j2new,m1new,m2new,itag)
         if(ilop.eq.3) then
           kfm=24
         else if(ilop.eq.1.or.ilop.eq.3) then
           kfm=-17-(3+m2new)/2
         end if
         if(ilop.eq.1) then
           kfb=45+(3-m1new)/2
         else if(ilop.eq.2) then
           kfb=67+(3-m1new)/2
         else if(ilop.eq.3) then
           kfb=70
         end if
       end if
  271 continue
      if(probs.eq.0.0) then
        call errex('resdec19: no phase space for decay')
      else if(abs(1.-probs).gt.1.e-3) then
        call errex('resdec19: probabilities do not add up')
      else if(zrand.gt.probs) then
        mtry=mtry+1
        if(mtry.gt.50) call errex('resdec19: mtry.gt.50')
        zrand=probs
        go to 269
      end if
      if(kfm.eq.0) then
        call errex('resdec19: no decay hadrons found')
      end if
      embar=getmas(0,kfb,1,-1.0)
      emmes=getmas(0,kfm,1,-1.0)
      if(embar+emmes+ekinmi.ge.emeff) go to 269
      embr=embar
      ipi=0
      go to 1010
   17 continue
      casyes=.true.
      mtry=0
  169 continue
      if(mtry.gt.50) call errex('resdec17: mtry.gt.50')
      probs=0.0
      kfm=0
      do 171 ilop=1,8
       prob(ilop)=dcratc(ilop,kmult,emeff)
       probso=probs
       probs=probs+prob(ilop)
       if(prob(ilop).ne.0.0.and.zrand.gt.probso.and.
     a                                   zrand.le.probs) then
         j1=1
         m1=isoind
         j2=0
         m2=0
         j1new=j1cas(ilop)
         j2new=j2cas(ilop)
         itag=0
         call isocgk(m1,j1,m2,j2,j1new,j2new,m1new,m2new,itag)
         if(ilop.eq.1.or.ilop.eq.3) then
           kfm=m2new/2*17+23*(2-iabs(m2new))/2
         else if(ilop.eq.2.or.ilop.eq.4) then
           kfm=24
         else if(ilop.eq.5.or.ilop.eq.6.or.ilop.eq.7) then
           kfm=-17-(3+m2new)/2
         else if(ilop.eq.8) then
           kfm=17+(3-m2new)/2
         end if
         if(ilop.eq.1.or.ilop.eq.2) then
           kfb=45+(3-m1new)/2
         else if(ilop.eq.3.or.ilop.eq.4) then
           kfb=67+(3-m1new)/2
         else if(ilop.eq.5) then
           kfb=44-m1new/2
         else if(ilop.eq.6) then
           kfb=57
         else if(ilop.eq.7) then
           kfb=66-m1new/2
         else if(ilop.eq.8) then
           kfb=70
         end if
       end if
  171 continue
      if(probs.eq.0.0) then
        call errex('resdec17: no phase space for decay')
      else if(abs(1.-probs).gt.1.e-3) then
        call errex('resdec17: probabilities do not add up')
      else if(zrand.gt.probs) then
        mtry=mtry+1
        zrand=probs
        go to 169
      end if
      if(kfm.eq.0) then
        call errex('resdec17: no decay hadrons found')
      end if
      embar=getmas(0,kfb,1,-1.0)
      emmes=getmas(0,kfm,1,-1.0)
      if(embar+emmes+ekinmi.ge.emeff) go to 169
      embr=embar
      ipi=0
      go to 1010
   13 continue
      if(zrand.le.0.33333) then
          irand=1
          embar=emsigp
      else if(zrand.le.0.66667) then
          irand=0
          embar=emsig0
      else
          irand=-1
          embar=emsigm
      end if
      embr=embar
      emmes=empion
      npidn=irand
      ipi= 8-irand
      in=15
      go to 1010
   15 continue
      third=(ranf(0).gt..666666666)
      nchanl=-npidol/1000
      if(nchanl.ne.1.and.emeff.lt.emnuc+(2.*empion+ekinmi)) npidol=0
      wdnpi=0.
      wddpi=0.
      wdnrho=0.
      wdspi=0.
      if(npidol.lt.0) then
         if(emold.le.emnuc+empion) then
            write(lun8,*) itind,npidol,emold,ind,issn(ind)
            call errex('wrong emold in resdec,15 for negat. npidol')
         end if
         npidol=-npidol
         if(npidol.gt.100) then
            iblsgk=1
            npidol=mod(npidol,100)
         else
            iblsgk=0
         end if
         if(npidol.gt.9) then
            write(lun8,*) npidol,ind
            call errex('wrong npidol in resdec')
         end if
         if(nchanl.gt.0) then
            if(nchanl.eq.1) then
                 wdnpi=1.
            else if(nchanl.eq.2) then
               if(emeff.gt.emnuc+2.*(empion+ekinmi)) then
                 wddpi=1.
               else
                 wdnpi=1.
               end if
            else if(nchanl.eq.3) then
              if(emeff.gt.emnuc+emrmin+ekinmi) then
                wdnrho=1.
              else
                wdnpi=1.
              end if
            else if(nchanl.eq.6) then
              if(emeff.gt.emsigm+emka0+ekinmi) then
                wdspi=1.
              else
                wdnpi=1.
              end if
            else if(nchanl.eq.7) then
              if(emeff.gt.emnuc+2.*empion+ekinmi) then
                nstyes=.true.
                wdnpi=1.
              else
                wdnpi=1.
              end if
            else
              call errex('resdec: wrong nchanl in delta branch')
            endif
         else
            wdnspi=dcratd(0,npidol,emeff)
            wdnpi=dcratd(1,npidol,emeff)
            if(wdnspi.gt.0.0) then
              if(ranf(0).lt.wdnspi/(wdnpi+wdnspi)) nstyes=.true.
            end if
            wdnpi=wdnpi+wdnspi
            wddpi=dcratd(2,npidol,emeff)
            wdnrho=dcratd(3,npidol,emeff)
            if(iblsgk.eq.1) then
               wdspi=0.
               wddpi=wddpi+dcratd(4,npidol,emeff)
            else
               wdspi=dcratd(4,npidol,emeff)
            end if
         end if
      else if(npidol.eq.0.or.npidol.eq.1) then
         wdnpi=1.
      else
         call errex('resdec:dead end in d branch???? ')
      end if
      if(abs(wdnpi+wddpi+wdnrho+wdspi-1.0).gt.1.e-3) then
        write(lun8,*) 'npidol,nchanl,emeff,issn(ind)'
        write(lun8,*) npidol,nchanl,emeff,issn(ind)
        write(lun8,*) 'wdnpi,wddpi,wdnrho,wdspi'
        write(lun8,*)  wdnpi,wddpi,wdnrho,wdspi
        call errex('resdec:probabilities do not sum up to 1,dbranch')
      end if
      if(npidol.eq.1) id1232=1
      goto (103,104,105,106),itind-2
      write(lun8,*)'error, select,  resdec , ind,ityp:',ind,itind
      call errex('fatal error')
  103 continue
      if((npidol.eq.0).or.(zrand.le.wdnpi+wdnrho)) then
         ipi=7
         in =1
         if((npidol.gt.0).and.
     a      (zrand.gt.wdnpi).and.
     b      (emeff.gt.emnuc+emrmin+ekinmi)) then
              rhoyes=.true.
         end if
         goto 600
      else
          if(zrand.gt.1.- wdspi) then
              if(emeff.gt.emsigm+emka0+ekinmi) then
               m1=-3
               go to 700
              end if
          end if
          if(ranf(0).gt.0.6) then
               ipi=7
               in=4
          else
               ipi=8
               in=3
          end if
          go to 800
      end if
  104 continue
      if(npidol.eq.0.or.(zrand.le.wdnpi+wdnrho)) then
         if (third) then
            ipi=7
            in= 2
         else
            ipi=8
            in =1
         end if
         if((npidol.gt.0).and.
     a      (zrand.gt.wdnpi).and.
     b      (emeff.gt.emnuc+emrmin+ekinmi)) then
              rhoyes=.true.
         end if
         goto 600
      else
          if(zrand.gt.1.- wdspi) then
              if(emeff.gt.emsigm+emkap+ekinmi) then
               m1=-1
               go to 700
              end if
          end if
          yrand=ranf(0)
          if(yrand.le.1./15.) then
               ipi=8
               in=4
          else if(yrand.le.0.6) then
               ipi=7
               in=5
          else
               ipi=9
               in=3
          end if
          go to 800
      end if
  105 continue
      if((npidol.eq.0).or.(zrand.le.wdnpi+wdnrho)) then
         if (third) then
           ipi=9
           in =1
         else
           ipi=8
           in =2
         end if
         if((npidol.gt.0).and.
     a      (zrand.gt.wdnpi).and.
     b      (emeff.gt.emnuc+emrmin+ekinmi)) then
              rhoyes=.true.
         end if
         goto 600
      else
          if(zrand.gt.1.- wdspi) then
              if(emeff.gt.emsigp+emka0+ekinmi) then
               m1= 1
               go to 700
              end if
          end if
          yrand=ranf(0)
          if(yrand.le.1./15.) then
               ipi=8
               in=5
          else if(yrand.le.0.6) then
               ipi=9
               in=4
          else
               ipi=7
               in=6
          end if
          go to 800
      end if
  106 continue
      if((npidol.eq.0).or.(zrand.le.wdnpi+wdnrho)) then
         ipi=9
         in =2
         if((npidol.gt.0).and.
     a      (zrand.gt.wdnpi).and.
     b      (emeff.gt.emnuc+emrmin+ekinmi)) then
              rhoyes=.true.
         end if
         go to 600
      else
          if(zrand.gt.1.- wdspi) then
              if(emeff.gt.emsigp+emkap+ekinmi) then
               m1= 3
               go to 700
              end if
          end if
          if(ranf(0).gt.0.6) then
               ipi=9
               in=5
          else
               ipi=8
               in=6
          end if
          go to 800
      end if
   16 continue
      znnpi=0.
      zndpi=0.
      znnrho=0.
      znneta=0.
      znnsca=0.
      znlpi=0.
      znspi=0.
      nchanl=-npidol/1000
      if(nchanl.gt.0) then
            znnpi=1.
            if(nchanl.eq.1) then
            else if(nchanl.eq.2) then
              if(emeff.gt.emnuc+2.*(empion+ekinmi)) then
                znnpi=0.
                zndpi=1.
              end if
            else if(nchanl.eq.3) then
              if(emeff.gt.emnuc+emrmin+ekinmi) then
                znnrho=1.
                znnpi=0.
              end if
            else if(nchanl.eq.4) then
              if(emeff.gt.emnuc+emeta+ekinmi) then
                znneta=1.
                znnpi=0.
              end if
            else if(nchanl.eq.5) then
              if(emeff.gt.emlamb+emka0+ekinmi) then
                znlpi=1.
                znnpi=0.
              end if
            else if(nchanl.eq.6) then
              if(emeff.gt.emsigm+emka0+ekinmi) then
                znspi=1.
                znnpi=0.
              end if
            else
               call errex('resdec: wrong nchanl in n* branch')
            endif
      else if(npidol.lt.0) then
          npidol=-npidol
          if(npidol.gt.100) then
             npidol=mod(npidol,100)
          else
             if(emeff.gt.emlamb+emka0)then
               znlpi=dcratn(5,npidol,emeff)
             end if
             if(emeff.gt.emsigm+emka0)then
               znspi=dcratn(6,npidol,emeff)
             end if
          end if
          znnpi= dcratn(1,npidol,emeff)
          if(emeff.gt.emnuc+emeta)then
                znneta= dcratn(4,npidol,emeff)
          else
                znneta= 0.
          end if
          if(emeff.gt.emnuc+emrmin)then
                znnrho=dcratn(3,npidol,emeff)
                znnsca=dcratn(0,npidol,emeff)
                znnrho=znnrho+znnsca
          else
                znnrho=0.
                znnsca=0.0
          end if
          if(emeff.gt.emnuc+2.*empion) then
                zndpi=dcratn(2,npidol,emeff)
          else
               znnpi=1.
               zndpi=0.
          end if
      else if(npidol.eq.0) then
              znnpi=1.
              zndpi=0.
              znneta=0.0
              znnrho=0.
      else if(npidol.ge.1) then
           call errex('resdec:dead end???? ')
      end if
      if(abs(znnpi+zndpi+znnrho+znneta+znlpi+znspi-1.0).gt.1.e-3) then
        write(lun8,*) 'emeff=',emeff,em(ind),
     a                 issn(ind),ityp(ind),npidec(ind)
        write(lun8,*) 'nchanl,npidol=',nchanl,npidol
        write(lun8,*)
     a    'znnpi,zndpi,znnrho,znneta,znlpi,znspi'
        write(lun8,*)
     a     znnpi,zndpi,znnrho,znneta,znlpi,znspi
        call errex('resdec:probabilities do not sum up to 1,n* branch')
      end if
      goto (10,11),itind-9
      write(lun8,*)'error, select,  resdec , ind,ityp:',ind,itind
      call errex('fatal error')
   10 continue
      if(zrand.lt. znnpi+znnrho) then
         if(zrand.ge.znnpi) then
           if(ranf(0).lt.znnsca/znnrho) then
             scayes=.true.
           else
             rhoyes=.true.
           end if
         end if
         if(scayes.or.ranf(0).gt.0.666667) then
            ipi=8
            in =1
         else
            ipi=7
            in =2
         end if
         go to 600
      else if(zrand.lt.1.-znneta) then
          zlimit=1.-znneta-znlpi
          if(zrand.gt.zlimit) then
            lamyes=.true.
            ipi=14
            in= 13
            iskaon=1
            npnew=0
            embar=emlamb
            emmes=emka0
            go to 500
          end if
          zlimit=zlimit-znspi
          if(zrand.gt.zlimit) then
            sigyes=.true.
            ipi=14
            in= 15
            xrand=ranf(0)
            if(xrand.lt.0.3333) then
                 embar=emsig0
                 emmes=emka0
                 iskaon=1
                 npnew=0
            else
                 embar=emsigm
                 emmes=emkap
                 iskaon=2
                 npnew=-1
            endif
            go to 500
          end if
          yrand=ranf(0)
          if( yrand .lt. 0.166667) then
            ipi=7
            in =5
          else if( yrand.lt. 0.5 ) then
            ipi=8
            in =4
          else
            ipi=9
            in =3
          end if
          goto 800
      else
          etayes=.true.
          ipi=12
          in=itind-9
          go to 600
      end if
   11 continue
      if(zrand.lt. znnpi+znnrho) then
          if(zrand.ge. znnpi) then
             if(ranf(0).lt.znnsca/znnrho) then
               scayes=.true.
             else
               rhoyes=.true.
             end if
          end if
          if(scayes.or.ranf(0).gt.0.666667) then
              ipi=8
              in =2
          else
              ipi=9
              in =1
          end if
          go to 600
      else if(zrand.lt.1.-znneta) then
          zlimit=1.-znneta-znlpi
          if(zrand.gt.zlimit) then
            lamyes=.true.
            embar=emlamb
            emmes=emka0
            ipi=14
            in= 13
            iskaon=2
            npnew=0
            go to 500
          end if
          zlimit=zlimit-znspi
          if(zrand.gt.zlimit) then
            sigyes=.true.
            ipi=14
            in= 15
            xrand=ranf(0)
            if(xrand.lt.0.3333) then
                 embar=emsig0
                 emmes=emkap
                 iskaon=2
                 npnew=0
            else
                 embar=emsigp
                 emmes=emka0
                 iskaon=1
                 npnew=1
            endif
            go to 500
          endif
          yrand=ranf(0)
          if( yrand.lt. 0.166667) then
              ipi=9
              in =4
          else if( yrand.lt. 0.5 ) then
              ipi=8
              in =5
          else
              ipi=7
              in =6
          end if
          goto 800
      else
          etayes=.true.
          ipi=12
          in=itind-9
          go to 600
      end if
  500 continue
      npidn=npnew
      if(.not.lamyes.and..not.sigyes) then
         call errex('hyperon decay channel in resdec is wrong')
      end if
      if(emeff.lt. embar+ emmes) then
          write(lun8,*) emeff,embar+emmes,embar,emmes
          call errex('too low effective mass in resdec 500')
      end if
      embr=embar
      go to 1010
  600 continue
      if(rhoyes) then
        if(nstyes) nstyes=.false.
      else if(nstyes) then
        go to 799
      end if
      embar=emnuc
      embr=embar
      npidn=0
      if(rhoyes.or.scayes) then
         if(rhoyes) then
           emres=emrho
           widres=widrho
         else
           emres=emsca
           widres=widsca
         end if
         cr=2.*(emrmin-emres)/widres
         cr1=atan(cr)
         cr2=pi/2.-cr1
         emmx=emeff-emnuc-ekinmi
         if(emmx.lt.emrmin)
     a           call errex('too low maximum rho mass in resdec ')
         xmax=(atan(2.*(emmx-emres)/widres)-cr1)/ cr2
         xmax=min(cvalu1,xmax)
         xx=xmax*ranf(0)
         t=tan(xx*cr2)
         emmes=emres+.5*widres*(cr+t)/(1.-cr*t)
      else if(etayes) then
         emmes=emeta
      else
          if(eminva.lt.emnuc+empion) then
              if(emold.lt.emnuc+empion) then
                  write(lun8,*) 'emeff,issn(ind),ind,em(ind)'
                  write(lun8,*) issn(ind),ind,emeff,eminva,em(ind)
                  write(lun8,*) emold,(p(i,ind),i=0,3)
                  call errex('too low resonance mass in resdec 600')
              else
                write(lun8,*)
     +  'warning: resdec produces off shell nucleon'
                write(lun8,*) issn(ind),ind,emeff,eminva,em(ind)
                embr=sqrt(emnuc**2+(eminva**2-emold**2))
              end if
          end if
          emmes=empion
      end if
      go to 1010
  700 continue
       nstyes=.false.
       ipi=14
       in=15
       sigyes=.true.
       j1=3
       j2=0
       j1new=2
       j2new=1
       m2=0
       itag=0
       call isocgk(m1,j1,m2,j2,j1new,j2new,m1new,m2new,itag)
       if(itag.eq.-1)
     a       call errex('isocgk does not allow for delta decay')
       npid1= m1new/2
       iskaon= (3+m2new)/2
       npidn=npid1
       if(npid1.eq.1) then
         embar=emsigp
       else if(npid1.eq.0) then
         embar=emsig0
       else
         embar=emsigm
       end if
       if(iskaon.eq.2) then
         emmes=emkap
       else
         emmes=emka0
       end if
       embr=embar
       go to 1010
 799  continue
         nstyes=.true.
         if(npidol.eq.9) then
           emres=1.680
           widres=0.125
           npidn=-5
         else if(npidol.eq.8) then
           emres=1.675
           widres=0.155
           npidn=-5
         else if(npidol.eq.5) then
           emres=1.520
           widres=0.125
           npidn=-2
         else
           emres=emnst
           widres=widnst
           npidn=-1
         end if
         emmin=emnuc+empion+ekinmi
         cr=2.*(emmin-emres)/widres
         cr1=atan(cr)
         cr2=pi/2.-cr1
         emmx=emeff-empion-ekinmi
         if(emmx.lt.emmin)
     a           call errex('too low maximum n* mass in resdec')
         xmax=(atan(2.*(emmx-emres)/widres)-cr1)/ cr2
         xmax=min(cvalu1,xmax)
         xx=xmax*ranf(0)
         t=tan(xx*cr2)
         embar=emres+.5*widres*(cr+t)/(1.-cr*t)
         embr=embar
         emmes=empion
         in=in+9
         go to 1010
 800  continue
      delyes=.true.
      npidn=1
      emmes=empion
      emmax=emeff-empion-ekinmi
      if(emmax.lt. emnuc+empion)
     a           call errex('too low n* mass in resdec 800')
          xmax=(atan(2.*(emmax-emdelt)/widdlt)-const1)/
     a    const2
      xmax=min(cvalu1,xmax)
      xx=xmax*ranf(0)
      t=tan(xx*const2)
      embar=emdelt+.5*widdlt*(const+t)/(1.-const*t)
      embr=embar
 1010 continue
      itypl=ipi
      kpthig=0
      if(rhoyes) then
        npidl=2
      else if(scayes) then
        npidl=1
      else if(etayes) then
         npidl=2
      else if(lamyes) then
         npidl=iskaon
         kpthig=2
      else if(sigyes) then
         npidl=iskaon
         kpthig=2
      else if(casyes.or.mesyes) then
        call transl(1,itypl,npidl,kfm)
        call transl(1,in,npidn,kfb)
      else
        npidl=0
      end if
      if(iqinv.eq.1) then
         call qinvrt(in,npidn,embar)
         call qinvrt(itypl,npidl,emmes)
      end if
      if(eminva.le.embr+emmes) then
         write(lun8,*) eminva,emeff,embr,emmes
         call errex('no prel found in resdec')
      else
         prel=pcmsr(eminva,embr,emmes)
      end if
      if(kpthig.eq.2) then
      else if(ida(50).eq.1.and.
     a          itind.le.11.and.mod(itind,10).le.6.and.
     b                          npold.ne.0.and.npold.ne.1) then
        ijet=0
        nll=0
        do 14 nl=1,nlund
         kh=mod(k(nl,1),100000)
         ks=k(nl,1)/100000
         if(ks.eq.4) then
           if(kh.eq.ident ) then
             if(ijet.ne.0) call errex('resdec:no unique jetsystem')
             ijet=1
             klflag=k(nl,2)
             klchar=k(nl+1,2)
             p0h=plund(nl,4)+plund(nl+1,4)
             bxqqq=(plund(nl,1)+plund(nl+1,1))/p0h
             byqqq=(plund(nl,2)+plund(nl+1,2))/p0h
             bzqqq=(plund(nl,3)+plund(nl+1,3))/p0h
             if(klchar.eq.2) then
               em1old=plund(nl,5)
               em2old=plund(nl+1,5)
               if(eminva.gt.em1old+em2old) then
                 prold=pcmsr(eminva,em1old,em2old)
               else
                 prold=-1.0
               end if
             else
               prold=-1.0
             end if
             mst(1)=nl
             mst(2)=nl+1
             bex=-bxqqq
             bey=-byqqq
             bez=-bzqqq
             call lurobo(0.,0.,bex,bey,bez)
             mst(1)=0
             mst(2)=0
             pabs=sqrt(plund(nl,1)*plund(nl,1)+
     a                   plund(nl,2)*plund(nl,2)+
     b                   plund(nl,3)*plund(nl,3)  )
             thetqq=acos(max(-cvalu1,min(cvalu1,plund(nl,3)/pabs)))
             if(plund(nl,2).eq.0.0.and.plund(nl,1).eq.0.) then
               phiqq=pi2*ranf(0)
             else
               phiqq=atan2(plund(nl,2),plund(nl,1))
             end if
           end if
         end if
         if(ijet.eq.0.or.ijet.gt.2) then
           nll=nll+1
           do 22 i=1,5
  22       plund(nll,i)=plund(nl,i)
           k(nll,1)=k(nl,1)
           k(nll,2)=k(nl,2)
         else
           ijet=ijet+1
         end if
  14    continue
        if(ijet.eq.3) then
          if(prold.gt.0.0) then
            taviso=2.*prel*prold
            if(taviso.gt.tavmax) then
              if(ranf(0).le.
     a           (taviso-tavmax)/(taviso-tavgau)) then
                kpthig=1
              end if
            end if
          else
            pt2iso=0.6667*prel**2
            if(pt2iso.gt.pt2max) then
              if(ranf(0).le.
     a              (pt2iso-pt2max)/(pt2iso-pt2gau)) then
                kpthig=1
              end if
            end if
          end if
          if(kpthig.eq.1) then
            nl=nlund-1
            mst(1)=nl
            mst(2)=nl
            thetlu=thetqq
            philu=phiqq
            izran=0
  501       izran=izran+1
            if(izran.gt.50) call  errex('resdec:infinite loop at 501? ')
            zrand=ranf(0)
            if(prold.gt.0.0) then
              tact=tavgau*(-log(max(cvalu4,zrand)))
              if(tact.gt.4.*prel*prold) go  to 501
              ct=1.-0.5*tact/prel/prold
              st=sqrt(1.-ct*ct)
            else
              ptact=ptgau*sqrt(-log(max(cvalu4,zrand)))
              st=ptact/prel
              if(st.gt.1.0) go  to 501
              ct=sqrt(1.-st*st)
            end if
            plund(nl,4)=0.0
            plund(nl,3)=-ct
            plund(nl,1)=-st
            plund(nl,2)=0.0
            call lurobo(thetlu,philu,0.0,0.0,0.0)
            thet=acos(max(-cvalu1,min(cvalu1,plund(nl,3))))
            ct=cos(thet)
            st=sin(thet)
            phi=atan2(plund(nl,2),plund(nl,1))
            mst(1)=0
            mst(2)=0
          end if
          nlund=nlund-2
        end if
      end if
      if(kpthig.ne.1) then
        ct=1.-2.*ranf(0)
        phi=ranf(0)*pi2
        st=sqrt(1.-ct*ct)
      end if
      pxrel=prel*cos(phi)*st
      pyrel=prel*sin(phi)*st
      pzrel=prel*ct
      npion=npion+1
      iwo=0
      if(nrmes(kclst)+nrbar(kclst).eq.iclusz(kclst))then
         if(kclst.eq.itripl .and. kdt.lt.idtcl) then
            write(lun8,*)
     +    'warning resdec: iclusz(itripl) too low'
         end if
         iwo=1
         io=0
         do 45 kcl=1,nrclst
  45     io=io+ iclusz(kcl)
         nrclst=nrclst+1
         nrbar(nrclst)=0
         nrmes(nrclst)=1
         iclusz(nrclst)=1
         nonrel(nrclst)=.false.
         l=io+1
         lmax=l
         if(l.ge.ntotma+1-nspect)
     a     call errex('particle number too large,abend in resdec')
      else if(nrmes(kclst)+nrbar(kclst).lt.iclusz(kclst))then
         nrmes(kclst)=nrmes(kclst)+1
         l=iofset+nrbar(kclst)+nrmes(kclst)
      else
         call errex('nrbar+nrmes.gt.iclusz  ???? ')
      end if
      nprtcl=nprtcl+1
      if(nprtcl.gt.ntotma) then
        call errex('nprtcl>ntotma in resdec, abort')
      end if
      ityp(l)=itypl
      npidec(l)=npidl
      em(l)=emmes
      ichbig(l)=0
      if(ida(15).ne.0)  ichbig(l)=3
      lastcl(l)=ievnt
      issn(l)=nprtcl
      identl=nprtcl
      tdtg(identl)=0.0
      itdth(1,identl)=0
      itdth(2,identl)=0
      itdth(3,identl)=0
      itdth(4,identl)=0
      itdth(5,identl)=0
      bx=ptot(1)/ptot(0)
      by=ptot(2)/ptot(0)
      bz=ptot(3)/ptot(0)
      b2=dmax1(1.d-6,bx*bx+by*by+bz*bz)
      gam=1./dsqrt(1.-b2)
      pb=bx*pxrel+by*pyrel+bz*pzrel
      ea=sqrt(em(l)*em(l)+pxrel*pxrel+pyrel*pyrel+pzrel*pzrel)
      gg=(gam-1.)*pb/b2+gam*ea
      p(1,l)=gg*bx+pxrel
      p(2,l)=gg*by+pyrel
      p(3,l)=gg*bz+pzrel
      pp= p(1,l)*p(1,l)+p(2,l)*p(2,l)+p(3,l)*p(3,l)
      p(0,l)=sqrt(em(l)*em(l)+pp)
         deltr= drind*sqrt(ranf(0))
         phi=pi2*ranf(0)
         costet=1.-2.*ranf(0)
         sintet=sqrt(1.-costet*costet)
         xrel= deltr* sintet* sin(phi)
         yrel= deltr* sintet* cos(phi)
         zrel= deltr* costet
         xb=bx*xrel+by*yrel+bz*zrel
         gg=(gam-1.)*xb/b2
         dr(0)= gam*xb
         dr(1)=gg*bx+xrel
         dr(2)=gg*by+yrel
         dr(3)=gg*bz+zrel
      delttr=decay(ind)-x(0,ind)
      if(qdot(0,ind).gt.0.) then
        do 201 i=0,3
         xind(i)=x(i,ind)+qdot(i,ind)/qdot(0,ind)*delttr
         x(i,l)=xind(i)+dr(i)
 201    continue
      else
         if(abs(delttr).gt.0.001) then
          write(lun8,*)
     +    'warning from resdec:  qdot(0)=0', ind,issn(ind),
     a               ityp(ind),npidec(ind),x(0,ind),decay(ind)
          call errex('resdec: qdot(0)=0 ?????? ')
         end if
         do 202 i=0,3
          xind(i)=x(i,ind)
          x(i,l)=xind(i)+ dr(i)
 202     continue
      end if
      tlast(l)=x(0,l)
      ylast(nprtcl)=0.5*log((p(0,l)+p(3,l))/(p(0,l)-p(3,l)))
      zlast(nprtcl)=x(3,l)-(pnorm(0)*x(0,l)-pnorm(3)*x(3,l))*pnorm(3)
      pidsq=embr*embr
      eb=sqrt(pidsq+pxrel*pxrel+pyrel*pyrel+pzrel*pzrel)
      gg=(gam-1.)*(-pb)/b2+gam*eb
      p(1,ind)=gg*bx-pxrel
      p(2,ind)=gg*by-pyrel
      p(3,ind)=gg*bz-pzrel
      pp= p(1,ind)*p(1,ind)+p(2,ind)*p(2,ind)+p(3,ind)*p(3,ind)
      p(0,ind)=sqrt(pidsq+pp)
      em(ind)=embar
      ityp(ind)=in
      npidec(ind)=npidn
      lastcl(ind)=ievnt
      tlast(ind)=xind(0)
      itdth(5,ident)=0
      startt=x(0,l)
      call dupdat(l,startt)
      startt=decay(ind)
      call dupdat(ind,startt)
      if(ifndnx.eq.0.and.ntag.eq.0)then
       if(ida(28).eq.0) then
           isccss=0
           imscst=2
           call mscstr(imscst,ind,l,isccss)
       else
           isccss=2
       end if
       if(switch(10)) then
            if(id1232.eq.1) ntag=l
            call paulin(ind,ntag)
            if(ntag.gt.0) call errex('ntag>0 not allowed in resdec')
       end if
       if(isccss.lt.1) ntag=-1
       if(ntag.lt.0)then
           idm=1
           call rstifo(ind,idm)
           startt=xind(0)
           call dupdat(ind,startt)
           nprtcl=nprtcl-1
           npion=npion-1
           if(iwo.eq.0) then
              nrmes(kclst)=nrmes(kclst)-1
           else
              nrclst= nrclst-1
           end if
           ityp(l)=-9999
       end if
      end if
      if(ntag.eq.0)then
         lmes=l
         do 401 i=0,3
  401    x(i,ind)=xind(i)
         if(itdth(2,ident).ne.0.and.
     a                      tdtg(ident).gt.xind(0)) then
           bxres=bx
           byres=by
           bzres=bz
           call qdrot(ind,ident,bxres,byres,bzres)
           decay(ind)=tdtg(ident)
           ilogo=itdth(2,ident)
           iexpon=isign(1,ilogo)*mod(iabs(ilogo),100)
         else
           iexpon=0
         end if
         ylast(ident)=0.5*log((p(0,ind)+p(3,ind))/(p(0,ind)-p(3,ind)))
         zlast(ident)=x(3,ind)-(pnorm(0)*x(0,ind)-
     a                                 pnorm(3)*x(3,ind))*pnorm(3)
      if(ida(5).eq.3) then
        ltypa=iabs(ltyp)
        if(ltypa.eq.41.or.ltypa.eq.42.or.ltypa.eq.62
     a                                 .or.ltypa.eq.63) then
          if(kmult.ge.0) then
            ibcode=100*kmult+ltyp
            write(lun10,1663) ibcode,ptot(0),(-ptot(i),i=1,3),emold
 1663 format(1x,i4,1x,5(f7.3,1x))
          end if
        end if
      end if
         if(ida(25).eq.1) then
           if(switch(23)) then
            ken= itripl
           else
            ken= kdt
           end if
           write(lun15,661)
     a        irun,ken,2,0,2,0,ident*1000+nclcnt(ident),0
  661      format(1x,i3,1x,i3,1x,i1,1x,i5,1x,i3,1x,i2,1x,i8,1x,i8)
  662    format(1x,i4,1x,i4,1x,f8.3,1x,2(f7.3,1x),f8.3,1x,
     a               f7.3,i3,1x,i8,1x,f8.3,2(1x,f7.3),1x,f8.3)
           if(iexpon.eq.0.or.qdot(0,ind).eq.0.0) then
             do 203 i=0,3
  203        xform(i)=xind(i)
           else
             do 204 i=0,3
  204        xform(i)=xind(i)+qdot(i,ind)/qdot(0,ind)*
     a                            (decay(ind)-xind(0))
           end if
           if(iqinv.eq.0) then
             itold=itind
           else
             call oldat(1,itold,npold,p0old,pxold,pyold,pzold,emold)
           end if
           if(npold.lt.-99) then
             npidl=-mod(-npold,100)
           else
             npidl=npold
           end if
           write(lun15,662)itold,npidl,ptot(0),ptot(1),ptot(2),
     a                                      ptot(3),emold,iexpon,
     b                                   ident,xind(0),
     c                               xind(1),xind(2),xind(3)
           write(lun15,662) ityp(ind),npidec(ind),(p(i,ind),i=0,3),
     a              em(ind),iexpon,issn(ind),xform(0),
     b                               xform(1),xform(2),xform(3)
           write(lun15,662)ityp(l),npidec(l),(p(i,l),i=0,3),em(l),
     a                        0,issn(l),x(0,l),
     b                               x(1,l),x(2,l),x(3,l)
           if(ida(36).eq.1) then
              if(ifndnx.eq.0) then
                 call dnscal(1,ind,-1,dens1)
                 write(lun15,663) dens1
              else
                 write(lun15,663) 0.
              end if
           end if
  663      format(1x,1(f6.3,1x))
           if(ida(38).eq.3.or.ida(38).eq.4) then
              if(itind.ge.3.and.itind.le.6.and.
     a                 (npold.eq.0.or.npold.eq.1)) then
                kstor(identl,1)=7
                kstor(ident,1)=7
              else
                kstor(identl,1)=3
                kstor(ident,1)=3
              end if
              if(ida(38).eq.3) then
                do 303 i=1,4
                 stork(identl,i)=x(i-1,l)
                 stork(ident,i)=x(i-1,ind)
  303           continue
              else
                do 304 i=1,4
  304           stork(identl,i)=stork(ident,i)
              end  if
              do 403 i=6,8
               stork(identl,i)=p(i-5,l)
               stork(ident,i)=p(i-5,ind)
  403         continue
           else if(ida(38).eq.1) then
             emil=em(l)
             if(issers(1,ida(38),ityp(l),npidec(l),emil))then
                   stork(identl,1)=stork(ident,1)
                   stork(identl,2)=stork(ident,2)
                   stork(identl,3)=stork(ident,3)
                   stork(identl,4)=stork(ident,4)
                   stork(identl,5)=stork(ident,5)
                   kstor(identl,1)=kstor(ident,1)
                   kstor(identl,2)=kstor(ident,2)
                   kstor(identl,3)=kstor(ident,3)
                   kstor(identl,4)=kstor(ident,4)
                   kstor(identl,5)=kstor(ident,5)
                   kstor(identl,6)=kstor(ident,6)
                   kstor(identl,7)=kstor(ident,7)
             end if
           end if
         end if
         if(ida(42).eq.1) then
           write(lun7)
     &        ityp(ind),issn(ind),npidec(ind),
     &        x(0,ind),x(1,ind),x(2,ind),x(3,ind),
     &        p(0,ind),p(1,ind),p(2,ind),p(3,ind),em(ind),
     &        tdtg(ident),itdth(2,ident),itdth(3,ident)
           if(iexpon.ne.0) then
             write(lun7)
     &        ityp(ind),issn(ind),npidec(ind),
     &        (xform(i),i=0,3),
     &        p(0,ind),p(1,ind),p(2,ind),p(3,ind),em(ind),
     &        0.0,0,0
           end if
           write(lun7)
     &          ityp(l),issn(l),npidec(l),
     &          x(0,l),x(1,l),x(2,l),x(3,l),
     &          p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &          0.0,0,0
         end if
         if(iwo.eq.0) then
              call propag(ind,l,0)
         else
              call propag(ind,-2,0)
         end if
      end if
      return
      end
      real function timelf(widgev,em,px,py,pz)
      include 'scatter7'
#include "amsrqmd.h"
      if(widgev.lt.0.) then
         timelf=0.
         return
      else if(widgev.gt.1.0e+10) then
         timelf=0.
         return
      end if
      wid=widgev*5.0674/da(4)
      p0=sqrt(em**2+px**2+py**2+pz**2)
      gam=p0/em
      zrand=ranf(0)
      tau=-log(max(zrand,cvalu2) )/wid
      timelf=gam*tau
      return
      end
      real function dwidth(em)
        include 'scatter7'
#include "amsrqmd.h"
       real*4 gamres
       common /gamrbk/ gamres
      if(em.gt.emnuc+empion) then
         pr=pcmsr(em,emnuc,empion)
      else
         pr=0.
      end if
      dwidth=29.*pr**3/(1.+40.*pr*pr)
      return
      end
      function dcratd(i,j,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 gamres,gemdl,emdl
       common /gamrbk/ gamres
       dimension lres(0:4,9),prob(0:4)
       data lres /1,1,1,1,1,
     a            0,0,3,0,0,
     b            3,3,0,3,3,
     c            0,0,0,3,0,
     d            4,4,2,2,4,
     e            2,2,2,2,2,
     f            2,2,2,2,2,
     g            3,3,3,3,3,
     h            4,4,4,4,4
     i           /
       dimension gemdl(9)
       data gemdl  /0.25, 0.16, 0.280, 0.15, 0.300, 0.220,
     a              0.22, 0.25 ,0.24/
       dimension emdl(9)
       data emdl  /1.60, 1.62, 1.700, 1.90, 1.905, 1.910,
     a              1.92, 1.93 ,1.95/
       dimension dcrat(0:4,9)
       data dcrat /
     a          0.15,0.35, 0.45, 0.05, 0.00,
     b          0.03,0.25, 0.60, 0.12, 0.00,
     c          0.00,0.15,.6984, 0.15,.0016,
     d          0.40,0.10, 0.05, 0.45, 0.00,
     e          0.16,0.10, 0.25, 0.45, 0.04,
     f          0.50,0.22, 0.14, 0.14, 0.00,
     g          0.40,0.20, 0.333,0.00,0.067,
     h          0.19,0.15, 0.36, 0.30, 0.00,
     i          0.13,0.55, 0.26, 0.053, 0.007
     j                                         /
       data prresm / 0.15/
       if(j.le.0.or.j.gt.9) then
         write(lun8,*) 'dcratd j=',j
         call errex('index j out of range in dcratd')
       end if
       if(i.lt.0.or.i.gt.4) then
         call errex('index i out of range in dcratd')
       end if
       probs=0.
       do 10 ilop=0,4
       if(ilop.eq.0)then
         if(j.eq.9) then
           embar=1.680
         else if(j.eq.8) then
           embar=1.675
         else if(j.eq.5) then
           embar=1.520
         else
           embar=1.440
         end if
         emmes=empion
       else if(ilop.eq.1)then
         embar=emnuc
         emmes=empion
       else if(ilop.eq.2)then
         embar=emdelt
         emmes=empion
       else if(ilop.eq.3)then
         embar=emnuc
         emmes=emrho
       else if(ilop.eq.4)then
         embar=emsigm
         emmes=emka0
       end if
       emres=emdl(j)
       if(emres.gt.embar+emmes) then
         prres=pcmsr(emres,embar,emmes)
         prres=max(prres,prresm)
       else
         prres=prresm
       end if
       if(em.gt.embar+emmes) then
         pr=pcmsr(em,embar,emmes)
         vfg=(emres/em)*1.2/(1.+0.2*(pr/prres)**(2*lres(ilop,j)))
       else
         pr=0.
         vfg=0.
       end if
       prob(ilop)=dcrat(ilop,j)*(pr/prres)**(2*lres(ilop,j)+1)*vfg
       if(prob(ilop).lt.0.) then
          call errex('neg. probability in dcratd')
       end if
       probs=probs+prob(ilop)
   10  continue
       gamres=probs*gemdl(j)
       if(probs.le.0.) then
           call errex('probs=0. abort in dcratd')
       end if
       dcratd=prob(i)/probs
      return
      end
      function dcratn(i,j,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 gamres,gemn2,emn2
       common /gamrbk/ gamres
       dimension lres(0:6,10),prob(0:6)
       data lres /
     a             1,1,1,1,1,1,1,
     b             2,2,0,0,2,2,2,
     c             0,0,2,0,0,0,0,
     d             0,0,2,0,0,0,0,
     e             2,2,2,2,2,2,2,
     f             3,3,1,1,3,3,3,
     g             2,2,2,0,2,2,2,
     h             1,1,1,1,1,1,1,
     i             1,1,1,1,1,1,1,
     j             3,3,3,3,3,3,3
     k           /
       dimension emn2(10)
       data emn2  /1.44, 1.52, 1.535, 1.65, 1.675, 1.680,
     a              1.7, 1.71, 1.72, 1.99/
       dimension gemn2(10)
       data gemn2  /0.200,0.125, 0.150, 0.15, 0.155, 0.125,
     a              0.1, 0.11, 0.20, 0.29/
       dimension dcrat(0:6,10)
       data dcrat /
     a         0.200,0.50, 0.15, 0.15, 0.00, 0.00, 0.00,
     b         0.000,0.55, 0.25, 0.20, 0.00, 0.00, 0.00,
     c         0.050,0.40, 0.00, 0.05, 0.50, 0.00, 0.00,
     d         0.080,0.60, 0.05, 0.175,0.015,0.08, 0.00,
     e         0.014,0.375,0.575,0.025,0.01, 0.001,0.00,
     f         0.150,0.60, 0.125,0.125,0.00, 0.00, 0.00,
     g         0.379,0.10, 0.379,0.10, 0.04, 0.002,0.00,
     h         0.090,0.15, 0.10, 0.20, 0.25, 0.15, 0.06,
     i         0.100,0.15, 0.10, 0.53, 0.035,0.05, 0.035,
     j         0.000,0.05, 0.40, 0.43, 0.07, 0.03, 0.02   /
       data prresm / 0.15/
       data ibug/ 0/
       if(j.le.0.or.j.gt.10) then
         call errex('index j out of range in dcratn')
       end if
       if(i.lt.0.or.i.gt.6) then
         call errex('index i out of range in dcratn')
       end if
       probs=0.
       do 10 ilop=0,6
       if(ilop.eq.0)then
         embar=emnuc
         emmes=0.60
       else if(ilop.eq.1)then
         embar=emnuc
         emmes=empion
       else if(ilop.eq.2)then
         embar=emdelt
         emmes=empion
       else if(ilop.eq.3)then
         embar=emnuc
         emmes=emrho
       else if(ilop.eq.4)then
         embar=emnuc
         emmes=emeta
       else if(ilop.eq.5)then
         embar=emlamb
         emmes=emka0
       else if(ilop.eq.6)then
         embar=emsigm
         emmes=emka0
       end if
       emres=emn2(j)
       if(emres.gt.embar+emmes) then
         prres=pcmsr(emres,embar,emmes)
         prres=max(prres,prresm)
       else
         prres=prresm
       end if
       if(em.gt.embar+emmes) then
         pr=pcmsr(em,embar,emmes)
         vfg=(emres/em)*1.2/(1.+0.2*(pr/prres)**(2*lres(ilop,j)))
       else
         pr=0.
         vfg=0.
       end if
       prob(ilop)=dcrat(ilop,j)*(pr/prres)**(2*lres(ilop,j)+1)*vfg
       if(prob(ilop).lt.0.) then
           write(lun8,*) em,j,i,prob(ilop),probs
           write(lun8,*) ilop,prres,pr,emres,embar,emmes
          call errex('neg. probability in dcratn')
       end if
       probs=probs+prob(ilop)
   10  continue
       gamres=probs*gemn2(j)
       if(probs.le.0.) then
           write(lun8,*) em,j,i,(prob(ilop),ilop=1,4),probs
           call errex('probs=0. abort in dcratn')
       end if
       dcratn=prob(i)/probs
      return
      end
      function dcrato(i,j,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 pmas,pwid,cfr
       common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       parameter (ichaom=3,irenom=1)
       real*4 gamres,gemom,emom
       common /gamrbk/ gamres
       dimension lres(ichaom,irenom),it1(ichaom),it2(ichaom)
       data lres /3*3
     e           /
       data it1 / 47,69,70
     a          /
       data it2 / 19,19,24
     a          /
       data ibegin /0/
       dimension emom(irenom),gemom(irenom),dcrat(ichaom,irenom)
       data emom  /2.230 /
       data gemom / 0.036/
       data dcrat /
     a              0.928, 0.072, 0.000/
       dimension prob(ichaom)
       if(j.le.0.or.j.gt.irenom) then
         write(lun8,*) 'dcrato j=',j
         call errex('index j out of range in dcrato')
       end if
       if(i.lt.1.or.i.gt.ichaom) then
         call errex('index i out of range in dcrato')
       end if
       probs=0.
       do 10 ilop=1,ichaom
       embar=pmas(it1(ilop))
       emmes=pmas(it2(ilop))
       emres=emom(j)
       if(emres.gt.embar+emmes) then
          prres=pcmsr(emres,embar,emmes)
       else
         prres=-1.
       end if
       if(em.gt.embar+emmes) then
         pr=pcmsr(em,embar,emmes)
         vfg=(emres/em)*1.2/(1.+0.2*(pr/prres)**(2*lres(ilop,j)))
       else
         pr=0.
         vfg=0.
       end if
       prob(ilop)=dcrat(ilop,j)*(pr/prres)**(2*lres(ilop,j)+1)*vfg
       if(prob(ilop).lt.0.) then
          call errex('neg. probability in dcrato')
       end if
       probs=probs+prob(ilop)
   10  continue
       gamres=probs*gemom(j)
       if(probs.le.0.) then
           write(lun8,*) 'em=',em,i,j
           call errex('probs=0. abort in dcrato')
       end if
       dcrato=prob(i)/probs
      return
      end
      function dcratc(i,j,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 pmas,pwid,cfr
       common /ludat2s/ ktyp(120),pmas(120),pwid(60),kfr(80),cfr(40)
       real*4 gamres,gemca,emca
       common /gamrbk/ gamres
       dimension lres(8,5),prob(8),it1(8),it2(8)
       data it1 / 47,47,69,69,45,57,67,70
     a          /
       data it2 / 17,24,17,24,19,19,19,19
     a          /
       data lres /2*0,2*2,2*0,2*2,
     a            2*2,2*0,2*2,2*0,
     b            2*3,2*1,2*3,2*1,
     c            8*2,
     d            2*3,2*2,2*3,2*2
     e           /
       data ibegin /0/
       dimension emca(5),gemca(5),dcrat(8,5)
       data emca  / 1.82,1.835,1.945,2.04,2.130 /
       data gemca /
     a  0.025,0.076,0.084,0.059,0.052/
       data dcrat /
     a  0.261, 0.944, 0.013, 0.024, 0.300, 0.425, 0.024, 0.048,
     b  0.604, 0.005, 0.086, 1.451, 0.190, 0.120, 1.451, 2.902,
     c  0.573, 0.000, 0.145, 1.070, 0.166, 0.102, 0.013, 2.140,
     d  0.008, 0.029, 0.033, 0.085, 0.691, 0.221, 0.018, 0.169,
     e  0.278, 0.032, 0.054, 0.000, 0.186, 0.343, 0.107, 0.690/
       if(j.le.0.or.j.gt.5) then
         write(lun8,*) 'dcratc j=',j
         call errex('index j out of range in dcratc')
       end if
       if(i.lt.1.or.i.gt.8) then
         call errex('index i out of range in dcratc')
       end if
       probs=0.
       do 10 ilop=1,8
       embar=pmas(it1(ilop))
       emmes=pmas(it2(ilop))
       emres=emca(j)
       if(emres.gt.embar+emmes) then
         prres=pcmsr(emres,embar,emmes)
       else
         embax=pmas(46)
         prres=pcmsr(emres,embax,empion)
       end if
       if(em.gt.embar+emmes) then
         pr=pcmsr(em,embar,emmes)
         vfg=(emres/em)*1.2/(1.+0.2*(pr/prres)**(2*lres(ilop,j)))
       else
         pr=0.
         vfg=0.
       end if
       prob(ilop)=dcrat(ilop,j)*(pr/prres)**(2*lres(ilop,j)+1)*vfg
       if(prob(ilop).lt.0.) then
          call errex('neg. probability in dcratc')
       end if
       probs=probs+prob(ilop)
   10  continue
       gamres=probs*gemca(j)
       if(probs.le.0.) then
           write(lun8,*) 'em=',em,i,j
           call errex('probs=0. abort in dcratc')
       end if
       dcratc=prob(i)/probs
      return
      end
      subroutine bwdist(idn,irand,em,ires,ibrnch,dcrat,bwig)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 gamres,emdl,emn2,emca
       common /gamrbk/ gamres
       dimension prob(10)
       dimension emdl(9),emn2(10),emca(5)
       data emdl  /1.60, 1.62, 1.700, 1.90, 1.905, 1.910,
     a              1.86, 1.93 ,1.95/
       data emn2  /1.44, 1.52, 1.535, 1.65, 1.675, 1.680,
     a              1.7, 1.71, 1.72, 1.99/
       data emca  /1.835, 1.82, 2.04,1.945,2.130 /
       dimension jspd(9),jspn(10),jspc(5)
       data jspd  /3,1,3,1,5,1,3,5,7/
       data jspn  /1,3,1,1,5,5,3,1,3,7/
       data jspc  /1,3,5,5,7/
       if(irand.gt.0) then
         maxres=ires
         iofs=ires
       else
         ires=-1
         if(idn.eq.1.or.idn.eq.2) then
           maxres=8+idn
         else if(idn.eq.5) then
           maxres=5
         else
           call errex('bwdist: wrong idn input')
         end if
         iofs=1
       end if
       probs=0.
       do 10 ilop=iofs,maxres
        if(idn.eq.1) then
            emres=emdl(ilop)
            dcrat=dcratd(ibrnch,ilop,em)
            jres=jspd(ilop)
        else if(idn.eq.2) then
            dcrat=dcratn(ibrnch,ilop,em)
            emres=emn2(ilop)
            jres=jspn(ilop)
        else if(idn.eq.5) then
            dcrat=dcratc(ibrnch,ilop,em)
            emres=emca(ilop)
            jres=jspc(ilop)
        end if
        bwig=(jres+1.)*dcrat*gamres**2/((em-emres)**2+0.25*gamres**2)
        prob(ilop)=bwig
        probs=probs+prob(ilop)
   10  continue
       if(irand.lt.0) then
         if(probs.eq.0.) then
           ires=999
           dcrat=0.
           bwig=0.
           return
         else
           zrand=min(ranf(0),0.999)
           do 20 ilop=iofs,maxres
            prob(ilop)=prob(ilop)/probs
            if(zrand.lt.prob(ilop))then
             ires=ilop
             go to 21
            else
             zrand=zrand-prob(ilop)
            end if
   20     continue
   21     continue
         end if
         if(ires.lt.0) then
            write(lun8,*)'bwdist',idn,irand,em,ires,ibrnch,dcrat
            call errex('no resonance found in bwdist????? ')
         end if
         if(idn.eq.1) then
            emres=emdl(ires)
            dcrat=dcratd(ibrnch,ires,em)
            jres=jspd(ires)
         else if(idn.eq.2) then
            dcrat=dcratn(ibrnch,ires,em)
            emres=emn2(ires)
            jres=jspn(ires)
         else if(idn.eq.5) then
            dcrat=dcratc(ibrnch,ires,em)
            emres=emca(ires)
            jres=jspc(ires)
         end if
         bwig=(jres+1.)*dcrat*gamres**2/((em-emres)**2+0.25*gamres**2)
       end if
      return
      end
      function dcr(kmult,kf,em)
       include 'scatter7'
#include "amsrqmd.h"
       real*4  dcr
       real*4 em
       emr=em
       dcr=widr(kmult,kf,emr)
      return
      end
      function dcrm(kmult,kf,em)
#include "amsrqmd.h"
       common /gamrbk/ gamres
       identr=idtmes(kmult,kf)
       call mesres(3,
     a    identr,0,0,0,0,k1n,k2n,iclcod,isobre,istrin,em,resxs,
     b                                                        reswav)
       dcrm=gamres
      return
      end
      function idtmes(kmult,kf)
#include "amsrqmd.h"
       kfa=iabs(kf)
       if(kmult.eq.1) then
         if(kfa.eq.17.or.kfa.eq.23) then
           idtmes=11
         else if(kf.eq.24) then
           idtmes=17
         else if(kf.eq.25) then
           idtmes=10
         else if(kfa.eq.18.or.kfa.eq.19) then
           idtmes=25
         else
           call errex('dcrm1, unknown meson code')
         end if
       else if(kmult.eq.2) then
         if(kfa.eq.17.or.kfa.eq.23) then
           idtmes=13
         else if(kf.eq.24) then
           idtmes=18
         else if(kf.eq.25) then
           idtmes=20
         else if(kfa.eq.18.or.kfa.eq.19) then
           idtmes=22
         else if(kfa.eq.27.or.kfa.eq.33) then
           idtmes=34
         else if(kf.eq.34) then
           idtmes=12
         else if(kf.eq.35) then
           idtmes=20
         else if(kfa.eq.28.or.kfa.eq.29) then
           idtmes=24
         else
           call errex('dcrm2, unknown meson code')
         end if
       else if(kmult.eq.3) then
         if(kfa.eq.17.or.kfa.eq.23) then
           idtmes=30
         else if(kf.eq.24) then
           idtmes=14
         else if(kf.eq.25) then
           idtmes=31
         else if(kfa.eq.18.or.kfa.eq.19) then
           idtmes=26
         else
           call errex('dcrm3, unknown meson code')
         end if
       else
         call errex('dcrm, unknown meson code')
       end if
      return
      end
CPAT,PAULIN   .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine paulin(ind,ntag)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      dimension qlk(0:3),plk(0:3),xind(0:3),pind(0:3)
      real*4  con(ntotma),  dxvc(ntotma),dpvc(ntotma)
      dimension pik(0:3)
      dimension ptngb(0:3),pdelt(0:3)
      real*8 pindsq,qlk,plk,dqlksq,dplksq,xpind,dqpind,dppind,
     a       pr2,r2,tcm,xcm,ycm,zcm,ecm,pxcm,pycm,pzcm,prcm,xcos,
     b       pxcos,
     c       ptngb,pdelt,pik,pind,xind
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data cos45 / 0.707/
      common/paulbk/
     a     aux,const3,radn,padn,radn2,padn2,phs
      data vernum/'version rqmd 1.08 -- 22-apr-92'/
      data pronam /'p a u l i n-no collisions into occupied states'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
        aux=(4.*pi/3.)**2
        const3=4./9.*pi*pi*4/(hc)**3.
        radn=3.
        padn=hc/radn/aux**.333/4**0.333
        radn2=(2.*radn)**2
        padn2=(2.*padn)**2
        phs=16./9.*pi*pi*radn**3*padn**3/(2*pi *.197)**3
233     format(1x,'pauli radii   r = ',f6.2,'   p = ',f6.2)
      end if
      if(ntag.gt.0) then
         linepi=ntag
      else
         linepi=0
      end if
      ntag=0
      if(iabs(ityp(ind)).gt.2) return
      sum=0.
      psum=0.
      contrs=0.
      tcm=0.
      xcm=0.
      ycm=0.
      zcm=0.
      ecm=0.
      pxcm=0.
      pycm=0.
      pzcm=0.
      nn=0
      nn3=0
      nn4=0
      nn5=0
      nn6=0
      do 5 i=0,3
       xind(i)=x(i,ind)+qdot(i,ind)*dtprop
    5 continue
      do 15 i=0,3
      pind(i)=p(i,ind)
      ptngb(i)=0.
   15 continue
      pindsq=pind(0)*pind(0)
      do 7 i=1,3
    7 pindsq=pindsq-pind(i)*pind(i)
      if(pindsq.lt.0.) then
          call errex('imaginary mass in paulin')
      end if
      do 1 k=1,nrbar(kclst)
      con(k)=0.
      ik=iofset+k
      if(iabs(ityp(ik)).gt.2) go to 1
      if(ik.eq.ind) go to 1
      do 6 i=0,3
      qlk(i)=x(i,ik)+qdot(i,ik)*dtprop-xind(i)
      plk(i)=p(i,ik)
    6 continue
      if(switch(23)) then
       if(qdot(0,ik).eq.0.) then
         do  9 i=0,3
    9    pik(i)=p(i,ik)
       else
         do 3 i=0,3
    3    pik(i)=qdot(i,ik)
       end if
       pkpkin =pik(0)*(pind(0)+plk(0))
       dqpkin =qlk(0)*(pind(0)+plk(0))
       do 4 i=1,3
        pkpkin=pkpkin-pik(i)*(pind(i)+plk(i))
        dqpkin=dqpkin-qlk(i)*(pind(i)+plk(i))
    4  continue
       do 27 i=0,3
       qlk(i)=qlk(i)- dqpkin/pkpkin * pik(i)
   27  continue
      end if
      dqlksq=qlk(0)*qlk(0)
      dplksq=plk(0)*plk(0)
      xpind =xind(0)*pind(0)
      dqpind =qlk(0)*pind(0)
      dppind =plk(0)*pind(0)
      do 8 i=1,3
      xpind=xpind-xind(i)*pind(i)
      dqpind=dqpind-qlk(i)*pind(i)
      dppind=dppind-plk(i)*pind(i)
      dqlksq=dqlksq-qlk(i)*qlk(i)
      dplksq=dplksq-plk(i)*plk(i)
    8 continue
      pr2= -dplksq+dppind*dppind/pindsq
      r2= -dqlksq+dqpind*dqpind/pindsq
      r=sqrt(r2)
      dxvc(k)=r
      if(r2.gt.radn2) goto 1
      nn3=nn3+1
      if(issn(ik).le.nt.and.nclcnt(issn(ik)).eq.0) then
        if(issn(ik).le.n1) then
          nn5=nn5+1
        else
          nn6=nn6+1
        end if
      end if
      do 34 i=0,3
       ptngb(i)=ptngb(i)+plk(i)
   34 continue
      if(pr2.gt.padn2) goto 1
      if(pr2.lt.0.) then
        pr2=0.
      end if
      pr=sqrt(pr2)
      r=sqrt(r2)
      dxvc(k)=r
      dpvc(k)=pr
      ahr=radn-r/2.
      ahp=padn-pr/2.
      contr=const3*ahr*ahr*(3*radn-ahr)*ahp*ahp*(3*padn-ahp)
      con(k)=contr
      tcm=tcm+qlk(0)-dqpind/pindsq*pind(0)
      xcm=xcm+qlk(1)-dqpind/pindsq*pind(1)
      ycm=ycm+qlk(2)-dqpind/pindsq*pind(2)
      zcm=zcm+qlk(3)-dqpind/pindsq*pind(3)
      ecm=ecm+plk(0)-dppind/pindsq*pind(0)
      pxcm=pxcm+plk(1)-dppind/pindsq*pind(1)
      pycm=pycm+plk(2)-dppind/pindsq*pind(2)
      pzcm=pzcm+plk(3)-dppind/pindsq*pind(3)
      nn=nn+1
      contrs=contrs+contr
    1 continue
      if(nn.eq.0)return
      rhosph=nn3/(4./3.*pi*radn2**1.5)/rho0
      eexct=sqrt(ptngb(0)**2-ptngb(1)**2-ptngb(2)**2-ptngb(3)**2)/nn3
      ekcms=(pind(0)*ptngb(0)-pind(1)*ptngb(1)-pind(2)*ptngb(2)
     a                                     -pind(3)*ptngb(3))/ eexct/nn3
     b       -sqrt(pindsq)
      if(ida(3).eq.1.and.ekcms.lt.0.037) then
       ekcms=ekcms-0.039
      end if
      ectoff=-eexct+emnuc+0.3*0.2684**2/emnuc*rhosph**0.66667+
     a                  0.5*alpha*rhosph+beta/(gamma+1.)*rhosph**gamma
      if(linepi.gt.0) then
        if(nn5.gt.nn6) then
          inucl=1
        else
          inucl=0
        end if
        nn5=max(nn5,nn6)
        if(nn5.gt.0) then
           xfrac=float(nn5)/float(nn3)
           if(xfrac.lt.0.9) xfrac=0.
        else
           xfrac=0.
        end if
        if(eexct-emnuc.lt.0.01.and.xfrac.gt.0.) then
          if(linepi.le.0.or.linepi.gt.ntotma-nspect) then
             call errex('linepi out of range in paulin')
          end if
          pdelt(0)=p(0,linepi)+pind(0)
          edelt=pdelt(0)*ptngb(0)
          emdact=pdelt(0)*pdelt(0)
          do 41 i=1,3
           pdelt(i)=p(i,linepi)+pind(i)
           edelt=edelt-pdelt(i)*ptngb(i)
           emdact=emdact-pdelt(i)*pdelt(i)
   41     continue
          edelt=edelt/eexct/nn3
          emdact=sqrt(emdact)
          pdact=sqrt(edelt*edelt-emdact*emdact)
          prel=pcmsr(emdact,emnuc,empion)
        else
          linepi=0
          if(ekcms.gt.ectoff) then
            sumf=contrs
            go to 33
          end if
        end if
      else
        if(ekcms.gt.ectoff) then
          sumf=contrs
          go to 33
        end if
      end if
      tcm=tcm/nn-xind(0)+xpind/pindsq*pind(0)
      xcm=xcm/nn-xind(1)+xpind/pindsq*pind(1)
      ycm=ycm/nn-xind(2)+xpind/pindsq*pind(2)
      zcm=zcm/nn-xind(3)+xpind/pindsq*pind(3)
      rcm=sqrt(-tcm*tcm+xcm*xcm+ycm*ycm+zcm*zcm)
      ecm=ecm/nn
      pxcm=pxcm/nn
      pycm=pycm/nn
      pzcm=pzcm/nn
      arg = -ecm*ecm+pxcm*pxcm+pycm*pycm+pzcm*pzcm
      if(arg.lt.0.) then
         prcm=0.
         if(-arg.gt. 1.e-3) then
            write(lun8,*) 'ind=',ind,'nn=',nn
            write(lun8,*)'paulin: imaginary prcm arg=',arg
            call errex('num. error in paulin too large,not corrected')
         end if
      else
         prcm=sqrt(arg)
      end if
      do 2 k=1,nrbar(kclst)
      if(linepi.eq.0.and.con(k).eq.0.) go to 2
      ik=k+iofset
      do 16 i=0,3
      qlk(i)=x(i,ik)+qdot(i,ik)*dtprop-xind(i)
      plk(i)=p(i,ik)
   16 continue
      if(switch(23)) then
        if(qdot(0,ik).eq.0.) then
         do 31 i=0,3
   31    pik(i)=p(i,ik)
        else
         do 32 i=0,3
   32    pik(i)=qdot(i,ik)
        end if
        pkpkin =pik(0)*(pind(0)+plk(0))
        dqpkin =qlk(0)*(pind(0)+plk(0))
        do 21 i=1,3
         pkpkin=pkpkin-pik(i)*(pind(i)+plk(i))
         dqpkin=dqpkin-qlk(i)*(pind(i)+plk(i))
   21   continue
        do 28 i=0,3
         qlk(i)=qlk(i)- dqpkin/pkpkin * pik(i)
   28   continue
      end if
      dr=dxvc(k)
      pdr=dpvc(k)
      if(dr*rcm.gt.1.e-4) then
        xcos=(-qlk(0)*tcm+qlk(1)*xcm+qlk(2)*ycm+qlk(3)*zcm)/dr/rcm
      else
        xcos=1.
      end if
      if(xcos.gt.cos45) then
        sum=sum+con(k)
      end if
      if(linepi.gt.0) then
        if(dr*dr.le.radn2.and.xcos.gt.cos45) then
           if(nclcnt(issn(ik)).eq.0.and.issn(ik).le.
     a           nt-inucl*n2.and.issn(ik).gt.(1-inucl)*n1) then
             nn4=nn4+1
           end if
        end if
      end if
      if(pdr.eq.0.) then
       pxcos=1.
      else if(prcm.eq.0.) then
       pxcos=1.
      else
       pxcos=(-plk(0)*ecm+plk(1)*pxcm+plk(2)*pycm+plk(3)*pzcm)/pdr/prcm
      end if
      if(pxcos.gt.cos45) then
        psum=psum+con(k)
      end if
   2  continue
      sum=sum*6.83
      psum=psum*6.83
      sumf=max(sum,psum)
      if(sumf.lt.contrs)  sumf=contrs
      if(linepi.gt.0) then
        rhodlt=nn4/(2.*(1.-cos45)/3.*pi*radn2**1.5)/rho0
        rhod=min(cvalu1,rhodlt)
        fpact=0.27*rhod**0.3333
        costmn=(prel*prel+(pdact/emdact*eexct)**2-fpact*fpact)*emdact/
     a             (2.*eexct*pdact*prel)
        costmn=min(cvalu1,max(costmn,-cvalu1))
        pcoll=0.25*(2.+ costmn + costmn**3)
        pblock=1.-pcoll
        if(pblock.gt.sumf) sumf=pblock
      end if
   33 continue
      if(sumf.gt.ranf(0))ntag=-1
      return
      end
CPAT,PIMAT    .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine piweg(i1,i2,i3,i4,nop,imixt,
     a                                  itag1,itag2,ichanl,srt,icltyp)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      parameter( fstrsq=4.5238)
      parameter( em1=0.138,npd1=0,em2=0.938,npd2=0)
      parameter( parama=fstrsq/em1/em1/6./3.141592*em2)
      parameter( paramb=20./3.*fstrsq/em1/em1/(5.0674)**2 )
      parameter( b0im=0.035/em1**4 )
      parameter( dsemax=0.04 )
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 1.09 -- 14-jul-93'/
      data pronam/'p i w e g  -- pion  absorption'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      kyes=0
      if(srt.le. emnuc+empion.or.srt.gt.1.5) return
      if(iqcnvt.ne.0.or.itag1.ne.0.or.itag2.ne.0) then
        kyes=1
      end if
      ppr= sqrt(((srt*srt-emnuc*emnuc-empion*empion)/
     a                                 (2.*emnuc))**2-empion*empion)
      pcms=pcmsr(srt,emnuc,empion)
      gamd=parama/srt*pcms**3
      sigin=paramb/(srt/emnuc*pcms)*
     a               pcms**2*dsemax/((srt-emdelt)**2+0.25*gamd**2)
      pimsmx=sigin
      pilu=sqrt(empion*empion+ppr*ppr)
      tpion=pilu-empion
      sigsab=1.5*(hc/pi2)**5*20.*pi2/ppr*
     a             (1.+0.5*pilu/empion)*b0im*rho0*
     b                            exp(-6.*max(cvalu0,tpion-.1))
      sigin=sigin+sigsab
      if(ranf(0).gt.sigsab/sigin) then
            sigsab=0.
      end if
      itp1=ityp(i1)
      itp2=ityp(i2)
      call cross1(1,srt,pcms,icltyp,sig,em1,em2,
     a                                  itp1,itp2,npd1,npd2)
      if(kyes.eq.1.or.ida(39).eq.0) then
         if(ranf(0).lt.sigin/sig) ichanl=0
      else
        zrand=ranf(0)
        if(zrand.gt.sigin/sig) then
          gmdlt= 29.*pcms**3/(1.+40.*pcms*pcms)
          sigsab=gmdlt/((srt-emdelt)**2+0.25*gmdlt**2)
          if(srt.gt.1.3) then
             xsdelt=10.*(hc/pi2)**2*pi2/pcms**2*sigsab*gmdlt
             if(imixt.eq.1) then
             elseif(imixt.eq.2) then
               xsdelt=0.3333*xsdelt
             else if(imixt.eq.3) then
               xsdelt=0.6667*xsdelt
             end if
             if(ranf(0)*(sig-sigin).gt.xsdelt) return
          end if
          sigsab=-sigsab
        end if
        call imsed(srt,pimsed,
     a               pimsmx,sigsab,icltyp,i1,i2,i3,i4,ichanl,nop)
      end if
      return
      end
      subroutine ndmed(i1,i2,i3,i4,nop,srt,
     a                  idcid1,idcid2,itag1,itag2,
     b                  icltyp,ityp1,npid1,ityp2,npid2,em1,em2,ichanl)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      if(ida(39).eq.1.and.idcid1.eq.0.and.idcid2.eq.0
     a       .and.iabs(npidec(i1)).le.1.and.iabs(npidec(i2)).le.1
     b            .and.itag1.eq.0.and.itag2.eq.0.and.iqcnvt.eq.0) then
      else
        if(ranf(0).gt.1./enhcnd) then
         ichanl=0
         call rstifo(i1,1)
         call rstifo(i2,2)
        end if
        return
      end if
      if(ityp(i1).ge.3.and.ityp(i1).le.6) then
         ia=i1
         ib=i2
         emd=em1
      else if(ityp(i2).ge.3.and.ityp(i2).le.6) then
         emd=em2
         ia=i2
         ib=i1
      else
          call errex('no delta in entrance, abort in ndmed')
      end if
      prel=pcmsr(emd,emnuc,empion)
      gamd= 29.*prel**3/(1.+40.*prel*prel)
      pimsmx=gamd
      call imsed(srt,pimsed,pimsmx,sigdum,
     a                    icltyp,ia,ib,i3,i4,ichanl,nop)
      if(ichanl.eq.0) then
         call rstifo(i1,1)
         call rstifo(i2,2)
      end if
      return
      end
      subroutine imsed(srt,pimsed,pimsmx,sigsab,
     a                                icltyp,i1,i2,i3,i4,ichanl,nop)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
        dimension qlk(0:3),plk(0:3),xind(0:3),p1(0:3),p2(0:3),pil(0:3)
        dimension prest(0:3),presto(0:3)
        data fmrho0,ds2 /0.27,2.165/
        data fstrsq / 4.5238/
       real*4 force,dcoef
       common/blocal/ ngbor(ntotma),force(0:3,ntotma),dcoef(ntotma)
       common /pimabk/
     a            ds2n,b0im,parama,paramb
        logical*1 ttvers
        data ttvers/ .true./
        cq(dum1)=-5.19*dum1*dum1+15.35*dum1+2.06
        ca2(dum2)=1.06*dum2*dum2-6.64*dum2+22.66
        ca3(dum3)=-13.46*dum3*dum3+46.17*dum3-20.34
        alp(dum4)=0.382*dum4*dum4-1.322*dum4+1.466
        bet(dum5)=-0.038*dum5*dum5+0.204*dum5+0.613
      if(ttvers) then
          ds2n=(pi*ds2)**1.5 * rho0
          b0im= 0.035/empion**4
          parama= fstrsq/empion/empion/6./pi*emnuc
          paramb= 20./3.*fstrsq/empion/empion*(hc/pi2)**2
          ttvers=.false.
      end if
      if(icltyp.le.3) then
         iclas=3
         i3delt=2*ityp(i1)-9
         if(iabs(i3delt).eq.1) then
            if(ranf(0).gt.0.6667) then
               ichgpi=isign(1,i3delt)
            else
               ichgpi=0
            end if
         else
            ichgpi=isign(1,i3delt)
         end if
         if(ityp(i1).eq.3) then
            iqabs=-1
            itp1n=1
         else if(ityp(i1).eq.6) then
            iqabs=1
            itp1n=2
         else
            iqabs=0
            itp1n=ityp(i1)-3
         end if
         itp2n=ityp(i2)
      else if(ityp(i1).ge.3.and.ityp(i1).le.6) then
         call errex('iclas=1 not allowed in imsed')
         iclas=1
         if(ityp(i1).eq.3) then
            iqabs=-1
            itp1n=1
         else if(ityp(i1).eq.6) then
            iqabs=1
            itp1n=2
         else
            iqabs=0
            itp1n=ityp(i1)-3
         end if
         iqs=ityp(i2)-1+iqabs
         if(iqs.eq.0.or.iqs.eq.1) then
           itp2n=iqs+1
           iqabs=0
         else
           itp2n=ityp(i2)
         end if
      else if(ityp(i1).ge.7.and.ityp(i1).le.9) then
         iclas=2
         ichgpi=ityp(i1)-8
         itp1n=-9999
         iqabs=ityp(i1)-8
         iqs=ityp(i2)-1+iqabs
         if(iqs.eq.0.or.iqs.eq.1) then
           itp2n=iqs+1
           iqabs=0
         else
           if(iqs.eq.2) then
             itp2n=2
             iqabs=1
           else if(iqs.eq.-1) then
             itp2n=1
             iqabs=-1
           end if
         end if
      else
          call errex('wrong particle type for absorption in imsed')
      end if
      if(iabs(iqabs).gt.1) then
          call errex('remaining charge exceeds -1 in imsed')
      end if
      i3=0
      i4=0
      pimsed=0.
      pimsqe=0.
      innch=2
      nrb=nrbar(kclst)
      do  9 i=0,3
    9   xind(i)=x(i,i2)+qdot(i,i2)*dtprop
        do 33 i=0,3
   33   prest(i)=0.
      do 30 l=1,nrb
       prop(l)=.false.
       dcoef(l)=0.
       il=iofset+l
       if(ityp(il).ne.1.and.ityp(il).ne.2) go to 30
       identl=issn(il)
       if(itdth(2,identl).ne.0 ) go to 30
       if(qdot(0,il).eq.0.) then
         do 10 i=0,3
   10     pil(i)=p(i,il)
       else
         do 20 i=0,3
   20     pil(i)=qdot(i,il)
       end if
       do 11 i=0,3
        qlk(i)=x(i,il)-xind(i)
        plk(i)=p(i,il)+p(i,i2)
   11  continue
       plplin =pil(0)*plk(0)
       dqplin =qlk(0)*plk(0)
       do 12 i=1,3
        plplin=plplin-pil(i)*plk(i)
        dqplin=dqplin-qlk(i)*plk(i)
   12  continue
       do 13 i=0,3
       qlk(i)=qlk(i)- dqplin/plplin *pil(i)
   13  continue
       dqlksq = qlk(0) *qlk(0)
       do 14 i=1,3
        dqlksq = dqlksq - qlk(i) *qlk(i)
   14  continue
       zlk= dqlksq
       if(sqrt(max(cvalu0,-zlk)).gt.3.) go to 30
       prop(l)=.true.
       dcoef(l)=exp(zlk/ds2)/ds2n
       if(iclas.eq.3.and.il.eq.i2) go to 30
        do 29 i=0,3
   29   prest(i)=prest(i)+p(i,il)
   30 continue
      fm=2.*fmrho0
      fmact=fmrho0
      if(iclas.eq.3.and.prest(0).eq.0.) then
         if(ranf(0).gt.1./enhcnd) ichanl=0
         return
      end if
      dens=0.
      cmsen=
     a   sqrt(prest(0)**2-(prest(1)**2+prest(2)**2+prest(3)**2))
      niter=0
   34 niter=niter+1
      denso=dens
      cmseno=cmsen
      cmsen=
     a   sqrt(prest(0)**2-(prest(1)**2+prest(2)**2+prest(3)**2))
      if(cmsen.le.0.1) then
        inabs=0
        go to 140
      else
        do 35 i=0,3
   35   prest(i)=prest(i)/cmsen
      end if
      dens=0.
      do 36 i=0,3
      presto(i)=prest(i)
      prest(i)=0.
   36 continue
      inabs=0
      pnabsp=0.
      pnabsn=0.
      do 40 l=1,nrb
       if(dcoef(l).eq.0.) go to 40
       il=iofset+l
       pilu=p(0,il)*presto(0)
       do 37 i=1,3
   37  pilu=pilu-p(i,il)*presto(i)
       pilrst=-(p(0,il)-pilu*presto(0))**2
       do 38 i=1,3
   38  pilrst=pilrst+(p(i,il)-pilu*presto(i))**2
       fmlmt2=fm**2
       if(pilrst.gt.fmlmt2) go to 40
       inabs=inabs+1
       if(ityp(il).eq.1) then
         pnabsn=pnabsn+1.
       else if(ityp(il).eq.2) then
         pnabsp=pnabsp+1.
       end if
       dens=dens+dcoef(l)
       if(iclas.eq.3.and.il.eq.i2) go to 40
       do 39 i=0,3
   39  prest(i)=prest(i)+p(i,il)
   40 continue
  140 continue
      if(iclas.eq.3.and.inabs.le.1) then
         if(ranf(0).gt.1./enhcnd) ichanl=0
         return
      else if(iclas.eq.2.and.inabs.le.1) then
         if(sigsab.ge.0.) then
            ichanl=0
         end if
         return
      else if(iclas.eq.1.and.inabs.le.1) then
         if(srt.gt.em(i1)+em(i2)) then
            ema=em(i1)
            emb=em(i2)
            prel=pcmsr(srt,ema,emb)
            call detbal(srt,prel,icltyp,ityp(i1),npidec(i1),ityp(i2),
     a                                  npidec(i2),em(i1),em(i2),sigdb)
            pimsed=sigdb
            go to 51
         else
            ichanl=0
            return
         end if
      end if
      if(niter.lt.5.and.((abs(dens-denso).gt.0.1.and.
     a                  dens.gt.0.1) .or.abs(cmsen-cmseno).gt.2.)) then
        fm=max(dens**0.33333*fmrho0,fmrho0)
        go to 34
      else
        cmsen=
     a     sqrt(prest(0)**2-(prest(1)**2+prest(2)**2+prest(3)**2))
        pilu=p(0,i1)*presto(0)
        do 42 i=1,3
   42   pilu=pilu-p(i,i1)*presto(i)
        pilrst=-(p(0,i1)-pilu*presto(0))**2
        do 43 i=1,3
   43   pilrst=pilrst+(p(i,i1)-pilu*presto(i))**2
        if(iclas.eq.2) then
          xsdelt=0.
          tpion=sqrt(empion*empion+pilrst)-empion
          if(sigsab.gt.0.) then
            sigsw=(hc/pi2)**5*20.*pi2/sqrt(pilrst)*
     a             (1.+0.5*pilu/empion)*b0im*dens*rho0*
     b                            exp(-6.*max(cvalu0,tpion-.1))
            if(sigsw.gt.sigsab) then
               write(lun8,*) 'warning from imsed: sigsw.gt. sigsab:',
     a                       sigsw,sigsab,tpion,dens
            end if
            rands=ranf(0)
            if(rands.lt.sigsw/sigsab) then
              pimsed=pimsmx
              go to 71
            else
              ichanl=0
              return
            end if
          else if(sigsab.lt.0.) then
            xsdelt=-sigsab
          end if
          emd=srt
          pilu=sqrt(emd*emd+pilrst)
          bdelt=sqrt(pilrst)/pilu
        else if(iclas.eq.1) then
          emd=sqrt(pilu**2-pilrst)
          if(emd.le.emnuc+empion) then
             ichanl=0
             return
          end if
          bdelt=sqrt(pilrst)/pilu
          tpion=sqrt(empion**2+pilrst)-empion
          write(lun8,*) 'imsed delta absorption: tpion=',tpion,bdelt
        else if(iclas.eq.3) then
          emd=sqrt(pilu**2-pilrst)
          bdelt=sqrt(pilrst)/pilu
          if(emd.le.emnuc+empion) then
              write(lun8,*)
     +    'imsed-warning:iclas=3, delta mass too small'
              ichanl=0
              return
          end if
          tpion=sqrt(empion**2+pilrst)-empion
        end if
      end if
      if(tpion.lt.0.) then
            call errex('imsed:negative kinetic pion energy')
            ichanl=0
            return
      end if
      chiiso=(pnabsn-pnabsp)/(pnabsn+pnabsp)
      xtpion=tpion/empion
      betx=max(cvalu0,bet(xtpion))
      if(iclas.eq.1) then
        vmltp=(1.+0.33333*(2*ityp(i1)-9)*chiiso)
      else if(iclas.eq.2.or.iclas.eq.3) then
        vmltp=1.5*(0.666667+ichgpi*chiiso*0.22222 +
     a                         chiiso**2*(1.-abs(ichgpi)*0.55555))
      end if
      vcnvrt=bdelt
      vrats=0.
      nn1=0
      itp=0
      lstart=int(ranf(0)*nrb)
      do 70 leff=lstart,lstart+nrb-1
        l=mod(leff,nrb)+1
        il=iofset+l
        if(il.eq.i2) go to 70
        if(.not.prop(l)) go to 70
        itp=il
        if(lmax.ge.ntotma-nspect) then
          go to 72
        else
          itq=ntotma-nspect
          if(iclas.eq.1.or.iclas.eq.3) then
            do 73 i=0,3
   73       p(i,itq)=p(i,i1)
          else
            do 74 i=0,3
   74       p(i,itq)=p(i,i1)+p(i,i2)
          end if
        end if
        nn1=nn1+1
        issn(itq)=ntotma
        call frzcor(ratv,itp,itq)
        vrats=vrats+ratv
        if(nn1.eq.3) go to 72
   70  continue
   72  continue
      if(nn1.gt.0) then
         ratv=vrats/nn1
         vcnvrt=ratv*vcnvrt
      end if
      if(ida(4).eq.2) then
        if(tpion.gt.0.315) then
           srtact=(emnuc+sqrt(emd**2+pilrst))**2-pilrst
           srtact=sqrt(srtact)
           prdn=pcmsr(srtact,emd,emnuc)
           call detbal(srtact,prdn,5,3,0,2,
     a                                  0,emd,emnuc,sigdb)
           sigdb=0.5*vmltp*sigdb
           frctwo=50.*sigdb*vcnvrt*(dens*rho0)/pi2*hc
        else
          catwo=ca2(xtpion)
          frctwo=vmltp*catwo*dens**betx
        end if
      else
        srtact=(emnuc+sqrt(emd**2+pilrst))**2-pilrst
        srtact=sqrt(srtact)
        prdn=pcmsr(srtact,emd,emnuc)
        call detbal(srtact,prdn,5,3,0,2,
     a                                  0,emd,emnuc,sigdb)
        sigdb=0.5*vmltp*sigdb
        frctwo=50.*sigdb*vcnvrt*(dens*rho0)/pi2*hc
      end if
      if(iclas.eq.1) then
          icltp=icltyp
      else if(iclas.eq.2.or.iclas.eq.3) then
        prbntr=pnabsn/(pnabsn+pnabsp)
        if(ranf(0).lt.prbntr) then
             itp3f=1
        else
             itp3f=2
        end if
        if(iclas.eq.2) then
             itp1f=ityp(i1)+ityp(i2)-5
             if(itp1f.lt.3.or.itp1f.gt.6) then
                call errex('wrong itp1f in imsed')
             end if
        else
             itp1f=ityp(i1)
        end if
        icltp=itp1f*(itp1f-1)/2+itp3f
      end if
      if(ida(4).eq.1) then
        emn=emnuc
        call wqdnch(icltp,itp1f,itp3f,0,0,srtact,prdn,emd,emn,
     a                       sigeno,sigel1,sigel2,sigdd1,sigdd2,sigdb)
        sigsum=sigeno+sigel1+sigel2+sigdd1+sigdd2
        pimsqe=0.05*sigsum*vcnvrt*(dens*rho0)/pi2*hc
        pimsed=frctwo*1.e-3
      else
        pimsed=(frctwo+max(cvalu0,ca3(xtpion))*dens**(2.*betx))*1.e-3
        alpx=max(cvalu0,alp(xtpion))
        pimsqe=max(cvalu0,cq(xtpion))*dens**alpx*1.e-3
        if(icltp.eq.17.or.icltp.eq.4 ) then
            enlrg=1.5
        else if(icltp.eq.16.or.icltp.eq.5 ) then
            enlrg=0.5
        else if(icltp.eq.12.or.icltp.eq.7 ) then
            enlrg=7./6.
        else if(icltp.eq.11.or.icltp.eq.8 ) then
            enlrg=5./6.
        else
           write(lun8,*) 'wrong icltp in imsed',icltp,iclas
           call errex('unclear situation')
        end if
        pimsqe=enlrg*pimsqe
      end if
      prel=pcmsr(emd,emnuc,empion)
      if(iclas.eq.2) then
         pimsed=pimsqe+pimsed
         valmu=(pilu*sqrt(emnuc*emnuc+prel*prel)-
     a                   sqrt(emnuc*emnuc+fmact*fmact)*emd)/
     b                                               (prel*sqrt(pilrst))
         if(dens.lt.1..and.dens.gt.0.01) then
             valmu=valmu/dens
         end if
         valmu=max(min(cvalu1,valmu),-cvalu1)
         gamdd=parama/srt*prel**3
         gmims=2.*pimsed
         gmeff=gamdd*0.25*(2.+valmu+valmu**3)+gmims
         pimsvf=paramb/srt*emnuc*prel/((srt-emdelt)**2+0.25*gmeff**2)
         pimsed=pimsvf*pimsed
         pimsqe=pimsvf*pimsqe
         if(xsdelt.gt.0.) then
            gmdlt= 29.*prel**3/(1.+40.*prel*prel)
            gmeff=gmdlt*0.25*(2.+valmu+valmu**3)
            enhnce=gmeff/xsdelt/((emd-emdelt)**2+0.25*(gmeff+gmims)**2)
            if(enhnce.gt.1.) then
              write(lun8,*) 'warning: iclas=2 in imsed, enhnce>1.'
              write(lun8,*) srt,icltyp,emd,enhnce,gmdlt,gmeff,valmu
              return
            else
              if(ranf(0).gt.enhnce) ichanl=0
              return
            end if
         end if
      else if(iclas.eq.1.or.iclas.eq.3) then
        if(iclas.eq.1) then
          pimsed=20.*pimsed/vcnvrt/(dens*rho0) * pi2/hc
          pimsqe=20.*pimsqe/vcnvrt/(dens*rho0) * pi2/hc
          pimsed=pimsqe+pimsed
        else if(iclas.eq.3) then
            pimsed=pimsed+pimsqe
            gmdlt=pimsmx
            valmu=(pilu*sqrt(emnuc*emnuc+prel*prel)-
     a                   sqrt(emnuc*emnuc+fmact*fmact)*emd)/
     b                                               (prel*sqrt(pilrst))
            valmu=max(min(cvalu1,valmu),-cvalu1)
            gmeff=gmdlt*0.25*(2.+valmu+valmu**3)+2.*pimsed
            enhnce=((emd-emdelt)**2+0.25*gmdlt**2)/
     a                      ((emd-emdelt)**2+0.25*gmeff**2)*gmeff/gmdlt
            if(pimsed.eq.0.) then
               if(ranf(0).gt.1./enhcnd) ichanl=0
               return
            else
               pimsmx=pimsed*enhcnd/enhnce
            end if
        end if
      end if
   51 continue
      rand=ranf(0)
      if((rand.gt.pimsed/pimsmx).or.
     a   (ida(4).eq.2.and.ranf(0).lt.pimsqe/pimsed))then
         ichanl=0
         return
      else if(ida(4).eq.1) then
        return
      end if
      pimsqe=0.
      if(iclas.eq.1) then
      elseif(iclas.eq.2) then
          if(pimsqe.gt.0. .and.ranf(0).lt.pimsqe/pimsed) then
                  innch=3
                  iqabs=-2*itp3f+3
          else
                  innch=2
          end if
      else if(iclas.eq.3) then
            if(ranf(0).lt.gmdlt/gmeff) then
                  return
            end if
            if(pimsqe.gt.0. .and.ranf(0).lt.pimsqe/pimsed) then
                  innch=3
                  iqabs=-2*itp3f+3
            else
                  innch=2
            end if
      end if
   71 continue
      if(iclas.eq.2.or.iclas.eq.3.or.iqabs.ne.0) then
       lstart=int(ranf(0)*nrb)
       do 50 leff=lstart,lstart+nrb-1
        l=mod(leff,nrb)+1
        il=iofset+l
        if(il.eq.i2) go to 50
        iqs=ityp(il)-1+iqabs
        if(.not.prop(l)) go to 50
        if(iqs.ne.0.and.iqs.ne.1) go to 50
        i3=il
        itp3n=iqs+1
        go to 52
   50  continue
   52  continue
       if(i3.eq.0) then
          ichanl=0
          return
       end if
      end if
      if(i3.eq.0) then
         nop=2
      else
         nop=3
         lastcl(i3)=ievntn
         if(qdot(0,i3).eq.0.) then
            do 110 i=0,3
  110       pil(i)=p(i,i3)
         else
            do 120 i=0,3
  120       pil(i)=qdot(i,i3)
         end if
         do 111 i=0,3
          qlk(i)=x(i,i3)-xind(i)
          plk(i)=p(i,i3)+p(i,i2)
  111    continue
         plplin =pil(0)*plk(0)
         dqplin =qlk(0)*plk(0)
         do 112 i=1,3
          plplin=plplin-pil(i)*plk(i)
          dqplin=dqplin-qlk(i)*plk(i)
  112    continue
         delts=max(cvalu0,dqplin/plplin)
         if(tlast(i3).gt.x(0,i3)) then
            delts=0.
         else
            delts=min(delts,(x(0,i3)-tlast(i3))/pil(0))
         end if
         if(qdot(0,i3).eq.0.) then
            do 210 i=0,3
  210       x(i,i3)=x(i,i3)-delts*pil(i)
         else
            do 220 i=0,3
  220       qdot(i,i3)=-qdot(i,i3)*delts/dtprop
         end if
      end if
      if(innch.eq.3) then
          if(icltp.eq.17.or.icltp.eq.4 ) then
            prb1=0.
          else if(icltp.eq.16.or.icltp.eq.5 ) then
            prb1=0.25
          else if(icltp.eq.12.or.icltp.eq.7 ) then
            prb1=1./28.
          else if(icltp.eq.11.or.icltp.eq.8 ) then
            prb1=0.1
          end if
          if(ranf(0).lt.prb1) then
             j=2
          else
             j=4
          end if
          j1new=1
          j2new=3
          m=2*(itp1f+itp3f)-12
          if(iabs(m).gt.4.or.iabs(m).gt.j) then
             call errex('imsed:innch=3, m out of range')
          end if
      end if
      if(iclas.eq.1) then
         em(i1)=emnuc
         ia=i1
         ib=i2
         em1eff=emnuc
         em2eff=emnuc
      else if(iclas.eq.2) then
         em(i1)=0.
         do 53 i=0,3
         p(i,i2)=p(i,i1)+p(i,i2)
   53    p(i,i1)=0.
         ia=i2
         ib=i3
         if(innch.eq.3) then
            em1eff=emnuc
            emd=p(0,i2)*p(0,i2)
            do 54 i=1,3
   54       emd=emd-p(i,i2)*p(i,i2)
            emd=sqrt(emd)
            sact=(p(0,i2)+p(0,i3))**2
            do 55 i=1,3
   55       sact=sact-(p(i,i2)+p(i,i3))**2
            sact=sqrt(sact)
            if(sact.le.2.*emnuc+empion+ekinmi) then
               write(lun8,*) 'iclas=',iclas,'imsed:missing cms energy',
     a                        ' for chrg. exch. ',sact
               ichanl=0
               return
            else if(sact.lt.emnuc+emd) then
               emd=max(emnuc+empion,0.5*(empion+sact))
            end if
            em2eff=emd
            em(i3)=emd
            itag=-50
            call isonew(j,m,j1new,j2new,m1new,m2new,itag)
            itp2n=(m1new+3)/2
            itp3n=(m2new+9)/2
         else
            em1eff=emnuc
            em2eff=emnuc
         end if
      else if(iclas.eq.3) then
         ia=i1
         ib=i3
         if(innch.eq.2) then
            em1eff=emnuc
            em2eff=emnuc
         elseif(innch.eq.3) then
            em1eff=emnuc
            sact=(p(0,i1)+p(0,i3))**2
            do 56 i=1,3
   56       sact=sact-(p(i,i1)+p(i,i3))**2
            sact=sqrt(sact)
            if(sact.le.2.*emnuc+empion+ekinmi) then
               write(lun8,*) 'iclas=',iclas,'imsed:missing cms energy',
     a                        ' for chrg. exch. ',sact
               return
            else if(sact.lt.emnuc+em(i1)) then
               emd=max(emnuc+empion,0.5*(empion+sact))
            end if
            em2eff=emd
            em(i3)=em2eff
            itag=-50
            call isonew(j,m,j1new,j2new,m1new,m2new,itag)
            itp1n=(m1new+3)/2
            itp3n=(m2new+9)/2
         end if
         em(i1)=emnuc
      end if
      ityp(i1)=itp1n
      npidec(i1)=0
      ityp(i2)=itp2n
      npidec(i2)=0
      if(nop.eq.3) then
        ityp(i3)=itp3n
        if(innch.eq.3) then
          npidec(i3)=1
        else
          npidec(i3)=0
        end if
      end if
      do 60 i=0,3
        p1(i)=p(i,ia)
        p2(i)=p(i,ib)
   60 continue
      call onshel(1,isccss,em1eff,em2eff,p1(0),p1(1),p1(2),p1(3),
     a                                       p2(0),p2(1),p2(2),p2(3))
      if(isccss.eq.1) then
         do 61 i=0,3
          p(i,ia)=p1(i)
          p(i,ib)=p2(i)
   61    continue
      else
         call errex('isccss.ne.1 in imsed,????????? ')
      end if
      if(lmax.ge.ntotma-nspect) then
         call errex('no free line in particle array, abort in imsed')
      else
         ltest=ntotma-nspect
         do 65 i=0,3
   65    plk(i)=p1(i)+p2(i)
         cmsen=sqrt(plk(0)**2-(plk(1)**2+plk(2)**2+plk(3)**2))
         prel=pcmsr(cmsen,em1eff,em2eff)
         cthet=1.-2.*ranf(0)
         sthet=sqrt(1.-cthet*cthet)
         phi=pi2*ranf(0)
         p(1,ltest)=prel*cos(phi)*sthet
         p(2,ltest)=prel*sin(phi)*sthet
         p(3,ltest)=prel*cthet
         p(0,ltest)=sqrt(em1eff*em1eff+prel*prel)
         bx=plk(1)/plk(0)
         by=plk(2)/plk(0)
         bz=plk(3)/plk(0)
         call trobo(1,ltest,ltest,cvalu0,cvalu0,bx,by,bz)
         do 69 i=0,3
         p(i,ia)=p(i,ltest)
         p(i,ib)=plk(i)-p(i,ia)
   69    continue
      end if
      return
      end
      function  klbar(ifla3,iflb3,iflc3)
#include "amsrqmd.h"
       if(ifla3.le.0.or.iflb3.le.0.or.iflc3.le.0) then
          call errex('abort in klbar')
       end if
       ifla1=max(ifla3,iflb3)
       iflc1=min(ifla3,iflb3)
       ifla1=max(ifla1,iflc3)
       iflc1=min(iflc1,iflc3)
       iflb1=ifla3+iflb3+iflc3-ifla1-iflc1
       if(ifla1.eq.3.and.ifla1.eq.iflc1) then
         klbar=70
       else if(ifla1.eq.3.and.ifla1.eq.iflb1) then
         klbar=67+iflc1
       else if(ifla1.eq.3.and.ifla1.gt.iflb1) then
         klbar=41+iflb1+iflc1
       else
         klbar=58+ifla1+iflb1+iflc1
       end if
      return
      end
      subroutine fill12(ityp1,ityp2,npid1,npid2,itypi,npidi,
     a                                                  em1,em2,srt)
        include 'scatter7'
#include "amsrqmd.h"
        em1=srt
        em2=0.
        ityp1=itypi
        npid1=npidi
        ityp2=-9999
        npid2=0
      return
      end
CPAT,RESFOR   .
      subroutine absorb(ipi,id,i3,i4,nop,itagdl,jesant,iann,
     a                      iqqst,isoan,ityp1,npid1,ityp2,npid2,
     b                      itag1,iqid1,itag2,iqid2,ichanl,icltyp,
     c                      ltype1,kmult1,ltype2,kmult2,
     c                      sigqsq,xstot,em1,em2,prel,pi1sq,pi2sq,cme)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       include 'sigmasx'
       dimension prob(3)
       dimension sigch(5)
       common /xspibk/ xspin1,xspin3,wnorm1,wnorm3,pow12,pow32,
     a                xsbgl1,xsbgl3,xs1218,xs32pn,xs12pn
       real*4 cgk212,cgk232,cgk2d
       real*4  emstr,prbas,embaa,emmea,embab,emmeb,ptx,pty,emda,emdb
       real*4  regsup,prcms,proia,proib,prlpi4,prspi4,pcms4,pr0r,spw
       common /resbk/ resfrm
       data ikhyp, iahyp /0,0/
        parameter (ixsect=5)
      logical  potyes
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version  rqmd 2.3 -- 23-sep-96'/
      data pronam/'a b s o r b  -- resonance formation '/
      data ttvers/.true./
       if(ttvers) then
         write(lun8,*)' version number report -------------'
         write(lun8,*)pronam
         write(lun8,*)vernum
         write(lun8,*)'------'
         ttvers=.false.
         resfrm=0.
         if(wnorm1.eq.0.0.or.wnorm3.eq.0.0) then
             call errex('absorb abort: wnorm not initialized')
         end if
       end if
       jome=0
       jcas=0
       jhyp=0
       jpin=0
       jpins=0
       jnds=0
       if(iann.eq.1) then
         jnds=1
         mflt=0
       else if(iann.eq.2) then
         jhyp=1
         mflt=1
       else if(iann.eq.3) then
         jcas=1
         mflt=2
       else if(iann.eq.4) then
         jome=1
         mflt=3
       else
        call errex('absorb:iann.ne.1-4 not  implemented')
       end if
       if(itag1.ne.0.or.itag2.ne.0) then
         ichanl=0
         return
       end if
       kestim=0
       ida53=ida(53)
       ida55=ida(55)
       kl1=ltype1
       kl2=ltype2
       kmul1=kmult1
       if(kmul1.eq.-1) kmul1=9
       kfinms=isign(1,kl1)*(iabs(kl1)+100*kmul1)
       kmul2=kmult2
       if(kmul2.eq.-1) kmul2=14
       kfinba=kl2+100*kmul2
       if(kmul1.eq.9.or.kmul2.eq.14) then
         irehev=1
       else
         irehev=0
       end if
       mfld=0
       if(ltype1.eq.24.or.ltype1.eq.25) then
         if(imspin(kfinms)/10.eq.3) mfld=3
       end if
       if(itag1.ne.0.or.itag2.ne.0) then
         kswi=2
       else
         kswi=1
       end if
       imesp=iabs(ltype1)+100*kmul1
       ibasp=kl2+100*kmul2
       call retcgk(99,ltype1,j1,m1,-1,cgk2d)
       call retcgk(99,ltype2,j2,m2,-1,cgk2d)
       m=m1+m2
       jtm1=m
       jt2=0
       jtm2=0
       if(cme.gt.1.5.or.iann.gt.1.or.em1.gt.0.2.or.
     a                         itag1.ne.0.or.itag2.ne.0) then
         call luiflv(kl1,ifla1,iflb1,iflc1,ksp)
         call luiflv(kl2,ifla2,iflb2,iflc2,ksp)
         if(iflc1*iflc2.ne.0) then
           write(lun8,*) ltype1,kmult1,ltype2,kmult2
           call errex('absorb:mb annihilation, but wrong types')
         end if
         ivac=0
         if(iflc1.eq.0)then
           if(ifla1+iflb1.eq.0) then
             ivac=1
             ifla3=ifla2
             iflb3=iflb2
             iflc3=iflc2
             zrand=ranf(0)
             if(zrand.lt.0.33333) then
               call iswap(ifla3,iflb3)
             else if(zrand.lt.0.66667) then
               call iswap(ifla3,iflc3)
             else
               call iswap(iflb3,iflc3)
             end if
             if(ranf(0).lt.0.5) call iswap(ifla3,iflb3)
             if(iabs(ifla1).ne.3.and.ifla3.eq.3) then
               if(iann.le.1) then
                 call iswap(ifla3,iflc3)
               else if(iann.eq.2) then
                 if(iflc3.lt.3) then
                   call iswap(ifla3,iflc3)
                 else
                   call iswap(ifla3,iflb3)
                 end if
               end if
             else if(iabs(ifla1).eq.3.and.ifla3.ne.3) then
               if(iann.eq.1.or.iann.eq.2) then
                 if(iflc3.eq.3) then
                   call iswap(ifla3,iflc3)
                 else
                   call iswap(ifla3,iflb3)
                 end if
               end if
             end if
           else
             if(ifla1*ifla2.gt.0) then
               call iswap(ifla1,iflb1)
             end if
             if(ifla1.eq.-ifla2) then
               ifla3=iflb1
               iflb3=iflb2
               iflc3=iflc2
             else if(ifla1.eq.-iflb2) then
               ifla3=iflb1
               iflb3=ifla2
               iflc3=iflc2
             else if(ifla1.eq.-iflc2) then
               ifla3=iflb1
               iflb3=ifla2
               iflc3=iflb2
             else
               ichanl=0
               write(lun8,*) ltype1,kmult1,ltype2,kmult2,
     a                      issn(ipi),issn(id)
               write(lun8,*) 'absorb:mb-ann, no common q/qbar-pair'
               return
             end if
           end if
         else
           call errex('absorb: meson not in first position')
         end if
         if(itag1.eq.1.or.itag2.eq.1) then
           if(iqid1.gt.0)
     a     call errex('absorb: no const.antiquark in meson')
           kcoun=0
           krejec=0
           iflban=ifla2+iflb2+iflc2-iflb3-iflc3
           if(itag1.eq.1) then
             irid2=0
             if(ivac.eq.1) then
               if(ifla3.ne.-iqid1) krejec=1
             end if
           else
             irid2=10*(ifla1+iflb1+iflban)
           end if
           if(itag2.eq.1) then
             iflcq1=iqid2/10
             iflcq2=mod(iqid2,10)
             if(iflcq1.eq.0) then
               if(itag1.eq.1) then
                 krejec=1
               end if
               if(ifla2.eq.iflcq2) then
                 iflbvq=iflb2
                 iflbwq=iflc2
               else if(iflb2.eq.iflcq2) then
                 iflbvq=ifla2
                 iflbwq=iflc2
               else if(iflc2.eq.iflcq2) then
                 iflbvq=ifla2
                 iflbwq=iflb2
               else
                 call errex('absorb:where is the cq in qqq? ')
               end if
               iqid2=irid2/10
             else
               iflbvq=ifla2+iflb2+iflc2-iflcq1-iflcq2
               if(iflbvq.ne.ifla2.and.iflbvq.ne.iflb2
     a                            .and.iflbvq.ne.iflc2) then
                 call errex('absorb:what is the vq in qqq? ')
               end if
               iflbwq=0
               if(iflban.eq.iflcq1) then
                 iqid2=irid2+iflcq2
               else
                 iqid2=irid2+iflcq1
               end if
             end if
             if(iflbvq.eq.iflbwq) then
               dkre=2.
             else
               dkre=1.
             end if
             if(iflbvq.eq.iflban.or.iflbwq.eq.iflban) then
               if(ifla2.eq.iflban) kcoun=1
               if(iflb2.eq.iflban) kcoun=kcoun+1
               if(iflc2.eq.iflban) kcoun=kcoun+1
               if(kcoun.eq.0)
     a         call errex('absorb:annihilated quark not recovered')
               if(ranf(0).gt.(kcoun-dkre)/float(kcoun)) krejec=1
             end if
           end if
           if(krejec.eq.1) then
             ichanl=0
             return
           end if
         end if
       end if
       if(jnds.eq.1) then
         if(ityp1.ge.7.and.ityp1.le.9) then
           if(npid1.eq.0) then
             if(ityp2.le.2) then
               jpin=1
               jnds=0
             else if(ityp2.ge.10.and.ityp2.le.11) then
               jpins=1
               jnds=0
             end if
           end if
           if(jpin.eq.1) then
             if(icltyp.eq.22.or.icltyp.eq.38) then
                imixt=1
                rat3=1.
                rat1=0.
             else if(icltyp.eq.37.or.icltyp.eq.23) then
                imixt=2
                rat3=0.333
                rat1=0.667
             elseif(icltyp.eq.29.or.icltyp.eq.30) then
                imixt=3
                rat3=0.667
                rat1=0.333
             end if
             if((ida(4).eq.1.or.ida(4).eq.2).and.
     a                                 jpin.eq.1) then
               call piweg(ipi,id,i3,i4,nop,imixt,
     a                              itag1,itag2,ichanl,cme,icltyp)
               if(ida(4).eq.2) itagdl=1
               if(ichanl.eq.0.or.nop.ne.1) return
             end if
             ichrgp=ityp1-8
             ichrgb=ityp2-1
           end if
         end if
       end if
       srt=cme
       if(em1+em2.ge.srt) then
         ichanl=0
         return
       end if
       pcms=prel
       pcms4=pcms
       emstr=srt
       em(ipi)=0.0
       em(id)=srt
       do  25 i=0,3
        p(i,id)=p(i,id)+p(i,ipi)
   25  continue
       ityp(ipi)=-9999
       decay(ipi)=1.e+35
       em2nur=2.8+mflt*0.15
       if(jpin+jpins+jnds+jhyp+jcas+jome.ne.1)
     a       call errex('error in absorb:wrong ingoing particles')
       if(jome.eq.1) then
       else if(jcas.eq.1) then
         if(srt.le.2.0.and.(itag1.ne.0.or.itag2.ne.0)) then
           ichanl=0
           return
         end if
         call casca(srt,pcms,em2,em1,sigstr,sigres,xs1530,
     a                   inchan,ltype2,kmult2,ltype1,kmult1)
         if(sigres+sigstr.eq.cvalu0) then
           ichanl=0
           return
         end if
         emcasc=1.318
         if(srt.le.emcasc+empion) then
           ichanl=0
           return
         end if
         xsann=xsesti(5,srt,pcms,strdum,iredu,mdum,icodum)
         if(ida55.ne.0.and.kswi.eq.1.and.iabs(m).eq.1
     a                            .and.sigstr.gt.cvalu0) then
           mbfix=0
           ichoba=5
           idntre=93
           fnlrga=0.
           ltyper=(idntre-m)/2
           call bele(iflfa,iflfb,ltyper)
           prbas=pcmsr(srt,emcasc,empion)
           emda=emcasc
           emdb=empion
           jt1=1
           jt1new=2
           jt2new=1
           idntbc=93
           itag=0
           call isocgk(jtm1,jt1,jtm2,jt2,jt1new,jt2new,
     a                                       jtm1nw,jtm2nw,itag)
           klmold=jtm1nw/2*17+23*(2-iabs(jtm1nw))/2
           klbold=(idntbc-jtm2nw)/2
           ktry=0
  326      ktry=ktry+1
           f1ia=1.0
           f2ia=1.0
           kfbaa=0
           if(ranf(0).gt.em2nur/srt) then
             imany=1
           else
             call bresdc(imany,
     a              iflfb,iflfa,ichoba,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbaa,kfmea,kmltba,kmltma,
     d              iflb,ifla,ifl3,kdfr,embaa,emmea,ptx,pty)
           end if
           if(imany.eq.0) then
             proia=prcms(emstr,embaa,emmea)
             kfbria=kfbaa+100*kmltba
             kfmsia=isign(1,kfmea)*(iabs(kfmea)+100*kmltma)
             f1ia=
     a         regsup(ida55,kfmsia,kfbria,klmold,klbold,ifl3,kex,
     b                          prbas,proia,emstr,pr0r,spw,iscd)
           end if
           enlrga=1.
           if(kfbaa.ne.0) then
             if(irehev.eq.1) then
               f2ia=0.0
             else
               f2ia=
     a         regsup(ida55,kfinms,kfinba,kfmsia,kfbria,mfld,kex,
     b                         pcms4,proia,emstr,pr0r,spw,iscd)
             end if
             enlrga=f2ia/f1ia
           end if
           fnlrga=fnlrga+enlrga
           if(ktry.eq.1) then
             sigupl=1.2*(1.+(prbas**2/0.64))*sigstr+sigres
             if(sigqsq.gt.sigupl) kestim=2
             if(sigqsq.le.sigres) kestim=1
           end if
           if(kestim.ne.1.and.ktry.le.ixsect)  go to 326
           fnlrg=fnlrga/ktry
           sigstr=fnlrg*sigstr
         end if
         sigmb=sigres+sigstr
         if(xsann.lt.sigmb) then
           write(lun8,*) 'warning: absorb326:',xsann,sigmb
           write(lun8,*) ltype1,kmult1,ltype2,kmult2
           write(lun8,*) 'srt=',srt,pcms,sigstr,xsann
         end if
         if(sigqsq.gt.sigmb) then
           ichanl=0
           return
         end if
         if(iabs(m).ne.1)
     a   call errex('absorb:cascade w wrong i3 component')
         if(ranf(0).gt.sigres/sigmb) then
           ktry=0
   46      continue
           ktry=ktry+1
           if(ktry.gt.20) call errex('absorb 46-abort')
           mbaf=mbafnd(7,srt)
           if(mbaf.gt.0) then
             itypb=84+mbaf
             if(itypb.eq.88) go to 46
             npidb=22+(93-m)/2
           else
             itypb=98
             npidb=(93-m)/2
           end if
           jesant=1
           isoan=10
         else if(xs1530.ne.cvalu0
     a                   .and.ranf(0).le.xs1530/sigres) then
           itypb=99
           npidb=(137-m)/2
         else
           call bwdist(5,-1,srt,km,inchan,dcrat,bwig)
           if(km.le.0.or.km.gt.5) then
             call errex('absorb: wrong random km from bwdist')
           end if
           if(km.le.4) then
             itypb=85+km
             if(itypb.eq.89) itypb=93
             npidb=(93-m)/2
           else
             itypb=88
             npidb=22+(93-m)/2
           end if
         end if
         ityp(id)=itypb
         npidec(id)=npidb
         if(kestim.eq.2)
     a     write(lun8,*) '326:srt=',srt,ltype1,ltype2,em1,em2
       else if(jhyp.eq.1) then
         srtpar=2.50
         if(srt.le.2.0.and.(itag1.ne.0.or.itag2.ne.0)) then
           ichanl=0
           return
         end if
         if(itag1.ne.0.or.itag2.ne.0) then
           isoan=10
         else
     a   if((icltyp.eq.92.or.icltyp.eq.93).and.em1.lt.0.5) then
           isoan=5
         else if((icltyp.ge.85.and.icltyp.le.87).or.
     a                  (icltyp.ge.112.and.icltyp.le.114)) then
           if(em1.lt.0.2.and.em2.le.1.2.and.srt.lt.srtpar) then
             isoan=6
           else
             isoan=10
           end if
         else
           isoan=10
         end if
         if(srt.le.emnuc+emkap) then
           ichanl=0
           return
         end if
         if(isoan.ne.5.and.srt.le.1.50) then
           ichanl=0
           return
         end if
         prkan=pcmsr(srt,emnuc,emkap)
         call cross1(1,srt,prkan,93,xstkmp,emnuc,emkap,2,14,0,-2)
         call cross1(1,srt,prkan,92,xstkmn,emnuc,emkap,1,14,0,-2)
         call cross1(2,srt,prkan,93,xsekmp,emnuc,emkap,2,14,0,-2)
         call cross1(2,srt,prkan,92,xsekmn,emnuc,emkap,1,14,0,-2)
         rlimit=min(cvalu1,(4.0/srt**2)**da(7))
         sigkmp=(xstkmp-xsekmp)*rlimit
         sigkmn=(xstkmn-xsekmn)*rlimit
         delxsp=0.0
         delxsm=0.0
         do 27 itot=0,2,2
         do 27 inum=1,3
          sigcha=piynkb(1,-1,1,1,itot,inum,srt,prkan)
          if(srt.ge.srtpar) sigcha=cvalu0
          delxsp=delxsp+sigcha
          if(inum.ne.2) delxsm=delxsm+2.*sigcha
   27    continue
         sigkmp=sigkmp-delxsp
         sigkmn=sigkmn-delxsm
         sig2=sigkmn
         sig0=2.*sigkmp-sigkmn
         if(sig2.lt.0.) sig2=0.
         if(sig0.lt.0.) sig0=0.
         sigsum=0.0
         if(isoan.ne.10) then
           do 28 inu=1,5
   28      sigch(inu)=0.0
           do 29 itot=0,2,2
           do 29 inu=1,5
            inum=inu
            if(isoan.eq.6) inum=-inum
            if(inu.le.4) then
              sigcha=piynkb(j1,m1,j2,m2,itot,inum,srt,pcms)
              if(inu.eq.4) sigcha=2.*sigcha
              if(srt.ge.srtpar.and.inu.le.3) then
                sigcha=cvalu0
              end if
            else if(isoan.eq.5.and.itot.eq.2.and.
     a                      iabs(m1+m2).eq.2) then
              if(srt.gt.2.0) then
                sigcha=xsekmn*(2./srt)**5
              else
                sigcha=xsekmn
              end if
            else
              sigcha=cvalu0
            end if
            if(sigcha.eq.cvalu0) go to 29
            sigch(inu)=sigcha
            sigsum=sigsum+sigcha
   29      continue
         end if
         if(isoan.ne.5) then
           mbfix=-5
           prbas=prkan
           emda=emnuc
           emdb=emkap
           ichoba=3
           jt1=2
           jt1new=1
           jt2new=1
           idntmc=-37
           idntbc=83
           ltyper=(88-m)/2
           fnlrga=0.
           ichobb=4
           fnlrgb=0.
           if(srt.le.1.5) then
             allow=0.
           else
             call bele(iflfa,iflfb,ltyper)
             itag=0
             call isocgk(jtm1,jt1,jtm2,jt2,jt1new,jt2new,
     a                                       jtm1nw,jtm2nw,itag)
             klmold=(idntmc-jtm1nw)/2
             klbold=(idntbc-jtm2nw)/2
             ktry=0
   26        ktry=ktry+1
             f1ia=1.0
             f2ia=1.0
             kfbaa=0
             f1ib=1.0
             f2ib=1.0
             f2sig0=0.0
             f2kao0=0.0
             f2sig2=0.0
             f2lam2=0.0
             f2kao2=0.0
             kfbab=0
             if(ida55.ne.0.and.kswi.eq.1) then
               if(m.eq.0) then
                 if(ranf(0).gt.em2nur/srt) then
                   imana=1
                   imanb=1
                 else
                   call bresdc(imana,
     a              iflfb,iflfa,ichoba,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbaa,kfmea,kmltba,kmltma,
     d              iflb,ifla,ifl3,kdfr,embaa,emmea,ptx,pty)
                   call bresdc(imanb,
     a              iflfb,iflfa,ichobb,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbab,kfmeb,kmltbb,kmltmb,
     d              iflb,ifla,jfl3,kdfr,embab,emmeb,ptx,pty)
                 end if
                 if(imana.eq.0) then
                   proia=prcms(emstr,embaa,emmea)
                   kfbria=kfbaa+100*kmltba
                   kfmsia=isign(1,kfmea)*(iabs(kfmea)+100*kmltma)
                   f1ia=
     a             regsup(ida55,kfmsia,kfbria,klmold,klbold,ifl3,kex,
     b                          prbas,proia,emstr,pr0r,spw,iscd)
                 end if
  111  format(2x,a5,2x,3(f6.3,1x),6(i6,1x))
                 if(imanb.eq.0) then
                   proib=prcms(emstr,embab,emmeb)
                   kfbrib=kfbab+100*kmltbb
                   kfmsib=isign(1,kfmeb)*(iabs(kfmeb)+100*kmltmb)
                   f1ib=
     a             regsup(ida55,kfmsib,kfbrib,klmold,klbold,jfl3,kex,
     b                          prbas,proib,emstr,pr0r,spw,iscd)
                 end if
               else
                 if(ranf(0).gt.em2nur/srt) then
                   imanb=1
                 else
                   call bresdc(imanb,
     a              iflfb,iflfa,ichobb,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbab,kfmeb,kmltbb,kmltmb,
     d              iflb,ifla,jfl3,kdfr,embab,emmeb,ptx,pty)
                 end if
                 if(imanb.eq.0) then
                   proib=prcms(emstr,embab,emmeb)
                   kfbrib=kfbab+100*kmltbb
                   kfmsib=isign(1,kfmeb)*(iabs(kfmeb)+100*kmltmb)
                   f1ib=
     a             regsup(ida55,kfmsib,kfbrib,klmold,klbold,jfl3,kex,
     b                          prbas,proib,emstr,pr0r,spw,iscd)
                 end if
               end if
             end if
             itm1=m
             it2=0
             itm2=0
             it2new=2
             enlrga=1.
             if(kfbaa.ne.0) then
               if(irehev.eq.1) then
                 f2ia=0.0
               else
                 f2ia=
     a           regsup(ida55,kfinms,kfinba,kfmsia,kfbria,mfld,kex,
     b                            pcms4,proia,emstr,pr0r,spw,iscd)
               end if
               enlrga=f2ia
               if(
     b            kmltba.eq.0.and.kmltma.eq.0.and.
     c            kfbaa.ge.65.and.kfbaa.le.67.and.
     d            (iabs(kfmea).eq.23.or.iabs(kfmea).eq.17))then
                 prspi=pcmsr(srt,emsig0,empion)
                 prspi4=prspi
                 clpsi=clphh(srt,prspi,emsig0,empion,ikasi,ikapi)
                 clpkao=clphh(srt,prkan,emnuc,emkap,ikan,ikap)
                 embout=embaa
                 emmout=emmea
                 prout=pcmsr(srt,embout,emmout)
                 clpout=clphh(srt,prout,embout,emmout,ika1,ika2)
                 if(isoan.eq.6.or.irehev.eq.1) then
                   f2kao0=0.
                 else
                   f2kao0=regsup(ida55,kfinms,kfinba,
     a                            klmold,klbold,mfld,kex,
     b                        pcms4,prbas,emstr,pr0r,spw,iscd)
                 end if
                 it1=0
                 it1new=2
                 itag=0
                 call isocgk(itm1,it1,itm2,it2,it1new,it2new,
     a                                     itm1nw,itm2nw,itag)
                 kfpi=itm2nw/2*17+23*(2-iabs(itm2nw))/2
                 kfy=45+(3-itm1nw)/2
                 if(irehev.eq.1) then
                   f2sig0=0.0
                 else
                   f2sig0=regsup(ida55,kfinms,kfinba,kfpi,kfy,
     a                     mfld,kex,pcms4,prspi4,emstr,pr0r,spw,iscd)
                 end if
                 if(srt.ge.srtpar) then
                   f2sig0=0.0
                 end if
                 enlrga=enlrga+0.5/clpout*
     a                          (clpsi*f2sig0+clpkao*f2kao0)
               end if
               enlrga=enlrga/f1ia
             end if
             enlrgb=1.
             if(kfbab.ne.0) then
               if(irehev.eq.1) then
                 f2ib=0.0
               else
                 f2ib=
     a           regsup(ida55,kfinms,kfinba,kfmsib,kfbrib,mfld,kex,
     b                        pcms4,proib,emstr,pr0r,spw,iscd)
               end if
               enlrgb=f2ib
               if(
     b            kmltbb.eq.0.and.kmltmb.eq.0.and.
     c            kfbab.ge.65.and.kfbab.le.67.and.
     d            (iabs(kfmeb).eq.23.or.iabs(kfmeb).eq.17))then
                 prlpi=pcmsr(srt,emlamb,empion)
                 prlpi4=prlpi
                 clpla=clphh(srt,prlpi,emlamb,empion,ikal,ikapi)
                 prspi=pcmsr(srt,emsig0,empion)
                 prspi4=prspi
                 clpsi=clphh(srt,prspi,emsig0,empion,ikasi,ikapi)
                 clpkao=clphh(srt,prkan,emnuc,emkap,ikan,ikap)
                 embout=embab
                 emmout=emmeb
                 prout=pcmsr(srt,embout,emmout)
                 clpout=clphh(srt,prout,embout,emmout,ika1,ika2)
                 if(isoan.eq.6.or.irehev.eq.1) then
                   f2kao2=0.
                 else
                   f2kao2=regsup(ida55,kfinms,kfinba,
     a                            klmold,klbold,mfld,kex,
     b                            pcms4,prbas,emstr,pr0r,spw,iscd)
                 end if
                 it1=2
                 it1new=0
                 itag=0
                 call isocgk(itm1,it1,itm2,it2,it1new,it2new,
     a                                       itm1nw,itm2nw,itag)
                 kfpi=itm2nw/2*17+23*(2-iabs(itm2nw))/2
                 kfy=57
                 if(irehev.eq.1) then
                   f2lam2=0.0
                 else
                   f2lam2=regsup(ida55,kfinms,kfinba,kfpi,kfy,
     a                     mfld,kex,pcms4,prlpi4,emstr,pr0r,spw,iscd)
                 end if
                 it1new=2
                 itag=0
                 call isocgk(itm1,it1,itm2,it2,it1new,it2new,
     a                                       itm1nw,itm2nw,itag)
                 kfpi=itm2nw/2*17+23*(2-iabs(itm2nw))/2
                 kfy=45+(3-itm1nw)/2
                 if(irehev.eq.1) then
                   f2sig2=0.0
                 else
                   f2sig2=regsup(ida55,kfinms,kfinba,kfpi,kfy,
     b                     mfld,kex,pcms4,prspi4,emstr,pr0r,spw,iscd)
                 end if
                 if(srt.ge.srtpar) then
                   f2sig2=0.0
                   f2lam2=0.0
                 end if
                 enlrgb=enlrgb+0.5/clpout*
     a                       (clpsi*f2sig2+clpla*f2lam2
     b                                   +clpkao*f2kao2)
               end if
               enlrgb=enlrgb/f1ib
             end if
             fnlrga=fnlrga+enlrga
             fnlrgb=fnlrgb+enlrgb
             if(ktry.eq.1) then
               call hyper(srt,pcms,em1,em2,
     a                   sig0,sig2,ityp1,npid1,ityp2,npid2)
               xsann=xsesti(4,srt,pcms,strdum,iredu,mdum,icodum)
               sigupl=1.3*(1.+(prbas**2/0.64))*(prkan/pcms)**2*
     a                xstkmp
               if(srt.gt.2.0.and.sigqsq.gt.sigupl) kestim=2
               if(sigqsq.le.sigsum) kestim=1
             end if
             allow=xsann
             if(allow.eq.0.0) then
               call errex('absorb: allow uncalculable')
             else
               allow=((fnlrga*sig0+fnlrgb*sig2)/ktry+sigsum)/allow
             end if
             if(ida55.ne.0.and.kswi.eq.1.and.
     a                  kestim.ne.1.and.ktry.le.ixsect)  go to 26
             if(allow.gt.1.0) then
               write(lun8,*) 'warning: absorb26:',allow
               write(lun8,*) ltype1,kmult1,ltype2,kmult2
               write(lun8,*) 'srt=',srt,pcms,allow*xsann,xsann
             end if
           end if
           if(sigqsq.gt.allow*xsann) then
             ichanl=0
             return
           else
             xsann=allow*xsann
             sig0=fnlrga/ktry*sig0
             sig2=fnlrgb/ktry*sig2
           end if
         else
           if(m.eq.0) then
             sig0=0.5*sig0
             sig2=0.5*sig2
           else
             sig0=0.
           end if
           xsann=xstot
           if(xsann.le.0.) call errex('absorb:kbar n,xsann wrong')
         end if
         if(isoan.ne.10) then
           if(srt.lt.1.52.and.isoan.eq.5) xsann=sigsum
           if(ranf(0).lt.sigsum/xsann) then
             zrand=ranf(0)
             icnu=4
             do 30 inu=1,5
              if(zrand.gt.sigch(inu)/sigsum) then
                zrand=zrand-sigch(inu)/sigsum
              else
                icnu=inu
                go to 31
              end if
   30        continue
   31        continue
             if(icnu.eq.1) then
               sig0=0.0
               sig2=1.0
               isoan=8
             else if(icnu.eq.2) then
               sig2=0.0
               sig0=1.0
               if(isoan.eq.5) then
                 isoan=9
               else
                 isoan=7
               end if
             else if(icnu.eq.3) then
               sig0=0.0
               sig2=1.0
               if(isoan.eq.5) then
                 isoan=9
               else
                 isoan=7
               end if
             else if(icnu.eq.4) then
               sig2=0.0
               sig0=1.0
               isoan=7
             else if(icnu.eq.5) then
               sig2=1.0
               sig0=0.0
               isoan=7
             end if
           end if
         end if
         if(sig0.eq.0.0.and.sig2.eq.0.0) then
           ichanl=0
           return
         else if(srt.le.1.5.and.
     a           (isoan.eq.10.or.isoan.eq.5)) then
           ichanl=0
           return
         else if(ranf(0).lt.sig0/(sig0+sig2)) then
           itypid=13
           npidid=0
           ibar=3
         else
           if(iabs(m).gt.2) then
               call errex('absorb:wrong charge for sigma* baryon')
           end if
           itypid=15
           npidid=m/2
           ibar=4
         end if
         mbaf=mbafnd(ibar,srt)
         if(mbaf.gt.0) then
           itypid=84+mbaf
           if(ibar.eq.3) then
             npidid=57
           else
             npidid=44-m/2
           end if
         end if
         ityp(id)=itypid
         npidec(id)=npidid
         if(kestim.eq.2)
     a     write(lun8,*) ' 26:srt=',srt,ltype1,ltype2,em1,em2
         jesant=1
         iahyp=iahyp+1
         if(iabs(iflb3).ne.3.and.iabs(iflc3).ne.3) ikhyp=ikhyp+1
       else if(jnds.eq.1.or.jpins.eq.1) then
         if(srt.le.emnuc+empion) then
           ichanl=0
           return
         end if
         call ndstar(
     a          srt,pcms,em1,em2,icltyp,ityp1,npid1,ityp2,npid2,
     b          icollc,mstr,ichd,ichn,ireco,nscod,strrat,vfspin)
         xsann=xsesti(1,srt,pcms,strrat,ireco,mstr,icollc)
         prpin=pcmsr(srt,emnuc,empion)
         dxsmb1=0.0
         dxsmb3=0.0
         sigmb3=0.
         sigmb1=0.
         if(srt.le.max(1.8,2.0)) then
           ida4=ida(4)
           ida(4)=0
           call cross1(1,srt,prpin,38,sig3t,emnuc,empion,2,9,0,0)
           call cross1(1,srt,prpin,23,sig1t,emnuc,empion,2,7,0,0)
           ida(4)=ida4
         end if
         jreco=0
         if(ireco.eq.0)  jreco=1
         vfflav=strrat
         bmigst=0.0
         if(jpins.eq.1) then
           jentry=0
           if(ireco.eq.0) then
           else if(nscod.eq.1) then
             mtry=0
  264        continue
             mtry=mtry+1
             if(mtry.gt.50) then
                call errex('absorb 264:mtry>50')
             end if
             call bwdist(1,-1,srt,jentry,ichd,zdnp,bwig)
             if(jentry.eq.3.or.jentry.eq.5.or.
     b               jentry.eq.8.or.jentry.eq.9) go to 264
             if(jentry.eq.999) jentry=0
           else if(nscod.eq.2) then
             jentry=5
           else if(nscod.eq.5) then
             jentry=8
           else if(nscod.eq.6) then
             jentry=9
           end if
           if(jentry.ne.0) then
             if(nscod.eq.1) then
               jent1=1
               jent2=9
             else
               jent1=jentry
               jent2=jentry
             end if
             bmigs=0.0
             do 265 jent=jent1,jent2
              if(nscod.eq.1.and.(jent.eq.3.or.jent.eq.5
     b           .or.jent.eq.8.or.jent.eq.9)) go to 265
              call bwdist(1,1,srt,jent,ichd,zdnp,bmig)
  265        continue
             bmigs=bmigs+bmig
           else
             bmigs=0.0
           end if
         else
           bmigs=0.0
           do 267 jent=1,9
            if(jent.ge.6.and.jent.le.8.and.
     a         (ichd.ne.4.or.jent.ne.7)
     a                                        ) then
              call bwdist(1,1,srt,jent,1,zdnp,bmig)
              bmigst=bmigst+bmig
            else if(jreco.eq.1.or.ichd.lt.0) then
            else
              call bwdist(1,1,srt,jent,ichd,zdnp,bmig)
              bmigs=bmigs+bmig
            end if
  267      continue
         end if
         if(srt.lt.2.0) then
           if(srt.lt.1.8) then
             gamdb=29.*prpin**3/(1.+40.*prpin**2)
             siginb=20.*pi*(hc/2./pi)**2/
     a           prpin**2*gamdb**2/((srt-emdelt)**2+0.25*gamdb**2)
           else
             siginb=0.0
           end if
           sig3t=max(cvalu0,sig3t-siginb-xsbgl3)
           bmigsp=0.0
           do 268 jent=1,9
            call bwdist(1,1,srt,jent,1,zdnp,bmig)
            bmigsp=bmigsp+bmig
  268      continue
           vfak=(prpin/pcms)**2*sig3t/bmigsp
         else
           vfak=0.5*pi*10.0*(hc/pi2)**2/pcms**2/wnorm3
         end if
         if(ireco.ne.0) sigmb3=vfak*vfspin*bmigs
         if(irehev.eq.0) dxsmb3=vfak*vfflav*bmigst
         bmigs=0.0
         bmigst=0.0
         do 269 jent=1,10
          if(jent.eq.10) then
            call bwdist(2,1,srt,jent,1,znnp,bmig)
            bmigst=bmigst+bmig
          else if(jreco.eq.1.or.ichn.le.0) then
          else
            call bwdist(2,1,srt,jent,ichn,znnp,bmig)
            bmigs=bmigs+bmig
          end if
  269    continue
         if(srt.lt.1.8) then
           bmigsp=0.0
           do 270 jent=1,10
            call bwdist(2,1,srt,jent,1,znnp,bmig)
            bmigsp=bmigsp+bmig
  270      continue
           sig1t=max(cvalu0,1.5*sig1t-0.5*sig3t-xsbgl1)
           vfak=(prpin/pcms)**2*sig1t/bmigsp
         else
           vfak=0.5*pi*10.0*(hc/pi2)**2/pcms**2/wnorm1
         end if
         if(ireco.ne.0) sigmb1=vfak*vfspin*bmigs
         if(irehev.eq.0)  dxsmb1=vfak*vfflav*bmigst
         if(ida(54).eq.1) then
           call hprop(kmult1,ltype1,em1,emr1,gamm1)
           call hprop(kmult2,ltype2,em2,emr2,gamm2)
           freson=1.
           if(gamm1.gt.0.0) then
             emmx=srt-em2
             argat=2./gamm1*(emmx-emr1)
             freson=freson/(0.5+atan(argat)/pi)
           end if
           if(gamm2.gt.0.0) then
             emmx=srt-em1
             argat=2./gamm2*(emmx-emr2)
             freson=freson/(0.5+atan(argat)/pi)
           end if
           sigmb1=freson*sigmb1
           sigmb3=freson*sigmb3
         end if
         sigmb3=sigmb3+dxsmb3
         sigmb1=sigmb1+dxsmb1
         call retcgk(99,ltype1,99,ltype2,1,cgk212)
         call retcgk(99,ltype1,99,ltype2,3,cgk232)
         sigmb1=cgk212*sigmb1
         sigmb3=cgk232*sigmb3
         dxsmb1=cgk212*dxsmb1
         dxsmb3=cgk232*dxsmb3
         vf=strrat*(prpin/pcms)**2
         if(srt.gt.1.8.and.cgk212.ne.0.0) then
           apin=(4.0/1.8**2)**da(7)
           scon1=cgk212*vf*xspin1*
     a              ((4.0/srt**2)**da(7)-apin*(1.8/srt)**pow12)
         else
           scon1=0.0
         end if
         if(srt.gt.2.0.and.cgk232.ne.0.0) then
           bpin=(4.0/2.0**2)**da(7)
           scon3=cgk232*vf*xspin3*
     a              ((4.0/srt**2)**da(7)-bpin*(2.0/srt)**pow32)
         else
           scon3=0.0
         end if
         if(scon1.gt.cvalu0) then
           if(ida55.ne.0.and.kswi.eq.1.and.iabs(m).eq.1) then
             mbfix=-11
             prbas=prpin
             emda=emnuc
             emdb=empion
             ichoba=2
             jt1=1
             jt1new=2
             jt2new=1
             idntre=83
             idntbc=83
             fnlrga=0.
             ltyper=(idntre-m)/2
             call bele(iflfa,iflfb,ltyper)
             itag=0
             call isocgk(jtm1,jt1,jtm2,jt2,jt1new,jt2new,
     a                                       jtm1nw,jtm2nw,itag)
             klmold=jtm1nw/2*17+23*(2-iabs(jtm1nw))/2
             klbold=(idntbc-jtm2nw)/2
             ktry=0
  126        ktry=ktry+1
             f1ia=1.0
             f2ia=1.0
             kfbaa=0
             if(ranf(0).gt.em2nur/srt) then
               imany=1
             else
               call bresdc(imany,
     a              iflfb,iflfa,ichoba,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbaa,kfmea,kmltba,kmltma,
     d              iflb,ifla,ifl3,kdfr,embaa,emmea,ptx,pty)
             end if
             if(imany.eq.0) then
               proia=prcms(emstr,embaa,emmea)
               kfbria=kfbaa+100*kmltba
               kfmsia=isign(1,kfmea)*(iabs(kfmea)+100*kmltma)
               f1ia=
     a         regsup(ida55,kfmsia,kfbria,klmold,klbold,ifl3,kex,
     b                        prbas,proia,emstr,pr0r,spw,iscd)
             end if
             enlrga=1.
             if(kfbaa.ne.0) then
               if(irehev.eq.1) then
                 f2ia=0.0
               else
                 f2ia=
     a           regsup(ida55,kfinms,kfinba,kfmsia,kfbria,mfld,kex,
     b                            pcms4,proia,emstr,pr0r,spw,iscd)
               end if
               enlrga=f2ia/f1ia
             end if
             fnlrga=fnlrga+enlrga
             if(ktry.eq.1) then
               sigupl=1.0*(1.+(prbas**2/0.64))*(scon1+scon3)
     a                                         +sigmb1+sigmb3
               if(sigqsq.gt.sigupl) kestim=2
               if(sigqsq.le.sigmb1+sigmb3) kestim=1
             end if
             if(kestim.ne.1.and.ktry.le.ixsect)  go to 126
             fnlrg=fnlrga/ktry
             scon1=fnlrg*scon1
             if(xsann.lt.scon1) then
               write(lun8,*) 'warning: absorb126:',fnlrg
               write(lun8,*) ltype1,kmult1,ltype2,kmult2
               write(lun8,*) 'srt=',srt,pcms,fnlrg*scon3,xsann
             end if
           end if
         end if
         if(scon3.gt.cvalu0) then
           if(ida55.ne.0.and.kswi.eq.1.and.iabs(m).le.3) then
             mbfix=-11
             prbas=prpin
             emda=emnuc
             emdb=empion
             ichoba=1
             jt1=3
             jt1new=2
             jt2new=1
             idntre=125
             idntbc=83
             fnlrga=0.
             ltyper=(idntre-m)/2
             call bele(iflfa,iflfb,ltyper)
             itag=0
             call isocgk(jtm1,jt1,jtm2,jt2,jt1new,jt2new,
     a                                       jtm1nw,jtm2nw,itag)
             klmold=jtm1nw/2*17+23*(2-iabs(jtm1nw))/2
             klbold=(idntbc-jtm2nw)/2
             ktry=0
  226        ktry=ktry+1
             f1ia=1.0
             f2ia=1.0
             kfbaa=0
             if(ranf(0).gt.em2nur/srt) then
               imany=1
             else
               call bresdc(imany,
     a              iflfb,iflfa,ichoba,mbfix,
     b              kswi,ida53,ida55,klbold,klmold,emstr,emda,emdb,
     c              kfbaa,kfmea,kmltba,kmltma,
     d              iflb,ifla,ifl3,kdfr,embaa,emmea,ptx,pty)
             end if
             if(imany.eq.0) then
               proia=prcms(emstr,embaa,emmea)
               kfbria=kfbaa+100*kmltba
               kfmsia=isign(1,kfmea)*(iabs(kfmea)+100*kmltma)
               f1ia=
     a         regsup(ida55,kfmsia,kfbria,klmold,klbold,ifl3,kex,
     b                           prbas,proia,emstr,pr0r,spw,iscd)
             end if
             enlrga=1.
             if(kfbaa.ne.0) then
               if(irehev.eq.1) then
                 f2ia=0.0
               else
                 f2ia=
     a           regsup(ida55,kfinms,kfinba,kfmsia,kfbria,mfld,kex,
     b                           pcms4,proia,emstr,pr0r,spw,iscd)
               end if
               enlrga=f2ia/f1ia
             end if
             fnlrga=fnlrga+enlrga
             if(ktry.eq.1) then
               sigupl=1.0*(1.+(prbas**2/0.64))*scon3+scon1
     a                                         +sigmb1+sigmb3
               if(sigqsq.gt.sigupl) kestim=2
               if(sigqsq.le.sigmb1+sigmb3+scon1) kestim=1
             end if
             if(kestim.ne.1.and.ktry.le.ixsect)  go to 226
             fnlrg=fnlrga/ktry
             scon3=fnlrg*scon3
             if(xsann.lt.scon3) then
               write(lun8,*) 'warning: absorb226:',fnlrg
               write(lun8,*) ltype1,kmult1,ltype2,kmult2
               write(lun8,*) 'srt=',srt,pcms,fnlrg*scon3,xsann
             end if
           end if
         end if
         sigr3=sigmb3+scon3
         sigr1=sigmb1+scon1
         if(sigr1+sigr3.gt.xsann) then
           write(lun8,*) 'absorb: estimated xs_ann to low'
           write(lun8,*) issn(ipi),issn(id),srt
           write(lun8,*) ltype1,kmult1,ltype2,kmult2
           write(lun8,*) sigr1,sigr3,xsann
         else
           if(sigqsq.gt.(sigr1+sigr3)) then
             ichanl=0
             return
           end if
         end if
         if(srt.gt.2.0) then
           resfrm=resfrm+1.
         end if
         icharg=(m1+m2+1)/2
         if(sigr1.eq.0.0.and.sigr3.eq.0.0) then
           ichanl=0
           return
         else if(ranf(0).lt.sigr1/(sigr1+sigr3)) then
           ityp(id)=icharg+10
           if(ranf(0).lt.sigmb1/sigr1) then
             if(ranf(0).le.dxsmb1/sigmb1) then
               jentry=10
             else
               call bwdist(2,-1,srt,jentry,ichn,znnp,bwig)
             end if
             isoan=mbtage(2,jentry,srt,jesant)
             npidec(id)=-jentry
           else
             npidec(id)=3
             jesant=1
             isoan=10
           end if
         else if(sigr3.gt.0.0) then
           ityp(id)=icharg+4
           if(ranf(0).lt.sigmb3/sigr3) then
             if(jpins.eq.1) then
             else if(ranf(0).le.dxsmb3/sigmb3) then
               probs=0.
               do 272 jent=6,8
                call bwdist(1,1,srt,jent,1,zdnp,bwig)
                prob(jent-5)=bwig/zdnp
                probs=probs+prob(jent-5)
  272          continue
               zrand=ranf(0)
               do 273 j=1,3
                jentry=5+j
                prob(j)=prob(j)/probs
                if(j.gt.1) prob(j)=prob(j-1)
                if(zrand.lt.prob(j)) go to 274
  273          continue
  274          continue
             else
               call bwdist(1,-1,srt,jentry,ichd,zdnp,bwig)
             end if
             isoan=mbtage(1,jentry,srt,jesant)
             npidec(id)=-jentry
           else
             npidec(id)=3
             jesant=1
             isoan=10
           end if
         end if
         if(kestim.eq.2)
     a     write(lun8,*) '226:srt=',srt,ltype1,ltype2,em1,em2
       else if(jpin.eq.1) then
         icharg=ichrgb+ichrgp
         ida4=ida(4)
         ida(4)=0
         if(srt.le.emnuc+empion) then
           ichanl=0
           return
         end if
         prpin=pcmsr(srt,emnuc,empion)
         call cross1(1,srt,prpin,38,sig3t,emnuc,empion,2,9,0,0)
         sigtpn=sig3t*rat3
         sig3=sigtpn
         if(imixt.gt.1) then
           if(srt.lt.emmnn2) then
             sig1t=0.
           else
             call cross1(1,srt,prpin,23,xspimp,emnuc,empion,2,7,0,0)
             sig1t=max(cvalu0,1.5*xspimp-0.5*sig3t)
           endif
           sigtpn=sigtpn+sig1t*rat1
         endif
         ida(4)=ida4
         if(sigtpn.le.1.e-10) then
           write(lun8,*) 'warning: sigtpn.lt. 1.e-10 in absorb',sigtpn
           rat3=1.
           rat1=0.
         else
           rat3=sig3/sigtpn
           rat1=1.-rat3
         end if
         ilocms=1
         xsann=xspin3*(4./srt**2)**da(7)
         if(em(id).gt.emnuc+2.*empion) then
           ida4=ida(4)
           ida(4)=0
           call cross1(2,srt,prpin,38,xspipe,emnuc,empion,2,9,0,0)
           ida(4)=ida4
           if(srt.lt.emmnd2) then
             zdnpi=1.
           else
            zdnpi=0.0
            bwigs=0.0
            do 66 jent=1,9
             call bwdist(1,1,srt,jent,1,zdnp,bwig)
             zdnpi=zdnpi+bwig*zdnp
             bwigs=bwigs+bwig
   66       continue
            zdnpi=zdnpi/bwigs
            sigbws=0.5*pi*10.0*(hc/pi2)**2/prpin**2*bwigs
            if(srt.gt.2.0)then
              probbw=sigbws/wnorm3/xsann
              zdnpi=probbw*zdnpi
            else
              probbw=1.0
            end if
            call bwdist(1,-1,srt,jentry,1,zdnp,bwig)
           end if
           if(zdnpi.eq.1.) then
             spinds=0.
           else
             spinds=(sig3t-xspipe)/(1.-zdnpi)
           end if
           if(spinds.gt.1.08*sig3t) then
             write(lun8,*) 'srt,sig3t,spinds',srt,sig3t,spinds
             write(lun8,*) 'xspipe,zdnpi=',xspipe,zdnpi
             call errex('absorb:spinds.gt.sig3t')
           end if
           if(spinds.gt.sig3t) spinds=sig3t
           if(spinds.lt.0.) spinds=0.
           spind=sig3t-spinds
           if(srt.gt.2.80) then
             xsdelt=0.0
           else if(srt.gt.1.50) then
             gmdlt= 29.*prpin**3/(1.+40.*prpin*prpin)
             sigsab=gmdlt/((srt-emdelt)**2+0.25*gmdlt**2)
             xsdelt=10.*(hc/pi2)**2*pi2/prpin**2*sigsab*gmdlt
           else
             xsdelt=spind
           end if
           xselb3=max(cvalu0,spind-xsdelt)
           if(srt.gt.2.00) then
             sigpar=(sig3t-xselb3)*xs32pn*2./srt/sig3t
           end if
         else
           ilocms=0
         end if
         if(ranf(0).le.rat3) then
           ityp(id)=4+icharg
           if(ilocms.eq.0) then
             npidec(id)=1
           else
             if(ranf(0).le.spind/sig3t) then
               if(ranf(0).lt.xsdelt/spind) then
                 npidec(id)=1
               else
                 ichanl=1
               end if
             else
               if(srt.gt.2.0.and.ranf(0).gt.probbw)then
                 jesant=1
                 isoan=11
                 npidec(id)=3
               else
                 isoan=mbtage(1,jentry,srt,jesant)
                 npidec(id)=-jentry
               end if
             end if
           end if
         else
           if(icharg.ne.0.and.icharg.ne.1)
     a              call errex('wrong charge in absorb')
           ityp(id)=10+icharg
           if(ilocms.ne.0) then
             if(sig1t.lt.1.e-10) then
               call errex('sig1t=0. in absorb????? ')
             end if
             ida4=ida(4)
             ida(4)=0
             call cross1(2,srt,prpin,23,xspime,emnuc,empion,2,7,0,0)
             ida(4)=ida4
             reltp=(xspipe+2.*xselb3)/sig3t
             reltm=xspime/xspimp
             if(imixt.eq.2) then
               rat3mp=rat3
             else
               rat3mp=1./(2.*sig1t/sig3t+1.)
             end if
             xelbg=reltm-0.33333*rat3mp*reltp
             if(xelbg.lt.0.0) then
               if(xelbg.lt.-0.02) then
                 write(lun8,*) srt,xelbg,reltm,rat3mp,reltp
                 write(lun8,*)
     a              '3/2 channel provides too much el. xs, absorb'
                 xelbg=0.0
               end if
             end if
             znnpi=0.0
             bwigs=0.0
             do 67 jent=1,10
              call bwdist(2,1,srt,jent,1,znnp,bwig)
              znnpi=znnpi+bwig*znnp
              bwigs=bwigs+bwig
   67        continue
             sigbws=0.5*pi*10.0*(hc/pi2)**2/prpin**2*bwigs
             znnpi=znnpi/bwigs
             if(srt.le.1.8) then
               probbw=1.0
               xsann=sig1t-xsbgl1
             else if(srt.le.2.0) then
               xsann=xs1218+(srt-1.8)/0.2*(xspin1-xs1218)
               probbw=sigbws/wnorm1/xsann
               if(probbw.gt.1.0) then
                 write(lun8,*) 'absorb-warning: probbw=',probbw
                 probbw=1.0
               end if
             else
               xsann=xspin1*(4.0/srt**2)**da(7)
               probbw=sigbws/wnorm1/xsann
             end if
             if(probbw.gt.1.001) then
               write(lun8,*) probbw,sigbws,wnorm1,xsann,srt,icltyp
               sigbws=0.5*pi*10.0*(hc/pi2)**2/prpin**2*bwigs
               write(lun8,*) prpin,bwigs,sigbws
               call errex('absorb: probbw>1')
             end if
             znnpi=probbw*znnpi
             rat1mp=1.0-rat3mp
             xelbg=(xelbg-0.66667*rat1mp*znnpi)/
     a                          (1.-0.66667*znnpi)/rat1mp
             sigr12=(1.-xelbg)*sig1t
             if(srt.gt.2.00) sigr12=sigr12*xs12pn*2./srt/sig1t
             if(xelbg.lt.-0.05.or.xelbg.gt.1.02) then
               if(srt.gt.1.55) then
                 write(lun8,*) srt,xelbg,
     a            'no consistent i=1/2 background el. xs, absorb'
               end if
             end if
             if(ranf(0).le.xelbg) then
               ichanl=1
             else
               call bwdist(2,-1,srt,jentry,1,znnp,bwig)
               if(srt.gt.1.8.and.
     a             ranf(0).gt.probbw) then
                 jesant=1
                 isoan=11
                 npidec(id)=3
               else
                 isoan=mbtage(2,jentry,srt,jesant)
                 npidec(id)=-jentry
               end if
             end if
           else
             call errex('too low cms energy,n* branch  absorb????? ')
           end if
         end if
       else
         call errex('absorb:dead end')
       end if
       if(jesant.eq.1) then
         iqqst=iqqsto(ityp(id),npidec(id),iflb3,iflc3)
         isoan=isign(1,ltype1)*(isoan+imesp*100)
         isoan=isign(1,isoan)*(iabs(isoan)+ibasp*100000)
       end if
      return
      end
      function iqqsto(ityp,npidec,iflb3,iflc3)
#include "amsrqmd.h"
       call transl(-1,ityp,npidec,kf)
       ltry=0
  701  call bele(jfla,jfl,kf)
       jflb=mod(jfl,10)
       jflc=jfl/10
       if(jflb.eq.iflb3.and.jflc.eq.iflc3) then
         iqqsto=jfl
       else if(jflc.eq.iflb3.and.jflb.eq.iflc3) then
         iqqsto=jfl
       else if(ltry.lt.50) then
         ltry=ltry+1
         go to 701
       else
        write(lun8,*) 'iqqsto warning:no qq found',iflb3,iflc3,kf
        iqqsto=jfl
       end if
       return
       end
      function  mbtage(idn,jentry,srt,jesant)
       include 'scatter7'
#include "amsrqmd.h"
       if(jentry.gt.0) then
         if(idn.eq.1) then
           if(jentry.ge.6.and.jentry.le.9) then
             jesant=1
             zrand=ranf(0)
             wdnpi=dcratd(1,jentry,srt)
             wdnspi=wdnpi+dcratd(0,jentry,srt)
             if(jentry.eq.7) then
               wdnsk=wdnspi+dcratd(4,jentry,srt)
               mbtage=15
             else
               wdnsk=wdnspi
               mbtage=13
             end if
             zrand=ranf(0)
             if(zrand.le.wdnpi) then
               mbtage=12
             else if(zrand.le.wdnspi) then
               mbtage=14
             else if(zrand.le.wdnsk) then
               mbtage=16
             end if
           else
             mbtage=0
           end if
         else if(idn.eq.2) then
           if(jentry.eq.10) then
             jesant=1
             zrand=ranf(0)
             znnpi=dcratn(1,jentry,srt)
             if(zrand.le.znnpi) then
               mbtage=12
             else
               mbtage=13
             end if
           else
             mbtage=0
           end if
         else
           call errex('undefined idn in mbtage')
         end if
       else
         mbtage=0
       end if
      return
      end
      function xsesti(icho,s,pr,strrat,ireco,mstr,icollc)
       include 'scatter7'
#include "amsrqmd.h"
       common /xspibk/ xspin1,xspin3,wnorm1,wnorm3,pow12,pow32,
     a                xsbgl1,xsbgl3,xs1218,xs32pn,xs12pn
       if(icho.le.2) then
          prpin=pcmsr(s,emnuc,empion)
          vf=(prpin/pr)**2*strrat
          if(s.gt.1.8) then
            xsesti=2.0*vf*xspin1*(4.0/s**2)**da(7)
            if(s.lt.2.2) xsesti=1.5*xsesti
            if(s.lt.2.0.and.(icollc.eq.1.or.icollc.eq.2))
     a                                        xsesti=1.7*xsesti
          else
            if(ireco.eq.1) then
              if(mstr.eq.0) then
                xsesti=(prpin/pr)**2*50.0
              else
                xsesti=(prpin/pr)**2*10.0
              end if
            else
              xsesti=(prpin/pr)**2*10.0
            end if
          end if
          if(pr.lt.0.1) xsesti=2.*xsesti
       else if(icho.le.4) then
         prkan=pcmsr(s,emnuc,emkap)
         vf=(prkan/pr)**2
         if(s.gt.1.8) then
           xsesti=vf*50.0*(4.0/s**2)**da(7)
         else
           xsesti=vf*50.0
           if(s.lt.1.6) xsesti=xsesti*4.0
         end if
         if(xsesti.gt.400.) xsesti=400.0
       else if(icho.le.6) then
         if(s.le.2.5) then
           xsesti=100.0
         else
           xsesti=25.0/pr/pr
         end if
       end if
      return
      end
      function imspin(kfin)
#include "amsrqmd.h"
       common /bresbk/ embarr(0:11,8),gambar(0:11,8),embmin(8),
     a                 emmesr(0:11,8),gammes(0:11,8),emmmin(8),
     b                 nstatb(0:11,8), mxbsta(8),jspbar(0:11,8),
     c                 nstatm(0:11,8), mxmsta(8),jspmes(0:11,8),
     d                 anglmx(0:11,2),
     e                 qqbdif,ssbdif
       common/ludat1s/mst(40),par(80)
       kf=kfin
       kfa=iabs(kf)
       kmult=kfa/100
       if(kfa.gt.100) kfa=mod(kfa,100)
       if(kfa.le.0.or.kfa.gt.70) then
         call errex('imspin: kfa out of range')
       end if
       kfred=isign(1,kf)*kfa
       call luiflv(kfred,ifla,iflb,iflc,ksp)
       if(kfred.eq.24.or.kfred.eq.25) then
         if(kmult.eq.0) then
           themix=par(72)/360.0*anglmx(0,1)
           valmix=0.3333*(cos(themix)-sqrt(2.)*sin(themix))**2
           if(kfred.eq.25) valmix=1.-valmix
           if(ranf(0).gt.valmix) then
             ifla=3
             iflb=-3
           else
             ifla=1
             iflb=-1
           end if
         else
           if(kfred.eq.25) then
             ifla=3
             iflb=-3
           else
             ifla=1
             iflb=-1
           end if
         end if
       end if
       if(kmult.eq.0) then
         if(ksp.eq.0.or.ksp.eq.1) then
           imspin=ksp
         else
           call errex('imspin: wrong ksp')
         end if
       else
         if(kmult.gt.3) then
           imspin=9
         else if(ksp.eq.0.or.ksp.eq.1) then
           imspin=kmult+1
         else
           call errex('imspin: wrong ksp')
         end if
       end if
       if(imspin.ge.0) then
         if(ifla.eq.3.or.iflb.eq.3) then
           if(ifla+iflb.ne.0) then
             imspin=imspin+10
           else
             imspin=imspin+30
           end if
         else if(ifla.eq.-3.or.iflb.eq.-3) then
           imspin=imspin+20
         end if
       end if
      return
      end
      function ibspin(ityp,npidec,kfin)
#include "amsrqmd.h"
       if(kfin.eq.0) then
         call transl(-1,ityp,npidec,kf)
       else
         kf=kfin
       end if
       kfa=iabs(kf)
       kmult=kfa/100
       if(kfa.gt.100) kfa=mod(kfa,100)
       if(kmult.eq.0) then
         ibspin=0
       else
         ibspin=1
       end if
       if(kfa.eq.57.or.
     a    (kfa.ge.43.and.kfa.le.45)) ibspin=ibspin+10
      return
      end
CPAT,RHAM     .
      subroutine relham(itrig,ntt,nrpion)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
        include 'storbig'
       common/dnsblk/jokall,timpri,bdens,hdens,edens,t11,t22,t33
     a                   ,tb11,tb22,tb33
     b                   ,tp11,tp22,tp33,hdcent
     c                   ,rtsq(2,-5:5),drzsq(2,-5:5)
     d                   ,rvel(2,-5:5),yldet(2,-5:5)
       dimension v4dum(0:3)
      real*4 force,dcoef
      common/blocal/ ngbor(ntotma),force(0:3,ntotma),dcoef(ntotma)
      real*8 qlk,plk,dqlksq,splksq,dqsplk,zlk,qtlk
      real*8 spkmsq,dqspkm
       logical potyes
      dimension qlk(0:3),plk(0:3),xrel(0:3)
      dimension qtlk(0:3),xind(0:3)
      dimension dphidq(0:3,2),dphidp(0:3,2)
      dimension dhldqm(0:3),dhldpm(0:3),dhmdql(0:3),dhmdpl(0:3)
      dimension dcldqm(0:3),dcldpm(0:3)
      logical clust,test
      character*3  frame
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data dq0max/ 25./
      data frcrr1/ 0.3/
      data vernum/'version rqmd 2.3 --10-sep-96'/
      data pronam /' r e l h a m  propagates the particles '/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'-version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
        nghbmx=0
        nttomx=0
        dq0max=dq0max*dt/0.2
      end if
      janr=0
      if(ida(23).ne.0.or.itrig.eq.-1) janr=1
      if(ntt.gt.nbarym) then
           call errex('too large baryon number in relham')
      end if
      nttot=ntt+nrpion
      dtprop=0.
      if(switch(23).or.ida(34).eq.2) then
         isimpl=1
      else
         isimpl=0
      end if
      if((isimpl.eq.0.and.nttot.gt.nclmx).or.
     a             (isimpl.eq.1.and.nttot.gt.ntotma)) then
           call errex('too large particle cluster number in relham')
      else if(nttot.le.1) then
           write(lun8,*)'warning:cluster with 1 particle in relham'
           return
      end if
      n1n2s=n1old+n2old
      ntotm1=nttot-1
      if(janr.eq.1) then
            ntm1=0
      else if(ida(8).eq.1) then
         if(nrpion.eq.0) then
            ntm1=ntt-1
         else
            ntm1=ntt
         end if
      else if(ida(8).eq.3) then
            ntm1=0
      else
         ntm1=nttot-1
      end if
      ntm2m1=nttot+ntm1
      ntm2m2=ntm2m1 -1
      if(ida(8).eq.2) then
         itrig=0
      else if(ida(8).eq.3) then
         itrig=1
      end if
      dtau=dt
    1 continue
      if(janr.ne.1) then
       do 6 l=1,ntm2m1
        do 5 k=1,ntm2m2
         at(k,l)=0.
    5   continue
    6  continue
      end if
      do 17 l=1,nttot
        prop(l)=.true.
   17 continue
       do 18 l=1,nttot
        il=iofset+l
        ichbig(il)=isign(1,ichbig(il))*mod(iabs(ichbig(il)),1000)
        if(ida(7).eq.1) then
          ident=issn(il)
          if(itdth(2,ident).ne.0.and.
     a            tdtg(ident).le.x(0,il)) then
             tdt1i=tdtg(ident)
             call ofshel(4,il,ident)
             call dupdat(il,tdt1i)
          end if
        end if
   18  continue
      icaltp=0
      jcaltp=0
      kcaltp=0
      if(ida(36).gt.1.and.jokall.eq.0) then
        icaltp=1
        timpra=timpri-0.01
        do 946 l=1,nttot
         do 945 i=1,3
  945    force(i,l)=0.
         il=iofset+l
         if(x(0,il).lt.timpri) kcaltp=1
         rtpote=sqrt(x(1,il)**2+x(2,il)**2)
         rlpote=abs(x(3,il))*gamnn
         if(rtpote.lt.frcrr1*rr1.and.rlpote.lt.frcrr1*rr1) then
           force(0,l)=0.0
         else
           force(0,l)=-1.0
         end if
  946   continue
      end if
      if(isimpl.eq.1) then
          do 345 l=1,nttot
           il=iofset+l
           ngbsum(l)=l-1
           nghbor(l)=l
           identl=issn(il)
           ncolil=nclcnt(identl)
           if(switch(23)) then
             ngbrnr(l)=-1
             if(ncolil.eq.0.and.identl.le.n1n2s) then
               do 461 i=0,3
                dhdq(i,l)=0.
  461          continue
               dhdp(0,l)=2.*p(0,il)
               dhdp(1,l)=0.
               dhdp(2,l)=0.
               if(identl.le.n1old) then
                  dhdp(3,l)=2.*betapr*p(0,il)
               else
                  dhdp(3,l)=2.*betata*p(0,il)
               end if
             else if(itdth(2,identl).ne.0.and.
     a                       tdtg(identl).gt.x(0,il)
     b                            .and.qdot(0,il).gt.0.0) then
               versko=p(0,il)/qdot(0,il)
               do 400 i=0,3
                dhdq(i,l)=0.
                dhdp(i,l)=2.*qdot(i,il)*versko
  400          continue
             else
               do 401 i=0,3
                dhdq(i,l)=0.
                dhdp(i,l)=2.*p(i,il)
  401          continue
             end if
           else
             ngbrnr(l)=1
             rhoeff=0.
             rhoef2=0.
             do 407 i=0,3
              xind(i)=0.
  407        continue
             itypl=ityp(il)
             npidl=npidec(il)
             iforc=0
             if(identl.gt.n1old.and.identl.le.n1n2s
     a                   .and.ncolil.eq.0) then
             else if(switch(6)) then
             else if(itdth(2,identl).ne.0.and.
     a                              tdtg(identl).gt.x(0,il)) then
             else if(.not.potyes(il,iqql)) then
             else
               iforc=1
             end if
             if(iforc.eq.0) then
               if(ncolil.eq.0.and.identl.le.nt) then
                 do 462 i=0,3
                  dhdq(i,l)=0.
  462            continue
                 dhdp(0,l)=2.*p(0,il)
                 dhdp(1,l)=0.
                 dhdp(2,l)=0.
                 if(identl.le.n1old) then
                  dhdp(3,l)=2.*betapr*p(0,il)
                 else
                  dhdp(3,l)=2.*betata*p(0,il)
                 end if
               else
                 do 463 i=0,3
                  dhdq(i,l)=0.
                  dhdp(i,l)=2.*p(i,il)
  463            continue
               end if
             else
                do 408 i=0,3
                 xind(i)=x(i,il)
  408           continue
                gamta=1./sqrt(1.-betata*betata)
                ti1=gamta*(xind(0)-betata*xind(3))
                xind(3)=gamta*(xind(3)-betata*xind(0))
                xind(0)=ti1
                xind(1)=xind(1)+bplus
                xind(3)=xind(3)-gamta*0.5*(zmxta+zmnta)
                drsq=xind(1)**2+xind(2)**2+xind(3)**2
                dr=sqrt(drsq)
                rhoeff=1./(exp((dr-rr2)/da(2))+1.)
                rhoprf=-1./da(2)*exp((dr-rr2)/da(2))/
     a                                        (1.+exp((dr-rr2)/da(2)))
                splksq=(p(0,il)+emnuc*gamta)**2-(p(1,il)**2+p(2,il)**2
     a                              +(p(3,il)+emnuc*gamta*betata)**2)
                if(splksq.gt.(em(il)+emnuc)**2) then
                  emil=em(il)
                  ecms=sqrt(splksq)
                  pr2=pcmsr(ecms,emil,emnuc)**2
                else
                  pr2=0.
                end if
                if(ida(32).eq.0.or.ida(32).eq.1) then
                  rcor=1.
                else
                  rcor=r0cor
                end if
                rhoef2=rhoeff
                rhoef3=rhoeff
                if(dr.gt.0.001) then
                  xind(0)=0.
                  do 409 i=1,3
                   xind(i)=xind(i)/dr*2.*emnuc*rhoprf*
     a                 (0.5*alpha*rhoef2*rcor+beta*gamma/(gamma+1.)*
     b                                rhoef3*rcor*(rhoef3*rcor)**gm1)
  409             continue
                  ti1=gamta*(xind(0)+betata*xind(3))
                  xind(3)=gamta*(xind(3)+betata*xind(0))
                  xind(0)=ti1
                else
                  do 465 i=0,3
  465             xind(i)=0.
                end if
                do 402 i=0,3
                 dhdq(i,l)=xind(i)
                 dhdp(i,l)=2.*p(i,il)
  402           continue
             end if
           end if
  345      continue
           go to 1809
      end if
      ngbsum(1)=0
      ngbs=0
      do 350 k=1,nttot
       if(k.gt.1) then
          ngbs=ngbsum(k-1)+ngbrnr(k-1)+2
          ngbsum(k)=ngbs
          if(ngbsum(k)+nclmx.gt.ngbrmx*nclmx) then
             write(lun8,*) 'k,nttot,ngbsum(k),ngbrmx*nclmx'
             write(lun8,*)  k,nttot,ngbsum(k),ngbrmx*nclmx
             call errex('array nghbor(1 ... ngbrmx*nclmx) too small')
          end if
       end if
       ngbrnr(k)=0
       nghbor(ngbs+1)=0
       ik=iofset+k
       do  346 l=1,k-1
         do  346 lnr=ngbsum(l)+1,ngbsum(l)+ngbrnr(l)
         if(nghbor(lnr).eq.k) then
           ngbrnr(k)=ngbrnr(k)+1
           nghbor(ngbs+ngbrnr(k))=l
         end if
  346  continue
       ngbrnr(k)=ngbrnr(k)+1
       nghbor(ngbs+ngbrnr(k))=k
       if(ityp(ik).eq.-9999.or.ichbig(ik).eq.3) then
         prop(k)=.false.
         go to 350
       end if
       identk=issn(ik)
       ncolik=nclcnt(identk)
       do  349 l=k+1,nttot
        il=iofset+l
        if(ityp(il).eq.-9999.or.ichbig(il).eq.3) go to 349
        identl=issn(il)
        ncolil=nclcnt(identl)
        if(ida(34).eq.1.and.min(identl,identk).gt.n1old.and.
     a       max(identk,identl).le.nt.and.max(ncolil,ncolik).eq.0)
     b                                                       go to 349
        do  347 i=0,3
         qlk(i)=x(i,il)-x(i,ik)
         plk(i)=p(i,il)+p(i,ik)
  347   continue
        dqlksq=qlk(0)*qlk(0)
        splksq=plk(0)*plk(0)
        dqsplk=qlk(0)*plk(0)
        do   348 i=1,3
         dqlksq=dqlksq-qlk(i)*qlk(i)
         splksq=splksq-plk(i)*plk(i)
         dqsplk=dqsplk-qlk(i)*plk(i)
  348   continue
         if(dqlksq.lt.0.16)then
            if(mod(ichbig(il),2).ne.1.and.mod(ichbig(ik),2).ne.1) then
              ichbig(il)=2
              ichbig(ik)=2
            end if
         end if
        if(dqlksq.gt.0.) then
          if(qlk(0).gt.0.) then
            prop(l)=.false.
          else
            prop(k)=.false.
          end if
        end if
        dqsq(l*(l-3)/2+k+1)=dqlksq
        spsq(l*(l-3)/2+k+1)=splksq
        dqsp(l*(l-3)/2+k+1)=dqsplk
        if(k.eq.(l-1)) then
           clust=.true.
        else if((l.eq.nttot).and.(k.eq.1)) then
           clust=.true.
        else
           clust=.false.
        end if
        if(-dqlksq.lt.dstint.or.clust) then
           ngbrnr(k)=ngbrnr(k)+1
           nghbor(ngbs+ngbrnr(k))=l
        end if
  349  continue
  350 continue
      if(ida(23).ne.0) go to 300
      do 2813 l=1,nttot
      chi(l)=0.
      if(.not.prop(l)) go to 2813
      il=iofset+l
      do 2812 knr=ngbsum(l)+1,ngbsum(l)+ngbrnr(l)
        k=nghbor(knr)
      if(k.ge.l) go to 2812
      ik=iofset+k
      if(.not.prop(k)) go to 2812
      dqlksq=dqsq(l*(l-3)/2+k+1)
      if(-dqlksq.lt.dstint) then
         if(-dqlksq.lt.0.000001) then
             dqlksq=-0.000001
         end if
         splksq=spsq(l*(l-3)/2+k+1)
         dqsplk=dqsp(l*(l-3)/2+k+1)
         if(dqlksq.gt.0.)then
            call errex('dqlksq>0. not allowed,1')
         end if
         if(ida(14).eq.1) then
            cofact=exp(dqlksq/al)*abs(al/dqlksq)*em(il)**2*em(ik)**2
     a                              *dqsplk/sqrt(splksq)
         else
            cofact=exp(dqlksq/al)*abs(al/dqlksq)*dqsplk
         end if
         if(ichbig(ik).ne.1)then
            chi(l)=chi(l)+cofact
         end if
         if(ichbig(il).ne.1)then
            chi(k)=chi(k)-cofact
         end if
      end if
 2812 continue
 2813 continue
        do 3813 l=1,nttot
         il=iofset+l
         if(.not.prop(l)) go to 3813
         if(ichbig(il).eq.2) then
         else if(ichbig(il).eq.0) then
            if(chi(l).lt.10.)go to 3813
            ichbig(il)=1
         else if(ichbig(il).eq.1) then
            if(chi(l).ge.1.) goto 3813
            ichbig(il)=0
         else if(ichbig(il).eq.3) then
         else
            call errex('ichbig not allowed in relham')
         end if
 3813   continue
        do 3814 l=1,nttot
         il=iofset+l
         if(.not.prop(l)) then
             if(ichbig(il).ne.3) ichbig(il)=1
         else if(ichbig(il).eq.1) then
             prop(l)=.false.
             chi(l)=0.
         else if(ichbig(il).eq.2) then
             ichbig(il)=0
         end if
 3814   continue
  300 continue
      do 310 l=1,nttot
        il=iofset+l
        if(.not.prop(l)) then
           nghbor(ngbsum(l)+1)=10000*ngbrnr(l)+nghbor(ngbsum(l)+1)
           ngbrnr(l)=0
           go to 310
        else
           itypl=ityp(il)
           npidl=npidec(il)
           if(switch(6)) then
               ngbrnr(l)=-ngbrnr(l)
           else if(l.gt.ntt) then
               ngbrnr(l)=-ngbrnr(l)
           else
             if(potyes(il,iqql)) then
               if(ida(35).gt.1) then
                 ngbor(l)=kpote(itypl,npidl,iqql)
               else
                 ngbor(l)=0
               end if
             else
               ngbrnr(l)=-ngbrnr(l)
             end if
           end if
        end if
        if(l.eq.1) go to 310
        if(ida(34).eq.1) go to 310
        iok=0
        do 308 knr=ngbsum(l)+iabs(ngbrnr(l)),ngbsum(l)+1,-1
           k=nghbor(knr)
           if(k.ge.l) go to 308
           if(prop(k)) then
              iok=1
              go to 312
           end if
  308   continue
        do 309  k=l-1,1,-1
          if(prop(k)) then
              ngbrnr(k)=isign(1,ngbrnr(k))*  (iabs(ngbrnr(k))+1)
              nghbor(ngbsum(k)+iabs(ngbrnr(k)))=l
              ngbrnr(l)=isign(1,ngbrnr(l))*  (iabs(ngbrnr(l))+1)
              nghbor(ngbsum(l)+iabs(ngbrnr(l)))=k
              iok=1
              go to 312
          end if
          if(k.eq.1) iok=1
  309   continue
  312   continue
        if(iok.ne.1) call errex('wrong iok-value in relham')
  310 continue
      if(janr.ne.1) then
        do 981 l=1,ntm1
           dcoef(l)=0.
  981   continue
        if(nttot+ntm1.gt.ntotma) then
            call errex('too small dcoef array in relham')
        end if
        if(ida(8).eq.3) then
           do 982 l=ntm1+1,ntm1+ntotm1
             dcoef(l)=chi(l-ntm1)
  982      continue
        else
           do 983 l=ntm1+1,ntm1+ntotm1
             dcoef(l)=0.
  983      continue
        end if
      end if
      do 415 l=1,ntt
      do 414 k=1,ntt
      dhldzm(k,l)=0.
  414 continue
  415 continue
      do 413 l=1,nttot
      il=iofset+l
      identl=issn(il)
      do 411 k=1,nttot
      dldqsm(k,l)=0.
      dldpsm(k,l)=0.
      dldqpm(k,l)=0.
  411 continue
      do 410 i=0,3
      dchidq(i,l)=0.
      dchidp(i,l)=0.
      dhdq(i,l)=0.
  410 continue
      if(itdth(2,identl).ne.0.and.
     a           tdtg(identl).gt.x(0,il)
     b            .and.qdot(0,il).gt.0.0) then
        versko=p(0,il)/qdot(0,il)
        do 708 i=0,3
         dhdp(i,l)=2.*qdot(i,il)*versko
  708   continue
      else
        do 709 i=0,3
         dhdp(i,l)=2.*p(i,il)
  709   continue
      end if
      if((itripl.eq.1.and..not.switch(17))
     a                         .or.ida(34).eq.1.or.switch(6)) then
        ncolil=nclcnt(identl)
        if(ncolil.eq.0.and.identl.le.nt) then
           dhdp(1,l)=0.
           dhdp(2,l)=0.
           if(identl.le.n1old) then
              dhdp(3,l)=2.*betapr*p(0,il)
           else
              dhdp(3,l)=2.*betata*p(0,il)
           end if
        end if
      end if
  413 continue
      if(janr.eq.1) go to 1808
      do 113 l=1,nttot
      il=iofset+l
      do 111 knr=ngbsum(l)+1,ngbsum(l)+iabs(ngbrnr(l))
      k=nghbor(knr)
      if(k.ge.l) go to 111
      ik=iofset+k
      if(.not.prop(k)) go to 111
      do 99 i=0,3
      qlk(i)=x(i,il)-x(i,ik)
      plk(i)=p(i,il)+p(i,ik)
   99 continue
      dqlksq=dqsq(l*(l-3)/2+k+1)
      splksq=spsq(l*(l-3)/2+k+1)
      dqsplk=dqsp(l*(l-3)/2+k+1)
      if(-dqlksq.lt.dstint ) then
         if((dqlksq.lt.0.000001).and.(-dqlksq.lt.0.000001)) then
           dqlksq=-0.000001
         end if
         if(ida(14).eq.1) then
            if(dqlksq.gt.1000.) dqlksq=1000.
            cofact=exp(dqlksq/al)*abs(al/dqlksq)
     a                            *em(il)**2*em(ik)**2/sqrt(splksq)
            do 1060 i=0,3
            dcdpkl=cofact*(qlk(i)-
     a                  dqsplk/splksq*plk(i))
            dcdqkl=-(cofact*(plk(i)+dqsplk*
     a                  2.*qlk(i)/al*(1.-(al/dqlksq))))
            dchidq(i,l)=dchidq(i,l)-dcdqkl
            dchidp(i,l)=dchidp(i,l)+dcdpkl
            dchidq(i,k)=dchidq(i,k)-dcdqkl
            dchidp(i,k)=dchidp(i,k)-dcdpkl
 1060       continue
            dldqpm(k,l)=cofact
            dldqpm(l,k)=cofact
            cofact=cofact*dqsplk
            dldqsm(k,l)=cofact /al*(1.-al/dqlksq)
            dldqsm(l,k)=-dldqsm(k,l)
            dldpsm(k,l)=-0.5*cofact/splksq
            dldpsm(l,k)=-dldpsm(k,l)
         else
            if(dqlksq.gt.1000.) dqlksq=1000.
            cofact=exp(dqlksq/al)*abs(al/dqlksq)
            do 106 i=0,3
            dcdpkl=cofact*qlk(i)
            dcdqkl=-(cofact*(plk(i)+dqsplk*
     a                  2.*qlk(i)/al*(1.-(al/dqlksq))))
            dchidq(i,l)=dchidq(i,l)-dcdqkl
            dchidp(i,l)=dchidp(i,l)+dcdpkl
            dchidq(i,k)=dchidq(i,k)-dcdqkl
            dchidp(i,k)=dchidp(i,k)-dcdpkl
  106       continue
            dldqpm(k,l)=cofact
            dldqpm(l,k)=cofact
            cofact=cofact*dqsplk
            dldqsm(k,l)=cofact /al*(1.-al/dqlksq)
            dldqsm(l,k)=-dldqsm(k,l)
            dldpsm(k,l)=0.
            dldpsm(l,k)=0.
         end if
      else
         if(ida(14).eq.1) then
            glkm4=glk*em(ik)**2*em(il)**2/sqrt(splksq)
            do 2006 i=0,3
            dcdpkl=glkm4*(qlk(i)-
     a                  dqsplk/splksq*plk(i)      )
            dcdqkl=-glkm4*plk(i)
            dchidq(i,l)=dchidq(i,l)-dcdqkl
            dchidp(i,l)=dchidp(i,l)+dcdpkl
            dchidq(i,k)=dchidq(i,k)-dcdqkl
            dchidp(i,k)=dchidp(i,k)-dcdpkl
 2006       continue
            dldqpm(k,l)=glkm4
            dldqpm(l,k)=glkm4
            dldqsm(k,l)=0.
            dldqsm(l,k)=0.
            glkm4=glkm4*dqsplk
            dldpsm(k,l)=-0.5*glkm4/splksq
            dldpsm(l,k)=-dldpsm(k,l)
         else
            do 1006 i=0,3
            dcdpkl=glk*qlk(i)
            dcdqkl=-glk*plk(i)
            dchidq(i,l)=dchidq(i,l)-dcdqkl
            dchidp(i,l)=dchidp(i,l)+dcdpkl
            dchidq(i,k)=dchidq(i,k)-dcdqkl
            dchidp(i,k)=dchidp(i,k)-dcdpkl
 1006       continue
            dldqpm(k,l)=glk
            dldqpm(l,k)=glk
            dldqsm(k,l)=0.
            dldqsm(l,k)=0.
            dldpsm(k,l)=0.
            dldpsm(l,k)=0.
         end if
      end if
  111 continue
  113 continue
      if(itrig.eq.0) then
         do 40 l=1,ntotm1
         il=iofset+l
         do 36 mnr=ngbsum(l)+1,ngbsum(l)+iabs(ngbrnr(l))
         m=nghbor(mnr)
         im=iofset+m
         do 38 knr=ngbsum(m)+1,ngbsum(m)+iabs(ngbrnr(m))
         kk=nghbor(knr)
         if(kk.ge.l) go to 38
         k=kk+ntm1
         ikk=iofset+kk
         if(.not.prop(kk))go to 38
         wert=0.
         signum=1.
         do 435 i=0,3
         if(kk.eq.m) then
           dphidp(i,1)=dchidp(i,kk)
           dphidq(i,2)=dchidq(i,kk)
         else
           qlk(i)=x(i,ikk)-x(i,im)
           plk(i)=p(i,ikk)+p(i,im)
           dphidp(i,1)=2.*dldpsm(m,kk)*plk(i)+dldqpm(m,kk)*qlk(i)
           dphidq(i,2)=-(2.*dldqsm(m,kk)*qlk(i)+dldqpm(m,kk)*plk(i))
         end if
         if(l.eq.m) then
           dphidq(i,1)=dchidq(i,l )
           dphidp(i,2)=dchidp(i,l )
         else
           qlk(i)=x(i,il )-x(i,im)
           plk(i)=p(i,il )+p(i,im)
           dphidq(i,1)=-(2.*dldqsm(m,l )*qlk(i)+dldqpm(m,l )*plk(i))
           dphidp(i,2)=2.*dldpsm(m,l )*plk(i)+dldqpm(m,l )*qlk(i)
         end if
         wert=wert+signum*(
     a         dphidp(i,1)*dphidq(i,1)-
     b         dphidq(i,2)*dphidp(i,2))
         signum=-1.
  435   continue
        if(l.le.ntm1) at(k,l)=at(k,l)+wert
        if(kk.le.ntm1) at(l+ntm1,kk)=at(l+ntm1,kk)-wert
   38   continue
   36 continue
   40 continue
      end if
 1808 continue
      do 230 l=1,ntt
      il=iofset+l
      identl=issn(il)
      denspp(identl)=0.
      do 229 knr=ngbsum(l)+1,ngbsum(l)+ngbrnr(l)
      k=nghbor(knr)
      ik=iofset+k
      if(ngbrnr(ik).le.0) go to 229
      if(k.lt.l) then
         dqlksq=dqsq(l*(l-3)/2+k+1)
         splksq=spsq(l*(l-3)/2+k+1)
         dqsplk=dqsp(l*(l-3)/2+k+1)
         pr2=(.25*(splksq-(em(ik)*em(ik)+em(il)*em(il)))**2-
     a           em(ik)*em(ik)*em(il)*em(il))/splksq
         zlk=dqlksq-dqsplk*dqsplk/splksq
         if(-zlk.lt.dstint) then
           cofact=exp(zlk/alpot)
           identk=issn(ik)
           denspp(identk)=denspp(identk)+cofact
           denspp(identl)=denspp(identl)+cofact
           ident1=issn(il)
           ident2=issn(ik)
           ncoli1=nclcnt(ident1)
           ncoli2=nclcnt(ident2)
           if(switch(8).and.
     a           ncoli1.eq.0.and.ncoli2.eq.0.and.
     b            ((ident1.le.n1old.and.ident2.le.n1old).or.
     c             (ident1.gt.n1old.and.ident1.le.n1n2s.and.
     d                 ident2.gt.n1old.and.ident2.le.n1n2s)))then
           else
             dhldzm(k,l)=-emnuc*cofact
             dhldzm(l,k)=-emnuc*cofact
           end if
         end if
      end if
  229 continue
  230 continue
      do 240 l=1,ntt
       il=iofset+l
       identl=issn(il)
       do 439 mnr=ngbsum(l)+1,ngbsum(l)+ngbrnr(l)
       m=nghbor(mnr)
       im=iofset+m
       if(ngbrnr(im).le.0) go to 439
       if(m.lt.l) then
          dqlksq=dqsq(l*(l-3)/2+m+1)
          splksq=spsq(l*(l-3)/2+m+1)
          dqsplk=dqsp(l*(l-3)/2+m+1)
          pr2=(.25*(splksq-(em(im)*em(im)+em(il)*em(il)))**2-
     a           em(im)*em(im)*em(il)*em(il))/splksq
          zlk=dqlksq-dqsplk*dqsplk/splksq
          if(-zlk.lt.dstint) then
                do 419 i=0,3
                  qlk(i)=x(i,il)-x(i,im)
                  plk(i)=p(i,il)+p(i,im)
  419           continue
                do 417 i=0,3
                  qtlk(i)=qlk(i)-dqsplk/splksq*plk(i)
  417           continue
              eos1=eosc1
              eos2=eosc2
              kpot=ngbor(l)+ngbor(m)
              pilsq=p(0,il)*p(0,il)
              pimsq=p(0,im)*p(0,im)
              do  427 i=1,3
               pilsq=pilsq-p(i,il)*p(i,il)
               pimsq=pimsq-p(i,im)*p(i,im)
  427         continue
              emil=sqrt(max(0.0,pilsq))
              emim=sqrt(max(0.0,pimsq))
              srtlm=sqrt(splksq)
              if(srtlm.gt.emil+emim) then
               prlm=pcmsr(srtlm,emil,emim)
              else
                prlm=0.0
              end if
              valm=prlm
              if((ida(12).eq.1.and.valm.gt.pr2max).or.
     a                                    ida(12).eq.2) then
                if(pr2.gt.pr2max) eos1=eosc3
                if(kpot.eq.2.or.kpot.eq.6.or.
     a                                     kpot.eq.3) then
                      eos1=eos1*da(13)
                      eos2=eos2*da(16)
                else if(kpot.eq.1) then
                      eos1=eos1*da(14)
                end if
              end if
                identm=issn(im)
                dhldzm(m,l)=0.5*dhldzm(m,l)*
     a                      (eos1+eos2*(denspp(identl)/salpot)**gm1)
                dhldzm(l,m)=0.5*dhldzm(l,m)*
     a                      (eos1+eos2*(denspp(identm)/salpot)**gm1)
                do 438 i=0,3
                  dhldqm(i)=-2.*dhldzm(m,l)*qtlk(i)
                  dhdq(i,l)=dhdq(i,l)-dhldqm(i)
                  dhmdql(i)=2.*dhldzm(l,m)*qtlk(i)
                  dhdq(i,m)=dhdq(i,m)-dhmdql(i)
                  dhldpm(i)=-2.*dhldzm(m,l)*dqsplk/splksq*qtlk(i)
                  dhdp(i,l)=dhdp(i,l)+dhldpm(i)
                  dhmdpl(i)=-2.*dhldzm(l,m)*dqsplk/splksq*qtlk(i)
                  dhdp(i,m)=dhdp(i,m)+dhmdpl(i)
  438           continue
                if(icaltp.ne.0) then
                  if(force(0,l).eq.0.0.and.force(0,m).eq.0.0) then
                    do 432 i=1,3
                     force(i,l)=force(i,l)-dhldqm(i)
                     force(i,m)=force(i,m)-dhmdql(i)
  432               continue
                  end if
                end if
                if(janr.ne.1) then
                 do 478 knr=ngbsum(m)+1,ngbsum(m)+ngbrnr(m)
                   k=nghbor(knr)
                   if(k.eq.nttot) go to 478
                   ik=iofset+k
                   if(.not.prop(k)) go to 478
                   signum=1.
                   wert=0.
                   do 476 i=0,3
                   if(k.eq.m) then
                    dphidp(i,1)=dchidp(i,k)
                    dphidq(i,2)=dchidq(i,k)
                   else
                    qlk(i)=x(i,ik)-x(i,im)
                    plk(i)=p(i,ik)+p(i,im)
                    dphidp(i,1)=2.*dldpsm(m,k)*plk(i)
     a                                   +dldqpm(m,k)*qlk(i)
                    dphidq(i,2)=-(2.*dldqsm(m,k)*qlk(i)
     a                                    +dldqpm(m,k)*plk(i))
                   end if
                   wert=wert+signum*(
     a                         dphidp(i,1)*dhldqm(i)-
     b                               dphidq(i,2)*dhldpm(i))
                   signum=-1.
  476              continue
                   if(k.le.ntm1.and.l.le.ntm1)
     a                           at(l,k)=at(l,k)-wert
                   at(k+ntm1,l+ntm1)=at(k+ntm1,l+ntm1)+wert
  478            continue
                 do 578 knr=ngbsum(l)+1,ngbsum(l)+ngbrnr(l)
                   k=nghbor(knr)
                   if(k.eq.nttot) go to 578
                   ik=iofset+k
                   if(.not.prop(k)) go to 578
                   signum=1.
                   wert=0.
                   do 576 i=0,3
                   if(k.eq.l) then
                    dphidp(i,1)=dchidp(i,k)
                    dphidq(i,2)=dchidq(i,k)
                   else
                    qlk(i)=x(i,ik)-x(i,il)
                    plk(i)=p(i,ik)+p(i,il)
                    dphidp(i,1)=2.*dldpsm(l,k)*plk(i)
     a                                   +dldqpm(l,k)*qlk(i)
                    dphidq(i,2)=-(2.*dldqsm(l,k)*qlk(i)
     a                                    +dldqpm(l,k)*plk(i))
                   end if
                   wert=wert+signum*(
     a                         dphidp(i,1)*dhmdql(i)-
     b                               dphidq(i,2)*dhmdpl(i))
                   signum=-1.
  576              continue
                   if(k.le.ntm1.and.m.le.ntm1)
     a                           at(m,k)=at(m,k)-wert
                   at(k+ntm1,m+ntm1)=at(k+ntm1,m+ntm1)+wert
  578            continue
                end if
          end if
       end if
  439 continue
  240 continue
      if(janr.eq.1) go to 1809
         do 2605 l=1,nttot
            il=iofset+l
            do 2618 knr=ngbsum(l)+1,ngbsum(l)+iabs(ngbrnr(l))
                k=nghbor(knr)
                if(k.eq.nttot) go to 2618
                ik=iofset+k
                if(.not.prop(k)) go to 2618
                signum=1.
                wert=0.
                do 2616 i=0,3
                  if(k.eq.l) then
                    dphidp(i,1)=dchidp(i,k)
                    dphidq(i,2)=dchidq(i,k)
                  else
                    qlk(i)=x(i,ik)-x(i,il)
                    plk(i)=p(i,ik)+p(i,il)
                    dphidp(i,1)=2.*dldpsm(l,k)*plk(i)
     a                                   +dldqpm(l,k)*qlk(i)
                    dphidq(i,2)=-(2.*dldqsm(l,k)*qlk(i)
     a                                    +dldqpm(l,k)*plk(i))
                   end if
                   wert=wert+signum*(
     a                         dphidp(i,1)*dhdq(i,l)-
     b                               dphidq(i,2)*dhdp(i,l))
                   signum=-1.
 2616              continue
                   if(k.le.ntm1.and.l.le.ntm1)
     a                           at(l,k)=at(l,k)-wert
                   at(k+ntm1,l+ntm1)=at(k+ntm1,l+ntm1) +wert
 2618        continue
 2605    continue
      if(itrig.eq.0) then
         do 30 l=1,min0(ntotm1,ntt)
         il=iofset+l
         do 26 mnr=ngbsum(l)+1,ngbsum(l)+ngbrnr(l)
          m=nghbor(mnr)
          im=iofset+m
          do 28 knr=ngbsum(m)+1,ngbsum(m)+ngbrnr(m)
            k=nghbor(knr)
            ik=iofset+k
            if(ngbrnr(k).le.0) go to 28
            if((k.ge.l).and.(k.ne.nttot)) go to 28
            wert=0.
            signum=1.
            if(l.gt.m) then
              splksq=spsq(l*(l-3)/2+m+1)
              dqsplk=dqsp(l*(l-3)/2+m+1)
            else if(l.lt.m) then
              splksq=spsq(m*(m-3)/2+l+1)
              dqsplk=-dqsp(m*(m-3)/2+l+1)
            end if
            if(k.gt.m) then
              spkmsq=spsq(k*(k-3)/2+m+1)
              dqspkm=dqsp(k*(k-3)/2+m+1)
            else if(k.lt.m) then
              spkmsq=spsq(m*(m-3)/2+k+1)
              dqspkm=-dqsp(m*(m-3)/2+k+1)
            end if
            do 425 i=0,3
             if(l.eq.m) then
                  dphidp(i,1)=dhdp(i,l)
                  dphidq(i,2)=dhdq(i,l)
             else
                  qlk(i)=x(i,il)-x(i,im)
                  plk(i)=p(i,il)+p(i,im)
                  qtlk(i)=qlk(i)-dqsplk/splksq*plk(i)
                  dphidp(i,1)=-2.*dhldzm(m,l)*dqsplk/splksq*qtlk(i)
                  dphidq(i,2)=-2.*dhldzm(m,l)*qtlk(i)
             end if
             if(k.eq.m) then
                  dphidq(i,1)=dhdq(i,k)
                  dphidp(i,2)=dhdp(i,k)
              else
                  qlk(i)=x(i,ik)-x(i,im)
                  plk(i)=p(i,ik)+p(i,im)
                  qtlk(i)=qlk(i)-dqspkm/spkmsq*plk(i)
                  dphidq(i,1)=-2.*dhldzm(m,k)*qtlk(i)
                  dphidp(i,2)=-2.*dhldzm(m,k)*dqspkm/spkmsq*qtlk(i)
              end if
              wert=wert+signum*(
     a                    dphidp(i,1)*dphidq(i,1)-
     b                                   dphidq(i,2)*dphidp(i,2))
              signum=-1.
  425       continue
            if(l.le.ntm1) at(l,k+ntm1)=at(l,k+ntm1)+wert
            if(k.le.ntm1)
     a            at(k,l+ntm1)=at(k,l+ntm1)-wert
   28      continue
   26  continue
   30 continue
      end if
      do 32 l=1,nttot
         if(.not.prop(l)) then
            if(l.le.ntm1) at(l,l)=1.
            if(l.le.ntotm1) at(ntm1+l,ntm1+l)=1.
         end if
   32 continue
      lend=ntm2m2+1
      j1end=ntm2m1+1
      if(itrig.eq.0) then
         lstart=1
         j2end=ntm2m2+1
      else
         lstart=ntm1+1
         j2end=ntotm1+1
      end if
      iok=0
      do 520 j=nttot,1,-1
        j1end=j1end-1
        j2end=j2end-1
         lend=lend-1
         bcoef(2*iofset+j1end)=0.
        if(prop(j))then
           iok=1
           go to 521
        end if
  520 continue
  521 continue
      if(iok.eq.0) then
          write(lun8,*)'irun,itripl,kdt,kclst,ntt,nrpion'
          write(lun8,*) irun,itripl,kdt,kclst,ntt,nrpion
          do 551 l=1,nttot
            il=iofset+l
            write(lun8,*) l,'prop=',prop(l),'ichbig=',ichbig(il)
            do 550 k=1,l-1
              dqlksq=dqsq(l*(l-3)/2+k+1)
              write(lun8,*) l,k,'dqlksq=',dqlksq
  550       continue
  551 continue
          call errex('only not.prop particles in relham????? ')
       end if
         do  510 l=lstart,lend
           dcoef(l)=dcoef(l)/at(l,l)
           do  509 j=l+1,j1end
             dcoef(j)=dcoef(j)-at(j,l)*dcoef(l)
             if(at(l,j).ne.0.) then
                at(l,j)=-at(l,j)/at(l,l)
                do 508 k=l+1,lend
                   at(k,j)=at(k,j)+at(l,j)*at(k,l)
  508           continue
             end if
  509     continue
  510   continue
        bcoef(2*iofset+j1end)=1.
        do 514 j=1,j2end
           jj=j1end-j
           bcoef(2*iofset+jj)=dcoef(jj)
           do 513 k=jj+1,j1end
              bcoef(2*iofset+jj)=bcoef(2*iofset+jj)+
     a                      at(jj,k)*bcoef(2*iofset+k)
  513      continue
           bcf=bcoef(2*iofset+jj)
           bcoef(2*iofset+jj)=max(cvalu0,bcf)
  514   continue
      bprmax=0.
      do 506 j=1,ntm2m1
        bcf=bcoef(2*iofset+j)
        bprmax=max(bcf,bprmax)
  506 continue
      if(bprmax.eq.0.) call errex('bprmax=0. in relham')
      do 507 j=1,ntm2m1
        bcoef(2*iofset+j)=bcoef(2*iofset+j)/bprmax
  507 continue
      dslsum=0.
      dslmax=0.
      nprop=0
      do 518 l=1,nttot
        il=iofset+l
        dsl=p(0,il)*pnorm(0)
        do 519 i=1,3
  519   dsl=dsl-p(i,il)*pnorm(i)
        dsl=2.*bcoef(2*iofset+ntm1+l)*dsl
            if(dsl.ne.0.) nprop=nprop+1
            dslsum=dslsum+dsl
        dslmax=max(dslmax,dsl)
  518 continue
      if(dslmax.le.0.) call errex('no prop. in relham')
      divide=1. / dslmax
      if(nprop.gt.0) then
            if(switch(17)) then
               dslsum=float(nprop)/dslsum
            else
               dslsum=float(nprop)/dslsum
            endif
            divide=dslsum
            if(dslmax*dtau*divide.gt.dq0max) then
                 divide=dq0max/(dslmax*dtau)
            end if
      end if
      do 505 j=1,ntm2m1
        bcoef(2*iofset+j)=bcoef(2*iofset+j)*divide
  505 continue
      do 503 il=iofset+1,iofset+nttot
        dsl=p(0,il)*pnorm(0)
        do 502 i=1,3
  502   dsl=dsl-p(i,il)*pnorm(i)
        dsl=0.6667*bcoef(iofset+ntm1+il)*dsl
        if(dsl.gt.1.) then
             bcoef(iofset+ntm1+il)=bcoef(iofset+ntm1+il)/dsl
        end if
  503 continue
 1809 continue
      if(janr.eq.1.and.ida(23).eq.0) then
         do 1810 j=1,ntm2m1
          if(j.le.ntm1) then
             bcoef(2*iofset+j)=0.
          else
             ji=iofset+j-ntm1
             if(.not.prop(ji-iofset)) then
                bcoef(2*iofset+j)=0.
             else
                bcoef(2*iofset+j)=0.5/em(ji)
             endif
          end if
 1810     continue
      else if(ida(23).ne.0) then
         teprop=tbegin+kdt*dtau
         do 2853 l=1,nttot
          il=iofset+l
          tilobs=x(0,il)*pnorm(0)-x(1,il)*pnorm(1)-
     a                          x(2,il)*pnorm(2)-x(3,il)*pnorm(3)
          identl=issn(il)
          ncolil=nclcnt(identl)
          if((itripl.eq.1.and..not.switch(17))
     a                         .or.ida(34).gt.0.or.switch(6)) then
            if(ncolil.eq.0.and.identl.le.nt.and.
     a                   (ida(34).ne.2.or.identl.gt.n1old)) then
              if(identl.le.n1old) then
                pilobs=p(0,il)*pnorm(0)-p(0,il)*betapr*pnorm(3)
              else
                pilobs=p(0,il)*pnorm(0)-p(0,il)*betata*pnorm(3)
              end if
            else
              pilobs=p(0,il)*pnorm(0)-p(1,il)*pnorm(1)-
     a                          p(2,il)*pnorm(2)-p(3,il)*pnorm(3)
            end if
          else
            pilobs=p(0,il)*pnorm(0)-p(1,il)*pnorm(1)-
     a                          p(2,il)*pnorm(2)-p(3,il)*pnorm(3)
          end if
          if(ichbig(il).eq.3) then
             bcoef(2*iofset+ntm1+l)=0.
             prop(l)=.false.
          else if(tilobs.gt.teprop) then
             ichbig(il)=1
             bcoef(2*iofset+ntm1+l)=0.
             prop(l)=.false.
          else
             prop(l)=.true.
             ichbig(il)=0
             bcoef(2*iofset+ntm1+l)=0.5*(teprop-tilobs)/dtau/pilobs
          end if
 2853   continue
        do 2852 j=1,ntm1
           bcoef(2*iofset+j)=0.
 2852   continue
      end if
      do 943 l=1,nttot
       il=iofset+l
       do 942 i=1,4
         at(i,l)=0.
         qdot(i-1,il)=0.
  942  continue
  943 continue
      do 944 l=1,nttot
         if(.not.prop(l)) then
             if(bcoef(2*iofset+ntm1+l).ne.0.) then
                  write(lun8,*)'bcoef=',bcoef(2*iofset+ntm1+l)
                  call errex('bcoef.ne.0. in relham')
             end if
         end if
  944 continue
       if(icaltp.ne.0) then
        do 1501 l=1,nttot
         if(force(0,l).lt.0.0) go to 1501
         if(ngbrnr(l).le.0) then
           force(0,l)=-1.0
           go to 1501
         end if
         il=iofset+l
         if(x(0,il).lt.timpra) then
           bchl=bcoef(2*iofset+ntm1+l)
           do 1500 i=1,3
 1500      force(i,l)=bchl*force(i,l)
           force(0,l)=1.0
           icaltp=2
         end if
 1501   continue
       end if
      do 1525 l=1,nttot
       il=iofset+l
       lalert=0
       if(icaltp.eq.0) then
       else if(force(0,l).lt.0.0) then
       else
         lalert=1
       end if
       if(lalert.eq.1) jcaltp=1
       do 1524 mnr=ngbsum(l)+1,ngbsum(l)+iabs(ngbrnr(l))
        m=nghbor(mnr)
        im=iofset+m
       malert=0
       if(lalert.eq.1) then
         if(m.eq.l) then
         else if(force(0,m).lt.0.0) then
         else if(force(0,m).gt.0.0) then
           malert=1
         end if
       end if
        if(l.eq.m) then
           do 1521 i=0,3
            dhldqm(i)=dhdq(i,l)
            dhldpm(i)=dhdp(i,l)
            if(ntm1.gt.0) then
              dcldqm(i)=dchidq(i,l)
              dcldpm(i)=dchidp(i,l)
            end if
 1521      continue
        else
            if((ntm1.eq.0).and.
     a         (ngbrnr(l).le.0.or.ngbrnr(m).le.0))
     b                                            go to 1524
            if(l.gt.m) then
              splksq=spsq(l*(l-3)/2+m+1)
              dqsplk=dqsp(l*(l-3)/2+m+1)
            else
              splksq=spsq(m*(m-3)/2+l+1)
              dqsplk=-dqsp(m*(m-3)/2+l+1)
            end if
            do 1522 i=0,3
                qlk(i)=x(i,il)-x(i,im)
                plk(i)=p(i,il)+p(i,im)
                if(ntm1.gt.0) then
                   dcldqm(i)=
     a               -(2.*dldqsm(m,l )*qlk(i)+dldqpm(m,l )*plk(i))
                   dcldpm(i)=
     a                2.*dldpsm(m,l )*plk(i)+dldqpm(m,l )*qlk(i)
                end if
 1522       continue
            if(ngbrnr(l).gt.0.and.ngbrnr(m).gt.0) then
              do 1519 i=0,3
                   qtlk(i)=qlk(i)-dqsplk/splksq*plk(i)
                   dhldqm(i)=-2.*dhldzm(m,l)*qtlk(i)
                   dhldpm(i)=-2.*dhldzm(m,l)*dqsplk/splksq*qtlk(i)
 1519         continue
            else
              do 1528 i=0,3
                   dhldqm(i)=0.
                   dhldpm(i)=0.
 1528         continue
            end if
        end if
        do 1523 i=0,3
         delt=bcoef(2*iofset+ntm1+l)*dhldqm(i)
         if(l.le.ntm1) delt=delt+bcoef(2*iofset+l)*dcldqm(i)
         at(1+i,m)=at(1+i,m)+delt
         v4dum(i)=delt
         delt=bcoef(2*iofset+ntm1+l)*dhldpm(i)
         if(l.le.ntm1) delt=delt+bcoef(2*iofset+l)*dcldpm(i)
         qdot(i,im)=qdot(i,im)+delt
 1523   continue
        if(malert.eq.1) then
          do 1505  i=1,3
 1505     force(i,m)=force(i,m)+v4dum(i)
        end if
 1524  continue
 1525 continue
      do 1535 l=1,nttot
       il=iofset+l
       if(qdot(0,il).lt.0.) then
         do 1537 i=0,3
 1537     qdot(i,il)=0.
       end if
       do 1533 i=0,3
        p(i,il)=p(i,il)-at(1+i,l)*dtau
        x(i,il)=x(i,il)+qdot(i,il)*dtau
 1533  continue
        if(ida(34).eq.2) then
          do 1534 i=0,3
           psyst(i)=psyst(i)-at(1+i,l)*dtau
 1534     continue
        end if
 1535 continue
      if(ida(28).eq.0.and.ida(34).eq.0) then
        lanf=0
        lend=ntt+1
        lchang=0
        do 1527 ldum=1,ntt
         if(lchang.eq.0) then
           lchang=1
           lanf=lanf+1
           l=lanf
         else
           lchang=0
           lend=lend-1
           l=lend
         end if
         il=iofset+l
         if(ida(7).eq.1) then
           identl=issn(il)
           if(itdth(2,identl).ne.0.and.
     a                       tdtg(identl).le.x(0,il))then
             tdt1i=tdtg(identl)
             call ofshel(7,il,identl)
             call dupdat(il,tdt1i)
           end if
         end if
         if(.not.potyes(il,iqql)) go to 1527
         if(iqql.eq.1)  go to 1527
         vil=vquasi(il,densa,densb,densc)
         eml=em(il)
         emeff2=eml**2+vil
         pilsqo=p(0,il)**2
         pp=0.0
         do 398 i=1,3
  398    pp=pp+p(i,il)**2
         pilsqo=pilsqo-pp
         dp0=p(0,il)-sqrt(emeff2+pp)
         if(abs(pilsqo-emeff2).gt.0.4) then
           itdo=1
         else if(abs(vil).lt.0.005.and.
     a      abs(pilsqo-emeff2).gt.0.004) then
           itdo=1
         else
           itdo=0
         end if
         ps005=0.005*psyst(0)
         itypl=ityp(il)
         npidl=npidec(il)
         emnew=pilsqo-vil
         if(emnew.lt.0.0) then
            emnew=-1.0
         else
           emnew=sqrt(emnew)
         end if
         newm=newmas(itypl,npidl,iqql,emnew)
         if(newm.eq.1) then
           em(il)=emnew
           go to 1527
         end if
         if(pcorr(3).eq.0.0) itdo=1
         ptsq=pp-p(3,il)**2
         p3nabs=p(0,il)**2-emeff2-ptsq
         if(p3nabs.lt.0.0) then
           dp3=0.0
           itdo=2
         else
           p3nabs=sqrt(p3nabs)
           dp3=p(3,il)-sign(1.0,p(3,il))*p3nabs
         end if
         if(itdo.eq.1) then
           if(nclcnt(il).eq.0.and.issn(il).le.n1n2s) then
             dp3=0.0
             itdo=2
           end if
         end if
         if(abs(pcorr(0)+dp0).gt.2.*ps005) then
           if(pcorr(3).eq.0.0.and.itdo.ne.2) itdo=1
           if(itdo.eq.1.or.pcorr(3)*dp3.lt.0.0) then
           pcorr(3)=pcorr(3)+dp3
           p(3,il)=p(3,il)-dp3
           go to 1527
         end if
         end if
         if(abs(pcorr(0)+dp0).lt.ps005.or.
     b                        pcorr(0)*dp0.lt.0.0
     c                        .or.itdo.ne.0
     d                                              ) then
           pcorr(0)=pcorr(0)+dp0
           if(itdo.ne.0.and.abs(pcorr(0)).gt.20.*ps005) then
             write(lun8,*) 'relham:problem with pcorr'
             write(lun8,*) 'relham:',irun,itripl,kdt,kclst,ntt,nttot
             write(lun8,*) pilsqo,emeff2,vil,dp0
             write(lun8,*) issn(il),'particle with wrong.inv.mass'
             write(lun8,*) 'p=',(p(i,il),i=0,3)
             write(lun8,*) 'pcorr=',(pcorr(i),i=0,3)
             call errex('abort in relham:problem with pcorr')
           end if
           p(0,il)=p(0,il)-dp0
         end if
 1527   continue
        if(lend-lanf.ne.1) call errex('relham abort:lend/lanf')
      end if
      if(icaltp.ne.0) then
        if(kcaltp.eq.0) then
          jokall=1
        else if(jcaltp.eq.0) then
        else if(icaltp.eq.1) then
          jokall=1
        else
          volfac=2.*pi*(frcrr1*rr1)**3/gamnn
          do 1547 l=1,nttot
           il=iofset+l
           if(force(0,l).gt.0.0) then
             if(x(0,il).gt.timpra) then
               do 1546 i=1,3
 1546          v4dum(i)=-force(i,l)/qdot(0,il)*x(i,il)/volfac
               tp11=tp11+v4dum(1)
               tp22=tp22+v4dum(2)
               tp33=tp33+v4dum(3)
               hdcent=hdcent+1.0/volfac
             end if
           end if
 1547     continue
        end if
      end if
      if(kdt.gt.ndt) then
        betafb=0.0
        call chkmsc(betafb)
      end if
      do 293 l=1,nttot
           ngbrnr(l)=iabs(ngbrnr(l))
             if(ngbrnr(l).eq.0) then
                ngbrnr(l)=nghbor(ngbsum(l)+1)/10000
                nghbor(ngbsum(l)+1)=mod(nghbor(ngbsum(l)+1),10000)
             end if
  293 continue
      if(ida(33).eq.0.and.kdt.gt.10.and.kdt.ne.idtcl-1) then
         l=0
  601   continue
           l=l+1
           if(l.gt.nrbar(kclst)+nrmes(kclst)) go to 611
           if(.not.prop(l)) go to 610
           if((iabs(ngbrnr(l)).gt.5.and.l.le.nrbar(kclst)).or.
     a                            iabs(ngbrnr(l)).gt.7) go to 610
           il=iofset+l
           if(decay(il).lt. 1.e+10) go to 610
           identl=issn(il)
           if(itdth(2,identl).ne.0) go to 610
           do 609 knr=ngbsum(l)+1,ngbsum(l)+iabs(ngbrnr(l))
            k=nghbor(knr)
            if(k.eq.l) go to 609
            ik=iofset+k
            if(.not.prop(k)) go to 610
            do  605 i=0,3
            qlk(i)=x(i,il)-x(i,ik)
            plk(i)=p(i,il)+p(i,ik)
  605       continue
            dqlksq=qlk(0)*qlk(0)
            splksq=plk(0)*plk(0)
            dqsplk=qlk(0)*plk(0)
            do  606 i=1,3
            dqlksq=dqlksq-qlk(i)*qlk(i)
            splksq=splksq-plk(i)*plk(i)
            dqsplk=dqsplk-qlk(i)*plk(i)
  606       continue
            do 826 i=0,3
             qtlk(i)=qlk(i)-dqsplk/splksq*plk(i)
  826       continue
            xtxdot=qtlk(0)*(p(0,il)-p(0,ik))
            do 827 i=1,3
             xtxdot=xtxdot-qtlk(i)*(p(i,il)-p(i,ik))
  827       continue
            if(xtxdot.gt.0.)then
               go to 610
            end if
            zlk=dqlksq-dqsplk*dqsplk/splksq
            if(-zlk.lt.dstint) then
               go to 610
            end if
  609      continue
            if(ida(28).eq.0.and.ida(34).eq.0.and.l.le.nrbar(kclst))then
               do 701 ik=iofset+1,iofset+nrbar(kclst)
                 if(ik.eq.il) go to 701
                 identk=issn(ik)
                 if(itdth(2,identk).ne.0) go to 701
                 if(tdtg(identk).ne.0.) go to 701
                imscst=0
                call mscstr(imscst,il,ik,isccss)
                 if(isccss.gt.0) go to 702
  701          continue
  702          continue
            end if
            io=0
            do 645 kcl=1,nrclst
                 io=io+iclusz(kcl)
  645       continue
              nrclst=nrclst+1
              if(l.le.nrbar(kclst)) then
                 nrbar(nrclst)=1
                 nrmes(nrclst)=0
              else
                 nrbar(nrclst)=0
                 nrmes(nrclst)=1
              end if
              iclusz(nrclst)=1
              nonrel(nrclst)=.false.
              lcl=io+1
              if(lcl.ge.ntotma+1-nspect) then
                  lcl=iofset+iclusz(kclst)
                  iclusz(kclst)=iclusz(kclst)-1
                  if(iclusz(kclst).lt. nrbar(kclst)+nrmes(kclst))then
                    call errex('storage overflow lcl.gt.ntotma,relham')
                  end if
                  do 652 kkcl=0,nrclst-2-kclst
                    kcl=nrclst-kkcl
                    nrbar(kcl)=nrbar(kcl-1)
                    nrmes(kcl)=nrmes(kcl-1)
  652             continue
                  if(l.le.nrbar(kclst)) then
                     nrbar(kclst+1)=1
                     nrmes(kclst+1)=0
                  else
                     nrbar(kclst+1)=0
                     nrmes(kclst+1)=1
                  end if
              else
                 lmax=lcl
              end if
              do 646 i=0,3
                x(i,lcl)=x(i,il)
                qdot(i,lcl)=0.0
                p(i,lcl)=p(i,il)
  646         continue
              em(lcl)=em(il)
              ityp(lcl)=ityp(il)
              decay(lcl)=decay(il)
              lastcl(lcl)=lastcl(il)
              issn(lcl)=issn(il)
              npidec(lcl)=npidec(il)
              ichbig(lcl)=0
              tlast(lcl)=tlast(il)
              ityp(il)=-9999
              decay(il)=1.e+35
              npion=npion+1
  610    continue
         go to 601
  611    continue
      end if
      ngbrt=ngbrnr(nttot)
      nghbmx=max(nghbmx,ngbsum(nttot)+ngbrt)
      nttomx=max(nttomx,nttot)
      return
      end
CPAT,ROPE     .
      subroutine tube
      include 'scatter7'
#include "amsrqmd.h"
      real*4 plund,par
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
      real*4 bex,bey,bez
      parameter (mxs=200)
      common /rop1bk/ lstar(mxs),lende(mxs),iroin,iroout
      common /rop2bk/  kparnt(3,mxs),
     a    xori(0:3,mxs),pqu(0:3,mxs),pqb(0:3,mxs)
       logical manip
       common /rop3bk/manip(mxs)
      real*4  atrmax,tnsmax,dndx4m,emqcns,emq,ems,prbrop
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
      common /dropbk/ distnk,xsprta,kprta
      include 'partblk7'
      dimension xactl(0:3),veloc(0:3)
      dimension pql(0:3),pqbarl(0:3)
      dimension ptotl(0:3),ptot(0:3)
      common /prinbk/ iprin
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      logical nghbor
      data vernum/'version  rqmd 2.4 -- 30-jan-98'/
      data pronam/'module: t u b e '/
      data ttvers/.true./
      if(ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
        istrpr=0
        if(iz1old.ge.0) then
          imespr=0
        else
          kfl=ityppr
          call luiflv(kfl,ifla,iflb,iflc,ksp)
          if(iabs(ifla).eq.3) istrpr=istrpr+1
          if(iabs(iflb).eq.3) istrpr=istrpr+1
          if(ksp.ge.2) then
            imespr=0
            if(iabs(iflc).eq.3) istrpr=istrpr+1
          else
            imespr=1
          end if
        end if
        xsprta=sigasy(1,imespr,istrpr,0,0)-
     a                 sigasy(0,imespr,istrpr,0,0)
      end if
      if(iroin.eq.0) return
      iroin=1
      l1b=lstar(1)
      l1e=lende(1)
        kansig=0
        mb=l1b
        me=l1e
        assign 50 to label
        go to 901
   50   continue
        if(ignore.eq.1)  go to 69
        do 51 i=0,3
         xori(i,1)=xactl(i)
         pqb(i,1)=pqbarl(i)
         pqu(i,1)=pql(i)
   51   continue
        jdente=issn(l1e)
        npar1=itdth(3,jdente)
        npar2=npar1/100000
        npar1=mod(npar1,100000)
        if(npar2.eq.0) then
          write(lun8,*)  jdente,itdth(1,jdente),npar1,npar2
          call errex('tube:npar2=0')
        end if
        kparnt(1,1)=npar1
        kparnt(2,1)=npar2
        if(zlast(issn(l1b)).ne.0.0) then
          kansig=1
          if(ida(15).ne.0) kansig=0
          if(l1e-l1b.ne.1) kansig=0
          kparnt(3,1)=40
          xtrans=zlast(issn(l1b))/da(17)
          if(xtrans.lt.0.0) xtrans=0.0
        else
          kparnt(3,1)=0
          xtrans=1.0
        end if
        if(ida(47).eq.0) go to 69
        nmin=iofset+nrbar(kclst)+1
        nmax=iofset+nrbar(kclst)+nrmes(kclst)
        kmin=0
        m=nmin-1
   56   continue
        m=m+1
         if(m.gt.nmax) go to 69
         if(m.ge.l1b.and.m.le.l1e) go to 56
         if(m.le.kmin) go to 56
         kmin=m
         identm=issn(m)
         if(identm.le.0.or.identm.gt.ntotma) then
           write(lun8,*) m,
     a      'identm,issn(m),iofset,nrbar(kclst),nrmes(kclst)'
           write(lun8,*) identm,issn(m),iofset,nrbar(kclst),nrmes(kclst)
           call errex('tube:no particle at position m???? ')
         end if
         if(itdth(2,identm).eq.0  .and.
     a                        itdth(1,identm).ne.0  ) then
           ktdt1=iabs(itdth(1,identm))
           if(nprtcl.ge.100000) then
             call errex('tube:nprtcl>100000,itdth-storage overflow')
           end if
           mpar1=itdth(3,ktdt1)
           mpar2=mpar1/100000
           if(mpar2.eq.0) then
             write(lun8,*) m, identm,itdth(1,identm),mpar1,mpar2
             call errex('tube:mpar2=0')
           end if
           mpar1=mod(mpar1,100000)
           if(itdth(1,identm).gt.0) then
             ident2=min(ntotma,max(1,issn(min(nmax,m+1))))
             if(ktdt1.ne.itdth(1,ident2)) then
                write(lun8,*) 'kmin=',kmin
                write(lun8,*) identm,m,(itdth(i,identm),i=1,2)
                write(lun8,*) issn(m+1),m+1,
     a                             (itdth(i,issn(m+1)),i=1,2)
                write(lun8,*) ident2,(itdth(i,ident2),i=1,2)
                write(lun8,*) 'tube56: string particle without partner '
                go to 56
             end if
             kstart=m
             kend=m+1
             do 403 ik=kstart+2,nmax
              identk=issn(ik)
              if(ktdt1.ne.itdth(1,identk)) go to 404
              if(itdth(2,identk).ne.0) go to 404
              kend=ik
  403        continue
  404        continue
           else
             kstart=m
             kend=m
           end if
           kmin=kend
           iron=1
           mb=kstart
           me=kend
           assign 52 to label
           go to 901
   52      continue
           if(ignore.eq.1) go to 56
           irok=iroin+1
           if(irok.gt.mxs) then
               write(lun8,*) 'tube56:irok>mxs'
               go to 56
           end if
           do 53 i=0,3
            xori(i,irok)=xactl(i)
            pqb(i,irok)=pqbarl(i)
            pqu(i,irok)=pql(i)
   53      continue
           if(kend.gt.kstart) then
             if(l1b.eq.l1e) then
               jsingl=1
             else
               jsingl=0
             end if
           else
             if(kstart.eq.kend) then
               jsingl=0
             else
               jsingl=2
             end if
           end if
           kprta=0
           if(max(npar1,npar2).le.n1old+n2old) then
             if(max(mpar1,mpar2).le.n1old+n2old) then
               if(npar1.eq.mpar1.or.npar1.eq.mpar2.or.
     a            npar2.eq.mpar1.or.npar2.eq.mpar2) then
                 kprta=1
               end if
             end if
           end if
           if(nghbor(iron,irok,jsingl)) then
             if(zlast(issn(kstart)).ne.0.0) then
               xtrtst=zlast(issn(kstart))/da(17)
               if(xtrtst.lt.0.0) xtrtst=0.0
               xtrtst=min(xtrans,xtrtst)
             else
               xtrtst=xtrans
             end if
             if(xtrtst.le.0.0) then
               write(lun8,*) "xtrtst,xtrans,zlast(issn(l1b))",
     a                          "zlast(issn(kstart))"
               write(lun8,*) xtrtst,xtrans,zlast(issn(l1b)),
     a                          zlast(issn(kstart))
               call errex("tube:neg. xtrtst")
             end if
             if(xtrtst.eq.1.0.or.ranf(0).lt.xtrtst*xtrtst) then
 
               iroin=iroin+1
               lstar(iroin)=kstart
               lende(iroin)=kend
               kparnt(1,iroin)=mpar1
               kparnt(2,iroin)=mpar2
               if(zlast(issn(kstart)).ne.0.0) then
                 kparnt(3,iroin)=40
               else
                 kparnt(3,iroin)=0
               end if
             end if
           end if
         end if
         if(m.lt.nmax) go to 56
   69 continue
       iroout=iroin
       nsave=nlund
       call strist
       if(kansig.eq.1.and.nlund.eq.nsave) call sigkan
       call intfac(nsave)
       nlund=nsave
      return
  901 continue
          identb=issn(mb)
          idente=issn(me)
          if(qdot(0,mb).gt.1.e-20) then
           do 529 i=0,3
  529      veloc(i)=qdot(i,mb)/qdot(0,mb)
          else
           do 530 i=0,3
  530      veloc(i)=0.0
          end if
          ignore=0
          if(me.gt.mb) then
            isingl=0
          else
            isingl=1
          end if
          do 424 i=0,3
  424     xactl(i)=frfp(i,identb)
          if(isingl.eq.0) then
            do 427 i=0,3
             pql(i)=frfp(i,idente)
  427       continue
            if(pql(0).lt.0.0) pql(0)=-pql(0)
          else
            nsave=nlund
            nlund=nlund+1
            if(nlund.gt.2000)
     a              call errex('tube:nlund>2000')
            mst(1)=nlund
            mst(2)=nlund
            bex=-p(1,mb)/p(0,mb)
            bey=-p(2,mb)/p(0,mb)
            bez=-p(3,mb)/p(0,mb)
            emmb=p(0,mb)**2
            do 422 i=1,3
             emmb=emmb-p(i,mb)**2
             plund(nlund,i)=x(i,mb)+veloc(i)*
     a                       (tlast(mb)-x(0,mb))-
     b                                    frfp(i,identb)
  422       continue
            plund(nlund,4)=x(0,mb)+veloc(0)*
     a                       (tlast(mb)-x(0,mb))-
     b                                    frfp(0,identb)
            call lurobo(0.,0.,bex,bey,bez)
            pabs=sqrt(plund(nlund,1)*plund(nlund,1)+
     a                  plund(nlund,2)*plund(nlund,2)+
     b                          plund(nlund,3)*plund(nlund,3))
            thet=acos(max(-cvalu1,min(cvalu1,plund(nlund,3)/pabs)))
            if(plund(nlund,2).eq.cvalu0.and.
     a                              plund(nlund,1).eq.cvalu0) then
               phi=cvalu0
            else
               phi=atan2(plund(nlund,2),plund(nlund,1))
            end if
            if(emmb.le.0.0) then
              call errex('tube:emmb**2<0')
            else
              emmb=sqrt(emmb)
            end if
            plund(nlund,4)=0.5*emmb
            plund(nlund,3)=plund(nlund,4)*cos(thet)
            plund(nlund,1)=plund(nlund,4)*sin(thet)*cos(phi)
            plund(nlund,2)=plund(nlund,4)*sin(thet)*sin(phi)
            call lurobo(0.,0.,-bex,-bey,-bez)
            do 426 i=1,3
  426       pql(i)=plund(nlund,i)
            pql(0)=plund(nlund,4)
            nlund=nsave
          end if
          do 429 i=0,3
           ptotl(i)=0.
  429     continue
          do 430 il=mb,me
           do 431 i=0,3
  431      ptotl(i)=ptotl(i)+p(i,il)
  430     continue
          do 432 i=0,3
  432     pqbarl(i)=ptotl(i)-pql(i)
          nsave=nlund
          nlund=nlund+2
          if(nlund.gt.2000)
     a              call errex('tube:nlund>2000')
          mst(1)=nsave+1
          mst(2)=nlund
          bex=-ptotl(1)/ptotl(0)
          bey=-ptotl(2)/ptotl(0)
          bez=-ptotl(3)/ptotl(0)
          do 440 i=1,3
           plund(nsave+1,i)=pql(i)
           plund(nlund,i)=pqbarl(i)
  440     continue
          plund(nsave+1,4)=pql(0)
          plund(nlund,4)=pqbarl(0)
          call lurobo(0.,0.,bex,bey,bez)
          pqpqb=0.
          pqsq=0.
          do 433 i=1,3
           pqpqb=pqpqb+plund(nlund,i)*plund(nsave+1,i)
           pqsq=pqsq+plund(nsave+1,i)*plund(nsave+1,i)
  433     continue
          plund(nlund,4)=abs(pqpqb)/sqrt(pqsq)
          do 434 i=1,3
  434     plund(nlund,i)=pqpqb/pqsq*plund(nsave+1,i)
          call lurobo(0.,0.,-bex,-bey,-bez)
          do 446 i=1,3
           pqbarl(i)=plund(nlund,i)
  446     continue
          pqbarl(0)=plund(nlund,4)
          nlund=nsave
          if(pqpqb.ge.0.0) then
            ignore=1
            go to label
          end if
          emqsq=pql(0)**2
          emqbsq=pqbarl(0)**2
          do 435 i=1,3
           emqsq=emqsq-pql(i)**2
           emqbsq=emqbsq-pqbarl(i)**2
  435     continue
          if(abs(emqsq).gt.0.004.or.
     a                  abs(emqbsq).gt.0.004) then
            write(lun8,*)
     a            'tube:wrong quark momenta'
            write(lun8,*) 'tube mb/me=',mb,me,issn(mb),issn(me)
            write(lun8,*) 'pqbarl=',(pqbarl(i),i=0,3)
            write(lun8,*) 'pql=',(pql(i),i=0,3)
            write(lun8,*) emqsq,emqbsq
            ignore=1
          end if
          go to label
      end
      logical function nghbor(iron,irok,jsingl)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 plund,par
       common /lujets/ nlund,k(2000,2),plund(2000,5)
       common/ludat1s/mst(40),par(80)
       real*4 bex,bey,bez,thetlu,philu
       parameter (mxs=200)
       common /rop1bk/ lstar(mxs),lende(mxs),iroin,iroout
       common /rop2bk/ kparnt(3,mxs),
     a    xori(0:3,mxs),pqu(0:3,mxs),pqb(0:3,mxs)
       common /dropbk/ distnk,xsprta,kprta
      common /prinbk/ iprin
       dimension ptot(0:3),ptotn(0:3)
       dimension x1(3),x2(3)
       nghbor=.false.
       if(max(iron,irok).gt.iroin+1) then
         call errex(
     a    'nghbor:max(iron,irok).gt.iroin+1')
       else if(min(iron,irok).le.0) then
         call errex(
     a    'nghbor:min(iron,irok).le.0')
       end if
       do 401 i=0,3
  401  ptot(i)=pqu(i,irok)+pqb(i,irok)
       do 402 i=0,3
  402  ptotn(i)=pqu(i,iron)+pqb(i,iron)
       emksq=ptot(0)**2
       do 403 i=1,3
  403  emksq=emksq-ptot(i)**2
       emnsq=ptotn(0)**2
       do 404 i=1,3
  404  emnsq=emnsq-ptotn(i)**2
       if(jsingl.eq.0) then
         if(emksq.gt.emnsq) then
           jrok=irok
           jron=iron
         else
           jrok=iron
           jron=irok
           do 405 i=0,3
  405      ptot(i)=ptotn(i)
         end if
       elseif(jsingl.eq.1) then
           jrok=irok
           jron=iron
       else
           jrok=iron
           jron=irok
           do 406 i=0,3
  406      ptot(i)=ptotn(i)
       end if
       p0tot=ptot(0)
       bxnew=ptot(1)/p0tot
       bynew=ptot(2)/p0tot
       bznew=ptot(3)/p0tot
       b2=bxnew**2+bynew**2+bznew**2
       if(b2.ge.1.0) then
         return
       end if
       nsave=nlund
       nlund=nsave+4
       plund(nsave+1,4)=pqu(0,jrok)
       plund(nsave+2,4)=pqu(0,jron)*tprd
       plund(nsave+3,4)=pqb(0,jron)*tprd
       plund(nsave+4,4)=xori(0,jron)-xori(0,jrok)
       do 410 i=1,3
        plund(nsave+1,i)=pqu(i,jrok)
        plund(nsave+2,i)=pqu(i,jron)*tprd
        plund(nsave+3,i)=pqb(i,jron)*tprd
        plund(nsave+4,i)=xori(i,jron)-xori(i,jrok)
  410  continue
       mst(1)=nsave+1
       mst(2)=nsave+4
       bex=-bxnew
       bey=-bynew
       bez=-bznew
       call lurobo(0.,0.,bex,bey,bez)
       pabs=sqrt(plund(nsave+1,1)*plund(nsave+1,1)+
     a                  plund(nsave+1,2)*plund(nsave+1,2)+
     b                          plund(nsave+1,3)*plund(nsave+1,3))
       thet=acos(max(-cvalu1,min(cvalu1,plund(nsave+1,3)/pabs)))
       if(plund(nsave+1,2).eq.0.0.and.
     a                              plund(nsave+1,1).eq.0.0) then
            phi=cvalu0
       else
            phi=atan2(plund(nsave+1,2),plund(nsave+1,1))
       end if
       thetlu=-thet
       philu=-phi
       mst(1)=nsave+2
       mst(2)=nsave+4
       call lurobo(0.,philu,0.,0.,0.)
       call lurobo(thetlu,0.,0.,0.,0.)
       e2sq=0.
       e1e2=0.
       do 907 i=1,2
        x1(i)=plund(nsave+4,i)+plund(nsave+3,i)
        x2(i)=plund(nsave+2,i)-plund(nsave+3,i)
        e2sq=e2sq+x2(i)*x2(i)
        e1e2=e1e2+x1(i)*x2(i)
  907  continue
       if(e2sq.gt.1.e-10) then
         smin=max(cvalu0,min(cvalu1,-e1e2/e2sq))
       else
         smin=0.
       end if
       e2sq=0.
       do 908 i=1,2
  908  e2sq=e2sq+(x1(i)+x2(i)*smin)**2
       distnk=sqrt(e2sq)
       radtr=da(17)
       if(kprta.eq.1) then
         if(ranf(0).gt.10.*pi*radtr**2/xsprta) then
           go to 920
         end if
       else
         if(e2sq.gt.radtr**2) go to 920
       end if
       x0=plund(nsave+4,4)
       x3=plund(nsave+4,3)
       xplu0=x0+x3
       xminu0=x0-x3
       x0=plund(nsave+4,4)+plund(nsave+3,4)+plund(nsave+2,4)
       x3=plund(nsave+4,3)+plund(nsave+3,3)+plund(nsave+2,3)
       xplus=x0+x3
       xminus=x0-x3
       if(xplu0.gt.0.) then
         if(xminu0.gt.0.) then
           gamk=1./sqrt(1.-bxnew**2-bynew**2-bznew**2)
           emk=p0tot/gamk*tprd
           if(sqrt(2.)*max(xplu0,xminu0).gt.emk) go to 920
         else
           if(xplus.gt.0..and.xminus.lt.0.) go to 920
         end if
       else
         if(xminu0.gt.0.) then
           if(xplus.lt.0..and.xminus.gt.0.) go to 920
         else
           if(xplus.lt.0..or.xminus.lt.0.)go to 920
         end if
       end if
       nghbor=.true.
  920  continue
       nlund=nsave
      return
      end
      subroutine bplist(ipmx,iqmx,emtube,emtrue,atrel)
#include "amsrqmd.h"
      parameter (mxs=200)
      parameter (kbpmax=750)
      common /bplibk/ libpmx,bpli(2,kbpmax)
      common /ropblk/
     a                ivlc(2,kbpmax),lord(2,kbpmax),
     b                ipact(2,kbpmax),iqact(2,kbpmax),ipiq(kbpmax),
     c                iquark(2,kbpmax),icomb(2,kbpmax),
     d                xlcbp(2,kbpmax),xlcmx(2,kbpmax),
     e                equark(2,kbpmax),ptr(2,2,kbpmax)
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
      data  atbas / 1.84/
       ipm=ipmx
       iqm=iqmx
       libmx=min(nint((ipm+iqm)*.25*emtrue/sqrt(emqcns**2)+5.),
     a                                            kbpmax-mxs*2)
       if(ipm.gt.16) then
          write(lun8,*) ipm,'too large field strength in bplist'
          ipm=16
       end if
       if(iqm.gt.16) then
          write(lun8,*) iqm,'too large field strength in bplist'
          iqm=16
       end if
       if(ipm.lt.iqm) then
          ipmax=iqm
          iqmax=ipm
       else
          ipmax=ipm
          iqmax=iqm
       end if
       libpmx=0
       ientry=ipmax*(ipmax+1)/2+iqmax
       dndx4m=2.*prbrop(1,ientry)+prbrop(2,ientry)+2.*prbrop(3,ientry)
     a         +prbrop(4,ientry)+2.*prbrop(5,ientry)+prbrop(6,ientry)+
     b                        4.*prbrop(7,ientry)+2.*prbrop(8,ientry)+
     c                        4.*prbrop(9,ientry)+2.*prbrop(10,ientry)
       wid=dndx4m*atrel*atbas*emtube/tnsmax
       atrmax=atrel
       time=0.0
   10  continue
       tdel=-log(max(ranf(0),1.e-10))/wid
       time=time+tdel
       period=emtube/tnsmax
       if(time.gt.period) then
         go to 50
       else if(time.le.0.5*period) then
         extens=2.*time
       else
         extens=2.*(period-time)
       end if
       zrand=ranf(0)
       if(zrand.lt.extens/period) then
         z=period*zrand-0.5*extens
       else
         go to 10
       end if
       if(libpmx+1.gt.kbpmax) then
          write(lun8,*) 'libpmx=',libpmx,kbpmax
          call errex('kbpmax array too small in bplist,abort')
          go to 50
       end if
       libpmx=libpmx+1
       equark(1,libpmx)=time+z
       equark(2,libpmx)=(time-z)*equark(1,libpmx)
       if(libpmx.eq.libmx) go to 50
       go to 10
   50  continue
       if(libpmx.eq.0) return
       do 60 ibp=1,libpmx
        lord(1,ibp)=1
        do 59 jbp=1,ibp-1
         if(equark(2,ibp).gt.equark(2,jbp))then
          lord(1,ibp)=lord(1,ibp)+1
         else
          lord(1,jbp)=lord(1,jbp)+1
         end if
   59   continue
   60  continue
       do 81 ibp=1,libpmx
        lord(2,ibp)=lord(1,ibp)
   81  continue
       isum=0
       do 79 ibp=1,libpmx
        i=lord(2,ibp)
        isum=isum+i
        if(i.lt.1.or.i.gt.libpmx) then
           call errex('bplist:ord problem')
        end if
        lord(1,i)=ibp
   79  continue
       if(isum.ne.libpmx*(libpmx+1)/2) then
           call errex('bplist 82:ord problem')
       end if
       do 90 ibp=1,libpmx
        bpli(1,ibp)=equark(1,lord(1,ibp))
        bpli(2,ibp)=equark(2,lord(1,ibp))/bpli(1,ibp)
   90  continue
       taumax=sqrt(bpli(2,libpmx)*bpli(1,libpmx))
      return
      end
      function qmass(ifl)
#include "amsrqmd.h"
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
       iabifl=iabs(ifl)
       modifl=mod(iabifl,10)
       iabifl=iabifl/10
       if(iabifl.eq.0) then
         qmas1=0.0
       else if(iabifl.eq.1.or.iabifl.eq.2) then
         qmas1=emq+emqcns
       else if(iabifl.eq.3) then
         qmas1=ems+emqcns
       else if(iabifl.eq.4) then
         qmas1=1.6+emqcns
       else
         call errex('wrong input ifl into qmass')
         qmas1=0.
       end if
       if(modifl.eq.1.or.modifl.eq.2) then
         qmass=qmas1+emq+emqcns
       else if(modifl.eq.3) then
         qmass=qmas1+ems+emqcns
       else if(modifl.eq.4) then
         qmass=qmas1+1.6+emqcns
       else
         call errex('wrong input ifl into qmass')
         qmass=0.
       end if
      return
      end
      logical function reject(ips,iqs,atrel)
#include "amsrqmd.h"
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
       if(ips.lt.iqs) then
          ip=iqs
          iq=ips
       else
          ip=ips
          iq=iqs
       end if
       if(ip.gt.16) ip=16
       if(iq.gt.16) iq=16
       ientry=min(152,ip*(ip+1)/2+iq)
       dndx4=2.*prbrop(1,ientry)+prbrop(2,ientry)+2.*prbrop(3,ientry)+
     a          prbrop(4,ientry)+2.*prbrop(5,ientry)+prbrop(6,ientry)+
     b                        4.*prbrop(7,ientry)+2.*prbrop(8,ientry)+
     c                        4.*prbrop(9,ientry)+2.*prbrop(10,ientry)
       if(ranf(0).gt.atrel*dndx4/(atrmax*dndx4m)) then
         reject=.true.
       else
         reject=.false.
       end if
      return
      end
      subroutine flavor(ips,iqs,ifl)
      implicit real*8(a-h,o-z)
#include "amsrqmd.h"
      real*4 ranf,par
      real*4  atrmax,tnsmax,dndx4m,emqcns,emq,ems,prbrop
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
      common/ludat1s/mst(40),par(80)
       if(ips.lt.iqs) then
          ip=iqs
          iq=ips
          jvz=-1
       else
          ip=ips
          iq=iqs
          jvz=1
       end if
       if(ip.gt.16) ip=16
       if(iq.gt.16) iq=16
       ientry=min(152,ip*(ip+1)/2+iq)
       dndx4=2.*prbrop(1,ientry)+prbrop(2,ientry)+2.*prbrop(3,ientry)+
     a          prbrop(4,ientry)+2.*prbrop(5,ientry)+prbrop(6,ientry)+
     b                        4.*prbrop(7,ientry)+2.*prbrop(8,ientry)+
     c                        4.*prbrop(9,ientry)+2.*prbrop(10,ientry)
       pq1=2.*prbrop(1,ientry)/dndx4
       ps1=pq1+prbrop(2,ientry)/dndx4
       pq2=ps1+2.*prbrop(3,ientry)/dndx4
       ps2=pq2+prbrop(4,ientry)/dndx4
       pqq=ps2+2.*prbrop(5,ientry)/dndx4
       pqs=pqq+prbrop(6,ientry)/dndx4
       pdiq1=pqs+4.*prbrop(7,ientry)/dndx4
       pdiqs1=pdiq1+2.*prbrop(8,ientry)/dndx4
       pdiq2=pdiqs1+4.*prbrop(9,ientry)/dndx4
       pdiqs2=pdiq2+2.*prbrop(10,ientry)/dndx4
   10  continue
       zrand=ranf(0)
       if(zrand.lt.pq1) then
         ifla=-1
         if(zrand/pq1.ge.0.5) then
           ifla=-2
         end if
       else if(zrand.lt.ps1) then
         ifla=-3
       else if(zrand.lt.pq2) then
         ifla=1
         if((zrand-ps1)/(pq2-ps1).ge.0.5) then
           ifla=2
         end if
       else if(zrand.lt.ps2) then
         ifla=3
       else if(zrand.lt.pqq) then
         ifla=10
         if((zrand-ps2)/(pqq-ps2).ge.0.5) then
           ifla=20
         end if
         yrand=ranf(0)*ps1
         if(yrand.lt.0.5*pq1) then
           ifla=ifla+1
         else if(yrand.lt.pq1) then
           ifla=ifla+2
         else
           ifla=ifla+3
         end if
       else if(zrand.lt.pqs) then
         ifla=30
         yrand=ranf(0)*ps1
         if(yrand.lt.0.5*pq1) then
           ifla=ifla+1
         else if(yrand.lt.pq1) then
           ifla=ifla+2
         else
           ifla=ifla+3
         end if
       else if(zrand.lt.pdiq1) then
         if(ranf(0).ge.0.5) then
           ifla=10
         else
           ifla=20
         end if
         yrand=ranf(0)
         if(yrand.lt.0.5) then
           ifla=ifla+1
         else
           ifla=ifla+2
         end if
       else if(zrand.lt.pdiqs1) then
         ifla=30
         yrand=ranf(0)
         if(yrand.lt.0.5) then
           ifla=ifla+1
         else
           ifla=ifla+2
         end if
       else if(zrand.lt.pdiq2) then
         if(ranf(0).ge.0.5) then
           ifla=-10
         else
           ifla=-20
         end if
         yrand=ranf(0)
         if(yrand.lt.0.5) then
           ifla=ifla-1
         else
           ifla=ifla-2
         end if
       else if(zrand.lt.pdiqs2) then
         ifla=-30
         yrand=ranf(0)
         if(yrand.lt.0.5) then
           ifla=ifla-1
         else
           ifla=ifla-2
         end if
       else
         write(lun8,*) 'flavor:numerical error',zrand
         go to 10
       end if
       ifla=jvz*ifla
       iflabs=iabs(ifla)
       if(iflabs.lt.10) then
         ifl=ifla
       else
         iflb=mod(iflabs,10)
         iflc=iflabs/10
         if(iflb.eq.iflc) then
           ifl=ifla
         else if(iflc.gt.iflb) then
           if(ranf(0).gt.3.*par(4)/(1.+3.*par(4))) then
             ifl=isign(1,ifla)*(10*iflb+iflc)
           else
             ifl=ifla
           end if
         else
           if(ranf(0).lt.3.*par(4)/(1.+3.*par(4))) then
             ifl=isign(1,ifla)*(10*iflb+iflc)
           else
             ifl=ifla
           end if
         end if
       end if
      return
      end
      subroutine newlcp(ppavl,pmavl,em1t,em2t,
     a             p1pl,p1mi,p2pl,p2mi,jt)
       include 'scatter7'
#include "amsrqmd.h"
       real*8 dacof,dccof,dp1mi,dp1pl,dp2mi,dp2pl,dem1sq,dem2sq,
     a        dpmavl,dppavl
           dem1sq=em1t*em1t
           dem2sq=em2t*em2t
           dppavl=ppavl
           dpmavl=pmavl
           dacof=0.5*(dpmavl*dppavl-dem2sq+dem1sq)/dppavl
           dccof=-dpmavl*dem1sq/dppavl
           if(jt.eq.1) then
              dp1mi=dacof-dsqrt(dacof**2+dccof)
           else
              dp1mi=dacof+dsqrt(dacof**2+dccof)
           end if
           dp1pl=dem1sq/dp1mi
           dp2mi=dpmavl-dp1mi
           dp2pl=dem2sq/dp2mi
           p1pl=dp1pl
           p1mi=dp1mi
           p2pl=dp2pl
           p2mi=dp2mi
           if(abs((p1pl+p2pl)/ppavl-1.).gt.0.001.or.
     a        abs((p1mi+p2mi)/pmavl-1.).gt.0.001) then
             write(lun8,*) 'newlcp no p conservation'
             write(lun8,*) 'p1/2+/-=',p1pl,p1mi,p2pl,p2mi
             write(lun8,*) ppavl,p1pl+p2pl,pmavl,p1mi+p2mi
           end if
           if(p1pl.lt.0.0.or.p1mi.lt.0.0.or.
     a                     p2pl.lt.0.0.or.p2mi.lt.0.0) then
             write(lun8,*) 'p1/2+/-=',p1pl,p1mi,p2pl,p2mi
             call errex('newlcp:wrong lc momenta ???? ')
           end if
       return
       end
       function lchar(ifl)
#include "amsrqmd.h"
        iflabs=iabs(ifl)
        ifl1=mod(iflabs,10)
        ifl2=iflabs/10
        if(ifl1.eq.1) then
          lchar=isign(2,ifl)
        else if(ifl1.eq.2) then
          lchar=-isign(1,ifl)
        else if(ifl1.eq.3) then
          lchar=-isign(1,ifl)
        else if(ifl1.eq.4) then
          lchar=isign(2,ifl)
        else
          call errex('lchar:unknown ifl')
        end if
        if(ifl2.gt.0) then
          if(ifl2.eq.1) then
            lchar=lchar+isign(2,ifl)
          else if(ifl2.eq.2) then
            lchar=lchar-isign(1,ifl)
          else if(ifl2.eq.3) then
            lchar=lchar-isign(1,ifl)
          else if(ifl2.eq.4) then
            lchar=lchar-isign(2,ifl)
          else
            call errex('lchar:unknown ifl')
          end if
        end if
       return
       end
       function itrip(ifl)
#include "amsrqmd.h"
        if(ifl.gt.0.and.ifl.lt.10) then
          itrip=10
        else if(-ifl.gt.0.and.-ifl.lt.10) then
          itrip=1
        else if(ifl.gt.10) then
          itrip=1
        else if(-ifl.gt.10) then
          itrip=10
        else
          write(lun8,*) 'ifl=',ifl
          itrip=1/ifl
          call errex('itrip:unknown ifl as input')
          itrip=0
        end if
       return
       end
      function sigptr(ips,iqs,k)
#include "amsrqmd.h"
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
      common/ludat1s/mst(40),par(80)
       if(ips.lt.iqs) then
          ip=iqs
          iq=ips
       else
          ip=ips
          iq=iqs
       end if
       if(ip.gt.16) ip=16
       if(iq.gt.16) iq=16
       if(ip.eq.1.and.iq.eq.0) then
         sigptr=par(12)
         return
       end if
       ientry=min(152,ip*(ip+1)/2+iq)
       if(k.ne.1.and.k.ne.2) then
         call errex('sigptr:wrong k input')
         sigptr=0.0
       else
         k=k+10
         sosrc2=max(0.0,par(12)**2-4./par(71)*prbrop(11,1)**2)
         stunn2=4./par(71)*prbrop(k,ientry)**2
         sigptr=sqrt(sosrc2+stunn2)
       end if
      return
      end
      block data tubdat
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
      data emqcns,emq,ems /
     *               0.35, 0.010, 0.160
     * /
       data (prbrop( 1,im),im=1,152)   /
     *   .139,   .256,   .406,   .591,   .809,   .809,  1.060,  1.345,
     *  1.664,  1.345,  1.664,  2.016,  2.402,  2.822,  2.016,  2.402,
     *  2.822,  3.275,  3.761,  4.281,  2.822,  3.275,  3.761,  4.281,
     *  4.835,  5.422,  6.043,  3.761,  4.281,  4.835,  5.422,  6.043,
     *  6.697,  7.385,  8.106,  4.835,  5.422,  6.043,  6.697,  7.385,
     *  8.106,  8.860,  9.647, 10.466,  6.043,  6.697,  7.385,  8.106,
     *  8.860,  9.647, 10.466, 11.319, 12.204, 13.122,  7.385,  8.106,
     *  8.860,  9.647, 10.466, 11.319, 12.204, 13.122, 14.071, 15.053,
     * 16.066,  8.860,  9.647, 10.466, 11.319, 12.204, 13.122, 14.071,
     * 15.053, 16.066, 17.111, 18.186, 19.293, 10.466, 11.319, 12.204,
     * 13.122, 14.071, 15.053, 16.066, 17.111, 18.186, 19.293, 20.430,
     * 21.598, 22.795, 12.204, 13.122, 14.071, 15.053, 16.066, 17.111,
     * 18.186, 19.293, 20.430, 21.598, 22.795, 24.022, 25.278, 26.564,
     * 14.071, 15.053, 16.066, 17.111, 18.186, 19.293, 20.430, 21.598,
     * 22.795, 24.022, 25.278, 26.564, 27.878, 29.220, 30.591, 16.066,
     * 17.111, 18.186, 19.293, 20.430, 21.598, 22.795, 24.022, 25.278,
     * 26.564, 27.878, 29.220, 30.591, 31.989, 33.415, 34.868, 18.186,
     * 19.293, 20.430, 21.598, 22.795, 24.022, 25.278, 26.564, 27.878,
     * 29.220, 30.591, 31.989, 33.415, 34.868, 36.347, 37.853, 39.385
     * /
       data (prbrop( 2,im),im=1,152)   /
     *   .041,   .105,   .199,   .325,   .482,   .482,   .672,   .893,
     *  1.147,   .893,  1.147,  1.434,  1.753,  2.105,  1.434,  1.753,
     *  2.105,  2.490,  2.908,  3.359,  2.105,  2.490,  2.908,  3.359,
     *  3.843,  4.360,  4.911,  2.908,  3.359,  3.843,  4.360,  4.911,
     *  5.494,  6.110,  6.760,  3.843,  4.360,  4.911,  5.494,  6.110,
     *  6.760,  7.442,  8.157,  8.905,  4.911,  5.494,  6.110,  6.760,
     *  7.442,  8.157,  8.905,  9.686, 10.499, 11.344,  6.110,  6.760,
     *  7.442,  8.157,  8.905,  9.686, 10.499, 11.344, 12.221, 13.130,
     * 14.071,  7.442,  8.157,  8.905,  9.686, 10.499, 11.344, 12.221,
     * 13.130, 14.071, 15.043, 16.046, 17.080,  8.905,  9.686, 10.499,
     * 11.344, 12.221, 13.130, 14.071, 15.043, 16.046, 17.080, 18.144,
     * 19.239, 20.364, 10.499, 11.344, 12.221, 13.130, 14.071, 15.043,
     * 16.046, 17.080, 18.144, 19.239, 20.364, 21.519, 22.702, 23.916,
     * 12.221, 13.130, 14.071, 15.043, 16.046, 17.080, 18.144, 19.239,
     * 20.364, 21.519, 22.702, 23.916, 25.157, 26.427, 27.726, 14.071,
     * 15.043, 16.046, 17.080, 18.144, 19.239, 20.364, 21.519, 22.702,
     * 23.915, 25.157, 26.427, 27.726, 29.052, 30.406, 31.787, 16.046,
     * 17.080, 18.144, 19.239, 20.364, 21.519, 22.702, 23.915, 25.157,
     * 26.427, 27.726, 29.052, 30.406, 31.787, 33.195, 34.629, 36.090
     * /
       data (prbrop( 3,im),im=1,152)   /
     *   .000,   .256,   .000,   .406,   .809,   .000,   .591,  1.060,
     *  1.664,   .000,   .809,  1.345,  2.016,  2.822,   .000,  1.060,
     *  1.664,  2.402,  3.275,  4.281,   .000,  1.345,  2.016,  2.822,
     *  3.761,  4.835,  6.043,   .000,  1.664,  2.402,  3.275,  4.281,
     *  5.422,  6.697,  8.106,   .000,  2.016,  2.822,  3.761,  4.835,
     *  6.043,  7.385,  8.860, 10.466,   .000,  2.402,  3.275,  4.281,
     *  5.422,  6.697,  8.106,  9.647, 11.319, 13.122,   .000,  2.822,
     *  3.761,  4.835,  6.043,  7.385,  8.860, 10.466, 12.204, 14.071,
     * 16.066,   .000,  3.275,  4.281,  5.422,  6.697,  8.106,  9.647,
     * 11.319, 13.122, 15.053, 17.111, 19.293,   .000,  3.761,  4.835,
     *  6.043,  7.385,  8.860, 10.466, 12.204, 14.071, 16.066, 18.186,
     * 20.430, 22.795,   .000,  4.281,  5.422,  6.697,  8.106,  9.647,
     * 11.319, 13.122, 15.053, 17.111, 19.293, 21.598, 24.022, 26.564,
     *   .000,  4.835,  6.043,  7.385,  8.860, 10.466, 12.204, 14.071,
     * 16.066, 18.186, 20.430, 22.795, 25.278, 27.878, 30.591,   .000,
     *  5.422,  6.697,  8.106,  9.647, 11.319, 13.122, 15.053, 17.111,
     * 19.293, 21.598, 24.022, 26.564, 29.220, 31.989, 34.868,   .000,
     *  6.043,  7.385,  8.860, 10.466, 12.204, 14.071, 16.066, 18.186,
     * 20.430, 22.795, 25.278, 27.878, 30.591, 33.415, 36.347, 39.385
     * /
       data (prbrop( 4,im),im=1,152)   /
     *   .000,   .105,   .000,   .199,   .482,   .000,   .325,   .672,
     *  1.147,   .000,   .482,   .893,  1.434,  2.105,   .000,   .672,
     *  1.147,  1.753,  2.490,  3.359,   .000,   .893,  1.434,  2.105,
     *  2.908,  3.843,  4.911,   .000,  1.147,  1.753,  2.490,  3.359,
     *  4.360,  5.494,  6.760,   .000,  1.434,  2.105,  2.908,  3.843,
     *  4.911,  6.110,  7.442,  8.905,   .000,  1.753,  2.490,  3.359,
     *  4.360,  5.494,  6.760,  8.157,  9.686, 11.344,   .000,  2.105,
     *  2.908,  3.843,  4.911,  6.110,  7.442,  8.905, 10.499, 12.221,
     * 14.071,   .000,  2.490,  3.359,  4.360,  5.494,  6.760,  8.157,
     *  9.686, 11.344, 13.130, 15.043, 17.080,   .000,  2.908,  3.843,
     *  4.911,  6.110,  7.442,  8.905, 10.499, 12.221, 14.071, 16.046,
     * 18.144, 20.364,   .000,  3.359,  4.360,  5.494,  6.760,  8.157,
     *  9.686, 11.344, 13.130, 15.043, 17.080, 19.239, 21.519, 23.916,
     *   .000,  3.843,  4.911,  6.110,  7.442,  8.905, 10.499, 12.221,
     * 14.071, 16.046, 18.144, 20.364, 22.702, 25.157, 27.726,   .000,
     *  4.360,  5.494,  6.760,  8.157,  9.686, 11.344, 13.130, 15.043,
     * 17.080, 19.239, 21.519, 23.916, 26.427, 29.052, 31.787,   .000,
     *  4.911,  6.110,  7.442,  8.905, 10.499, 12.221, 14.071, 16.046,
     * 18.144, 20.364, 22.703, 25.157, 27.726, 30.406, 33.195, 36.090
     * /
       data (prbrop( 5,im),im=1,152)   /
     *   .016,   .000,   .112,   .008,   .000,   .278,   .056,   .008,
     *   .000,   .512,   .139,   .056,   .008,   .000,   .813,   .256,
     *   .139,   .056,   .008,   .000,  1.181,   .406,   .256,   .139,
     *   .056,   .008,   .000,  1.617,   .591,   .406,   .256,   .139,
     *   .056,   .008,   .000,  2.120,   .809,   .591,   .406,   .256,
     *   .139,   .056,   .008,   .000,  2.690,  1.060,   .809,   .591,
     *   .406,   .256,   .139,   .056,   .008,   .000,  3.328,  1.345,
     *  1.060,   .809,   .591,   .406,   .256,   .139,   .056,   .008,
     *   .000,  4.032,  1.664,  1.345,  1.060,   .809,   .591,   .406,
     *   .256,   .139,   .056,   .008,   .000,  4.804,  2.016,  1.664,
     *  1.345,  1.060,   .809,   .591,   .406,   .256,   .139,   .056,
     *   .008,   .000,  5.643,  2.402,  2.016,  1.664,  1.345,  1.060,
     *   .809,   .591,   .406,   .256,   .139,   .056,   .008,   .000,
     *  6.549,  2.822,  2.402,  2.016,  1.664,  1.345,  1.060,   .809,
     *   .591,   .406,   .256,   .139,   .056,   .008,   .000,  7.523,
     *  3.275,  2.822,  2.402,  2.016,  1.664,  1.345,  1.060,   .809,
     *   .591,   .406,   .256,   .139,   .056,   .008,   .000,  8.563,
     *  3.761,  3.275,  2.822,  2.402,  2.016,  1.664,  1.345,  1.060,
     *   .809,   .591,   .406,   .256,   .139,   .056,   .008,   .000
     * /
       data (prbrop( 6,im),im=1,152)   /
     * .00014, .00000, .01476, .00007, .00000, .08190, .00738, .00007,
     * .00000, .20912, .04095, .00738, .00007, .00000, .39798, .10456,
     * .04095, .00738, .00007, .00000, .64947, .19899, .10456, .04095,
     * .00738, .00007, .00000, .96434, .32474, .19899, .10456, .04095,
     * .00738, .00007, .00000,1.34316, .48217, .32474, .19899, .10456,
     * .04095, .00738, .00007, .00000,1.78642, .67158, .48217, .32474,
     * .19899, .10456, .04095, .00738, .00007, .00000,2.29448, .89321,
     * .67158, .48217, .32474, .19899, .10456, .04095, .00738, .00007,
     * .00000,2.86769,1.14724, .89321, .67158, .48217, .32474, .19899,
     * .10456, .04095, .00738, .00007, .00000,3.50629,1.43384,1.14724,
     * .89321, .67158, .48217, .32474, .19899, .10456, .04095, .00738,
     * .00007, .00000,4.21050,1.75314,1.43384,1.14724, .89321, .67158,
     * .48217, .32474, .19899, .10456, .04095, .00738, .00007, .00000,
     *4.98052,2.10525,1.75314,1.43384,1.14724, .89321, .67158, .48217,
     * .32474, .19899, .10456, .04095, .00738, .00007, .00000,5.81643,
     *2.49026,2.10525,1.75314,1.43384,1.14724, .89321, .67158, .48217,
     * .32474, .19899, .10456, .04095, .00738, .00007, .00000,6.71842,
     *2.90822,2.49026,2.10525,1.75315,1.43385,1.14724, .89321, .67158,
     * .48217, .32474, .19899, .10456, .04095, .00738, .00007, .00000
     * /
       data (prbrop( 7,im),im=1,152)   /
     *  152*0.0
     * /
       data (prbrop( 8,im),im=1,152)   /
     *  152*0.0
     * /
       data (prbrop( 9,im),im=1,152)   /
     *  152*0.0
     * /
       data (prbrop(10,im),im=1,152)   /
     *  152*0.0
     * /
       data (prbrop(11,im),im=1,152)   /
     *   .126,   .153,   .176,   .196,   .215,   .215,   .232,   .247,
     *   .262,   .247,   .262,   .276,   .290,   .303,   .276,   .290,
     *   .303,   .315,   .327,   .338,   .303,   .315,   .327,   .338,
     *   .349,   .360,   .370,   .327,   .338,   .349,   .360,   .370,
     *   .380,   .390,   .400,   .349,   .360,   .370,   .380,   .390,
     *   .400,   .409,   .418,   .427,   .370,   .380,   .390,   .400,
     *   .409,   .418,   .427,   .435,   .443,   .452,   .390,   .400,
     *   .409,   .418,   .427,   .435,   .443,   .452,   .459,   .467,
     *   .475,   .409,   .418,   .427,   .435,   .443,   .452,   .459,
     *   .467,   .475,   .482,   .489,   .496,   .427,   .435,   .443,
     *   .452,   .459,   .467,   .475,   .482,   .489,   .496,   .502,
     *   .509,   .515,   .443,   .452,   .459,   .467,   .475,   .482,
     *   .489,   .496,   .502,   .509,   .515,   .521,   .527,   .533,
     *   .459,   .467,   .475,   .482,   .489,   .496,   .502,   .509,
     *   .515,   .521,   .527,   .533,   .539,   .544,   .550,   .475,
     *   .482,   .489,   .496,   .502,   .509,   .515,   .521,   .527,
     *   .533,   .539,   .544,   .550,   .555,   .560,   .565,   .489,
     *   .496,   .502,   .509,   .515,   .521,   .527,   .533,   .539,
     *   .544,   .550,   .555,   .560,   .565,   .570,   .575,   .579
     * /
       data (prbrop(12,im),im=1,152)   /
     * -1.000,   .153, -1.000,   .176,   .215, -1.000,   .196,   .232,
     *   .262, -1.000,   .215,   .247,   .276,   .303, -1.000,   .232,
     *   .262,   .290,   .315,   .338, -1.000,   .247,   .276,   .303,
     *   .327,   .349,   .370, -1.000,   .262,   .290,   .315,   .338,
     *   .360,   .380,   .400, -1.000,   .276,   .303,   .327,   .349,
     *   .370,   .390,   .409,   .427, -1.000,   .290,   .315,   .338,
     *   .360,   .380,   .400,   .418,   .435,   .452, -1.000,   .303,
     *   .327,   .349,   .370,   .390,   .409,   .427,   .443,   .459,
     *   .475, -1.000,   .315,   .338,   .360,   .380,   .400,   .418,
     *   .435,   .452,   .467,   .482,   .496, -1.000,   .327,   .349,
     *   .370,   .390,   .409,   .427,   .443,   .459,   .475,   .489,
     *   .502,   .515, -1.000,   .338,   .360,   .380,   .400,   .418,
     *   .435,   .452,   .467,   .482,   .496,   .509,   .521,   .533,
     * -1.000,   .349,   .370,   .390,   .409,   .427,   .443,   .459,
     *   .475,   .489,   .502,   .515,   .527,   .539,   .550, -1.000,
     *   .360,   .380,   .400,   .418,   .435,   .452,   .467,   .482,
     *   .496,   .509,   .521,   .533,   .544,   .555,   .565, -1.000,
     *   .370,   .390,   .409,   .427,   .443,   .459,   .475,   .489,
     *   .502,   .515,   .527,   .539,   .550,   .560,   .570,   .579
     * /
       data (prbrop(13,im),im=1,152)   /
     *   .269,   .839,   .604,  1.152,  2.149,  1.075,  1.793,  2.625,
     *  4.063,  1.679,  2.587,  3.570,  4.697,  6.581,  2.418,  3.534,
     *  4.674,  5.946,  7.371,  9.704,  3.291,  4.632,  5.936,  7.356,
     *  8.923, 10.647, 13.429,  4.298,  5.882,  7.355,  8.926, 10.637,
     * 12.501, 14.524, 17.752,  5.439,  7.282,  8.930, 10.655, 12.511,
     * 14.516, 16.677, 18.996, 22.669,  6.714,  8.833, 10.662, 12.543,
     * 14.546, 16.692, 18.990, 21.445, 24.057, 28.168,  8.122, 10.534,
     * 12.548, 14.588, 16.739, 19.026, 21.462, 24.052, 26.797, 29.697,
     * 34.239,  9.663, 12.383, 14.588, 16.789, 19.088, 21.517, 24.091,
     * 26.815, 29.691, 32.720, 35.901, 40.868, 11.334, 14.380, 16.780,
     * 19.144, 21.592, 24.163, 26.874, 29.732, 32.739, 35.896, 39.202,
     * 42.657, 48.037, 13.136, 16.522, 19.123, 21.651, 24.249, 26.962,
     * 29.809, 32.799, 35.936, 39.220, 42.650, 46.227, 49.947, 55.732,
     * 15.065, 18.808, 21.613, 24.308, 27.056, 29.911, 32.894, 36.016,
     * 39.280, 42.689, 46.243, 49.940, 53.778, 57.756, 63.934, 17.120,
     * 21.235, 24.250, 27.113, 30.011, 33.007, 36.125, 39.378, 42.769,
     * 46.302, 49.977, 53.792, 57.747, 61.839, 66.066, 72.628, 19.299,
     * 23.802, 27.031, 30.063, 33.112, 36.248, 39.500, 42.882, 46.400,
     * 50.055, 53.850, 57.782, 61.851, 66.056, 70.393, 74.861, 81.794
     * /
      data (prbrop(14,im),im=1,152)   /
     *   152*0.0
     *            /
      end
      subroutine intfac(nsave)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       real*4 plund
       common /lujets/ nlund,k(2000,2),plund(2000,5)
       parameter (mxs=200)
       common /rop1bk/ lstar(mxs),lende(mxs),iroin,iroout
       logical manip
       logical issers
       common /rop3bk/manip(mxs)
       dimension xvold(0:3),ptot(0:3)
       if(nlund.eq.nsave) go to 92
       if(mod(nlund-nsave,2).eq.1) then
         call errex('intfac:wrong nlund/nsave')
       end if
       iposi=(nlund-nsave)/2
       ievntn=ievntn+1
       do 18 iroa=1,iroin
        if(manip(iroa)) then
          do 17  ik=lstar(iroa),lende(iroa)
           deltx0=decay(ik)-x(0,ik)
           if(qdot(0,ik).eq.0) then
           else
             do 6 i=0,3
    6        x(i,ik)=x(i,ik)+qdot(i,ik)/qdot(0,ik)*deltx0
           end if
   17     continue
        end if
   18  continue
       if(ida(25).eq.1) then
         if(switch(23)) then
           ken=itripl
         else
           ken=kdt
         end if
         jkill=0
         do 5 iroa=1,iroin
          if(manip(iroa)) then
            jkill=jkill+lende(iroa)-lstar(iroa)+1
          end if
    5    continue
         write(lun15,661) irun,ken,4,0,jkill,0,0,0
       end if
  661  format(1x,i3,1x,i3,1x,i1,1x,i5,1x,i3,1x,i2,1x,i8,1x,i8)
       do 8 iroa=1,iroin
        if(manip(iroa)) then
          do 7  ik=lstar(iroa),lende(iroa)
           idntk=issn(ik)
           call transl(-1,ityp(ik),npidec(ik),kf)
           if(ida(25).eq.1) then
             write(lun15,662)  9999,kf,(p(i,ik),i=0,3),
     a             em(ik),0,idntk,x(0,ik),
     b                               x(1,ik),x(2,ik),x(3,ik)
           end if
           if(ida(42).eq.1) then
             write(lun7)
     &              -9999,issn(ik),kf,
     &              x(0,ik),x(1,ik),x(2,ik),x(3,ik),
     &              p(0,ik),p(1,ik),p(2,ik),p(3,ik),em(ik),
     &              0.0,0,0
           end if
           if(ida(38).eq.1.or.ida(38).eq.2.or.
     a                 ida(38).eq.5.or.ida(38).eq.7) then
             if(ida(38).eq.1.or.ida(38).eq.2) then
               jeng=1
             else
               jeng=0
             end if
             emik=em(ik)
             if(issers(jeng,ida(38),ityp(ik),npidec(ik),emik))then
               write(lun13,888) idntk, 0,ityp(ik),npidec(ik),
     a                          p(0,ik),(-p(i,ik),i=1,3)
               write(lun13,889) (stork(idntk,i),i=1,5)
               write(lun13,890) (kstor(idntk,i),i=1,7)
               write(lun13,888) idntk,-3,ityp(ik),npidec(ik),
     a                          p(0,ik),(-p(i,ik),i=1,3)
               write(lun13,889) (stork(idntk,i),i=1,5)
               write(lun13,890) (kstor(idntk,i),i=1,7)
             end if
           end if
  888      format(1x,4(i7,1x),1x,4(f7.3,1x))
  889      format(1x,5(f7.3,1x))
  890      format(1x,5(i7,1x),2(i4,1x))
    7     continue
        end if
    8  continue
       if(ida(25).eq.1)
     a write(lun15,661) irun,ken,5,0,iposi,0,0,0
       iro=0
       irosto=0
       do 10 iroa=1,iroin
        if(manip(iroa)) then
          iro=iroa
          go to 12
        end if
   10  continue
   12  continue
       if(iro.eq.0) then
         call errex('intfac:iro=0')
       end if
       ntotm=ntotma+1
       lnew=0
       ksta=lstar(iro)
       ke=lende(iro)
       il=ksta-1
       do 80 nl=nsave+1,nsave+iposi
        il=il+1
        if(min(ntotm,il).gt.ke) then
          irosto=iro
          do 20 iroa=iro+1,iroin
           if(manip(iroa)) then
             iro=iroa
             go to 22
           end if
   20     continue
   22     continue
          if(irosto.eq.iro) then
            ke=ntotm
            if(nrmes(kclst)+nrbar(kclst).lt.iclusz(kclst)) then
              il=iofset+nrmes(kclst)+nrbar(kclst)+1
            else
              call errex('intfac:no free space in arrays left')
            end if
            if(lnew.eq.0) then
              lnew=1
              lstan=il
            end if
          else
            ksta=lstar(iro)
            ke=lende(iro)
            il=ksta
          end if
        end if
        if(ke.eq.ntotm) then
          npion=npion+1
          nrmes(kclst)=nrmes(kclst)+1
          if(nrmes(kclst)+nrbar(kclst).gt.iclusz(kclst)) then
            call errex('intfac:rqmd array overflow')
          end if
          nprtcl=nprtcl+1
          if(nprtcl.gt.ntotma) then
            call errex('intfac:nprtcl>ntotma, abort')
          end if
          issn(il)=nprtcl
          lendn=il
        end if
        do 71 i=1,3
   71   p(i,il)=plund(nl,i)
        p(0,il)=plund(nl,4)
        em(il)=plund(nl,5)
        kf=k(nl,2)
        kmulth=iabs(kf)/100
        kf=isign(1,kf)*mod(iabs(kf),100)
        eml=em(il)
        call oldnew(0,ityp(il),npidec(il),eml,kmulth,kf)
        nlu=nl+iposi
        do 72 i=1,3
   72   x(i,il)=plund(nlu,i)
        x(0,il)=plund(nlu,4)
        decay(il)=x(0,il)
        do 73 i=0,3
   73   qdot(i,il)=0.0
        lastcl(il)=0
        identl=issn(il)
        ylast(identl)=0.5*log((p(0,il)+p(3,il))/(p(0,il)-p(3,il)))
        zlast(identl)=x(3,il)
        if(ida(25).eq.1) then
  662     format(1x,i4,1x,i4,1x,f8.3,1x,2(f7.3,1x),f8.3,1x,
     a               f7.3,i3,1x,i8,1x,f8.3,2(1x,f7.3),1x,f8.3)
             write(lun15,662) ityp(il),npidec(il),(p(i,il),i=0,3),
     a              em(il),0,identl,x(0,il),
     b                               x(1,il),x(2,il),x(3,il)
        end if
        if(ida(42).eq.1) then
          write(lun7)
     &         ityp(il),issn(il),npidec(il),
     &         x(0,il),x(1,il),x(2,il),x(3,il),
     &         p(0,il),p(1,il),p(2,il),p(3,il),em(il),
     &         0.0,0,0
        end if
        if(ida(38).eq.3.or.ida(38).eq.4) then
          if(iposi.eq.1) then
            kstor(identl,1)=1
          else
            kstor(identl,1)=4
          end if
          do 203 i=1,4
  203     stork(identl,i)=x(i-1,il)
          do 303 i=6,8
  303     stork(identl,i)=p(i-5,il)
        else if(ida(38).gt.0.and.ida(38).le.2) then
            if((ida(38).eq.1.and.(ityp(il).eq.14
     a                          .or.iabs(npidec(il)).eq.28.or.
     b                                iabs(npidec(il)).eq.29)).or.
     c       (ida(38).eq.2.and.
     d        (ityp(il).eq.13.or.ityp(il).eq.15
     e         .or.(iabs(npidec(il)).ge.43.and.iabs(npidec(il)).le.47)
     f                 .or.iabs(npidec(il)).eq.57
     g                         .or.iabs(npidec(il)).ge.65))
     h                                                        ) then
                 idntl=issn(il)
                 do 201 i=1,7
  201            stork(idntl,i)=0.0
                 do 202 i=3,7
  202            kstor(idntl,i)=0
                 kstor(idntl,1)=0
                 kstor(idntl,2)=9999
            end if
        else if(ida(38).eq.1.or.ida(38).eq.2.or.
     a                 ida(38).eq.5.or.ida(38).eq.7) then
          if(ida(38).eq.1.or.ida(38).eq.2) then
            jeng=1
          else
            jeng=0
          end if
          emil=em(il)
          if(issers(jeng,ida(38),ityp(il),npidec(il),emil))then
            idntl=issn(il)
            do 204 i=1,7
  204       stork(idntl,i)=0.0
            do 205 i=3,7
  205       kstor(idntl,i)=0
            kstor(idntl,1)=0
            kstor(idntl,2)=9999
          end if
        end if
   80  continue
       if(ke.ne.ntotm) then
         ilstar=il
         do 81 il=ilstar+1,lende(iro)
          ityp(il)=-9999
          do 82 i=0,3
   82     qdot(i,il)=0.0
   81    continue
         do 90 iroa=iro+1,iroin
          if(manip(iroa)) then
            do 85 il=lstar(iroa),lende(iroa)
             ityp(il)=-9999
             do 94 i=0,3
   94        qdot(i,il)=0.0
   85       continue
          end if
   90    continue
       end if
       if(lnew.eq.1) then
         if(iroout.eq.mxs) then
           call errex('intfac:mxs-arrays too small')
         else
           iroout=iroout+1
           lstar(iroout)=lstan
           lende(iroout)=lendn
           manip(iroout)=.true.
         end if
       end if
   92  continue
       do 91 iro=2,iroin
        if(.not.manip(iro)) lstar(iro)=0
   91  continue
      return
      end
      subroutine fndq(kl1,ifle1,iqtun,istat)
#include "amsrqmd.h"
              istat=0
              call luiflv(kl1,ifla1,iflb1,iflc1,ksp)
              if(iflc1.eq.0) then
                if(ifla1+iflb1.eq.0) then
                  ifle1=-iqtun
                else
                  if(ifla1.eq.iqtun) then
                    ifle1=iflb1
                  else if(iflb1.eq.iqtun) then
                    ifle1=ifla1
                  else
                    istat=-1
                  end if
                end if
              else
                itry=0
  441           continue
                call bele(ifla1,iflb1,kl1)
                if(iabs(iqtun).lt.10) then
                  iflt1=ifla1
                  iflt2=iflb1
                else
                  iflt2=ifla1
                  iflt1=iflb1
                end if
                if(iqtun.eq.iflt1) then
                  ifle1=iflt2
                else if(itry.le.50) then
                  itry=itry+1
                  go to 441
                else
                  istat=-1
                end if
              end if
      return
      end
      function barwgh(para11,ifla,iflb)
#include "amsrqmd.h"
       if(para11.ge.0.25) then
         call errex('rewrite barwgh source code')
       end if
       barwgh=1.0
       ifl1=iabs(ifla)
       ifl2=iabs(iflb)
       if(ifl1.gt.10) then
         ifl3=ifl1/10
         ifl1=mod(ifl1,10)
       else if(ifl2.gt.10) then
         ifl3=ifl2/10
         ifl1=mod(ifl2,10)
       else
         return
       end if
       iequal=0
       if(ifl1.eq.ifl2) iequal=1
       if(ifl1.eq.ifl3) iequal=iequal+1
       if(ifl2.eq.ifl3) iequal=iequal+1
       if(iequal.eq.0) then
         prbwgh=1.0
       else if(iequal.eq.1) then
         prbwgh=0.83333*(1.+2.*para11)/(1.+para11)
       else if(iequal.eq.3) then
         prbwgh=2.*para11
         if(ifl1.eq.3) prbwgh=2.0*prbwgh
       end if
       barwgh=barwgh*prbwgh
      return
      end
      function kqqret(ifl1,ifl2)
#include "amsrqmd.h"
       ifla=iabs(ifl1)
       iflb=iabs(ifl2)
       if(int(ranf(0)*4.).ne.0) then
         kqqret=10*max(iflb,ifla)+min(iflb,ifla)
       else
         kqqret=10*min(iflb,ifla)+max(iflb,ifla)
       end if
       kqqret=isign(1,ifl1)*kqqret
      return
      end
      function getmas(mltp,kf,igfix,emmax)
       include 'scatter7'
#include "amsrqmd.h"
       real*4 getms4,emmx4
       emmx4=emmax
       getmas=getms4(mltp,kf,igfix,emmx4)
      return
      end
      function getms4(mltp,kf,igfix,emmax)
#include "amsrqmd.h"
       mtry=0
       kfa=iabs(kf)
       if(kfa.gt.100) then
         minw=kfa/100
         kfa=mod(kfa,100)
       else
         minw=mltp
       end if
   10  mtry=mtry+1
       if(mtry.gt.50) then
         getms4=-1000.0
         return
       end if
       if(minw.eq.0) then
         em=ulmass(1,kfa)
       else
         maxw=minw
         if(iabs(kfa).lt.40) then
           idn=idnmes(kfa)
           kmltdm=kresm(1,igfix,idn,minw,maxw,kfa,em)
         else
           idn=idnbar(kfa)
           kmltdm=kresb(igfix,idn,minw,maxw,kfa,em)
         end if
       end if
       if(emmax.gt.0.0) then
         if(em.ge.emmax) go to 10
       end if
       getms4=em
      return
      end
      subroutine sigkan
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       real*4 plund
       common /lujets/ nlund,k(2000,2),plund(2000,5)
       parameter (mxs=200)
       common /rop1bk/ lstar(mxs),lende(mxs),iroin,iroout
       logical manip
       common /rop3bk/manip(mxs)
       if(lstar(1).eq.0) call errex('sigkan abort, input')
       if(lende(1)-lstar(1).gt.1) return
       if(nlund+2.gt.2000) call errex('sigkan:array problem')
       lsta=lstar(1)
       le=lende(1)
       k(nlund+1,2)=124
       eminv=0.0
       do 22 im=1,4
        i=mod(im,4)
        plund(nlund+1,im)=p(i,lsta)+p(i,le)
        eminv=eminv+isign(1,1-2*i)*plund(nlund+1,im)**2
        if(qdot(0,lsta).eq.0.0) then
          if(abs(decay(lsta)-x(0,lsta)).gt.1.e-4) then
            call errex('sigkan:qdot=0,decay.ne.x(0)')
          end if
          qd0ls=1.0
        else
          qd0ls=qdot(0,lsta)
        end if
        if(qdot(0,le).eq.0.0) then
          if(abs(decay(le)-x(0,le)).gt.1.e-4) then
            call errex('sigkan:qdot=0,decay.ne.x(0)')
          end if
          qd0le=1.0
        else
          qd0le=qdot(0,le)
        end if
        plund(nlund+2,im)=0.5*(x(i,lsta)+
     a                         qdot(i,lsta)/qd0ls*
     b                            (decay(lsta)-x(0,lsta))+
     c                         x(i,le)+
     d                         qdot(i,le)/qd0le*
     e                            (decay(le)-x(0,le)))
   22  continue
       plund(nlund+1,5)=sqrt(eminv)
       if(plund(nlund+1,5).gt.1.0) return
       manip(1)=.true.
       nlund=nlund+2
      return
      end
CPAT,RQMDEC   .
      subroutine rqmdec(ind)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       include 'storbig'
       real*4 prtgam
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
       parameter (mxs=200)
       common /rop1bk/ lstar(mxs),lende(mxs),iroin,iroout
       common /ioutbk/i1,i2,i3,i4,nop,ichanl,iexpn1,iexpn2
     a                 ,idcid1,idcid2,iqsq
       common /routbk/xold1(0:3),xold2(0:3),srt,bxtot,bytot,bztot
       logical jets
            if(decay(ind).eq.x(0,ind).and.qdot(0,ind).eq.0.) then
                delts=tlstev-time
            else if(qdot(0,ind).gt.1.e-20) then
                delts=max(cvalu0,
     a            (decay(ind)-x(0,ind)+qdot(0,ind)*dt)/qdot(0,ind) )
            else
                write(lun8,*) 'is this particle decay reasonable? '
                write(lun8,*) 'qdot,decay,dt,x0',issn(ind)
                write(lun8,*) qdot(0,ind),decay(ind),dt,x(0,ind)
                delts=dt
            end if
            dtprop=delts-dt
            if(-dtprop.lt.-0.001*dt) then
               write(lun8,*) 'dtprop>0 in rqmdec ??? ',delts,dt,dtprop,k
            end if
            tnexev=time+delts
            if(tnexev+1.e-2.lt.tlstev.and.ida(23).eq.0) then
               write(lun8,*) 'tlstev.ge.tnexev in rqmdec??? ',tlstev,tne
               write(lun8,*) irun,itripl,kdt,kclst
               write(lun8,*) 'x=',(x(i,ind),i=0,3)
               write(lun8,*)'ident=',issn(ind),ityp(ind),npidec(ind)
               write(lun8,*) 'qdot=',(qdot(i,ind),i=0,3)
               write(lun8,*) 'decay=',decay(ind),'delts=',delts
               tnexev=tlstev
            end if
            tlstev=tnexev
            ntag=0
            iqcnvt=0
            tact=decay(ind)
            ident=issn(ind)
            ityp1=ityp(ind)
            npid1=npidec(ind)
            em1=em(ind)
           if(itdth(4,ident).ne.0) then
             itdti=itdth(4,ident)
             itdtia=iabs(itdti)
             itdtj=itdth(4,itdtia)
             itdtja=iabs(itdtj)
             if(itdtja.eq.ident) then
               identj=itdtia
               identi=ident
               ili=ind
               ilj=0
               do 301 il=iofset+1,iofset+nrbar(kclst)+nrmes(kclst)
                identl=issn(il)
                if(identl.eq.identj) then
                  ilj=il
                  go to 302
                end if
  301          continue
  302          continue
               if(ilj.eq.0)
     a         call errex('rqmdec:no ilj found, abort')
               ityp2=ityp(ilj)
               npid2=npidec(ilj)
               em2=ityp(ilj)
               i1=ili
               i2=ilj
               call sveifo(i1,1)
               call sveifo(i2,2)
               call oldnew(1,ityp1,npid1,em1,kmult1,ltyp1)
               call oldnew(1,ityp2,npid2,em2,kmult2,ltyp2)
               if(ltyp1*ltyp2.ge.0) then
                 call errex('rqmdec: bbar-problem with ingoing types')
               else if(ltyp1.gt.0) then
                 ibry1=1
               else
                 ibry1=-1
               end if
               if(itdti.lt.0) then
                 ind=ilj
                 ident=identj
               end if
               idento=identi+identj-ident
               ilo=ili+ilj-ind
               if(ida(7).eq.1) then
                 if(itdth(2,ident).ne.0) then
                   call ofshel(3,ind,ident)
                 end if
                 if(itdth(2,idento).ne.0) then
                   call ofshel(3,ilo,idento)
                 end if
               end if
               srt=0.0
               do 304 i=0,3
                xold1(i)=x(i,ili)+qdot(i,ili)*dtprop
                xold2(i)=x(i,ilj)+qdot(i,ilj)*dtprop
  304          continue
               do 303 i=0,3
                p(i,ind)=p(i,ind)+p(i,ilo)
                srt=srt+isign(1,3-2*(i+1))*p(i,ind)**2
                p(i,ilo)=0.0
  303          continue
               nop=1
               iqsq=0
               ichanl=2
               ievntn=ievntn+1
               srt=sqrt(srt)
               bxtot=p(1,ind)/p(0,ind)
               bytot=p(2,ind)/p(0,ind)
               bztot=p(3,ind)/p(0,ind)
               iexpn1=0
               iexpn2=0
               call xtupdt
               ida19=ida(19)
               ic=-3
               if(ibry1.lt.0) then
                 call antibb(ic,ityp1,ityp2,npid1,npid2,em1,em2,srt)
                 ityp(ind)=ityp1
                 npidec(ind)=npid1
               else
                 call antibb(ic,ityp2,ityp1,npid2,npid1,em2,em1,srt)
                 ityp(ind)=ityp2
                 npidec(ind)=npid2
               end if
               if(ic.eq.0) call errex('rqmdec: abort after antibb call')
               ida(19)=ida19
               em(ind)=srt
               tlast(ind)=decay(ind)
               em(ilo)=0.0
               ityp(ilo)=-9999
               npidec(ilo)=0
               decay(ilo)=1.e+35
               call output(2)
               call propag(ilo,-2,0)
               ikenz=5
             else
               ikenz=6
             end if
           else if(itdth(2,ident).eq.0.and.
     a                                itdth(1,ident).ne.0) then
             nmin=iofset+1
             nmax=iofset+nrbar(kclst)+nrmes(kclst)
             ident1=min(ntotma,max(1,issn(max(nmin,ind-1))))
             ident2=min(ntotma,max(1,issn(min(nmax,ind+1))))
             ltdt1=itdth(1,ident)
             if(ltdt1.ne.itdth(1,ident1).and.
     a                   (ltdt1.ne.itdth(1,ident2).or.
     a                    ident2.eq.ident)) then
                if(itdth(1,ident).ge.0) then
                  write(lun8,*) ident,ind,(itdth(i,ident),i=1,2)
                  write(lun8,*) ident1,(itdth(i,ident1),i=1,2)
                  write(lun8,*) ident2,(itdth(i,ident2),i=1,2)
                  call errex(
     a                 'rqmdec: string particle without partner? ')
                end if
                lstart=ind
                lend=ind
             else
                lstart=0
                do 401 l=ind,1,-1
                  identl=issn(l)
                  if(ltdt1.ne.itdth(1,identl)) go to 402
                lstart=l
  401           continue
  402           continue
                lend=0
                do 403 l=lstart,iofset+nrbar(kclst)+nrmes(kclst)
                 identl=issn(l)
                 if(identl.le.0.or.identl.gt.nprtcl) go to 404
                 if(ltdt1.ne.itdth(1,identl)) go to 404
                 lend=l
  403           continue
  404           continue
                if(lend.le.lstart) call errex('rqmdec:lend.le.lstart')
                if(lstart.le.iofset+nrbar(kclst))
     a                         call errex('rqmdec:lstart too small')
                if(ltdt1.ne.issn(lstart))
     a                    call errex('rqmdec:ltdt1.ne.ident(lstart)')
              end if
              lstar(1)=lstart
              lende(1)=lend
              iroin=1
              iroout=1
              call tube
              do 407 iro=1,iroout
              if(lstar(iro).eq.0) go to 407
              do 405 l=lstar(iro),lende(iro)
               identl=issn(l)
               nclcnt(identl)=0
               if(itdth(2,identl).ne.0  )
     a          call errex('rqmdec:itdth(2).ne.0 for string hadron' )
               itdth(1,identl)=0
               itdth(3,identl)=0
               itdth(4,identl)=0
               itdth(5,identl)=0
               do 406 i=0,3
  406          frfp(i,identl)=0.0
               if(decay(l).eq.1.e+35) then
                 write(lun8,*) issn(l),ityp(l),npidec(l),
     a                      iro,(x(i,l),i=0,3)
                 call errex('rqmdec: decay(l)=infinity')
               end if
               delttr=decay(l)-x(0,l)
               if(qdot(0,l).gt.0.) then
                 do 400 i=0,3
                  x(i,l)=x(i,l)+qdot(i,l)/qdot(0,l)*delttr
  400            continue
               else
                 if(abs(delttr).gt.1.e-4) then
                   write(lun8,*) issn(l),decay(l),delttr
                   call errex('rqmdec:delttr.ne.0,qdot(0)=0')
                 end if
               end if
               tlast(l)=decay(l)
               startt=x(0,l)
               call dupdat(l,startt)
               tform=tlast(l)
               zform=x(3,l)
               zlast(identl)=
     a              zform-(pnorm(0)*tform-pnorm(3)*zform)*pnorm(3)
               if(ida(15).ne.0) then
                   ichbig(l)=3
                   do 408 i=0,3
  408              qdot(i,l)=0.0
               end if
               call propag(l,-2,0)
  405         continue
  407         continue
              return
            else if(itdth(2,ident).ne.0.and.
     a           tdtg(ident).eq.decay(ind)) then
              ikenz=6
            else if(jets(ityp1,npid1,em1,0)) then
              ikenz=5
            else if(ityp1.ge.12.and.ityp1.le.15) then
              ikenz=4
            else if(ityp1.ge.3.and.ityp1.le.6) then
              ikenz=1
            else if(ityp1.ge.10.and.ityp1.le.11) then
              ikenz=2
            else if(ityp1.ge.7.and.ityp1.le.9.and.
     a            npid1.gt.0) then
              ikenz=3
            else if(ityp1.ge.85.and.ityp1.le.97)then
              ikenz=7
            else if(ityp1.eq.98)then
              ikenz=5
            else if(ityp1.eq.99)then
              if(-npid1.ge.61.and.-npid1.le.64) then
                 ikenz=8
              else
                 ikenz=4
              endif
            else
              write(lun8,*) 'wrong ityp for decay in rqmdec'
              write(lun8,*)'iwhat=d  ind=',ind,'decay=',decay(ind)
              write(lun8,*) 'ident,itdth'
              write(lun8,*)  ident,(itdth(j,ident),j=1,4)
              write(lun8,*) 'ind,ityp,npidec',ind,ityp(ind),npidec(ind),
     a                                              issn(ind)
              decay(ind)=1.e+35
              return
            end if
            if(ida(7).eq.1.and.ikenz.ne.5) then
              if(itdth(2,ident).ne.0  ) then
                 call ofshel(3,ind,ident)
              end if
            end if
            if(ida(15).eq.2) then
              if((ikenz.ge.1.and.ikenz.le.4).or.
     a            (ikenz.ge.7.and.ikenz.le.8)) then
                if(ident.le.n1old+n2old) then
                  if(qdot(0,ind).gt.0.) then
                    delttr=decay(ind)-x(0,ind)
                    zdeca=x(3,ind)+qdot(3,ind)/qdot(0,ind)*delttr
                  else
                    zdeca=x(3,ind)
                  end if
                  if(zdeca.lt.zmnta.or.zdeca.gt.zmxpr) ikenz=9
                else
                  zdeca=0.0
                  ikenz=9
                end if
              end if
              if(itdth(2,ident).ne.0.and.
     a            tdtg(ident).lt.decay(ind)) tlast(ind)=tdtg(ident)
            end if
            idm=1
            call sveifo(ind,idm)
            lmes=0
            if(ikenz.eq.0) then
            else if(ida(1).eq.1.and.((ikenz.eq.3.and.npidec(ind).eq.2)
     a              .or.(ikenz.eq.1.and.
     b                       npidec(ind).eq.1))) then
              decay(ind)=1.e+35
              return
            else if(ikenz.eq.1) then
              call resdec(ind,lmes,ntag)
            else if(ikenz.eq.2) then
              call resdec(ind,lmes,ntag)
            else if(ikenz.eq.3) then
              call lddec(ind,ntag)
            else if(ikenz.eq.4) then
              call lddec(ind,ntag)
            else if(ikenz.eq.5) then
              call jetdec(ind,ntag)
            else if(ikenz.eq.6) then
              itdth(1,ident)=0
              itdth(2,ident)=0
              itdth(3,ident)=0
              itdth(4,ident)=0
              tlast(ind)=decay(ind)
              if(qdot(0,ind).gt.0.) then
                delttr=decay(ind)-x(0,ind)
                do 421 i=0,3
  421           x(i,ind)=x(i,ind)+qdot(i,ind)/qdot(0,ind)*delttr
              end if
              startt=x(0,ind)
              call dupdat(ind,startt)
              if(ida(15).ne.0.and.ident.gt.n1old+n2old) then
                if(decay(ind).lt.1.e+30) then
                  delttr=decay(ind)-x(0,ind)
                  do 422 i=0,3
                   x(i,ind)=x(i,ind)+p(i,ind)/p(0,ind)*delttr
  422             continue
                end if
                ichbig(ind)=3
                do 423 i=0,3
  423           qdot(i,ind)=0.0
              end if
              call propag(ind,-1,0)
            else if(ikenz.eq.7) then
              call resdec(ind,lmes,ntag)
            else if(ikenz.eq.8) then
              call resdec(ind,lmes,ntag)
            else if(ikenz.eq.9) then
              itdth(1,ident)=0
              itdth(2,ident)=0
              itdth(3,ident)=0
              itdth(4,ident)=0
              ichbig(ind)=3
              if(qdot(0,ind).gt.0.) then
                delttr=tlast(ind)-x(0,ind)
                do 523 i=0,3
  523           x(i,ind)=x(i,ind)+qdot(i,ind)/qdot(0,ind)*delttr
              end if
              do 524 i=0,3
  524         qdot(i,ind)=0.0
              call propag(ind,-1,0)
            end if
            if(ierror.eq.1) return
            if(ntag.lt.0)then
             xbldel=xbldel+1.
             return
            else
              if(ikenz.eq.1) then
                idcntd=idcntd+1
              else if(ikenz.eq.2) then
                idcntn=idcntn+1
              else if(ikenz.eq.3) then
                idcntr=idcntr+1
              end if
            end if
            if(ikenz.eq.5) then
            else if
     a      (itdth(2,ident).ne.0.and.tdtg(ident).gt.tact) then
              iexpn=itdth(2,ident)
              call newcqe(ityp(ind),npidec(ind),iexpn,0)
              itdth(2,ident)=iexpn
            else
              itdth(1,ident)=0
              itdth(2,ident)=0
              itdth(3,ident)=0
              itdth(4,ident)=0
            end if
      return
      end
CPAT,RSTALL   .
      subroutine pribd(dtpr)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       common/dnsblk/jokall,timpri,bdens,hdens,edens,t11,t22,t33
     a                   ,tb11,tb22,tb33
     b                   ,tp11,tp22,tp33,hdcent
     c                   ,rtsq(2,-5:5),drzsq(2,-5:5)
     d                   ,rvel(2,-5:5),yldet(2,-5:5)
       dimension xact(0:3)
        if(ida(36).eq.3) then
          ietmin=-3
          ietmax=3
          do iet=ietmin,ietmax
           do 19 j=1,2
            rtsq(j,iet)=0.0
            drzsq(j,iet)=0.0
            yldet(j,iet)=0.0
            rvel(j,iet)=0.0
   19      continue
          end do
          iofs=0
          do 31 kcl=1,nrclst
           do 30 il=iofs+1,iofs+nrbar(kcl)+nrmes(kcl)
            if(ityp(il).eq.-9999) go to 30
            itpil=ityp(il)
            npil=npidec(il)
            emil=em(il)
            call oldnew(1,itpil,npil,emil,kmult,ltyp)
            jact=0
            if(kmult.eq.0) then
              if(iabs(ltyp).eq.17.or.ltyp.eq.23) then
                jact=2
               end if
            end if
            if(ltyp.gt.0.and.ltyp.le.120) then
              if(kspin(ltyp).ge.2) jact=1
            end if
            if(jact.eq.0) go to 30
            do 39 i=0,3
   39       xact(i)=x(i,il)+qdot(i,il)*dtprop
            if(tlast(il).gt.xact(0)) go to 30
            identl=issn(il)
            if(identl.le.n1old+n2old.and.nclcnt(il).eq.0)go to 30
            if(tdtg(identl).gt.xact(0).and.
     a                     itdth(2,identl).ne.0) go to 30
            til=xact(0)
            zil=xact(3)
            uetil=til+zil
            detil=til-zil
            if(uetil.lt.0.0.or.detil.lt.0.0) go to 30
            if(detil.lt.0.0001) go to 30
            etail=0.5*log(uetil/detil)
            ieta=sign(1.0,etail)*nint(abs(etail))
            if(ieta.lt.ietmin.or.ieta.gt.ietmax) go to 30
            yil=0.5*log((p(0,il)+p(3,il))/(p(0,il)-p(3,il)))
            vrt=0.0
            rtil=0.0
            do 38 i=1,2
             vrt=vrt+p(i,il)*xact(i)
             rtil=rtil+xact(i)**2
   38       continue
            if(rtil.lt.0.01) then
              vrt=0.0
            else
              vrt=vrt/sqrt(rtil)/p(0,il)*cosh(yil)
            end if
            tauil=sqrt(til**2-zil**2)
            zetail=tauil*sinh(yil)
            yldet(jact,ieta)=yldet(jact,ieta)+1.0
            rtsq(jact,ieta)=rtsq(jact,ieta)+xact(1)**2+xact(2)**2
            drzsq(jact,ieta)=drzsq(jact,ieta)+
     a                       (xact(3)-zetail)**2
            rvel(jact,ieta)=rvel(jact,ieta)+vrt
   30      continue
           iofs=iofs+iclusz(kcl)
   31     continue
          do iet=ietmin,ietmax
           do 29 j=1,2
            if(yldet(j,iet).eq.0.0) go to 29
            rtsq(j,iet)=rtsq(j,iet)/yldet(j,iet)
            drzsq(j,iet)=drzsq(j,iet)/yldet(j,iet)
            rvel(j,iet)=rvel(j,iet)/yldet(j,iet)
   29      continue
          end do
          do iet=ietmin,ietmax
           do 28 j=1,2
            rtsq(j,iet)=sqrt(rtsq(j,iet))
            drzsq(j,iet)=sqrt(drzsq(j,iet))
   28      continue
          end do
   43  format(1x,f4.1,2x,7(f8.3,1x))
          write(lun13,43)  timpri,(yldet(1,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(yldet(2,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(rtsq(1,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(rtsq(2,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(drzsq(1,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(drzsq(2,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(rvel(1,iet),iet=ietmin,ietmax)
          write(lun13,43)  timpri,(rvel(2,iet),iet=ietmin,ietmax)
        else if(ida(36).eq.2) then
                 delty=0.7
                 iptpi=0
                 ptpi=0.
                 iptba=0
                 idba=0
                 inba=0
                 iba=0
                 ptba=0.
                 poteng=0.0
                 sumpx=0.0
                 sumetd=0.0
                 avdent=0.0
                 avden3=0.0
                 avden2=0.0
                 avvil=0.0
                 iofs=0
                 do 21 kcl=1,nrclst
                 do 20 il=iofs+1,iofs+nrbar(kcl)+nrmes(kcl)
                   if(ityp(il).eq.-9999) go to 20
                   yil=0.5*log((p(0,il)+p(3,il))/(p(0,il)-p(3,il)))
                   if(ityp(il).ge.7.and.ityp(il).le.9) then
                     if(yil.lt.delty.and.yil.gt.-delty) then
                        iptpi=iptpi+1
                        ptpi=ptpi+sqrt(p(1,il)**2+p(2,il)**2)
                     end if
                   else if(kcl.ne.kclst) then
                     if(yil.lt.delty.and.yil.gt.-delty) then
                        if(ityp(il).eq.1.or.ityp(il).eq.2) then
                          iptba=iptba+1
                          ptba=ptba+sqrt(p(1,il)**2+p(2,il)**2)
                        end if
                        inba=inba+1
                     end if
                   else if(il.le.iofs+nrbar(kcl)) then
                     if(yil.lt.delty.and.yil.gt.-delty) then
                        vil=vquasi(il,dens2,dens3,denst)
                        avvil=avvil+vil
                        pvec2=p(1,il)**2+p(2,il)**2+p(3,il)**2
                        poteng=poteng+p(0,il)-sqrt(em(il)**2+pvec2)
                        avden3=avden3+dens3
                        avden2=avden2+dens2
                        avdent=avdent+denst
                        if(ityp(il).eq.1.or.ityp(il).eq.2) then
                          iptba=iptba+1
                          ptba=ptba+sqrt(p(1,il)**2+p(2,il)**2)
                        end if
                        identl=issn(il)
                        if(ityp(il).le.2.and.(itdth(2,identl).eq.0
     a                    .or.(itdth(2,identl).ne.0.and.
     b                    tdtg(identl).lt.x(0,il)+qdot(0,il)*dtpr))
     b                                                          ) then
                          inba=inba+1
                        else
     a                  if(ityp(il).le.6.and.iabs(npidec(il)).le.1
     b                                  .and.(itdth(2,identl).eq.0
     a                    .or.(itdth(2,identl).ne.0.and.
     d                    tdtg(identl).lt.x(0,il)+qdot(0,il)*dtpr))
     b                                                          ) then
                          idba=idba+1
                        else
                          iba=iba+1
                        end if
                     end if
                   end if
                   if(yil.lt.delty.and.yil.gt.-delty) then
                     if(abs(p(1,il)).lt.1.e-6) then
                     else
                       tangle=abs(p(2,il)/p(1,il))
                       if(atan(tangle).lt.0.25*pi) then
                         sgn=1.0
                       else
                         sgn=-1.0
                       end if
                       sumetd=sumetd+p(0,il)*sgn
                     end if
                   end if
                   if(yil.gt.0.0) then
                     sumpx=sumpx+p(1,il)
                   else
                     sumpx=sumpx-p(1,il)
                   end if
   20            continue
                 iofs=iofs+iclusz(kcl)
   21            continue
                 itba=inba+idba+iba
                 if(itba.gt.0) then
                    if(iptba.gt.0) ptba=ptba/iptba
                    poteng=poteng/itba
                    avdent=avdent/itba
                    avden3=avden3/itba
                    avden2=avden2/itba
                    avvil=avvil/itba
                 end if
         call dnscal(0,i1,i2,dens1)
   33  format(1x,f4.1,2x,14(f6.3,1x),1x,f5.2,2x,f8.3,1x,f8.3)
         write(lun13,33)  timpri,
     a        bdens,hdens,edens,t11,t22,t33,
     b          tb11,tb22,tb33,
     d           ptba,poteng,
     c          tp11,tp22,tp33,
     e          hdcent,sumpx,sumetd
         hdcent=0.0
         tp11=0.0
         tp22=0.0
         tp33=0.0
       end if
      return
      end
      subroutine dnscal(iswd,i2,i1,dens)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
       common/dnsblk/jokall,timpri,bdens,hdens,edens,t11,t22,t33
     a                   ,tb11,tb22,tb33
     b                   ,tp11,tp22,tp33,hdcent
     c                   ,rtsq(2,-5:5),drzsq(2,-5:5)
     d                   ,rvel(2,-5:5),yldet(2,-5:5)
       dimension qlk(0:3),plk(0:3),xind(0:3)
       data ds2 /2.165/
      dens=0.
      bdens=0.0
      hdens=0.0
      edens=0.0
      t11=0.0
      t22=0.0
      t33=0.0
      tb11=0.0
      tb22=0.0
      tb33=0.0
      ds2n=(pi*ds2)**1.5
      nrb=nrbar(kclst)
      nrm=nrmes(kclst)
      if(iswd.eq.0) then
        do 8 i=1,3
    8   xind(i)=0.0
        xind(0)=timpri
        i1=0
        i2=0
        nrt=nrb+nrm
      else
        do 9 i=0,3
    9   xind(i)=x(i,i2)+qdot(i,i2)*dtprop
        nrt=nrb
      end if
      do 30 l=1,nrt
       il=iofset+l
       identl=issn(il)
       if(iswd.eq.0) then
         itypl=ityp(il)
         if(itypl.eq.-9999) go to 30
         npidl=npidec(il)
         eml=em(il)
         call oldnew(1,itypl,npidl,eml,kmultl,ltypl)
         ltypa=iabs(ltypl)
         if(kspin(ltypa).ge.2) then
           if(ltypl.gt.0) then
             idb=1
           else
             idb=-1
           end if
         else
           idb=0
         end if
       else
         if(il.eq.i2) go to 30
         if(il.eq.i1) go to 30
         if(ityp(il).gt.11.or.
     a      (ityp(il).ge.7.and.ityp(il).le.9)) go to 30
       end if
       if(qdot(0,il).le.0.) then
         dtpr=0.
       else
         dtpr=(xind(0)-x(0,il))/qdot(0,il)
       end if
       do 11 i=0,3
        qlk(i)=-x(i,il)-qdot(i,il)*dtpr+xind(i)
   11  continue
       xbet=0.
       xsq=0.
       bsq=0.
       do 12 i=1,3
       if(qdot(0,il).gt.0.) then
         plk(i)=qdot(i,il)/qdot(0,il)
       else
         plk(i)=0.
       end if
       xbet=xbet+qlk(i)*plk(i)
       xsq=xsq+qlk(i)*qlk(i)
       bsq=bsq+plk(i)*plk(i)
   12  continue
       if(bsq.gt.1.e-3) then
         xparsq=xbet*xbet/bsq
       else
         xparsq=0.
       end if
       if(bsq.lt.0.0.or.bsq.ge.1.) then
         write(lun8,*) 'bsq out of range in dnscal',bsq
         go to 30
       end if
       gamil=1./sqrt(1.-bsq)
       xtrsq=xsq-xparsq
       if(sqrt(max(cvalu0,xsq)).gt.3.) go to 30
       densil=gamil*exp(-(xtrsq+gamil*gamil*xparsq)/ds2)/ds2n
       dens=dens+densil
       if(iswd.eq.0) then
         identl=issn(il)
         if(tlast(il).gt.xind(0)) go to 30
         if(tdtg(identl).gt.xind(0).and.itdth(2,identl).ne.0) go to 30
         if(issn(il).le.n1old+n2old.and.nclcnt(il).eq.0) go to 30
         hdens=hdens+densil
         edens=edens+p(0,il)*densil
         t11=t11+p(1,il)**2*densil/p(0,il)
         t22=t22+p(2,il)**2*densil/p(0,il)
         t33=t33+p(3,il)**2*densil/p(0,il)
         if(idb.ne.0) then
           bdens=bdens+densil*idb
           tb11=tb11+p(1,il)**2*densil/p(0,il)*idb
           tb22=tb22+p(2,il)**2*densil/p(0,il)*idb
           tb33=tb33+p(3,il)**2*densil/p(0,il)*idb
         end if
       end if
   30 continue
      dens=dens/rho0
      return
      end
      subroutine rstall
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      real*4 plund
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      nlund=0
      do 1000 l=1,ntotma
       do  999 i=0,3
        x(i,l)=0.0
        p(i,l)=0.0
        qdot(i,l)=0.0
        itdth(i+1,l)=0
  999   continue
        itdth(5,l)=0
        tlast(l)=0.0
        tdtg(l)=0.0
        em(l)=0.0
        denspp(l)=0.0
       do  998 i=0,3
        frfp(i,l)=0.0
  998   continue
        ityp(l)=0
        lastcl(l)=0
        kstor(l,1)=0
        ichbig(l)=0
        npidec(l)=0
        nclcnt(l)=0
        issn(l)=0
        idud(1,l)=0
        decay(l)=0.0
        datsto(l)=0.0
        ylast(l)=0.0
        zlast(l)=0.0
 1000 continue
      write(lun8,*) 'reset completed'
      return
      end
CPAT,SCATTR   .
      subroutine scattr(srt,p0tot,p1tot,p2tot,p3tot,enlrge,
     &                    p0i1,px1,py1,pz1, p0i2,px2,py2,pz2, em1,em2,
     &                     pi1sqo,pi2sqo,dtau1,dtau2,prbhd1,prbhd2,
     &                     dtceff,ityp1,npid1,ityp2,npid2,iqsq,
     &                    icltyp,iexpn1,iexpn2,itagdl,itag1,itag2,
     &                    i1,i2,i3,i4,idcid1,idcid2,isubr1,isubr2,
     &                        kdiffr,nchain,ichanl,ibbban,nop,absrb)
        include 'scatter7'
#include "amsrqmd.h"
        include 'sigmasx'
        include 'partblk7'
      real*4 plund,par,thetlu,philu
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
        common /ierdum/ierr
       common /prpsto/ kmulo1,ltypo1,kmulo2,ltypo2
      common /seabk/kchain,iofcha,isea(18),psea(0:3,18),isoan,iqqst,
     a              emsmb
      real*4 angmxv,angeff
      real*4 tboard
      common /su3mix/ angmxv,angeff
      logical  jets,string
      logical anpla
      dimension sigin(mxchan)
      logical absrb
      data  nchan /0/
      dimension pv(10,5),rord(10),ue(3),be(3),pl(10,5),dpar(8)
      data dpar /2.,5.,15.,60.,250.,1500.,1.2e+4,1.2e+5  /
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version rqmd 2.4  -- 30-jan-98'/
      data pronam/'module: s c a t t r'/
      data ttvers/.true./
      if (ttvers) then
        write(lun8,*)'- version number report -------------'
        write(lun8,*)pronam
        write(lun8,*)vernum
        write(lun8,*)'-------'
        ttvers=.false.
      end if
      dtau1=0.0
      dtau2=0.0
      emda=0.0
      emdb=0.0
       iabsrb=0
            kdiffr=0
            nchain=0
            kchain=0
            nop=2
            isubr1=-isubr1
            isubr2=-isubr2
            itagdl=0
            bx=(p1tot)/(p0tot)
            by=(p2tot)/(p0tot)
            bz=(p3tot)/(p0tot)
            gam=1./sqrt(1.-bx**2-by**2-bz**2)
            b2=max(cvalu7,bx**2+by**2+bz**2)
            pb=bx*px1+by*py1+bz*pz1
            gg=(gam-1.)*pb/b2-gam*p0i1
            pzr=gg*bz+pz1
            pxr=gg*bx+px1
            pyr=gg*by+py1
            pr=sqrt(pxr*pxr+pyr*pyr+pzr*pzr)
            if(pr.lt.1.e-3) then
                ichanl=-1
                return
            end if
            x01=x(0,i1) +qdot(0,i1)*dtprop
            x02=x(0,i2) +qdot(0,i2)*dtprop
            x0=x01-x02
            x1=x(1,i1)-x(1,i2) +(qdot(1,i1)-qdot(1,i2))*dtprop
            x2=x(2,i1)-x(2,i2) +(qdot(2,i1)-qdot(2,i2))*dtprop
            x3=x(3,i1)-x(3,i2) +(qdot(3,i1)-qdot(3,i2))*dtprop
            ident1=issn(i1)
            ident2=issn(i2)
            iexpn1=itdth(2,ident1)
            iexpn2=itdth(2,ident2)
            itag1=0
            itag2=0
            if(iexpn1.ne.0.and.tdtg(ident1).gt.x01) itag1=1
            if(iexpn2.ne.0.and.tdtg(ident2).gt.x02) itag2=1
       cost=pzr/pr
       iswave=0
       ibbban=0
       intmod=0
       itdt31=itdth(3,ident1)
       itdt32=itdth(3,ident2)
       icltp=min(icltyp,maxtyp+1)
       call cross1(1,srt,pr,icltp,sig,em1,em2,
     a                                ityp1,ityp2,npid1,npid2)
       xb=bx*x1+by*x2+bz*x3
       gg=(gam-1.)*xb/b2-gam*x0
       x1=gg*bx+x1
       x2=gg*by+x2
       x3=gg*bz+x3
       qsqcms=x1*x1+x2*x2+x3*x3
       sigqsq=10.*pi*qsqcms
       if(enlrge.gt.0.0) sigqsq=sigqsq/enlrge
       if(iqsq.eq.1) then
         sigqsq=0.0
       end if
       if(sigqsq.gt.sig) then
         ichanl=0
         return
       end if
       emsmb=em1+em2
       isoan=0
       iqqst=0
       if(icltyp.le.3.and.itag1.eq.0.and.itag2.eq.0) then
         ipin=0
       else
         ipin=2
       end if
       call oldnew(1,ityp1,npid1,em1,kmult1,ltyp1)
       call oldnew(1,ityp2,npid2,em2,kmult2,ltyp2)
       if(kmult1.gt.0) then
         if(kmulo1.ne.kmult1)
     a   call errex('scattr:kmulo1.ne.kmult1')
       else if(kmult1.lt.0) then
         if(kmulo1.eq.0)
     a   call errex('scattr:kmulo1.eq.0')
       else
         if(kmulo1.ne.0)  then
           write(lun8,*) ityp(i1),npidec(i1),em(i1)
           write(lun8,*) ityp1,npid1,em1,kmult1,ltypo1,kmulo1
         end if
         if(kmulo1.ne.0)
     a   call errex('scattr:kmulo1.ne.0')
       end if
       if(kmult2.gt.0) then
         if(kmulo2.ne.kmult2)
     a   call errex('scattr:kmulo2.ne.kmult2')
       else if(kmult2.lt.0) then
         if(kmulo2.eq.0)
     a   call errex('scattr:kmulo2.eq.0')
       else
         if(kmulo2.ne.0)
     a   call errex('scattr:kmulo2.ne.0')
       end if
       if(iabs(ltyp1).ne.iabs(ltypo1).or.
     a                     iabs(ltyp2).ne.iabs(ltypo2)) then
         write(lun8,*) ltyp1,ltypo1,ltyp2,ltypo2
         call errex('scattr:ltyp.ne.ltypo')
       end if
       call contnt(ltyp1,ltyp2,istra1,istra2,
     a                         imeso1,imeso2,ibry1,ibry2,iann)
       if(iann.gt.0) then
         if(iann.gt.4) call errex('scattr:unexpected iann')
         icltp=min(icltyp,maxtyp+1)
         call cross1(3,srt,pr,icltp,sigbas,em1,em2,
     a                                       ityp1,ityp2,npid1,npid2)
         if(ranf(0).gt.sigbas/sig) then
           absrb=.true.
           sigqsq=sigqsq*(sig-sigbas)/sig
           sig=sig-sigbas
         else
           sigqsq=sigqsq*sigbas/sig
           sig=sigbas
         end if
       end if
       if(icltyp.gt.maxtyp) then
         if(icltyp.lt.4754.or.icltyp.gt.4950) then
           write(lun8,*)' invalid type in  scattr  : ',icltyp
           call errex( 'fatal error')
         end if
       end if
       idecis=1
            ityp1o=ityp1
            ityp2o=ityp2
            npid1o=npid1
            npid2o=npid2
            em1old=em1
            em2old=em2
            pxrold=pxr
            pyrold=pyr
            pzrold=pzr
       jesant=0
       ievntn=ievntn+1
       lastcl(i1)=ievntn
       lastcl(i2)=ievntn
       s=srt
       if(iqsq.eq.1) then
         sigel=sig
       else if(absrb) then
         sigel=0.0
       else if(n1.eq.1.and.iz1.eq.1.and.n2.eq.1.and.ncollt.eq.0
     a                                       .and.ncoll.eq.0) then
         if(sig.lt.0.1) then
           write(lun8,*) 'sig seems to be 0????? ',sig
         else
           if(irun.le.10) write(lun8,*)
     b              'warning:hd. ncln. coll.,only inel. scattering'
         end if
         call cross1(0,srt,pr,icltyp,sigel,em1, em2,
     a                               ityp1,ityp2,npid1,npid2)
         sigqsq=sigqsq*(sig-sigel)/sig
         sig=sig-sigel
         sigel=0.0
       else
         icltp=min(icltyp,maxtyp+1)
         call cross1(0,srt,pr,icltp,sigel,em1, em2,
     a                               ityp1,ityp2,npid1,npid2)
       end if
       if(.not.absrb.and.(itag1.eq.1.or.itag2.eq.1)) then
         redcqf=1.0
         if(itag1.eq.1) redcqf=redcqf*redcqi(imeso1,iexpn1)
         if(itag2.eq.1) redcqf=redcqf*redcqi(imeso2,iexpn2)
         if(ranf(0).gt.redcqf) then
           ichanl=0
           return
         end if
       end if
       if(ranf(0).gt.sigel/sig) goto 3000
 2000  continue
       ichanl=1
       if(switch(15)) return
       if(itag1.ne.0.or.itag2.ne.0) then
         ichanl=-1
         return
       end if
       if(srt.le.em1+em2) then
         ichanl=-1
         return
       end if
       if((ityp1.ge.3.and.ityp1.le.6).or.
     a         (ityp1.ge.10.and.ityp1.le.11)) then
         if(npid1.lt.-100) npid1=-mod(-npid1,100)
       end if
       if((ityp2.ge.3.and.ityp2.le.6).or.
     a         (ityp2.ge.10.and.ityp2.le.11)) then
         if(npid2.lt.-100) npid2=-mod(-npid2,100)
       end if
       goto 5000
 3000  continue
       nscop=0
       call cross2(srt,pr,em1,em2,npid1,npid2,icltyp,
     &               istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     &            ityp1,ityp2,sig,sigel,sigin,icnum,nscop,nonstr)
       if(icnum.le.1) then
         ichanl=0
         return
       end if
       xssum=0.
       do 5 ic=1,icnum-1
        if(sigin(ic).lt.0.) then
          write(lun8,*)  i1,i2,ityp(i1),ityp(i2),ic,sigin(ic)
          call errex('negative cross section in channel ic')
        end if
        xssum=xssum+sigin(ic)
    5  continue
       sum=0.0
       rand=ranf(0)
       do 10 i=2,icnum
        ic=i-1
        sum=sum+sigin(ic)
        if(rand.le.sum/xssum) goto 3100
   10  continue
       ichanl=0
       goto 2000
 3100  continue
       if(absrb.and.ic.gt.2) then
         absrb=.false.
       end if
       ilmass=0
       ikmass=0
       immass=0
       board=tboard(ityp1,ityp2)
  302  continue
       cmeff=srt
       if(absrb) then
       else if((switch(15)).or.(icltyp.gt.3.and.ic.eq.2)
     a                                .or.srt.gt.board) then
          if(.not.switch(6)) then
            deltp0=delten(1,p0tot,p1tot,p2tot,p3tot,em1,em2,cmeff)
            if(cmeff.gt.srt) cmeff=srt
          end if
          ic=2
          call lmass(kdiffr,itag1,itag2,iexpn1,iexpn2,nchain,ipin,
     a      sig,sigel,srt,pr,em1,em2,cmeff,ityp1,ityp2,iann,
     b      kmulo1,kmulo2,istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     c      ltyp1,ltyp2,iflvch,idecis,npid1,npid2,ic,pi1sqo,pi2sqo)
          ilmass=1
       else if(icltyp.le.3.and.(itag1.eq.1.or.itag2.eq.1).and.
     a                                                ic.le.nscop) then
          ic=2
          call lmass(kdiffr,itag1,itag2,iexpn1,iexpn2,nchain,ipin,
     a      sig,sigel,srt,pr,em1,em2,cmeff,ityp1,ityp2,iann,
     b      kmulo1,kmulo2,istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     c      ltyp1,ltyp2,iflvch,idecis,npid1,npid2,ic,pi1sqo,pi2sqo)
          ilmass=1
       else if(ic.gt.nonstr) then
         if(imeso1.eq.1.and.imeso2.eq.1) immass=1
         if(immass.eq.1) then
           if(itag1.eq.1.or.itag2.eq.1) then
             xsect=0.0
           else
             call mesmes(jesant,
     a        srt,pr,xsect,em1,em2,idum,
     b        kmulo1,ltyp1,kmulo2,ltyp2,kmuln1,ltypn1,kmuln2,ltypn2,
     c                                               iswave,0)
           end if
           sigqsq=sigqsq*sigin(3)/sig
           if(sigqsq.lt.xsect) then
             if(xsect.gt.sigin(3)) then
               write(lun8,*) 'sig,sigel,sigin(2),sigin(3),xsect'
               write(lun8,*) sig,sigel,sigin(2),sigin(3),xsect
               write(lun8,*)
     a            srt,pr,xsect,em1,em2,ityp1,npid1,ityp2,npid2
               write(lun8,*)'scattr:xsect.gt.sigin(3)'
             end if
             if(ida(48).eq.1) then
               call mesmes(jesant,
     a          srt,pr,xsect,em1,em2,ic,kmulo1,
     b          ltyp1,kmulo2,ltyp2,kmuln1,ltypn1,kmuln2,ltypn2,
     c                                                 iswave,1)
               if(ic.ne.0) then
                 call oldnew(0,ityp1,npid1,em1,kmuln1,ltypn1)
                 call oldnew(0,ityp2,npid2,em2,kmuln2,ltypn2)
               end if
             else
               ic=0
             end if
           else
             ic=0
           end if
         else
           call kmass(srt,pr,em1,em2,em3,em4,ityp1,ityp2,ityp3,ityp4,
     a      icnum,npid1,npid2,npid3,npid4,ic,icltyp,nop,nscop,nonstr)
           ikmass=1
         end if
       else
         if(srt.lt.snnlim.or.icltyp.gt.3) then
           call rqmd_cmass(srt,pr,em1,em2,ityp1,ityp2,iqcnvt,
     a                                          icltyp,npid1,npid2,ic)
         else
           call lmass(kdiffr,itag1,itag2,iexpn1,iexpn2,nchain,ipin,
     a      sig,sigel,srt,pr,em1,em2,cmeff,ityp1,ityp2,iann,
     b      kmulo1,kmulo2,istra1,istra2,imeso1,imeso2,ibry1,ibry2,
     c      ltyp1,ltyp2,iflvch,idecis,npid1,npid2,ic,pi1sqo,pi2sqo)
           if(ic.gt.0) ic=2
           ilmass=1
         end if
       end if
       if(ic.eq.-1) then
         go to 2000
       else if(ic.eq.-2) then
         if(ilmass.eq.1) then
          call errex('scattr error:ilmass=1,ic=-2 disabled')
         else if(immass.eq.1) then
          jesant=1
         else
          call errex('scattr error:ilmass.ne.1 and immass.ne.1')
         end if
         ic=2
         intmod=2
       else if(ic.eq.-3) then
         if(ilmass.ne.1) call errex('ic=-3,scattr error:ilmass.ne.1')
         if(ibry1.lt.0) then
            call antibb(ic,ityp1,ityp2,npid1,npid2,em1,em2,s)
         else
            call antibb(ic,ityp2,ityp1,npid2,npid1,em2,em1,s)
         end if
         if(ic.eq.-3) then
            jesant=1
            ic=1
            intmod=3
         end if
       end if
       if(itag1.eq.1.or.itag2.eq.1) then
         if(absrb.and.intmod.eq.0) intmod=1
         if(ikmass.eq.1) intmod=2
         if(immass.eq.1) intmod=2
         iqid1=0
         iqid2=0
         if(ilmass.eq.1.and.intmod.eq.0.and.iflvch.eq.0) then
         else if(intmod.eq.1) then
           if(itag1.eq.1) iqid1=isign(1,iexpn1)*
     a                         (-1)**iqcnvt*mod(iabs(iexpn1),100)
           if(itag2.eq.1) iqid2=isign(1,iexpn2)*
     a                         (-1)**iqcnvt*mod(iabs(iexpn2),100)
           if((itag1.eq.1.and.iqid1.gt.0
     a                               .and.imeso1.eq.1).or.
     b        (itag2.eq.1.and.iqid2.gt.0
     c                               .and.imeso2.eq.1)) then
             ic=0
             absrb=.false.
           end if
         else if(intmod.eq.2) then
           ic=0
         else if(intmod.eq.0.and.ic.ne.0) then
           jqcnvt=iqcnvt
           if(itag1.eq.1) call newcqe(ityp1,npid1,iexpn1,jqcnvt)
           if(itag2.eq.1) call newcqe(ityp2,npid2,iexpn2,jqcnvt)
         else if(intmod.eq.3) then
           iexpn1=0
           iexpn2=0
         end if
       end if
       if(ic.eq.0) then
         ichanl=0
         return
       end if
       if(absrb) then
         nop=1
         ichanl=2
         ic=1
         sigqsq=sigqsq*sigin(2)/sig
         ierr=systim(strt,dummy)
         if(imeso1.eq.1) then
           call absorb(i1,i2,i3,i4,nop,itagdl,jesant,iann,
     a                 iqqst,isoan,ityp1,npid1,ityp2,npid2,
     b                 itag1,iqid1,itag2,iqid2,ichanl,icltyp,
     c                 ltyp1,kmulo1,ltyp2,kmulo2,
     c                 sigqsq,sig,em1,em2,pr,pi1sqo,pi2sqo,srt)
         else if(imeso2.eq.1) then
           call absorb(i2,i1,i3,i4,nop,itagdl,jesant,iann,
     a                 iqqst,isoan,ityp2,npid2,ityp1,npid1,
     b                 itag2,iqid2,itag1,iqid1,ichanl,icltyp,
     c                 ltyp2,kmulo2,ltyp1,kmulo1,
     c                 sigqsq,sig,em2,em1,pr,pi2sqo,pi1sqo,srt)
         else
           call errex('scattr: absorb is called without m ingoing')
         end if
         iqqst=(-1)**iqcnvt*iqqst
         if(nop.eq.1.and.ichanl.le.1) then
           call rstifo(i1,1)
           call rstifo(i2,2)
         else if(nop.eq.1.and.ichanl.eq.2) then
           emsto1=em(i1)
           emsto2=em(i2)
           iabsrb=1
           if(imeso1.eq.1) then
             call fill12(
     a                 ityp2,ityp1,npid2,npid1,ityp(i2),npidec(i2),
     b                                                 em2,em1,srt)
           else
             call fill12(
     a                 ityp1,ityp2,npid1,npid2,ityp(i1),npidec(i1),
     b                                                 em1,em2,srt)
           end if
         end if
         ierr=systim(tend,dummy)
         tmabsr=tmabsr+tend-strt
         if(intmod.eq.1) then
           if(itag2.eq.1.and.ityp(i1).eq.-9999) then
             iexpn2=(iexpn2/100)*100+(-1)**iqcnvt*iqid2
           else if(itag1.eq.1.and.ityp(i2).eq.-9999) then
             iexpn1=(iexpn1/100)*100+(-1)**iqcnvt*iqid1
           end if
         end if
         if(jesant.eq.1) then
         else if(ichanl.eq.1) then
           go to 2000
         else if(ichanl.eq.0) then
           return
         else if(nop.eq.1.and.ichanl.eq.2) then
           jesant=1
         else
           isubr1=-isubr1
           isubr2=-isubr2
           return
         end if
       end if
       if(nop.lt.4) then
         em4=0.
         npid4=0
         ityp4=0
       end if
       if(nop.lt.3) then
         em3=0.
         npid3=0
         ityp3=0
       end if
       ichanl=ic+1
       if(nop.gt.2) go to 6000
 5000  continue
       if(srt.lt.em1+em2) then
         write(lun8,*)'scattr: icltyp,ityp1,ityp2,ic,s,em1,em2'
         write(lun8,*) icltyp,ityp1,ityp2,ic,srt,em1,em2
         if(nchain.ne.0) then
           call errex('too large masses after scattering')
         else
           write(lun8,*) 'too large masses after scattering'
         end if
       end if
       if(ichanl.eq.1.and.ida(3).eq.0) then
         pi1sq=pi1sqo
         pi2sq=pi2sqo
       else
         pi1sq=em1*em1
         pi2sq=em2*em2
       end if
       prold=pr
       ema=sqrt(pi1sq)
       emb=sqrt(pi2sq)
       pr=pcmsr(srt,ema,emb)
       if(iswave.eq.1) then
         ida37=ida(37)
         ida(37)=1
       end if
       icthmx=0
   67  continue
       if(ichanl.eq.1) then
         emm=em1+em2
         call angel(sig,emm,s,pr,icltyp,phisc,cthet)
         if(abs(cthet).eq.1) then
            ichanl=-1
            return
         end if
       else if(jesant.eq.1) then
         cthet=1.
         phisc=0.
       else
         call angin(s,pr,prold,icltyp,phisc,cthet)
       end if
       if(switch(19)) cthet=1.
       nop=2
       if(iqsq.eq.1) then
         cthmax=2.0*(dtceff*pr*pi2/hc)**2
         if(cthmax.gt.1.0) then
           cthmax=sqrt(1.-1/cthmax)
         else
           write(lun8,*) 'scattr warning:dtceff',dtceff,cthmax,pr*pi2/hc
           cthmax=1.0
         end if
         write(lun15,*) 'dtceff,cthmax,cthet',dtceff,cthmax,cthet,pr,s
         if(abs(cthet).gt.cthmax) then
            icthmx=icthmx+1
            if(icthmx.lt.50) go to 67
         end if
       end if
       if(iswave.eq.1) then
         ida(37)=ida37
         phisc=pi
       end if
       thetr=acos(max(-cvalu1,min(cvalu1,cost)))
       if(pxr.eq.0.0.and.pyr.eq.0.0) then
         phir=cvalu0
       else
         phir=atan2(pyr,pxr)
       end if
       thetlu=-thetr
       philu=-phir
       nlund=nlund+1
       if(nlund.gt.2000) call errex('scattr abort:nlund')
       mst(1)=nlund
       mst(2)=nlund
       plund(nlund,1)=x1
       plund(nlund,2)=x2
       plund(nlund,3)=x3
       plund(nlund,4)=x0
       call lurobo(0.,philu,0.,0.,0.)
       call lurobo(thetlu,0.,0.,0.,0.)
       if(plund(nlund,2).eq.0.0.and.
     a                    plund(nlund,1).eq.0.0) then
         phib=cvalu0
       else
         phib=atan2(plund(nlund,2),plund(nlund,1))
       end if
       phisc=phib+phisc
       sthet=sqrt(1.-cthet**2)
       plund(nlund,3)=pr*cthet
       plund(nlund,1)=pr*sthet*cos(phisc)
       plund(nlund,2)=pr*sthet*sin(phisc)
       thetlu=-thetlu
       philu=-philu
       call lurobo(thetlu,philu,0.,0.,0.)
       pxr=plund(nlund,1)
       pyr=plund(nlund,2)
       pzr=plund(nlund,3)
       nlund=nlund-1
       p(1,i1)=pxr
       p(2,i1)=pyr
       p(3,i1)=pzr
       p(0,i1)=sqrt(pi1sq+pr*pr)
       p(1,i2)=-pxr
       p(2,i2)=-pyr
       p(3,i2)=-pzr
       p(0,i2)=sqrt(pi2sq+pr*pr)
       call trobo(1,i1,i1,cvalu0,cvalu0,bx,by,bz)
       call trobo(1,i2,i2,cvalu0,cvalu0,bx,by,bz)
 6000  continue
       if(nop.gt.2) then
                pv(1,1)= p1tot
                pv(1,2)= p2tot
                pv(1,3)= p3tot
                pv(1,4)= p0tot
                pv(1,5)=srt
                nd=nop
                pl(1,5)=em1
                pl(2,5)=em2
                if(nd.ge.3 ) pl(3,5)= em3
                if(nd.eq.4 ) pl(4,5)= em4
                ps=0.
                do 6001 nn=1,nd
 6001           ps=ps+ pl(nn,5)
                if(ps.gt. srt -ekinmi) then
                   write(lun8,*) 'nop=',nop
                   write(lun8,*) 'ps=',ps,em1,em2,em3,em4
                   write(lun8,*) 'srt-ekinmi=',srt-ekinmi
                   write(lun8,*) ityp1,npid1,ityp2,npid2,
     a                            ityp3,npid3,ityp4,npid4
                   call errex('too high mass sum in scattr')
                end if
                pv(nd,5)= pl(nd,5)
                if(nd.eq.2) go to 280
                wtmax=1./dpar(nd-2)
                pmax=pv(1,5)-ps+pl(nd,5)
                pmin=0.
                do 230 il=nd-1,1,-1
                pmax=pmax+pl(il,5)
                pmin=pmin+pl(il+1,5)
                plil5=pl(il,5)
  230           wtmax=wtmax*pcmsr(pmax,pmin,plil5)
  240           rord(1)=1.
                do 260 il1=2,nd-1
                rsav=ranf(0)
                do 250 il2=il1-1,1,-1
                if(rsav.le.rord(il2)) goto 260
  250           rord(il2+1)=rord(il2)
  260           rord(il2+1)=rsav
                rord(nd)=0.
                wt=1.
                do 270 il=nd-1,1,-1
                pv(il,5)=pv(il+1,5)+pl(il,5)+
     a                       (rord(il)-rord(il+1))*(pv(1,5)-ps)
                plil5=pl(il,5)
  270           wt=wt*pcmsr(pv(il,5),pv(il+1,5),plil5)
                if(wt.lt.ranf(0)*wtmax) goto 240
  280           do 300 il=1,nd-1
                plil5=pl(il,5)
                pa=pcmsr(pv(il,5),pv(il+1,5),plil5)
                ue(3)=2.*ranf(0)-1.
                phi=pi2*ranf(0)
                ue(1)=sqrt(1.-ue(3)**2)*cos(phi)
                ue(2)=sqrt(1.-ue(3)**2)*sin(phi)
                do 290 j=1,3
                pl(il,j)=pa*ue(j)
  290           pv(il+1,j)=-pa*ue(j)
                pl(il,4)=sqrt(pa**2+pl(il,5)**2)
  300           pv(il+1,4)=sqrt(pa**2+pv(il+1,5)**2)
                do 310 j=1,4
  310           pl(nd,j)=pv(nd,j)
                do 340 il=nd-1,1,-1
                do 320 j=1,3
  320           be(j)=pv(il,j)/pv(il,4)
                ga=pv(il,4)/pv(il,5)
                do 340 i=il,nd
                bep=be(1)*pl(i,1)+be(2)*pl(i,2)+be(3)*pl(i,3)
                do 330 j=1,3
  330           pl(i,j)=pl(i,j)+ga*(ga*bep/(1.+ga)+pl(i,4))*be(j)
  340           pl(i,4)=ga*(pl(i,4)+bep)
                do 350 i=1,3
                p(i,i1)=pl(1,i)
  350           p(i,i2)=pl(2,i)
                p(0,i1)=pl(1,4)
                p(0,i2)=pl(2,4)
                do 370 lloop=3,nd
                npion=npion+1
                if(nrmes(kclst)+nrbar(kclst).eq.iclusz(kclst))then
                   if(kclst.eq.itripl .and. kdt.lt.idtcl) then
                    write(lun8,*)
     +   'warning scattr: iclusz(itripl) too low'
                   end if
                   io=0
                   do 45 kcl=1,nrclst
  45               io=io+ iclusz(kcl)
                   nrclst=nrclst+1
                   nrbar(nrclst)=0
                   nrmes(nrclst)=1
                   iclusz(nrclst)=1
                   nonrel(nrclst)=.false.
                   l=io+1
                   lmax=l
                   if(l.ge.ntotma+1-nspect)
     a          call errex('particle number too large,abend in scattr')
                else if(nrmes(kclst)+nrbar(kclst).lt.iclusz(kclst))then
                   nrmes(kclst)=nrmes(kclst)+1
                   l=iofset+nrbar(kclst)+nrmes(kclst)
                else
                   call errex('nrbar+nrmes.gt.iclusz  ???? ')
                end if
                nprtcl=nprtcl+1
                issn(l)=nprtcl
                decay(l)=1.e+35
                if(lloop.eq.3) i3=l
                if(lloop.eq.4) i4=l
                x(0,l)=0.
                do 360 i=1,3
  360           p(i,l)=pl(lloop,i)
                p(0,l)= pl(lloop,4)
                em(l)= pl(lloop,5)
                ichbig(l)=0
  370           continue
                ityp(i3)=ityp3
                npidec(i3)=npid3
                em(i3)=em3
                lastcl(i3)=ievntn
                if(nop.eq.4) then
                   ityp(i4)=ityp4
                   npidec(i4)=npid4
                   em(i4)=em4
                   lastcl(i4)=ievntn
                end if
       end if
       if(nop.eq.2.and.ema.ne.0.0.and.emb.ne.0.0
     a                          .and.min(ema,emb).lt.2.0) then
                prz=pr*abs(cthet)
                e1old=sqrt(pi1sqo+prold*prold)
                dplz1=abs(e1old-prold
     a                         -(sqrt(ema*ema+pr*pr)-prz))
                if(dplz1.lt.1.e-10) then
                  write(lun8,*) 'scattr warning:dplz1=0'
                  write(lun8,*) ichanl,e1old,prold,prz,ema
                  dplz1=1.e-10
                end if
                dtau1=0.5/dplz1*da(15)
                dtau1=dtau1/e1old*sqrt(pi1sqo)*hc/pi2
                e2old=sqrt(pi2sqo+prold*prold)
                dplz2=abs(e2old-prold
     a                         -(sqrt(emb*emb+pr*pr)-prz))
                if(dplz2.lt.1.e-10) then
                  write(lun8,*) 'scattr warning:dplz2=0'
                  write(lun8,*) ichanl,e2old,prold,prz,emb
                  dplz2=1.e-10
                end if
                dtau2=0.5/dplz2*da(15)
                dtau2=dtau2/e2old*sqrt(pi2sqo)*hc/pi2
                prbhd1=1.
                prbhd2=1.
       end if
       p0out = p(0,i1)+p(0,i2)
       if(nop.ge.3) p0out=p0out + p(0,i3)
       if(nop.eq.4) p0out=p0out + p(0,i4)
       if((p0tot/p0out.gt.1.01).or.
     a                           (p0tot/ p0out.lt.0.99)) then
                    arg=(srt*srt-(pi1sq+pi2sq))**2-4.*
     a                                                pi1sq*pi2sq
                    prel = 0.5/srt*sqrt(arg)
                    call errex('no energy conservation in collision')
       end if
       if(nop.gt.2) then
         if(isubr1.eq.-1) then
           emoff=(p(0,i1)-frfp(0,ident1))**2-
     a                ((p(1,i1)-frfp(1,ident1))**2+
     b                      (p(2,i1)-frfp(2,ident1))**2+
     c                             (p(3,i1)-frfp(3,ident1))**2)
           if(emoff.lt.em1*em1)  isubr1=1
         end if
         if(isubr2.eq.-1) then
           emoff=(p(0,i2)-frfp(0,ident2))**2-
     a                ((p(1,i2)-frfp(1,ident2))**2+
     b                      (p(2,i2)-frfp(2,ident2))**2+
     c                             (p(3,i2)-frfp(3,ident2))**2)
           if(emoff.lt.em2*em2)  isubr2=1
         end if
       else if(nop.eq.2) then
         if(jesant.eq.1) then
           if(isubr1.eq.-1) isubr1=1
           if(isubr2.eq.-1) isubr2=1
         end if
         em1n=em1
         em2n=em2
         if(isubr1.eq.-1) then
           emoff=(p(0,i1)-frfp(0,ident1))**2-
     a                ((p(1,i1)-frfp(1,ident1))**2+
     b                      (p(2,i1)-frfp(2,ident1))**2+
     c                             (p(3,i1)-frfp(3,ident1))**2)
           if(emoff.lt.em1*em1) then
              isubr1=1
           else
              em1n=sqrt(emoff)
           end if
         end if
         if(isubr2.eq.-1) then
            emoff=(p(0,i2)-frfp(0,ident2))**2-
     a                ((p(1,i2)-frfp(1,ident2))**2+
     b                      (p(2,i2)-frfp(2,ident2))**2+
     c                             (p(3,i2)-frfp(3,ident2))**2)
           if(emoff.lt.em2*em2) then
              isubr2=1
           else
              em2n=sqrt(emoff)
           end if
         end if
         if(ityp1.le.11.and.mod(ityp1,10).le.6) then
             if(idecis.eq.0.and.npid1.eq.3) npid1=4
         end if
         if(ityp2.le.11.and.mod(ityp2,10).le.6) then
             if(idecis.eq.0.and.npid2.eq.3) npid2=4
         end if
         if(ida(50).eq.1)  then
           call plasto(em1,jesant,ityp1,npid1,istor)
           if(istor.eq.1) then
             pxrel=pxrold
             pyrel=pyrold
             pzrel=pzrold
             emda=em1old
             emdb=em2old
             if(jesant.eq.0) then
               inew=0
             else
               inew=1
             end if
             call jetcon(inew,nchan,
     a                      emda,emdb,pxrel,pyrel,pzrel,em1,ityp1,
     a                                        npid1,ident1,bx,by,bz)
           end if
           call plasto(em2,jesant,ityp2,npid2,istor)
           if(istor.eq.1) then
             pxrel=-pxrold
             pyrel=-pyrold
             pzrel=-pzrold
             emda=em1old
             emdb=em2old
             if(jesant.eq.0) then
               inew=0
             else
               inew=1
             end if
             call jetcon(inew,nchan,
     a                      emda,emdb,pxrel,pyrel,pzrel,em2,ityp2,
     a                                        npid2,ident2,bx,by,bz)
           end if
         end if
         string=jets(ityp1,npid1,em1,0)
         if(string.or.nchain.gt.0) then
            if(string) idcid1=1
            if(jesant.eq.0) then
               pxrel=pxr
               pyrel=pyr
               pzrel=pzr
               if(isubr1.eq.-1)then
                 kt=-1
                 call transl(-1,ityp1,npid1,k2)
                 call torsts(em1n,k2,idum1,idum2,dum1,dum2,kt)
                 if(kt.eq.-1) then
                    em1n=em1
                    isubr1=1
                 end if
               end if
               if(isubr1.eq.-1) then
                 ptb=bx*frfp(1,ident1)+
     a                  by*frfp(2,ident1)+bz*frfp(3,ident1)
                 gg=(gam-1.)*ptb/b2-gam*frfp(0,ident1)
                 frp1=(gg*bx+frfp(1,ident1))
                 frp2=(gg*by+frfp(2,ident1))
                 frp3=(gg*bz+frfp(3,ident1))
                 pxrel=pxrel-frp1
                 pyrel=pyrel-frp2
                 pzrel=pzrel-frp3
                 if(nchain.gt.0) then
                   p0old=sqrt(em1**2+pr*pr)
                   p0new=sqrt(em1n**2+pxrel**2+pyrel**2+pzrel**2)
                   frp0=p0old-p0new
                 end if
               end if
               iofcha=0
               iback=0
  401          continue
               emstor=em1n
               inew=0
               if(mod(kdiffr,2).eq.1) then
                  inew=4
               else if(ida(20).eq.0) then
                 if(ibry1.ne.0.and.kmulo1.ne.0) inew=2
               end if
               call jetcon(inew,nchain,
     a                      emda,emdb,pxrel,pyrel,pzrel,em1n,ityp1,
     a                                  npid1,ident1,bx,by,bz)
               if(iback.eq.-1) then
                 nchain=-nchain
               end if
               if(iabs(nchain).gt.0) then
                 if(em1n.ne.emstor.and.isubr1.eq.-1) then
                     pxon=pxrel+frp1
                     pyon=pyrel+frp2
                     pzon=pzrel+frp3
                     p0on=sqrt(em1n**2+pxrel**2+pyrel**2+pzrel**2)+
     a                    frp0
                     em1sq=p0on**2-(pxon**2+pyon**2+pzon**2)
                     if(em1sq.gt.0.) then
                       em1tst=sqrt(em1sq)
                       kt=-1
                       call torsts(em1tst,k2,idum1,idum2,dum1,dum2,kt)
                     else
                       kt=-1
                     end if
                     if(kt.eq.-1) then
                       iback=-1
                       nchain=-nchain
                       do 402 n=9,1,-1
                        if(isea(n).ne.0) then
                          isea(n)=0
                          p0new=sqrt(em1n**2+pxrel**2+pyrel**2+
     a                                         pzrel**2)+psea(0,n)
                          pxrel=pxrel+psea(1,n)
                          pyrel=pyrel+psea(2,n)
                          pzrel=pzrel+psea(3,n)
                          em1n=p0new**2-(pxrel**2+pyrel**2+pzrel**2)
                          if(em1n.lt.em1sq) then
                           call errex(
     a                      'scattr: string mass < after adding chain')
                          else
                           em1n=sqrt(em1n)
                          end if
                          em1=sqrt((p0on+psea(0,n))**2-
     a                        ((pxon+psea(1,n))**2+(pyon+psea(2,n))**2+
     b                                            (pzon+psea(3,n))**2))
                          go to 401
                        end if
  402                  continue
                       call errex('abend in scattr at 402-loop')
                     else
                       em1=sqrt(em1sq)
                     end if
                 else
                     pxon=pxrel
                     pyon=pyrel
                     pzon=pzrel
                     p0on=sqrt(em1n**2+pxon**2+pyon**2+pzon**2)
                     if(isubr1.eq.-1) then
                       pxon=pxon+frp1
                       pyon=pyon+frp2
                       pzon=pzon+frp3
                       p0on=p0on+frp0
                     else
                       em1=em1n
                     end if
                 end if
                 p(1,i1)=pxon
                 p(2,i1)=pyon
                 p(3,i1)=pzon
                 p(0,i1)=p0on
                 call trobo(1,i1,i1,cvalu0,cvalu0,bx,by,bz)
               end if
            else
               inew=1
               emda=em1old
               emdb=em2old
               call jetcon(inew,nchain,
     a                      emda,emdb,pxrold,pyrold,pzrold,em1,ityp1,
     a                                  npid1,ident1,bx,by,bz)
            end if
            if(inew.eq.1.and.string)idcid1=2
         end if
         string=jets(ityp2,npid2,em2,0)
         if(string.or.nchain.gt.0) then
            if(string) idcid2=1
            if(jesant.eq.0) then
               pxrel=-pxr
               pyrel=-pyr
               pzrel=-pzr
               if(isubr2.eq.-1)then
                 kt=-1
                 call transl(-1,ityp2,npid2,k2)
                 call torsts(em2n,k2,idum1,idum2,dum1,dum2,kt)
                 if(kt.eq.-1) then
                    em2n=em2
                    isubr2=1
                 end if
               end if
               if(isubr2.eq.-1) then
                 ptb=bx*frfp(1,ident2)+
     a                  by*frfp(2,ident2)+bz*frfp(3,ident2)
                 gg=(gam-1.)*ptb/b2-gam*frfp(0,ident2)
                 frp1=(gg*bx+frfp(1,ident2))
                 frp2=(gg*by+frfp(2,ident2))
                 frp3=(gg*bz+frfp(3,ident2))
                 pxrel=pxrel-frp1
                 pyrel=pyrel-frp2
                 pzrel=pzrel-frp3
                 if(nchain.gt.0) then
                   p0old=sqrt(em2**2+pr*pr)
                   p0new=sqrt(em2n**2+pxrel**2+pyrel**2+pzrel**2)
                   frp0=p0old-p0new
                 end if
               end if
               iofcha=1
               iback=0
  403          continue
               emstor=em2n
               inew=0
               if(kdiffr.ge.2) then
                  inew=4
               else if(ida(20).eq.0) then
                 if(ibry2.ne.0.and.kmulo2.ne.0) inew=2
               end if
               call jetcon(inew,nchain,
     a                      emda,emdb,pxrel,pyrel,pzrel,em2n,
     a                         ityp2,npid2,ident2,bx,by,bz)
               if(iback.eq.-1) then
                 nchain=-nchain
               end if
               if(iabs(nchain).gt.0) then
                 if(em2n.ne.emstor.and.isubr2.eq.-1) then
                     pxon=pxrel+frp1
                     pyon=pyrel+frp2
                     pzon=pzrel+frp3
                     p0on=sqrt(em2n**2+pxrel**2+pyrel**2+pzrel**2)+
     a                    frp0
                     em2sq=p0on**2-(pxon**2+pyon**2+pzon**2)
                     if(em2sq.gt.0.) then
                       em2tst=sqrt(em2sq)
                       kt=-1
                       call torsts(em2tst,k2,idum1,idum2,dum1,dum2,kt)
                     else
                       kt=-1
                     end if
                     if(kt.eq.-1) then
                       iback=-1
                       nchain=-nchain
                       do 404 n=18,10,-1
                        if(isea(n).ne.0) then
                          isea(n)=0
                          p0new=sqrt(em2n**2+pxrel**2+pyrel**2+
     a                                        pzrel**2)+psea(0,n)
                          pxrel=pxrel+psea(1,n)
                          pyrel=pyrel+psea(2,n)
                          pzrel=pzrel+psea(3,n)
                          em2n=p0new**2-(pxrel**2+pyrel**2+pzrel**2)
                          if(em2n.lt.em2sq) then
                           call errex(
     a                      'scattr: string mass < after adding chain')
                          else
                            em2n=sqrt(em2n)
                          end if
                          em2=sqrt((p0on+psea(0,n))**2-
     a                        ((pxon+psea(1,n))**2+(pyon+psea(2,n))**2+
     b                                            (pzon+psea(3,n))**2))
                          go to 403
                        end if
  404                  continue
                       call errex('abend in scattr at 404-loop')
                     else
                       em2=sqrt(em2sq)
                     end if
                 else
                     pxon=pxrel
                     pyon=pyrel
                     pzon=pzrel
                     p0on=sqrt(em2n**2+pxon**2+pyon**2+pzon**2)
                     if(isubr2.eq.-1) then
                       pxon=pxon+frp1
                       pyon=pyon+frp2
                       pzon=pzon+frp3
                       p0on=p0on+frp0
                     else
                       em2=em2n
                     end if
                 end if
                 p(1,i2)=pxon
                 p(2,i2)=pyon
                 p(3,i2)=pzon
                 p(0,i2)=p0on
                 call trobo(1,i2,i2,cvalu0,cvalu0,bx,by,bz)
               end if
            else
               inew=1
               emda=em1old
               emdb=em2old
               call jetcon(inew,nchain,
     a                      emda,emdb,-pxrold,-pyrold,-pzrold,em2,
     a                                   ityp2,npid2,ident2,bx,by,bz)
            end if
            if(inew.eq.1.and.string)idcid2=2
         end if
         nchast=nchain
         if(nchain.gt.0) then
           if(nop.ne.2) then
             call errex('scattr:nop=2 expected')
           end if
           atsea=pi*da(17)**2/nchain
           rtsea=sqrt(atsea/pi)
 
           lstart=iofset+nrbar(kclst)+nrmes(kclst)+1
           lend=lstart+nchain-1
           do 405 n=1,18
            if(isea(n).ne.0) then
               nchain=nchain-1
               nop=nop+1
               npion=npion+1
               if(nrmes(kclst)+nrbar(kclst).ge.iclusz(kclst))then
                   call errex('scattr:no space for sea chain')
               else
                   nrmes(kclst)=nrmes(kclst)+1
                   l=iofset+nrbar(kclst)+nrmes(kclst)
               end if
               if(nop.eq.3) i3=l
               if(nop.eq.4) i4=l
               do 406 i=0,3
  406          p(i,l)=psea(i,n)
               if(n.le.9) then
                do 407 i=0,3
                 x(i,l)=x(i,i1)+qdot(i,i1)*dtprop
                 qdot(i,l)=0.
  407           continue
               else
                do 408 i=0,3
                 x(i,l)=x(i,i2)+qdot(i,i2)*dtprop
                 qdot(i,l)=0.
  408           continue
               end if
               tlast(l)=x(0,l)
               ichbig(l)=0
               lastcl(l)=ievntn
               nprtcl=nprtcl+1
               issn(l)=nprtcl
               tdtg(nprtcl)=0.0
               itdth(2,nprtcl)=0
               if(itdt31.eq.0) then
                 ktdt31=ident1
               else
                 ktdt31=mod(itdt31,100000)
               end if
               if(itdt32.eq.0) then
                 ktdt32=ident2
               else
                 ktdt32=mod(itdt32,100000)
               end if
               if(n.le.9) then
                 identb=ktdt31
                 identa=ktdt32
               else
                 identa=ktdt31
                 identb=ktdt32
               end if
               itdth(3,nprtcl)=identa*100000+identb
               itdth(4,nprtcl)=0
               ityp(l)=98
               npidec(l)=40
               pp=psea(0,n)**2
               do 409 i=1,3
  409          pp=pp-psea(i,n)**2
               em(l)=sqrt(pp)
               denspp(l)=rtsea
 
            end if
  405      continue
           call trobo(1,lstart,lend,cvalu0,cvalu0,bx,by,bz)
         end if
         if(nchain.ne.0) then
           call errex('scattr:nchain.ne.0')
         end if
         nchain=nchast
       end if
       ityp(i1)=ityp1
       npidec(i1)=npid1
       em(i1)=em1
       ityp(i2)=ityp2
       npidec(i2)=npid2
       em(i2)=em2
       if(iabsrb.eq.1) then
         em(i1)=emsto1
         em(i2)=emsto2
       end if
       if(intmod.eq.3) ibbban=1
       if(ida(4).gt.0.and.icltyp.le.3.and.ilmass.eq.0.and.
     a    srt.lt.snnlim.and.(ichanl.eq.2.or.ichanl.eq.3)) then
         call ndmed(i1,i2,i3,i4,nop,srt,
     a                idcid1,idcid2,itag1,itag2,
     b                icltyp,ityp1,npid1,ityp2,npid2,em1,em2,ichanl)
         if(ichanl.eq.0) then
           if(isubr1.eq.1) isubr1=-1
           if(isubr2.eq.1) isubr2=-1
         end if
       end if
       if(nop.eq.2.and.min(ityp(i2),ityp(i1)).eq.-9999) then
         nop=1
       end if
      return
      end
      function tboard(ityp1,ityp2)
#include "amsrqmd.h"
      include 'sigmasx'
      itp1=ityp1
      itp2=ityp2
      if ((itp1.eq.14.or.itp2.eq.14).or.
     &    (itp1.eq.13.and.itp2.ge.7.and.itp2.le.9).or.
     &    (itp2.eq.13.and.itp1.ge.7.and.itp1.le.9).or.
     &    (itp1.eq.15.and.itp2.ge.7.and.itp2.le.9).or.
     &    (itp2.eq.15.and.itp1.ge.7.and.itp1.le.9)) then
                                         tboard=tblhig-0.46
      else
     &if (((itp1.le.6.or.(itp1.ge.10.and.itp1.le.11)).and.
     &    ((itp2.ge.7.and.itp2.le.9).or.itp2.eq.12)) .or.
     &    ((itp2.le.6.or.(itp2.ge.10.and.itp2.le.11)).and.
     &    ((itp1.ge.7.and.itp1.le.9).or.itp1.eq.12) )) then
                                          tboard=tblhig-0.938
      else
           tboard=tblhig
      end if
      return
      end
      subroutine  newcqe(ityp1,npid1,iexpn1,iqcn)
#include "amsrqmd.h"
               call transl(-1,ityp1,npid1,kf1)
               call luiflv(kf1,ifa,ifb,ifc,ksp)
               iqid1=mod(iexpn1,100)
               iabiq=iabs(iqid1)
               if1=iabiq/10
               if2=iabiq-10*if1
               ido=1
               if(iabiq.gt.10) then
                 if(if1.eq.iabs(ifa)) then
                    if(if2.eq.iabs(ifb).or.if2.eq.iabs(ifc)) ido=0
                 else if(if1.eq.iabs(ifb)) then
                    if(if2.eq.iabs(ifa).or.if2.eq.iabs(ifc)) ido=0
                 else if(if1.eq.iabs(ifc)) then
                    if(if2.eq.iabs(ifa).or.if2.eq.iabs(ifb)) ido=0
                 end if
               else
                 if2=isign(1,iqid1)* if2 *(-1)**iqcn
                 if(if2.eq.ifa.or.if2.eq.ifb.or.if2.eq.ifc.or.
     a                    (ifa+ifb+ifc.eq.0.and.iabs(if2).ne.3)) ido=0
               end if
               if(ido.eq.1) then
                   call bele(ifla,iflb,kf1)
                   ifla=(-1)**iqcn*ifla
                   iflb=(-1)**iqcn*iflb
                   if(iabiq.gt.10) then
                      iexpn1=(iexpn1/100)*100 +iflb
                   else
                      if(isign(1,iqid1).eq.isign(1,ifla)) then
                          iexpn1=(iexpn1/100)*100 +ifla
                      else if(isign(1,iqid1).eq.isign(1,iflb)) then
                          iexpn1=(iexpn1/100)*100 +iflb
                          if(iabs(iflb).gt.10 ) then
                             write(lun8,*) iexpn1,ifla,iflb,iqcn,kf1
                             call errex('unclear situation in newcqe')
                          end if
                      else
                          write(lun8,*) iexpn1,ifla,iflb,iqcn,kf1
                          call errex('garbage in newcqe')
                      end if
                   end if
               end if
      return
      end
      subroutine plasto(em1,jesant,ityp1,npid1,istor)
       include 'scatter7'
#include "amsrqmd.h"
       logical jets
        istor=0
        if(ityp1.le.11.and.mod(ityp1,10).le.6.and.
     a                                npid1.ne.0.and.npid1.ne.1
     b                        .and..not.jets(ityp1,npid1,em1,0)) then
          istor=1
        else if(((ityp1.ge.7.and.ityp1.le.9.and.npid1.eq.2).or.
     a           (npid1.eq.35.and.ityp1.eq.99).or.
     b      (iabs(npid1).ge.28.and.iabs(npid1).le.29.and.ityp1.eq.99))
     c                                                           ) then
 
          istor=1
        end if
      return
      end
CPAT,SETEOS   .
      subroutine seteos
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
      intrep=inttyp/1000
      inttp=mod(inttyp,1000)
      intdel=inttp/100
      inttp=mod(inttyp,100)
      intbar=inttp/10
      ictoff=mod(inttp,10)
      if(intdel.lt.0.or.intdel.gt.2) then
        call errex('wrong interaction type as input')
      else if(intdel.gt.0) then
        ida(35)=intdel
      end if
      if(intbar.lt.0.or.intbar.gt.3) then
            call errex('wrong interaction type as input')
      else if(intbar.gt.0) then
        ida(13)=intbar
      end if
      if(ictoff.lt.0.or.ictoff.gt.2) then
            call errex('wrong interaction type as input')
      else if(ictoff.gt.0) then
        ida(12)=ictoff
      end if
      if(switch(6)) then
      else if(ida(13).eq.1) then
           write(lun8,*)'potential between nucleons and deltas only'
      else if(ida(13).eq.2) then
           write(lun8,*)'potential between non-strange baryons only'
      else if(ida(13).eq.3) then
           write(lun8,*)'potential between all baryons'
      end if
      if(switch(6)) then
      else if(ida(12).eq.1) then
           write(lun8,*)
     a      'relative momentum dependence in 2body potential'
      else if(ida(12).eq.2) then
           write(lun8,*)
     a      'no relative momentum dependence in 2body potential'
      end if
      al =        8.66
      sal =      21.0
      if(ida(32).eq.0) then
          alpot =     4.33
          salpot =    7.525
      else if(ida(32).eq.1) then
          alpot =     2.20
          salpot =    (pi*alpot)**1.5*0.15
      else if(ida(32).eq.2) then
          alpot =     2.20
          salpot=(pi*alpot)**1.5*0.17
      end if
      if(ida(32).eq.0.or.ida(32).eq.1) then
        if (ieos.eq. 1) then
             alpha = -0.124
             beta  =  0.0705
             gamma =  2.
        else if (ieos.eq. 2)then
             alpha = -0.356
             beta  =  0.303
             gamma =  7./6.
        else
             write(lun14,*)'error in seteos  select of eos  run aborted'
             stop
        end if
      else
        if (ieos.eq. 1) then
             alpha = -0.1466
             beta  =  0.0988
             gamma =  2.
        else if (ieos.eq. 2) then
             alpha = -0.4365
             beta  =  0.385
             gamma =  7./6.
        else
             write(lun14,*)'error in seteos  select of eos  run aborted'
             stop
        end if
      end if
      if(ida(12).eq.1) then
        pr2max=0.5*emnuc*0.27
        alprep=alpha+0.08
      else
        pr2max=0.0
      end if
      if(.not.switch(6)) then
      write(lun8,116)  alpha,beta,gamma
  116 format(1x,'qmd skyrme   alpha=',f7.3,'  beta=',f7.3,
     &                                         ' gamma=',f7.3)
      if(ieos.eq.2) write(lun8,115)
      if(ieos.eq.1)  write(lun8,1151)
115   format(1x,'soft e.o.s')
1151  format(1x,'stiff e.o.s')
      end if
      dstint=25.
      glk=exp(-dstint/al)*al/dstint
      gm1=gamma-1.
      eosc1=2.*alpha/(alpot*salpot)
      eosc2=4./(gamma+1.)*beta*gamma/(alpot*salpot)
      coef1=alpha*emnuc/salpot
      coef2=2./(gamma+1.)*beta*emnuc
      if(ida(12).eq.1) then
        coef3=alprep*emnuc/salpot
        eosc3=2.*alprep/(alpot*salpot)
      else
        coef3=coef1
        eosc3=eosc1
      end if
      return
      end
      function velo12(srt,pr,eml,emk)
        include 'scatter7'
#include "amsrqmd.h"
        denom=srt**2-eml**2-emk**2
        if(denom.le.0.0) then
          velo12=0.0
        else
          velo12=2.*pr*srt/denom
        end if
      return
      end
CPAT,STRINGA  .
      subroutine string
      include 'scatter7'
#include "amsrqmd.h"
      external ludata
      character*33 vernum
      character*46 pronam
      logical*1 ttvers
      data vernum/'version  rqmd 2.4 -- 30-jan-98'/
      data pronam/'module: s t r i n g'/
      data ttvers/.true./
      dimension ptot(0:3),dr(0:3),qlk(0:3),xold(0:3),xnew(0:3)
      dimension p1(0:3),p2(0:3),dxqb(3,0:3),xqj(0:3)
      real*4  xform(0:3),pform(0:3)
      real*4 bex,bey,bez,x1lu,x3lu,psi,vink,thetlu,philu
      real*4 xpos,plund,par,dpar,cbr,prtgam,emst,emda,emdb
      real*4 angmxv,angeff
      real*4 paraqq,paraq,paraqs
      dimension pq(0:3),pqbar(0:3),ptst(0:3),veloc(0:3)
      dimension xpos(0:5,100),iflold(2)
      include 'partblk7'
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
      common /lupobk/ xpos,ilund
      common /luopt1/
     a         iopt(20),kfstr,icqq,mbfix,ideltq,ibbcol,
     b         mmult(100),
     a         iprbcq,ilead,iback,ibrtag,icqbar,idlj,klmold,
     b         klbold,isot,misot,lbreak(100),emst,emda,emdb
      common /zdisbk/ paraqq,paraq,paraqs
      common /su3mix/ angmxv,angeff
      common /prinbk/ iprin
      save angsto,ssbsp1,ssbsp2
      data drind/ 0.3/
      data ptkl40/ 0.6/
      data irk /1/
      data ishyp,ifhyp /0,0/
      dimension nsco(9)
      data nsco / 1,1,0,1,2,1,1,5,6/
      real*4 par2,par5,par8,par12,par14,par15,par51,par52
      logical issers
      data  klchmx/17/
      save   nstp,mst10,mst11,
     a        par1,par2,par5,par8,par12,par14,par15,par51,par52,gprd
      entry ldinit
       nstp=0
       nlund=0
       tfrmhd=0.
       tfrmcq=0.
       nfrmhd=0
       nfrmcq=0
       write(lun8,*)'rqmd version including  string decay'
       if(.not.switch(15)) then
         write(lun8,*) 'modifications of the jetset default parameters'
         write(lun8,*) 'resonance masses are smeared out'
         mst(8)=1
         write(lun8,*) 'mst(8)=',mst(8)
         mst(10)=0
         write(lun8,*) 'mst(10)=',mst(10)
         write(lun8,*) 'string endpoints get transverse momenta'
         mst(11)=1
         write(lun8,*) 'mst(11)=',mst(11)
         par(5)=0.9
         write(lun8,*)
     a   'enhanced b m anti-b/ b anti-b configuration par(5)=',par(5)
         par(1)=0.10
         par1=par(1)
         write(lun8,*)
     a  'diquark suppression parameter: par(1)=',par(1)
         par(77)=1.0
         if(par(77).gt.0.0)
     a    write(lun8,*)
     b    'suppression of lowlying baryon resonance nonet',par(77)
         par(78)=0.4
         write(lun8,*)
     a       'suppression of sigma*(1385)  from qq-q:',par(78)
         par(79)=1.0
         if(par(79).lt.1.0) then
           write(lun8,*)
     a       'ssbar suppression if diquark breaks:',par(79)
         end if
         par(80)=0.25
         write(lun8,*)
     a       'eta(prime) suppression:',par(80)
         par(15)=par(12)
         write(lun8,*)
     a       'opposite pt for quarks in splitting qq, par(15)=par(12)'
       end if
       idb(19)=-idb(19)
       idb(43)=-idb(43)
       idb(44)=-idb(44)
       idb(45)=-idb(45)
       idb(57)=-idb(57)
       if(ida(41).eq.1) then
         prtgam(35)=-1.0
         idb(35)=-idb(35)
       end if
       idb(46)=-idb(46)
       idb(47)=-idb(47)
       idb(70)=-idb(70)
       if(switch(9)) then
         prtgam(28)=-1.0
         idb(28)=-idb(28)
         prtgam(29)=-1.0
         idb(29)=-idb(29)
         prtgam(34)=-1.0
         idb(34)=-idb(34)
         if(idb(35).gt.0) idb(35)=-idb(35)
         prtgam(65)=-1.0
         idb(65)=-idb(65)
         prtgam(66)=-1.0
         idb(66)=-idb(66)
         prtgam(67)=-1.0
         idb(67)=-idb(67)
       end if
       if(ida(49).eq.1.and.mod(ida(16),2).eq.0) then
         iopt(8)=1
       else
         iopt(8)=0
       end if
       mst10=mst(10)
       mst11=mst(11)
       par2=par(2)
       par5=par(5)
       par8=par(8)
       par12=par(12)
       par14=par(14)
       par15=par(15)
       par51=par(51)
       par52=par(52)
       if(da(4).ne.1.) then
         write(lun8,*) 'warning: da(4).ne.1. do you know what you do? '
         tprd=tprd*da(4)
       end if
       if(ida(29).ne.3) then
         ida(44)=0
         ida(45)=0
         ida(46)=0
         ida(47)=0
       else
         ida(21)=1
       end if
       if(ida(10).ne.0) ida(47)=0
       if(ida(45).eq.0) ida(47)=0
       if(ida(21).eq.1) then
          gmprop=-abs(gmprop)
       else
          ida(18)=0
       end if
       if(tprd.gt.1.e-30) then
         gprd=1./tprd*hc/pi2
       else
         gprd=1.e+29
       end if
       iopt(2)=ida(16)
       if(ida(16).ge.2) then
         ida(29)=3
       end if
       if(mod(iopt(2),2).eq.0) then
         if(tpar2.eq.cvalu0) then
           write(lun8,*)
     a      'hadron formation=arithmetic mean of string break points'
         else if(tpar2.eq.0.5) then
           write(lun8,*)
     a        'hadron formation=yo-yo meeting point (in the average)'
         end if
       end if
       if(ida(51).eq.2) then
         angmxv=da(9)*pi2/360.0
         angeff=da(10)*pi2/360.0
       else if(ida(51).eq.1) then
         angmxv=da(9)*pi2/360.0
         angeff=angmxv
       else if(ida(51).eq.0) then
         angmxv=35.3*pi2/360.0
         angeff=angmxv
       else
         call  errex('input  value  for ida(51) not  allowed')
       end if
       angsto=angeff
       paraqq=1.0
       paraq=3.0
       paraqs=1.0
       ssbsp2=1.0
       iopt(12)=ida(53)
      return
      entry jetdec(ind,ntag)
        if(ttvers) then
          write(lun8,*)'----version number report -------------'
          write(lun8,*)pronam
          write(lun8,*)vernum
          write(lun8,*)'-----'
          ttvers=.false.
        end if
       ievnt=lastcl(ind)
       ident=issn(ind)
       itpind=ityp(ind)
       npind=npidec(ind)
       emind=em(ind)
       call oldnew(1,itpind,npind,emind,kmult,ltyp)
       iprin=0
       kopt1=0
       ibar1=0
       gamind=p(0,ind)/emind
       if(tlast(ind)-1.e-2.gt. decay(ind))  then
         write(lun8,*) 'ind,issn,decay,x(0,ind),tlast'
         write(lun8,*)  ind,issn(ind),decay(ind),x(0,ind),tlast(ind)
         call errex('wrong tlast in jetdec')
       end if
       if(qdot(0,ind).gt.0.) then
         do 107 i=0,3
  107    veloc(i)=qdot(i,ind)/qdot(0,ind)
       else
         if(ifndnx.eq.0.and.tlast(ind).ne.decay(ind)) then
           write(lun8,*)
     a        'string ident=',ident ,'ind=',ind,'type=',ltyp,
     a                    npind
           call errex('jetdec: qdot=0 ???? ')
         end if
         do 108 i=0,3
  108    veloc(i)=0.0
       end if
       if(decay(ind)-tlast(ind).gt.1.e-3) then
         iftalt=1
       else
         iftalt=0
       end if
       delttr=decay(ind)-x(0,ind)
       do 211 i=0,3
        x(i,ind)=x(i,ind)+veloc(i)*delttr
        xold(i)=x(i,ind)
        dxqb(1,i)=0.0
 211   continue
       iprbcq=0
       icqend=0
       icqsto=0
       if(xold(0).lt.tdtg(ident).and.itdth(2,ident).ne.0) then
         ilogo=itdth(2,ident)
         iprbcq=iabs(ilogo)/100
         icqend=isign(1,ilogo)*mod(iabs(ilogo),100)
         icqsto=icqend
         if(iprbcq.ne.1.and.iprbcq.ne.2) then
           call errex('iprbcq cannot be interpreted in jetdec')
         end if
         do 199 i=0,3
  199    xqj(i)=xold(i)+veloc(i)*(tdtg(ident)-xold(0))
       else if(itdth(2,ident).ne.0) then
          call ofshel(10,ind,ident)
       end if
       ltdt3=itdth(3,ident)
       idfhad=iprbcq
       kpartr=0
       kpartm=0
       tdtg(ident)=0.
       itdth(1,ident)=0
       itdth(2,ident)=0
       itdth(3,ident)=0
       ijet=0
       nll=0
       do 14 nl=1,nlund
        kh=mod(k(nl,1),100000)
        ks=k(nl,1)/100000
        if(ks.eq.4) then
          if(kh.eq.ident ) then
            if(ijet.ne.0) call errex('not unique jetsystem for ind')
            ijet=1
            klflag=k(nl,2)
            klchar=k(nl+1,2)
            p0h=plund(nl,4)+plund(nl+1,4)
            bx=(plund(nl,1)+plund(nl+1,1))/p0h
            by=(plund(nl,2)+plund(nl+1,2))/p0h
            bz=(plund(nl,3)+plund(nl+1,3))/p0h
            emda=plund(nl,5)
            emdb=plund(nl+1,5)
            do  12 ii=1,4
             i=mod(ii,4)
             pq(i)=plund(nl,ii)
             pqbar(i)=plund(nl+1,ii)
   12       continue
            emjtsm=(pq(0)+pqbar(0))**2
            do 46 i=1,3
   46       emjtsm=emjtsm-(pq(i)+pqbar(i))**2
            emjtsm=sqrt(emjtsm)
            mst(1)=nl
            mst(2)=nl+1
            bex=-bx
            bey=-by
            bez=-bz
            call lurobo(0.,0.,bex,bey,bez)
            mst(1)=0
            mst(2)=0
            pabs=sqrt(plund(nl,1)*plund(nl,1)+
     a                   plund(nl,2)*plund(nl,2)+
     b                   plund(nl,3)*plund(nl,3))
            thet=acos(max(-cvalu1,min(cvalu1,plund(nl,3)/pabs)))
            if(plund(nl,2).eq.0.0.and.plund(nl,1).eq.0.) then
              phi=pi2*ranf(0)
            else
              phi=atan2(plund(nl,2),plund(nl,1))
            end if
          end if
        end if
        if(ijet.eq.0.or.ijet.gt.2) then
          nll=nll+1
          do 11 i=1,5
  11      plund(nll,i)=plund(nl,i)
          k(nll,1)=k(nl,1)
          k(nll,2)=k(nl,2)
        else
          ijet=ijet+1
        end if
  14   continue
       if(ijet.ne.3) then
         write(lun8,*)'issn(ind),type,kmult,em'
         write(lun8,*) issn(ind),ltyp,kmult,emind
         write(lun8,*)'ijet=',ijet,nlund
         call errex('wrong ijet in jetdec,14')
       end if
       nlund=nlund-2
       nsave=nlund
       if(nlund+6.ge.2000)
     a       call errex('lund storage too small, abort in string')
       pp=p(0,ind)*p(0,ind)
       do 78 i=1,3
  78   pp=pp-p(i,ind)*p(i,ind)
       emjs=sqrt(pp)
       iopt(7)=0
       iopt(4)=0
       iopt(10)=0
       iopt(11)=0
       irever=1
       mbfix=0
       mbtag=0
       ivzklc=isign(1,klchar)
       klchar=iabs(klchar)
       klmold=ivzklc*mod(klchar,100000)/100
       klbold=klchar/100000
       klchar=mod(klchar,100)
       lmult=0
       ltypa=iabs(ltyp)
       mbconr=0
       if(kmult.gt.0.and.klchar.le.3) then
         iopt(13)=0
         if(ltypa.gt.40) then
           klchar=10
           klflag=0
         end if
       else
         iopt(13)=ida(55)
         mlklmo=iabs(klmold)/100
         mlklbo=iabs(klbold)/100
         if(mlklmo.eq.9.or.mlklbo.eq.14) then
           mbconr=1
           iopt(13)=-1
         end if
         if(ida(55).le.0) iopt(11)=1
       end if
       if(ltypa.eq.40.or.iprbcq.ne.0) then
         isot=-1
       else if(klchar.eq.3) then
         isot=isosp(ltypa)
         misot=isign(1,ltyp)*isosp3(ltypa)
       else
         isot=-1
       end if
       if(klchar.ge.0.and.klchar.le.3) then
       else if(klchar.ge.5.and.klchar.le.klchmx) then
         if(klchar.eq.5.or.klchar.eq.6.or.klchar.eq.11.or.
     a      klchar.eq.13.or.klchar.eq.15) then
           mbfix=-klchar
         else if(klchar.eq.7) then
           mbfix=24
         else if(klchar.eq.8) then
           mbfix=31
         else if(klchar.eq.9) then
           mbfix=41
         else if(klchar.eq.12) then
           mbfix=21
         else if(klchar.eq.14) then
           idcod=kmult
           if(idcod.le.0.or.idcod.gt.9) then
             call errex('jetdec: idcod out of range')
           end if
           nsc=nsco(idcod)
           mbfix=100*nsc+21
         else if(klchar.eq.16) then
           mbfix=44
         else if(klchar.eq.17) then
           mbfix=61
         end if
         call luiflv(ltyp,mfl1,mfl2,mfl3,ksp)
         if(iopt(11).eq.1.and.mbfix.gt.0) iopt(11)=0
         mfl1=iabs(mfl1)
         mfl2=iabs(mfl2)
         mfl3=iabs(mfl3)
         if(mfl1.ne.3)mfl1=0
         if(mfl2.ne.3)mfl2=0
         if(mfl3.ne.3)mfl3=0
         mflt=mfl1+mfl2+mfl3
         em2nur=2.8+(mflt/3)*0.15
         if(mflt.eq.0) then
           if(iabs(ltyp).ge.61.and.iabs(ltyp).le.64) then
             iopt(10)=1
           else
             iopt(10)=2
           end if
         else if(mflt.eq.3) then
           if(iabs(ltyp).eq.57) then
             iopt(10)=3
           else
             iopt(10)=4
           end if
         else if(mflt.eq.6) then
           iopt(10)=5
         else if(mflt.eq.9) then
           iopt(10)=6
         else
           call errex('jetdec:unknown baryon resonance, mflt')
         end if
         if(iopt(10).eq.3.or.iopt(10).eq.4) then
           if(mbfix.ne.0)then
           else if(emjs.lt.1.60)then
             mbfix=99
           end if
         else if(iopt(10).eq.5)then
           if(emjs.lt.1.75.or.kmult.gt.0) then
             mbfix=99
           end if
         else if(iopt(10).eq.6)then
           if(emjs.lt.1.90.or.kmult.gt.0) then
             mbfix=99
           end if
         end if
       else
         write(lun8,*) 'klchar=',klchar
         call errex('jetdec:unknown klchar')
       end if
       if(ida(51).eq.2.and.
     a           (klchar.ge.5.and.klchar.le.klchmx)) then
         angeff=angmxv
       else
         angeff=angsto
       end if
       do 79 i=0,3
   79  ptot(i)=p(i,ind)
       bxnew=ptot(1)/ptot(0)
       bynew=ptot(2)/ptot(0)
       bznew=ptot(3)/ptot(0)
       ntry=0
       iokay=0
       iopt(5)=0
       icqq=0
       iopt(6)=0
       kl40=0
       if(klchar.eq.1) then
         if(ranf(0).lt.da(20)) then
           iopt(5)=1
         end if
       else if(klchar.eq.2) then
         iopt(2)=mod(ida(16),2)
       else if(klchar.eq.3) then
         if(iprbcq.ne.0) klchar=0
       else if(klchar.ge.5.and.klchar.le.klchmx) then
         iopt(2)=mod(ida(16),2)
         zlimit=(em2nur/emjs)
         if(mbconr.eq.1) then
           iopt(7)=2
         else if(ranf(0).gt.zlimit) then
           iopt(7)=2
         else
           iopt(7)=1
           if(icqsto.eq.0.and.iopt(11).eq.0) icqend=0
         end if
         if(icqend.eq.0) icqend=klflag
       else if(ltypa.eq.40) then
         iopt(2)=mod(ida(16),2)
         kl40=1
         rtsea=denspp(ind)
 
       end if
       if(iftalt.eq.1.and.iprbcq.eq.0) then
         iopt(2)=mod(iopt(2),2)
       end if
       emst=emjs
       if(klchar.eq.2)  then
         iopt(6)=2
       else if(kl40.eq.1) then
         iopt(6)=2
       end if
       if(ida(51).eq.2) then
         if(klchar.ge.5.and.klchar.le.klchmx) then
           iopt(9)=1
         else
           iopt(9)=2
         end  if
       else if(ida(51).eq.1) then
         iopt(9)=1
       else if(ida(51).eq.0) then
         iopt(9)=0
       end if
       if(kl40.eq.1) then
         iopt(14)=0
       else
         iopt(14)=1
       end if
       fist=0.0
   17  ntry=ntry+1
       ideltq=0
       if(icqq.ne.2) mbcqno=0
       nlund=nsave
       emst=emjs
       if((abs(bxnew-bx).gt.cvalu6).or.
     b            (abs(bynew-by).gt.cvalu6).or.
     c               (abs(bznew-bz).gt.cvalu6).or.
     d                  (abs(emjs-emjtsm).gt.cvalu6)) then
         nlcor=nlund
         mst(1)=nlcor+1
         mst(2)=nlcor+2
         plund(nlcor+1,4)=pq(0)*emjs/emjtsm
         plund(nlcor+2,4)=pqbar(0)*emjs/emjtsm
         do  8 i=1,3
          plund(nlcor+1,i)=pq(i)*emjs/emjtsm
          plund(nlcor+2,i)=pqbar(i)*emjs/emjtsm
    8    continue
         nlund=nlund+2
         bex=-bx
         bey=-by
         bez=-bz
         call lurobo(0.,0.,bex,bey,bez)
         bex=bxnew
         bey=bynew
         bez=bznew
         call lurobo(0.,0.,bex,bey,bez)
         mst(1)=0
         mst(2)=0
         nlund=nlcor
         do  9 ii=1,4
          i=mod(ii,4)
          pq(i)=plund(nlund+1,ii)
          pqbar(i)=plund(nlund+2,ii)
    9    continue
         bx=bxnew
         by=bynew
         bz=bznew
         emjtsm=emjs
       end if
       mst(7)=0
       mst(11)=mst11
       if(ntry.gt.30.and.icqsto.eq.0) then
         if(icqend.ne.0)  then
           icqend=0
         end if
         iokay=0
       endif
       if(ntry.gt.40) then
           write(lun8,*) 'iprbcq,icqend,ifla,iflb',ntry
           write(lun8,*)  iprbcq,icqend,ifla,iflb,kl40,iokay
       endif
       if(ntry.gt.50) then
             write(lun8,*) 'no fragmentation of jetsystem in string',
     a             ' possible ltyp=',ltyp,'emjs=',emjs,issn(ind)
             call errex('error occurred in string')
       endif
       ilead=0
       iback=0
       if(kl40.eq.1)  iokay=0
       if(iokay.eq.0) call bele(ifla,iflb,ltyp)
       if(kl40.eq.1) then
         if(iabs(ifla).gt.10) then
           iflabs=iabs(ifla)
           mfl1=mod(iflabs,10)
           mfl2=iflabs/10
           if(mfl1.ne.3)mfl1=0
           if(mfl2.ne.3)mfl2=0
           mflt=mfl1+mfl2
           demjs=(mflt/3)*2.*0.15
           if(emjs.lt.2.2+demjs) go to 17
           if(emjs.lt.2.8) then
             prmx=pcmsr(emjs,emnuc,emnuc)
             if(ranf(0).gt.1.-exp(-(prmx/(1.41*ptkl40))**2)) go to 17
           end if
         else if(iabs(ifla).eq.3) then
           if(emjs.lt.1.0) go to 17
           if(emjs.lt.2.0) then
             prmx=pcmsr(emjs,emkap,emkap)
             if(ranf(0).gt.1.-exp(-(prmx/(1.41*ptkl40))**2)) go to 17
           end if
         end if
       end if
       ibbcol=0
       if(klchar.ge.5.and.klchar.le.klchmx) then
       else
         if(kl40.eq.1.or.klchar.ge.1.or.icqsto.ne.0) then
         else if(iabs(iflb).gt.10) then
           ibbcol=1
           mfl1=iabs(iflb)/10
           mfl2=mod(iabs(iflb),10)
           mfl3=iabs(ifla)
           if(mfl3.ne.3) then
             if(mfl1.eq.3.and.ranf(0).gt.0.6) then
               iokay=0
               go to 17
             end if
             if(mfl2.eq.3.and.ranf(0).gt.0.6) then
               iokay=0
               go to 17
             end if
           end if
         end if
       end if
       if(iabs(iflb).gt.10) then
         ibstri=1
       else
         ibstri=0
       end if
       if(iopt(5).eq.1) then
         if(icqend.eq.0) then
           icqend=iflb
           iprbcq=2
         end if
       end if
       if(iabs(ifla).gt.10) then
         if(kl40.eq.1) then
         else if(icqq.eq.1.or.icqq.eq.2) then
         else
           write(lun8,*)
     a   'some counters like idlj do not always work for iabs(ifla)>10'
           call errex('problem in string decay')
         end if
       end if
       qqsupp=1.0
       par(1)=par1*qqsupp
       par(14)=par14
       par(12)=par12
       ifl1=mod(iabs(iflb),10)
       ifl2=iabs(iflb)/10
       if(ida(20).ne.0) then
         probqq=0.
       else if(iopt(5).eq.0.and.iprbcq.ne.0) then
         if(iabs(iflb).gt.10) then
           probqq=1.
         else
           probqq=0.
         end if
       else if(iopt(5).eq.1) then
         probqq=0.
       else if(iopt(4).eq.1) then
         probqq=0.
       else if(klchar.eq.3.and.ranf(0).lt.0.66667) then
         probqq=0.
       else if(ifl2.ge.ifl1) then
         probqq=1.-da(18)
       else
         probqq=1.-da(19)
       end if
       iopt(3)=0
       iopt(4)=0
       if(icqq.gt.0) then
       else if(iopt(5).eq.1) then
       else if(iopt(7).eq.1) then
         iopt(3)=1
       else if(kl40.eq.1) then
         par(12)=ptkl40
       else if(iabs(iflb).gt.10.and.ranf(0).lt.probqq) then
         iopt(3)=1
         if(iprbcq.eq.0) then
           par(51)=paraqq
           par(52)=paraq
         else
           par(51)=paraqs
           par(52)=paraqs
         end if
       else if(iprbcq.ne.0) then
       else if(iabs(iflb).lt.10) then
         iopt(3)=1
         par(51)=paraqs
         par(52)=paraqs
       else if(iabs(iflb).gt.10.and.ida(20).eq.0) then
         iopt(4)=1
         par(51)=paraqq
         par(52)=paraq
       end if
       if(iabs(iflb).gt.10.and.iopt(3).eq.1
     a                           .and.iopt(7).eq.0) then
         iopt(6)=3
       end if
       if(ida(45).eq.0) then
         iopt(2)=mod(iopt(2),2)
         iopt(3)=0
         iopt(5)=0
         iopt(6)=0
         iopt(7)=0
         iopt(9)=0
         mst(10)=1
       end if
       if(iopt(5).eq.1) mst(11)=0
       if(iopt(4).eq.1)  mst(10)=1
       if(iopt(7).eq.1)  mst(11)=0
       if((iopt(10).ge.3.and.iopt(10).le.6).and.
     a           emjs.gt.2.8.and.icqend.ne.0.and.
     a             icqsto.eq.0.and.iopt(4).eq.1.and.
     a             iopt(7).ne.1.and.
     a                     ranf(0).lt.(4.0/emjs)**3)  then
         iokay=0
         icqend=0
         go to 17
       end if
       ibrtag=0
       icqbar=0
       jctvrt=0
       jfla=0
       jflb=0
       if(iprbcq.ne.0.or.
     a      (icqend.ne.0.and.klchar.ge.5.and.klchar.le.klchmx
     b                                   .and.icqq.ne.2)) then
         if(iprbcq.eq.1) then
           if(ifla.ne.icqend) then
             if(iabs(ifla).lt.10.and.iabs(iflb).lt.10) then
               if(ifla+iflb.eq.0) then
                 if(iabs(icqend).gt.10) then
                   write(lun8,*) 'icqend,ifla,iflb,type'
                   write(lun8,*)  icqend,ifla,iflb,ltyp
                   call errex(
     a                     'jetdec:icqend should not be a diquark')
                 end if
                    ifla=icqend
                      iflb=-icqend
               else
                 ifl1=ifla
                 ifl2=iflb
                 ifla=ifl2
                 iflb=ifl1
                 if(ifla.ne.icqend) then
                   write(lun8,*) ltyp,icqend,ifla, iflb
                   call errex('wrong icqend in jetdec')
                 end if
               end if
             else
               if(iabs(icqend).le.10.and.iabs(ifla).gt.10) then
                    call errex('iabs(ifla).gt.10 notallowed in jetdec')
               else if(iabs(icqend).le.10.and.iabs(ifla).le.10) then
                 go to 17
               else
                 call errex('iabs(ifla).gt.10 notallowed in jetdec')
               end if
             end if
           end if
         else
           if(iflb.ne.icqend) then
             if(iabs(ifla).lt.10.and.iabs(iflb).lt.10) then
               if(ifla+iflb.eq.0) then
                 iflb=icqend
                 ifla=-icqend
               else
                 ifl1=ifla
                 ifl2=iflb
                 ifla=ifl2
                 iflb=ifl1
                 if(iflb.ne.icqend) then
                   write(lun8,*) ltyp,icqend,ifla,iflb
                   call errex('wrong icqend in jetdec')
                 end if
               end if
             else
               if(iabs(icqend).le.10.and.iabs(iflb).gt.10) then
                 if1=iflb/10
                 if2=iflb-10*if1
                 if(icqend.ne.if1.and.icqend.ne.if2) then
                   go to 17
                 else
                   jctvrt=1
                   if(icqend.eq.if1) then
                     icqbar=if2
                   else
                     icqbar=if1
                   end if
                 end if
               else if(iabs(icqend).le.10.and.iabs(iflb).le.10) then
                 go to 17
               else
                 if1=iflb/10
                 if2=iflb-10*if1
                 if3=icqend/10
                 if4=icqend-10*if3
                 if(if3.eq.if1) then
                   if(if4.ne.if2) go to 17
                 else if(if3.eq.if2) then
                   if(if4.ne.if1) go to 17
                 else
                   go to 17
                 end if
                 iflb=icqend
               end if
             end if
           end if
         end if
         if(ida(20).eq.0.and.iopt(2).ge.2.and.iopt(5).eq.0.and.
     a                             klchar.eq.0.and.icqq.eq.0) then
           if(iabs(icqend).gt.10.and.jctvrt.eq.0) then
             if(icqend.ne.iflb)
     a              call errex('iflb.ne.icqend in string')
             if(mst(10).ne.0)
     a              call errex('mst(10).ne.0,ida(20)=0 conflicting')
             icqq=2
             iprbcq=0
             ifl1=isign(1,iflb)*mod(iabs(iflb),10)
             ifl2=isign(1,iflb)*iabs(iflb)/10
             if(ranf(0).gt.0.5) then
               call iswap(ifl1,ifl2)
             end if
             iflh=ifl1
             if(iabs(iflh).gt.iabs(ifla)) then
               call iswap(iflh,ifla)
             end if
             if(ranf(0).lt.0.75) then
               ifla=10*ifla+iflh
             else
               ifla=10*iflh+ifla
             end if
             iflb=ifl2
             icqend=ifl1
           else if(iabs(iflb).gt.10.and.jctvrt.eq.1) then
             if(iprbcq.ne.2)
     a              call errex('iprbcq.ne.2,jctvrt=1 in string')
             icqq=1
             iopt(3)=0
             ifl1=isign(1,iflb)*mod(iabs(iflb),10)
             ifl2=isign(1,iflb)*iabs(iflb)/10
             if(ifl1.eq.icqend) then
               call iswap(ifl1,ifl2)
             end if
             if(ifl2.ne.icqend)
     a            call errex('jetdec,icqq=1:where is icqend')
             zrand=ranf(0)
             if((iabs(ifl1).gt.iabs(ifla).and.zrand.gt.0.75)
     a          .or.(iabs(ifl1).lt.iabs(ifla).and.zrand.le.0.75)
     b                                                      ) then
               call iswap(ifl1,ifla)
             end if
             ifla=10*ifl1+ifla
             iflb=icqend
           end if
         else if(iopt(7).ne.0.and.icqsto.ne.0) then
           if(iabs(icqend).gt.10) then
             iprbcq=0
             ideltq=1
             ifl1=isign(1,iflb)*mod(iabs(iflb),10)
             ifl2=isign(1,iflb)*iabs(iflb)/10
             iflqb=isign(1,icqsto)*mod(iabs(icqsto),10)
             if(ifl1.ne.iflqb)
     a           call iswap(ifl1,ifl2)
             iflb=10*ifla+ifl1
             ifla=ifl2
             jfla=ifl2
             jflb=ifl1
           else
             iopt(3)=0
             iopt(4)=0
             mst(10)=0
             mbcqno=1
             ifl1=isign(1,iflb)*mod(iabs(iflb),10)
             ifl2=isign(1,iflb)*iabs(iflb)/10
             if(ifl1.eq.icqsto) call iswap(ifl1,ifl2)
             if(ifl2.ne.icqend)
     a            call errex('jetdec,where is icqsto')
             iflb=10*ifl1+ifla
             ifla=icqsto
             iprbcq=3-iprbcq
             jfla=ifla
             jflb=iflb
             if(iprbcq.ne.1.and.iprbcq.ne.2)
     a       call errex('cq-qq resonance: unexpected iprbcq')
           end if
         end if
       end if
       iflold(1)=ifla
       iflold(2)=iflb
       if(jfla.ne.0) iflold(1)=jfla
       if(jflb.ne.0) iflold(2)=jflb
       if(npind.eq.4.and.iabs(ltyp).gt.40) then
         par(2)=0.001
       else
         par(2)=par2
       end if
       kfstr=ltyp
       iokay=1
       ktori=2
       kt=0
       call torsts(emjs,ltyp,iflb,ifla,x1,x3,kt)
       if(kt.eq.-1) then
         if(kl40.eq.1) then
           par(8)=0.0
           kt=2
           ktori=-2
         else if(iopt(7).eq.0) then
           npart1=nsave+2
           npart2=nsave+1
           go to 172
         else
           kt=2
         end if
       end if
       if(ida(45).eq.1) then
         kt=2
       end if
       npart1=nsave+kt
       npart2=nsave+1
       if(kl40.eq.1.or.(iprbcq.eq.2.and.icqq.ne.1)) then
       else
         if(fist.eq.0.0) then
           do 197 ide=1,2
            deltr=0.8*sqrt(ranf(0))
            fist=pi2*ranf(0)
            nlund=nlund+1
            mst(1)=nlund
            mst(2)=nlund
            plund(nlund,1)=deltr*cos(fist)
            plund(nlund,2)=deltr*sin(fist)
            plund(nlund,3)=0.0
            plund(nlund,4)=0.0
            thetlu=thet
            philu=phi
            bex=bxnew
            bey=bynew
            bez=bznew
            call lurobo(thetlu,philu,bex,bey,bez)
            mst(1)=0
            do 198 i=1,4
  198       dxqb(ide,mod(i,4))=plund(nlund,i)
            nlund=nlund-1
  197      continue
         end if
       end if
       if(kt.eq.2) then
         if(ktori.eq.-2) then
           call twodec(kay,ifla,iflb,nsave,kt,1,
     a                                emjs,bxnew,bynew,bznew)
           if(kay.eq.0) go to 17
         else
           call lu2jet(nsave+1,iflb,ifla,emst)
           call luexec
           if(ierror_dum.ne.0)then
            write(*,*)'lu2exec error'
            ierror=ierror_dum
            return
           endif
         end if
         mst(1)=nsave+1
         nlu=nlund
         nlund=2*nlu-nsave-kt
         if(nlund.gt.2000) then
           call errex(
     a        'jetdec: not enough free space in jetset arrays')
         end if
         if(nlu-nsave.gt.100) then
           write(lun8,*) 'too many particles produced in jetdec for',
     a                 'array xpos  no=',(nlu-nsave)
           call errex('jetdec:stop')
         end if
         nht=nlu-nsave-kt
         do 101 l=1,nht
            il=nlu+l
            nlochd=nsave+l+kt
            do 103 i=1,3
             plund(il,i)=irever*xpos(i,l)
  103       continue
            plund(il,4)=xpos(0,l)
  101    continue
         if(irever.eq.-1)then
           do  75 i=0,3
             p1(i)=pqbar(i)
             pqbar(i)=pq(i)
             pq(i)=p1(i)
   75      continue
           do 117 nlochd=nsave+kt+1,nlu
            do 116 i=1,3
  116       plund(nlochd,i)=-plund(nlochd,i)
  117      continue
         end if
       elseif(kt.eq.3) then
         x1lu=x1
         x3lu=x3
         call lu3jet(nsave+1,iflb,ifla,emst,x1lu,x3lu)
         call luexec
           if(ierror_dum.ne.0)then
            write(*,*)'lu3exec error'
            ierror=ierror_dum
            return
           endif
         mst(1)=nsave+1
         th=atan2(plund(nsave+3,1),plund(nsave+3,3))
         thp=pi -th
         psi=0.5*atan((x3*x3*sin(2*thp))/(x1*x1+x3*x3*cos(2*thp)))
         nlu=nlund
         nlund=2*nlu-nsave-kt
         do 105   l=1,nlu-nsave-kt
            il=nlu+l
            nlochd=nsave+l+kt
            do 104   i=1,3
             plund(il,i)=irever*xpos(i,l)
  104       continue
            plund(il,4)=xpos(0,l)
  105    continue
         if(irever.eq.-1)then
           do  76 i=0,3
            p1(i)=pqbar(i)
            pqbar(i)=pq(i)
            pq(i)=p1(i)
   76      continue
           do 115 nlochd=nsave+kt+1,nlu
            do 113 i=1,3
  113       plund(nlochd,i)=-plund(nlochd,i)
  115      continue
         end if
         call lurobo(psi,0.,0.,0.,0.)
         vink=pi2*ranf(0)
         call lurobo(0.,vink,0.,0.,0.)
       else
         write(lun8,*) kt
         call errex('error in jetdec:wrong kt')
       endif
       if(switch(19))then
         do 317 nlochd=nsave+kt+1,nlu
          do 316 i=1,2
           psyst(i)=psyst(i)-plund(nlochd,i)
           plund(nlochd,i)=0.
  316     continue
  317    continue
       endif
       thetlu=thet
       philu=phi
       bex=bxnew
       bey=bynew
       bez=bznew
       call lurobo(thetlu,philu,bex,bey,bez)
       mst(1)=0
       nlund=nlu
       ks1=k(nsave+1,1)/10000
  172  continue
       mst(7)=1
       if(ks1.le.1.or.kt.eq.-1) then
         mst(24)=0
         call twodec(kay,ifla,iflb,nsave,kt,2,
     a                                emjs,bxnew,bynew,bznew)
         if(kay.eq.0) go to 17
         ideltq=0
       end if
       if(kl40.eq.1) then
         ifl3=0
       else
         call luiflv(ltyp,ifl1,ifl2,ifl3,ksp)
       end if
       if(ifl3.eq.0) then
         ldbar=0
       else
         ldbar=isign(1,ifl3)
         if( (ifl1*ifl3.lt. 0).or.(ifl1*ifl2.lt.0))
     a          call errex('wrong quark content in subr. string, 15')
       end if
       if(ideltq.ne.0) then
         if(iopt(7).eq.1) then
           ivz=isign(1,ideltq)
           ideltq=iabs(ideltq)
           iflold(1)=ivz*ideltq/100
           iflold(2)=ivz*mod(ideltq,100)
         end if
       end if
       if(ida(7).eq.1.and.idfhad.ne.0) then
         do 38 i=0,3
   38    ptst(i)=frfp(i,ident)
         iop1=0
   35    continue
         do 34 lloop=nsave+1,nlund
           if(iop1.gt.1) go to 34
           ks=k(lloop,1)/10000
           if(ks.gt.1) go to 34
           kh=mod(k(lloop,1),10000)
           if(iop1.eq.1.or.lloop.eq.nlund-1.or.
     a                  (iprbcq.eq.2.and.kh.eq.npart1).or.
     b                              (iprbcq.eq.1.and.kh.eq.npart2))then
               if(iop1.eq.0)iop2=0
               if(iop1.eq.1)iop2=1
   37          continue
               do 36 llo=lloop+1,nlund
                if(iop2.gt.1) go to 36
                if(iop2.eq.1.or.llo.eq.nlund.or.
     a                      (iprbcq.eq.2.and.kh.eq.npart1)
     b                        .or.(iprbcq.eq.1.and.kh.eq.npart2))then
                  emsq=(plund(lloop,4)+plund(llo,4)+ptst(0))**2-
     a                ((plund(lloop,1)+plund(llo,1)+ptst(1))**2+
     b                    (plund(lloop,2)+plund(llo,2)+ptst(2))**2+
     c                      (plund(lloop,3)+plund(llo,3)+ptst(3))**2)
                  if(emsq.le.(plund(lloop,5)+plund(llo,5))**2) then
                      if(lloop.eq.nlund-1.and.llo.eq.nlund.and.
     a                 iop1.eq.1) then
                      end if
                  else
                      if(iop1.gt.1.or.iop2.gt.1) call errex(
     a                     'unexpected iop1,iop2 in string decay loop')
                      iop1=5
                      iop2=5
                      isccss=0
                      do 62 ii=1,4
                        i=mod(ii,4)
                        plund(lloop,ii)=plund(lloop,ii)+ptst(i)
                        psyst(i)=psyst(i)+ptst(i)
                        frfp(i,ident)=0.
   62                 continue
                      emllp=plund(lloop,5)
                      p1(0)=plund(lloop,4)
                      emll=plund(llo,5)
                      p2(0)=plund(llo,4)
                      do 61 i=1,3
                       p1(i)=plund(lloop,i)
                       p2(i)=plund(llo,i)
   61                 continue
                      call onshel(2,isccss,emllp,emll,
     a                          p1(0),p1(1),p1(2),p1(3),
     b                           p2(0),p2(1),p2(2),p2(3))
                      plund(lloop,5)=emllp
                      plund(lloop,4)=p1(0)
                      plund(llo,5)=emll
                      plund(llo,4)=p2(0)
                      do 60 i=1,3
                       plund(lloop,i)=p1(i)
                       plund(llo,i)=p2(i)
   60                 continue
                      if(isccss.eq.0) then
                          write(lun8,*) 'string onsh lloop=',lloop,
     a                            (plund(lloop,i),i=1,5)
                          write(lun8,*) 'string onsh llo=',llo,
     a                                   (plund(llo,i),i=1,5)
                          call errex('isccss=0 in string decay????? ')
                      end if
                  end if
                end if
   36          continue
               iop2=iop2+1
               if(iop2.eq.1) go to 37
           end if
   34    continue
         iop1=iop1+1
         if(iop1.eq.1) then
            go to 35
         else if(iop1.eq.2.and.iop2.eq.2) then
            emjtsm=emjs
            pp=0.
            do 51 i=0,3
             p(i,ind)=p(i,ind)+ptst(i)
             ptot(i)=p(i,ind)
             psyst(i)=psyst(i)+ptst(i)
             frfp(i,ident)=0.
             ivz=isign(1,-i)
             pp=pp+ivz*p(i,ind)*p(i,ind)
   51       continue
            emjs=sqrt(pp)
            bxnew=p(1,ind)/p(0,ind)
            bynew=p(2,ind)/p(0,ind)
            bznew=p(3,ind)/p(0,ind)
            if(iopt(7).ne.0) then
              iokay=0
              if(iopt(7).ne.0.and.icqsto.ne.0
     a                             .and.iabs(icqend).lt.10) then
                iprbcq=3-iprbcq
              end if
              go to 17
            end if
            call twodec(kay,ifla,iflb,nsave,kt,2,
     a                                   emjs,bxnew,bynew,bznew)
            if(kay.eq.0) go to 17
            nlcor=nlund
            mst(1)=nlcor+1
            mst(2)=nlcor+2
            plund(nlcor+1,4)=pq(0)*emjs/emjtsm
            plund(nlcor+2,4)=pqbar(0)*emjs/emjtsm
            do  1008 i=1,3
             plund(nlcor+1,i)=pq(i)*emjs/emjtsm
             plund(nlcor+2,i)=pqbar(i)*emjs/emjtsm
 1008       continue
            nlund=nlund+2
            if(nlund.ge.2000)
     a         call errex('lund storage too small, abort in string')
             bex=-bx
             bey=-by
             bez=-bz
             call lurobo(0.,0.,bex,bey,bez)
             bex=bxnew
             bey=bynew
             bez=bznew
             call lurobo(0.,0.,bex,bey,bez)
             mst(1)=0
             nlund=nlcor
             do  1009 ii=1,4
              i=mod(ii,4)
              pq(i)=plund(nlund+1,ii)
              pqbar(i)=plund(nlund+2,ii)
 1009        continue
             bx=bxnew
             by=bynew
             bz=bznew
         else if(iop1.ne.6.or.iop2.ne.6) then
            write(lun8,*) 'iop1,iop2=',iop1,iop2
            call errex('unexpected iop1,iop2 in string decay')
         end if
       end if
       if(ida(29).eq.3) then
         do 110   l=1,nlund-nsave-kt
            il=nlund+l
            nlochd=nsave+l+kt
            if(k(nlochd,2).eq.1) go to 110
            do 112   i=1,4
              plund(il,i)=tprd*plund(il,i)
  112       continue
               do 118   i=1,3
  118          xpos(i,l)=xold(i)+plund(il,i)
               xpos(0,l)=xold(0)+plund(il,4)
  110    continue
       end if
       if(kl40.eq.1) then
         izcq=0
       else
         if(iprbcq.eq.0) then
           izcq=2
         else
           izcq=1
         end if
         if(ibrtag.ne.0) izcq=izcq+1
       end if
       nprtno=nlund-(nsave+kt)
       nstpur=nprtno-izcq
       if(icqq.eq.1) nstpur=nstpur-1
       if(kmult.gt.0) nstpur=0
       if(nstpur.gt.0.and.
     a      nrbar(kclst)+nrmes(kclst)+nprtno.gt.iclusz(kclst))
     b                                                nstpur=0
       iopt(2)=ida(16)
       mst(10)=mst10
       mst(11)=mst11
       par(1)=par1
       par(2)=par2
       par(5)=par5
       par(8)=par8
       par(12)=par12
       par(14)=par14
       par(15)=par15
       par(51)=par51
       par(52)=par52
       lindf=1
       kright=0
       kleft=0
       bx=ptot(1)/ptot(0)
       by=ptot(2)/ptot(0)
       bz=ptot(3)/ptot(0)
       if(emind.ne.0.) then
           gam=ptot(0)/emind
       else
          write(lun8,*) ind,'p=',(p(i,ind),i=0,3),'em=',emind
          write(lun8,*) 'type=',ltyp,kmult
          call errex('unstable photon in string???? ')
       end if
       b2=max(cvalu7,bx**2+by**2+bz**2)
       if(ida(25).eq.1.and.ntag.eq.0) then
         if(switch(23)) then
           ken=itripl
         else
           ken=kdt
         end if
         ihatot=nlund-nsave-kt
         write(lun15,661)
     a       irun,ken,3,0,ihatot,0,issn(ind)*1000+nclcnt(issn(ind)),0
  661    format(1x,i3,1x,i3,1x,i1,1x,i5,1x,i3,1x,i2,1x,i8,1x,i8)
  662    format(1x,i4,1x,i4,1x,f8.3,1x,2(f7.3,1x),f8.3,1x,
     a               f7.3,i3,1x,i8,1x,f8.3,2(1x,f7.3),1x,f8.3)
         call oldat(1,itold,npold,p0old,pxold,pyold,pzold,emold)
         write(lun15,662)itold,npold,p0old,pxold,pyold,pzold,emold,
     a                           icqsto,ident,xold(0),
     b                               xold(1),xold(2),xold(3)
       end if
       iditag=0
       if(jctvrt.eq.1) ibrtag=0
       lstart=0
       jleft=0
       jright=0
       nidbeg=0
       jlrel=0
       jrrel=0
       irrel=0
       if(kl40.eq.1) then
         ityp(ind)=-9999
         decay(ind)=1.e+35
         lindf=0
       end if
       irank1=0
       irank2=0
       zplsum=cvalu0
       if(2*nlund-nsave-kt.gt.2000) then
          call errex('string:lund storage too small')
       end if
       ide=0
       do 20 lloop=nsave+1,nlund
        iprtno=lloop-nsave-kt
        ks=k(lloop,1)/10000
        kfm=k(lloop,2)
        if(ks.gt.1) go to 20
        kh=mod(k(lloop,1),10000)
        if(kh-nsave.eq.1) then
          irank1=irank1+1
        else if(kh-nsave.eq.2) then
          irank2=irank2+1
        else
          write(lun8,*) nsave,kh
          call errex('unclear parent quark in string decay')
        end if
        call luiflv(kfm,ifla,iflb,iflc,ksp)
        if(iflc.eq.0) then
          lnbar=0
        else
          lnbar=isign(1,iflc)
        end if
        if(iditag.eq.1) then
          if(kh.eq.npart1.and.ibrtag.eq.1) then
             idlj=idlj-1
             if(idlj.eq.0) then
               kleft=0
               iditag=2
             end if
          end if
          if(kh.eq.npart2.and.ibrtag.eq.2) then
             idlj=idlj-1
             if(idlj.eq.0) then
               kright=0
               iditag=2
             end if
          end if
        end if
        if(kleft.eq.0) then
          if(kh.eq.npart1) then
            kleft=1
            if(ibrtag.eq.1.and.iditag.eq.0) then
              iditag=1
            end if
          end if
        else if(kleft.eq.1) then
          kleft=2
        endif
        if(kright.eq.0) then
          if(kh.eq.npart2) then
            kright=1
            if(ibrtag.eq.2.and.iditag.eq.0) then
              iditag=1
            end if
          end if
        else if(kright.eq.1) then
          kright=2
        endif
        if(lloop.eq.nlund) then
          if(kleft.eq.0) then
            kleft=1
          else if(kright.eq.0) then
            kright=1
          end if
        end if
        lfill=0
        if(lindf.eq.1) then
          if(lnbar.eq.ldbar.or.(ind.gt.iofset+nrbar(kclst)))then
            if(kright.gt.0.or.(icqq.eq.2.and.kleft.gt.0)
     a                                                 ) then
              lfill=1
            end if
          end if
        else if(iopt(5).eq.1) then
          lfill=1
        end if
        if((iopt(5).eq.1).or.
     a      (kl40.eq.0.and.((kleft.eq.1.and.iprbcq.ne.2).or.
     b                       (kright.eq.1.and.iprbcq.ne.1)))) then
          notdly=1
        else
          notdly=0
        end if
        if(mbcqno.eq.1) lfill=0
        if(notdly.eq.0.and.izcq.ne.0.and.lfill.eq.1) then
          lfill=0
        end if
        if(notdly.eq.1) then
          if(kh.eq.npart2) irrel=irrel+1
        end if
        if(kh.eq.npart1) then
          jlrel=jlrel+1
          inkre=2*nlund+1-nsave-kt-jlrel
        else
          jrrel=jrrel+1
          inkre=nlund+jrrel
        end if
        k(inkre,1)=lbreak(lloop-nsave-kt)
        if(notdly.eq.0.and.lstart.ne.0.and.lfill.eq.1) then
          lfill=0
        end if
        if(lfill.eq.1) then
          l=ind
          lindf=0
        else
          npion=npion+1
          if(nrmes(kclst)+nrbar(kclst).eq.iclusz(kclst)) then
            if(kclst.eq.itripl.and.kdt.lt.idtcl) then
              write(lun8,*)'warning string:iclusz(itripl) too low'
            end if
            io=0
            do 45 kcl=1,nrclst
  45        io=io+ iclusz(kcl)
            nrclst=nrclst+1
            nrbar(nrclst)=0
            nrmes(nrclst)=1
            iclusz(nrclst)=1
            nonrel(nrclst)=.false.
            l=io+1
            lmax=l
            if(lmax.ge.ntotma+1-nspect)
     a      call errex('particle number too large,abend in string')
          else if(nrmes(kclst)+nrbar(kclst).lt.iclusz(kclst))then
            nrmes(kclst)=nrmes(kclst)+1
            l=iofset+nrbar(kclst)+nrmes(kclst)
            if(notdly.eq.0.and.lstart.eq.0) then
              if(nstpur.ge.1) then
                lstart=l
                izcqst=max(0,izcq-lindf)
                nmax=nlund-lloop+1-izcq
                nmax2=nlund-lloop+1-lindf
                if(mbcqno.eq.1) then
                  nmax2=nmax2+1
                  if(izcq.eq.1) izcqst=izcqst+1
                end if
                if(lstart+nmax2+lindf-1-iofset.gt.
     a                                          iclusz(kclst)) then
                  call errex(
     a                  'string: lstart.ne.0, iclusz problem')
                else
                  do 22 lst=lstart,lstart+nmax2+lindf-1
   22             ityp(lst)=0
                end if
              end if
            end if
            if(lstart.ne.0) then
              if(notdly.eq.1) then
                if(izcqst-izcq.ge.0) then
                  l=lstart+izcqst-izcq
                else
                  l=lstart+nmax
                end if
              else
                if(kh.eq.npart2) then
                  l=lstart+izcqst+jright
                  jright=jright+1
                else
                  jleft=jleft+1
                  l=lstart+nmax2-jleft
                end if
              end if
              if(ityp(l).ne.0) then
                write(lun8,*)
     a               'notdly,lstart,izcqst,izcq,nmax,nmax2,kh',
     b                    ',npart2,jright,jleft'
                write(lun8,*)
     a                notdly,lstart,izcqst,izcq,nmax,nmax2,kh,
     b                     npart2,jright,jleft
                write(lun8,*)'ityp(l),l=',ityp(l),l
                call errex(
     a                   'string: lstart.ne.0, ityp(l).ne.0 ')
              end if
              if(l.lt.lstart.or.l.gt.lstart+nmax2+lindf-1) then
                call errex(
     a                  'string: lstart.ne.0, l out of range')
              end if
            end if
          else
            call errex('string:nrbar+nrmes.gt.iclusz  ???? ')
          end if
          nprtcl=nprtcl+1
          if(nprtcl.gt.ntotma) then
            call errex('string:nprtcl>ntotma, abort')
          end if
          issn(l)=nprtcl
          lastcl(l)=ievnt
        end if
        if(l.eq.ind) then
          nidhad=ident
        else
          nidhad=nprtcl
        end if
        if(notdly.eq.1.and.iopt(5).eq.0) then
          if(kright.eq.1.and.ibstri.eq.1) then
            if(kpartm.eq.0.and.iopt(4).gt.0.and.ibrtag.ne.0) then
              kpartm=nidhad
            else
              kpartr=nidhad
            end if
          end if
        end if
        eml=plund(lloop,5)
        p1(0)=plund(lloop,4)
        do 21 i=1,3
  21    p1(i)=plund(lloop,i)
        iexpon=0
        if(notdly.eq.1) then
          ierr=0
          if(kleft.eq.1) then
            kact=1
          else
            kact=2
          end if
          if(ldbar.eq.0) then
            iexpon=iflold(kact)
            if(ifla.ne.iexpon.and.iflb.ne.iexpon.and.
     a                    iflc.ne.iexpon.and.
     b                                   ifla+iflb+iflc.ne.0) then
              ierr=1
            else
              iflold(kact)=0
            end if
          else
            if(iflc.eq.0) then
              isg=isign(1,iflold(kact))
              iabold=iabs(iflold(kact))
              if(iabold.gt.10) then
                if1=isg*(iabold/10)
                if2=isg*(iabold-10*(iabold/10))
                if(if1.eq.icqbar)  then
                  iexpon=if1
                  iflold(kact)=if2
                else if(if2.eq.icqbar)  then
                  iexpon=if2
                  iflold(kact)=if1
                else
                  ierr=2
                end if
              else
                iexpon=iflold(kact)
                if(ifla.ne.iexpon.and.iflb.ne.iexpon.and.
     a                            iflc.ne.iexpon.and.
     b                                           ifla+iflb.ne.0) then
                  ierr=2
                else
                  iflold(kact)=0
                end if
              end if
            else
              if(iditag.eq.1.and.kact.eq.ibrtag) then
                iexpon=icqbar
                if(ifla.ne.iexpon.and.iflb.ne.iexpon.and.
     a                                             iflc.ne.iexpon) then
                  ierr=3
                else
                  isg=isign(1,iflold(kact))
                  iabold=iabs(iflold(kact))
                  if(iabold.le.10) then
                    ierr=4
                  else
                    if1=isg*(iabold/10)
                    if2=isg*(iabold-10*(iabold/10))
                    if(icqbar.eq.if1)then
                      iflold(kact)=if2
                    else if(icqbar.eq.if2) then
                      iflold(kact)=if1
                    else
                      ierr=5
                    end if
                  end if
                end if
              else
                iexpon=iflold(kact)
                isg=isign(1,iflold(kact))
                iabold=iabs(iflold(kact))
                if1=isg*(iabold/10)
                if2=isg*(iabold-10*(iabold/10))
                if((if1.ne.0.and.if1.ne.ifla.and.
     a             if1.ne.iflb.and.if1.ne.iflc).or.
     b                         (if2.ne.ifla.and.
     c                         if2.ne.iflb.and.if2.ne.iflc))then
                  ierr=6
                else
                  iflold(kact)=0
                end if
              end if
            end if
          end if
          if(iditag.eq.2) then
            iditag=0
          end if
          if(ierr.ne.0) then
            write(lun8,*) 'const. quark cannot be identified:jetdec'
            write(lun8,*) 'ierr=',ierr
            write(lun8,*) 'kleft,kright,iditag,ibrtag,ldbar'
            write(lun8,*)  kleft,kright,iditag,ibrtag,ldbar
            write(lun8,*)'kact,ifla,iflb,iflc,kfm,ltyp,iflold,',
     a                         'kleft,kright'
            write(lun8,*) kact,ifla,iflb,iflc,kfm,ltyp,iflold(1),
     a                          iflold(2),kleft,kright
            write(lun8,*) 'if1/2',if1,if2
            call errex('jetdec- garbage')
          end if
          if(iopt(5).gt.0) then
            iopt(5)=-1
            kleft=1
            kright=1
            iflold(1)=0
            iflold(2)=0
          end if
          notdly=1
          izcq=izcq-1
          if(nprtcl.gt.ntotma) then
            write(lun8,*) 'nprtcl=',nprtcl,'in jetdec'
            write(lun8,*) 'too large nprtcl for array itdth'
            call errex('jetdec:ntotma arrays too small')
          end if
          if(l.eq.ind) then
            iposit=0
            dr(0)=0.
          else
                do 310 i=0,3
 310             x(i,l)=xold(i)
                if(ida(29).eq.3) then
                  iposit=0
                  dr(0)=0.
                else
                  iposit=1
                end if
          end if
          if(ida(29).ne.3) then
            if(ida(29).eq.2) then
              pbvec=p1(1)*bxnew+p1(2)*bynew+p1(3)*bznew
              p0rsjs=gamind*(p1(0)-pbvec)
              gamhrs=p0rsjs/eml
              if(gamhrs.le.1.) then
                write(lun8,*) 'string:gamhrs.le.1 ????  gamhrs=',gamhrs
                gamhrs=1.
              end if
              pminsm=gamhrs*(1.-sqrt(1.-1./(gamhrs*gamhrs)))
              gwait=2.*gprd/(emjs*pminsm+
     a                              2.*tpar2*sqrt(eml*eml+0.16))
              wait=gwait
              tfrmcq=tfrmcq+hc/(wait*pi2)
              nfrmcq=nfrmcq+1
              twait=timelf(wait,eml,p1(1),p1(2),p1(3))
            else if(ida(29).le.1) then
              wait=gprd
              tfrmcq=tfrmcq+hc/(wait*pi2)
              nfrmcq=nfrmcq+1
              twait=timelf(wait,eml,p1(1),p1(2),p1(3))
            end if
            tdtg(nidhad)=max(xold(0)+twait,xold(0))
          else if(ida(29).eq.3) then
            lact=lloop-kt-nsave
            emht=xpos(4,lact)
            tpr=tpar3
            if(tpr.lt.1.e-30) then
              twait=0.
            else
              wait=gprd/(tpr*emht)
              twait=timelf(wait,eml,p1(1),p1(2),p1(3))
            end if
            if(icqq.eq.2.and.ident.eq.nidhad) then
              do 309 i=0,3
 309          qdot(i,l)=0.5*(xpos(i,lact)+xqj(i))-xold(i)
              tdtg(nidhad)=0.5*(xpos(0,lact)+xqj(0))+twait
            else
              do 311 i=0,3
 311          qdot(i,l)=xpos(i,lact)-xold(i)
              tdtg(nidhad)=xpos(0,lact)+twait
            end if
            if(ident.ne.nidhad) then
              ide=ide+1
              ide=min(2,ide)
              do 312 i=0,3
               x(i,l)=xold(i)+dxqb(ide,i)
 312          continue
              tdtg(nidhad)=tdtg(nidhad)+ dxqb(ide,0)
            end if
            if(iopt(5).eq.0.or.idfhad.ne.0) then
              gaml=p1(0)/eml
              taul=(tdtg(nidhad)-xold(0))/gaml
              tfrmcq=tfrmcq+taul*emht/eml
              nfrmcq=nfrmcq+1
            end if
          end if
        else
          iposit=2
          if(ida(29).eq.0) then
              wait=gprd
              tfrmhd=tfrmhd+hc/(wait*pi2)
              nfrmhd=nfrmhd+1
          else if(ida(29).eq.1) then
              wait=gprd*empion/eml
              tfrmhd=tfrmhd+hc/(wait*pi2)
              nfrmhd=nfrmhd+1
          else if(ida(29).eq.2) then
                    emht=sqrt(eml*eml+0.16)
                    wait=gprd/(sqrt(tpar1+0.25*emht*emht)+tpar2*emht)
                    tfrmhd=tfrmhd+hc/(wait*pi2)
                    nfrmhd=nfrmhd+1
          else if(ida(29).eq.3) then
                    emht=xpos(4,lloop-kt-nsave)
                    if(tpar2.lt.1.e-30) then
                       iposit=0
                       wait=1.e+30
                    else
                       wait=gprd/(tpar2*emht)
                    end if
                    do 114   i=0,3
  114               x(i,l)=xpos(i,lloop-kt-nsave)
                    if(lstart.gt.0) then
                       if(nstpur.ge.2.and.l.eq.lstart+izcqst) then
                         nidbeg=nidhad
                       end if
                       phpqb=p1(0)*pqbar(0)
                       do 102 i=1,3
  102                  phpqb=phpqb-p1(i)*pqbar(i)
                       zplus=2.*phpqb/emjs/emjs
                       zplsum=zplsum+zplus
                       zminus=emht**2/emjs**2/zplus
                       if(mod(iopt(2),2).eq.1) then
                         ph0=zplus*pq(0)+zminus*pqbar(0)
                         deltt=0.5*ph0*tprd
                       else
                         deltt=0.
                       end if
                       tlastl=xpos(0,lloop-kt-nsave)+deltt
                    end if
                    gaml=p1(0)/eml
                    taul=(x(0,l)-xold(0))/gaml+1./wait*hc/pi2
                    nfrmhd=nfrmhd+1
                    tfrmhd=tfrmhd+taul*emht/eml
          endif
          if(iopt(5).eq.2) then
            iposit=1
            do 308 i=0,3
 308        x(i,l)=xold(i)
          end if
        endif
        if(iposit.eq.1) then
            deltr=drind*sqrt(ranf(0))
            phi=pi2*ranf(0)
            costet=1.-2.*ranf(0)
            sintet=sqrt(1.-costet*costet)
            xrel=deltr* sintet* sin(phi)
            yrel=deltr* sintet* cos(phi)
            zrel=deltr* costet
            xb=bx*xrel+by*yrel+bz*zrel
            gg=(gam-1.)*xb/b2
            dr(0)=gam*xb
            dr(1)=gg*bx+xrel
            dr(2)=gg*by+yrel
            dr(3)=gg*bz+zrel
            do 31 i=0,3
  31        x(i,l)=xold(i)+dr(i)
            wait=100.
            if(iabs(kfm).le.10) then
               iposit=0
            end if
        end if
        if(iposit.eq.1.or.iposit.eq.2) then
          ixnew=0
          twait=timelf(wait,eml,p1(1),p1(2),p1(3))
          if(iposit.eq.1) dr(0)=dr(0)+twait
  27      continue
          ixnew=ixnew+1
          if(ixnew.gt.5) then
              write(lun8,*) 'ixnew>5 in string'
              do 128 i=0,3
               x(i,l)=xold(i)
 128          continue
              twait=0.001*p1(0)
          end if
          if(ixnew.ge.2.or.iposit.eq.1.or.
     a                                 ida(29).eq.3) then
             do 228 i=0,3
               xnew(i)=x(i,l)+p1(i)/p1(0)*twait
               qlk(i)=xnew(i)-xold(i)
 228         continue
          else
             do 129 i=0,3
               xnew(i)=xold(i)+p1(i)/p1(0)*twait
               qlk(i)=xnew(i)-xold(i)
 129         continue
          end if
          irturn=0
          dqlksq=qlk(0)*qlk(0)
          do 19 i=1,3
  19       dqlksq=dqlksq-qlk(i)*qlk(i)
          if(ixnew.lt.10) then
            if(ida(29).eq.3) then
            else
              if(dqlksq.le.0..or.qlk(0).le.0.) then
                irturn=1
              end if
            end if
          end if
          if(irturn.eq.1) then
             delqp=qlk(0)*ptot(0)
             pindsq=ptot(0)*ptot(0)
             do 33 i=1,3
              pindsq=pindsq-ptot(i)*ptot(i)
              delqp=delqp-qlk(i)*ptot(i)
  33         continue
             val=delqp/pindsq
             arg=(0.01-dqlksq)/pindsq+val*val
             if(arg.lt.0.) then
                if(-arg.gt.0.01) then
                   write(lun8,*) 'arg.lt.0 in string,33  ???????? ',arg
                   call errex('numerical problem in string')
                end if
                arg=0.
             else
                arg=sqrt(arg)
             end if
             delts=-val+arg
             do 32 i=0,3
               x(i,l)=xnew(i)+ptot(i)*delts
  32         continue
             twait=0.01
             if(iposit.eq.1) dr(0)=dr(0)+0.01+ptot(0)*delts
             go to 27
          end if
          do 26 i=0,3
            x(i,l)=xnew(i)
  26      continue
        end if
        if(notdly.eq.0.and.lstart.gt.0.and.
     a        l.ge.lstart+izcqst.and.l.le.lstart+izcqst+nstpur-1) then
          tlast(l)=tlastl
          ipurst=1
        else
          tlast(l)=x(0,l)
          ipurst=0
        end if
        ylast(nidhad)=0.5*log((p1(0)+p1(3))/(p1(0)-p1(3)))
        if(ipurst.eq.0) then
          zlast(nidhad)=
     a           x(3,l)-(pnorm(0)*x(0,l)-pnorm(3)*x(3,l))*pnorm(3)
        else
          if(kl40.eq.1) then
            if(rtsea.gt.0.0) then
              zlast(nidhad)=rtsea
            else
              zlast(nidhad)=-1.0
            end if
            if(rtsea.le.0.0)then
              call errex("0/neg. radius of sea string")
            end if
          else
            zlast(nidhad)=0.
          end if
        end if
        ichbig(l)=0
        kmulth=mmult(iprtno)
        call oldnew(0,ityp(l),npidec(l),eml,kmulth,kfm)
        em(l)=eml
        itdth(4,nidhad)=0
        itdth(5,nidhad)=0
        do 28 i=0,3
   28   p(i,l)=p1(i)
        kfa=iabs(kfm)
        if(notdly.eq.0) then
          if(l.ne.ind) then
            tdtg(nidhad)=0.
            itdth(1,nidhad)=0
            itdth(2,nidhad)=0
            itdth(3,nidhad)=0
          end if
          do 206 i=0,3
  206     xform(i)=x(i,l)
        else
          tdtg(nidhad)=tdtg(nidhad)+dr(0)
          itdth(3,nidhad)=ltdt3
          if(iprbcq.eq.0) then
            if(icqq.eq.2) then
              if(kact.eq.2) itdth(3,nidhad)=nidhad
            else
              if(kact.eq.1) itdth(3,nidhad)=nidhad
            end if
          else
            itdth(3,nidhad)=nidhad
          end if
          if(icqq.eq.2.and.kact.eq.1) iexpon=icqend
          if(iopt(7).eq.1.and.iprbcq.eq.0) then
            iexpon=0
            kact=0
          else if(iopt(2).ge.2) then
            kact=2
          end if
          itdth(2,nidhad)=iexpon+isign(1,iexpon)*kact*100
          if(iopt(5).eq.-1.and.idfhad.eq.0) then
            tdtg(nidhad)=0.
            itdth(1,nidhad)=0
            itdth(2,nidhad)=0
            itdth(3,nidhad)=0
            iexpon=0
          end if
          if(ida(10).eq.1) then
            if(l.ne.ind) then
              do 321 i=0,3
               x(i,l)=x(i,l)+p(i,l)/p(0,l)*
     a                        (tdtg(nidhad)-x(0,l))
  321         continue
              notdly=0
            end if
            tdtg(nidhad)=0.
            itdth(1,nidhad)=0
            itdth(2,nidhad)=0
            itdth(3,nidhad)=0
            iexpon=0
          end if
          if(notdly.eq.0) then
          else if(iexpon.eq.0) then
            deltf=0.0
          else
            deltf=tdtg(nidhad)-x(0,l)
          end if
          if(notdly.eq.0) then
          else if(ida(29).eq.3) then
            do 202 i=0,3
  202       xform(i)=x(i,l)+qdot(i,l)/qdot(0,l)*deltf
          else
            do 201 i=0,3
  201       xform(i)=x(i,l)+p(i,l)/p(0,l)**deltf
          end if
        end if
        if(ida(25).eq.1)then
          if(ntag.eq.0) then
            write(lun15,662) ityp(l),npidec(l),(p(i,l),i=0,3),em(l),
     a                    iexpon,issn(l),xform(0),
     b                    xform(1),xform(2),xform(3)
          end if
        end if
        if(ida(38).eq.3.or.ida(38).eq.4) then
          idntl=issn(l)
          kstor(idntl,1)=2
          if(itdth(2,nidhad).eq.0) then
            do 203 i=1,4
  203       stork(idntl,i)=x(i-1,l)
          else
            do 204 i=1,4
  204       stork(idntl,i)=xform(i-1)
          end if
          do 303 i=6,8
  303     stork(idntl,i)=p(i-5,l)
        else if(ida(38).eq.1.or.ida(38).eq.2.or.
     a                   ida(38).eq.5.or.ida(38).eq.7) then
          if(ida(38).eq.1.or.ida(38).eq.2) then
            jeng=1
          else
            jeng=0
          end if
          emil=em(l)
          if(issers(jeng,ida(38),ityp(l),npidec(l),emil))then
                 idntl=issn(l)
                 stork(idntl,1)=stork(ident,1)
                 stork(idntl,2)=stork(ident,2)
                 stork(idntl,3)=stork(ident,3)
                 stork(idntl,4)=stork(ident,4)
                 stork(idntl,5)=stork(ident,5)
                 kstor(idntl,1)=kstor(ident,1)
                 kstor(idntl,2)=kstor(ident,2)
                 kstor(idntl,3)=kstor(ident,3)
                 kstor(idntl,4)=kstor(ident,4)
                 kstor(idntl,5)=kstor(ident,5)
                 kstor(idntl,6)=kstor(ident,6)
                 kstor(idntl,7)=kstor(ident,7)
          end if
        end if
        if(notdly.eq.1.and.iexpon.ne.0) then
          if(ida(7).eq.1) then
            emlef=p(0,l)*p(0,l)
            phpq=p(0,l)*pq(0)
            phpqb=p(0,l)*pqbar(0)
            do 40 i=1,3
             phpq=phpq-p(i,l)*pq(i)
             phpqb=phpqb-p(i,l)*pqbar(i)
             emlef=emlef-p(i,l)*p(i,l)
   40       continue
            phpq=phpq/emjs/emjs
            phpqb=phpqb/emjs/emjs
            ptpart=1.
            if(emlef.gt.0.) then
              emlef=sqrt(emlef)
            else
              call errex('imaginary emlef in string decay')
            end if
            if(abs(emlef-em(l)).gt.0.001) then
              write(lun8,*) 'difference between effective and free mass'
              write(lun8,*)'noticed in string:  emlef,em=',emlef,em(l)
              write(lun8,*) 'l,ident=',l,issn(l)
              if(kfa.ne.17.and.kfa.ne.18.and.kfa.ne.19.and.kfa.ne.23
     a                               .and.kfa.ne.41.and.kfa.ne.42) then
                em(l)=emlef
                write(lun8,*) issn(l),' got its new effective mass'
              end if
            end if
            do 41 i=0,3
             frfp(i,nidhad)=
     a              ptpart*(p(i,l)-2.*(phpq*pqbar(i)+phpqb*pq(i)))
             p(i,l)=p(i,l)-frfp(i,nidhad)
             psyst(i)=psyst(i)-frfp(i,nidhad)
   41       continue
            plor=frfp(0,nidhad)**2-frfp(1,nidhad)**2-
     a                          frfp(2,nidhad)**2-frfp(3,nidhad)**2
            if(plor.gt.0.001) then
              write(lun8,*) 'string:nidhad=',nidhad,phpq,phpqb
              write(lun8,*) 'pq=',(pq(i),i=0,3)
              write(lun8,*) 'pqbar=',(pqbar(i),i=0,3)
              write(lun8,*) nidhad,'p=',(p(i,l),i=0,3)
              write(lun8,*) 'frfp=',(frfp(i,nidhad),i=0,3)
              write(lun8,*) 'plor=',plor,
     +      'should be nonpositively definite'
              call errex('numerical problem in string')
            end if
          end if
          decay(l)=tdtg(nidhad)
        else
          if(lstart.gt.0.and.
     a        l.ge.lstart+izcqst.and.l.le.lstart+izcqst+nstpur-1) then
            decay(l)=x(0,l)
          else
            startt=x(0,l)
            call dupdat(l,startt)
          end if
        end if
        if(notdly.eq.0.and.lstart.gt.0.and.
     a      l.ge.lstart+izcqst.and.l.le.lstart+izcqst+nstpur-1) then
          iswprp=2
        else
     a  if(notdly.eq.1.or.ida(23).ne.0) then
          iswprp=0
        else
          iswprp=1
          do 345 i=0,3
 345      qdot(i,l)=0.
          ichbig(l)=1
        end if
        if(ida(15).gt.0) then
          if(notdly.eq.1)then
          else if(notdly.eq.0.and.lstart.gt.0.and.
     a      l.ge.lstart+izcqst.and.l.le.lstart+izcqst+nstpur-1) then
              iswprp=2
          else
            do 346 i=0,3
 346        qdot(i,l)=0.
            ichbig(l)=3
          end if
        end if
        if(kdt.le.ndt.and.l.le.iofset+iclusz(kclst).and.ntag.eq.0) then
          if(ida(42).eq.1) then
            identl=issn(l)
            write(lun7)
     &          ityp(l),issn(l),npidec(l),
     &          x(0,l),x(1,l),x(2,l),x(3,l),
     &          p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &          tdtg(identl),itdth(2,identl),itdth(3,identl)
            if(notdly.eq.1) then
              do 352 i=0,3
 352          pform(i)=p(i,l)+frfp(i,identl)
              write(lun7)
     &          ityp(l),issn(l),npidec(l),
     &          (xform(i),i=0,3),
     &          (pform(i),i=0,3),em(l),
     &          0.0,0,0
            end if
          end if
          call propag(l,-2,iswprp)
        else
          do 347 i=0,3
 347      qdot(i,l)=0.
        end if
        k(lloop,1)=l
  20   continue
       if(ida(25).eq.1) then
         if(ntag.eq.0) then
           if(ida(36).eq.1) then
              if(ifndnx.eq.0) then
                 call dnscal(1,ind,-1,dens1)
                 write(lun15,663) dens1
              else
                 write(lun15,663)  0.
              end if
           end if
         end if
  663    format(1x,1(f6.3,1x))
       end if
       if(iditag.ne.0) write(lun8,*) 'iditag=',iditag,'?????? ',
     a             kdt,ident,itripl
       if(lindf.eq.1) then
         iswprp=1
         ityp(ind)=-9999
         decay(ind)=1.e+35
         call propag(ind,-2,iswprp)
       end if
       if(izcq.ne.0.and.ida(29).eq.3) then
         call errex('final izcq.ne.0 in string')
       end if
       if((kleft.eq.0.or.kright.eq.0)) then
         write(lun8,*) 'kleft,kright=',kleft,kright
         call errex('error  in subr. string')
       end if
       if(lstart.gt.0) then
         nstp=nstp+nstpur
         lstart=lstart+izcqst
         identb=issn(lstart)
         do 299 i=0,3
  299    frfp(i,identb)=xold(i)
         lend=lstart+nstpur-1
         if(nidbeg.eq.0) then
           itdth(1,identb)=-identb
           itdth(3,identb)=ltdt3
           inkre=nlund+irrel+1
           if(icqq.eq.1) inkre=inkre+1
           lbrek=k(inkre,1)
           if(lbrek.lt.0) lbrek=100-lbrek
           nclcnt(identb)=lbrek
         else
           ldif=nlund+irrel
           if(icqq.eq.1) ldif=ldif+1
           do 301 l=lstart,lend
            nidhad=issn(l)
            itdth(3,nidhad)=ltdt3
            if(itdth(1,nidhad).ne.0  .or.
     a                       itdth(2,nidhad).ne.0  ) then
              call  errex(
     a          'tdtag.ne.0 for newly formed hadrons in string')
            end if
            ldif=ldif+1
            lbrek=k(ldif,1)
            if(iabs(lbrek).gt.100) then
              lbrek=isign(1,lbrek)*mod(iabs(lbrek),100)
            end if
            if(lbrek.lt.0) lbrek=100-lbrek
            nclcnt(nidhad)=lbrek
            itdth(1,nidhad)=nidbeg
  301      continue
           if(zplsum.lt.cvalu0.or.zplsum.gt.1.001) then
             write(lun8,*)
     a         'string: strange value for zplsum:',zplsum,ident
             zplsum=min(cvalu1,max(cvalu0,zplsum))
           end if
           do 304 i=0,3
  304      frfp(i,nidhad)=pq(i)*zplsum
         end if
       end if
       nlstor=nlund
       nlund=nsave
       do 30 lloop=nsave+kt+1,nlstor
        l=k(lloop,1)
        if(l.le.0.or.l.gt.ntotma)
     a           call errex('jetdec30, abort')
        eml=em(l)
        ident=issn(l)
        call oldnew(1,ityp(l),npidec(l),eml,kmulth,kfm)
        if(kmulth.ne.0.and.iabs(kfm).gt.40) call makjet(l)
  30   continue
      return
      end
CPAT,STRINGB  .
      subroutine qdrot(ind,ident,bx,by,bz)
        include 'scatter7'
#include "amsrqmd.h"
        include 'partblk7'
       real*4 bex,bey,bez,thetlu,philu
       common /lujets/ nlund,k(2000,2),plund(2000,5)
       common/ludat1s/mst(40),par(80)
          if(switch(19)) return
          if(itdth(2,ident).eq.0  .or.
     a          tdtg(ident).le.tlast(ind)) return
           if(tdtg(ident).eq.decay(ind)) then
             idecha=1
           else
             idecha=0
           end if
           if(bx**2+by**2+bz**2.ge.1.0) then
              write(lun8,*) bx,by,bz,
     a                    bx**2+by**2+bz**2
             call errex('qdrot:velocities out of range')
           end if
           if(qdot(0,ind).eq.0.) return
           if(ityp(ind).eq.-9999) return
           nlund=nlund+3
           if(nlund.gt.2000) call errex('n2dec:nlund>2000')
           mst(1)=nlund-2
           mst(2)=nlund
           bex=-bx
           bey=-by
           bez=-bz
           do 298 i=1,4
            plund(nlund-2,i)=p(mod(i,4),ind)
            plund(nlund-1,i)=
     a                       qdot(mod(i,4),ind)/qdot(0,ind)*
     b                           (tdtg(ident)-tlast(ind))
            plund(nlund,i)=qdot(mod(i,4),ind)
  298      continue
           call lurobo(0.,0.,bex,bey,bez)
           qdotsq=0.0
           psq=0.0
           xsq=0.0
           do 299 i=1,3
            psq=psq+plund(nlund-2,i)**2
            xsq=xsq+plund(nlund-1,i)**2
            qdotsq=qdotsq+plund(nlund,i)**2
  299      continue
           qdotsq=sqrt(qdotsq)
           psq=sqrt(psq)
           xsq=sqrt(xsq)
           plund(nlund-1,1)=0.0
           plund(nlund-1,2)=0.0
           plund(nlund-1,3)=xsq
           plund(nlund,1)=0.0
           plund(nlund,2)=0.0
           plund(nlund,3)=qdotsq
           bex=-bex
           bey=-bey
           bez=-bez
           if(plund(nlund-2,2).eq.0.0.and.plund(nlund-2,1).eq.0.) then
             philu=pi2*ranf(0)
           else
             philu=atan2(plund(nlund-2,2),plund(nlund-2,1))
           end if
           thetlu=
     a       acos(max(-cvalu1,min(cvalu1,plund(nlund-2,3)/psq)))
           mst(1)=nlund-1
           call lurobo(thetlu,philu,bex,bey,bez)
           do 297 i=1,4
  297      qdot(mod(i,4),ind)=plund(nlund,i)
             tdtg(ident)=tlast(ind)+plund(nlund-1,4)
             if(idecha.eq.1) decay(ind)=tdtg(ident)
           if(ida(38).eq.3.or.ida(38).eq.4) then
             do 303 i=1,4
              stork(ident,i)=x(i-1,ind)+
     a                       qdot(i-1,ind)/qdot(0,ind)*
     b                             (tdtg(ident)-x(0,ind))
  303        continue
           end if
           mst(1)=0
           mst(2)=0
           nlund=nlund-3
      return
      end
      subroutine trobo(idec,imin,imax,the,phi,bex,bey,bez)
      include 'scatter7'
#include "amsrqmd.h"
      include 'partblk7'
      dimension rot(3,3),pv(3)
      double precision dp(4),dbex,dbey,dbez,dga,dbep,dgabep
      if(imin.le.0.or.imax.gt.ntotma) then
          write(lun8,*) 'wrong imin,imax in trobo',imin,imax
          call errex('stop')
      end if
      if(the**2+phi**2.gt.cvalu4) then
        rot(1,1)=cos(the)*cos(phi)
        rot(1,2)=-sin(phi)
        rot(1,3)=sin(the)*cos(phi)
        rot(2,1)=cos(the)*sin(phi)
        rot(2,2)=cos(phi)
        rot(2,3)=sin(the)*sin(phi)
        rot(3,1)=-sin(the)
        rot(3,2)=0.
        rot(3,3)=cos(the)
        do 120 i=imin,imax
        do 100 j=1,3
          if(idec.eq.1) then
             pv(j)=p(j,i)
          else
             pv(j)=x(j,i)
          end if
  100   continue
        do 110 j=1,3
          if(idec.eq.1) then
            p(j,i)=rot(j,1)*pv(1)+rot(j,2)*pv(2)+rot(j,3)*pv(3)
          else
            x(j,i)=rot(j,1)*pv(1)+rot(j,2)*pv(2)+rot(j,3)*pv(3)
          end if
  110   continue
  120   continue
      endif
      if(bex**2+bey**2+bez**2.gt.1e-20) then
        dbex=bex
        dbey=bey
        dbez=bez
        dga=1d0/dsqrt(1d0-dbex**2-dbey**2-dbez**2)
        do 140 i=imin,imax
        if(idec.eq.1) then
           do 130 j=1,4
  130      dp(j)=p(mod(j,4),i)
        else
           do 131 j=1,4
  131      dp(j)=x(mod(j,4),i)
        end if
        dbep=dbex*dp(1)+dbey*dp(2)+dbez*dp(3)
        dgabep=dga*(dga*dbep/(1d0+dga)+dp(4))
        if(idec.eq.1) then
           p(1,i)=dp(1)+dgabep*dbex
           p(2,i)=dp(2)+dgabep*dbey
           p(3,i)=dp(3)+dgabep*dbez
           p(0,i)=dga*(dp(4)+dbep)
        else
           x(1,i)=dp(1)+dgabep*dbex
           x(2,i)=dp(2)+dgabep*dbey
           x(3,i)=dp(3)+dgabep*dbez
           x(0,i)=dga*(dp(4)+dbep)
        end if
  140   continue
      endif
      return
      end
      subroutine twodec(
     a                 kay,ifla,iflb,nsave,kt,iwo,
     b                                        emjs,bxnew,bynew,bznew)
      include 'scatter7'
#include "amsrqmd.h"
      real*4 bex,bey,bez
      real*4 plund,par,pall(4)
      real*4 zact,emht,emst,emda,emdb
      common /luspbk/ pall,iqqsp,ifirst,ibegin,istart,istfl
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
      common /luopt1/
     a         iopt(20),kfstr,icqq,mbfix,ideltq,ibbcol,
     b         mmult(100),
     a         iprbcq,ilead,iback,ibrtag,icqbar,idlj,klmold,
     b         klbold,isot,misot,lbreak(100),emst,emda,emdb
 
      real*4 xpos(0:5,100)
      common /lupobk/ xpos,ilund
             kay=0
             ntry=0
    5        continue
             ifl1=iflb
             ifl2=int(0.5+ranf(0))+1
             ifl2=isign(1,iflb)*ifl2
             if(iabs(iflb).lt.10)  ifl2=-ifl2
             call luifld(ifl1,0,ifl2,ifdm,kf1)
             ifl1=ifla
             call luifld(ifl1,0,-ifl2,ifdm,kf2)
             em1=getmas(0,kf1,1,-1.0)
             em2=getmas(0,kf2,1,-1.0)
             if(em1+em2.ge.emjs) then
               if(ntry.lt.40) go to 5
               return
             end if
             lbreak(1)=ifl2
             lbreak(2)=ifla
             kay=1
             kt=2
             ibrtag=0
             nlund=nsave+4
             prel=pcmsr(emjs,em1,em2)
             ct=1.-2.*ranf(0)
             st=sqrt(1.-ct*ct)
             phi=ranf(0)*pi2
             pxrel=prel*cos(phi)*st
             pyrel=prel*sin(phi)*st
             pzrel=prel*ct
             k(nsave+1,1)=20000
             k(nsave+1,2)=0
             k(nsave+2,1)=20000
             k(nsave+2,2)=1
             k(nsave+3,1)=nsave+1
             k(nsave+3,2)=kf1
             k(nsave+4,1)=nsave+2
             k(nsave+4,2)=kf2
             do 10 i=1,3
             plund(nsave+1,i)=0.
             plund(nsave+2,i)=0.
   10        continue
             plund(nsave+3,1)=pxrel
             plund(nsave+3,2)=pyrel
             plund(nsave+3,3)=pzrel
             plund(nsave+4,1)=-pxrel
             plund(nsave+4,2)=-pyrel
             plund(nsave+4,3)=-pzrel
             plund(nsave+1,4)=emjs
             plund(nsave+1,5)=emjs
             plund(nsave+2,4)=0.
             plund(nsave+2,5)=0.
             plund(nsave+3,4)=sqrt(em1*em1+prel*prel)
             plund(nsave+3,5)=em1
             plund(nsave+4,4)=sqrt(em2*em2+prel*prel)
             plund(nsave+4,5)=em2
             mmult(1)=0
             mmult(2)=0
               ifirst=0
               ibegin=0
               istart=0
               istfl=0
               iqqsp=0
               pall(4)=emjs
               do 11 i=1,3
   11          pall(i)=0.0
               iact=nsave+4
               jtact=3
               call lupos(0.,zact,emht,iact-1,jtact,0,ifl2,iflb)
               call lupos(0.,zact,emht,iact,4,0,-ifl2,ifla)
             if(iwo.eq.1) return
             mst(1)=nsave+1
             mst(2)=nsave+6
             do 12 l=1,2
             do 12 ii=1,4
   12        plund(nsave+4+l,ii)=xpos(mod(ii,4),l)
             bex=bxnew
             bey=bynew
             bez=bznew
             call lurobo(0.,0.,bex,bey,bez)
             mst(1)=0
            return
            end
      subroutine lddec(ind,ntag)
      include 'scatter7'
#include "amsrqmd.h"
      dimension ptot(0:3),dr(0:3),qlk(0:3),xold(0:3),xnew(0:3)
      real*4   xform(0:3)
      dimension p1(0:3)
      common/ludat1s/mst(40),par(80)
      real*4 plund,prtgam,dpar,par,bex,bey,bez
      dimension veloc(0:3)
      include 'partblk7'
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common /ludat3s/ dpar(20),idb(120),cbr(400),kdp(1600)
      common /aludat/ prtgam(120),isosp(120),isosp3(120),mgpar(120)
      logical scayes
      logical issers
      data drind/ 0.3/
      if(switch(19)) then
        ntag=-1
        decay(ind)=1.e+35
        return
      end if
      ievnt=lastcl(ind)
      nsave=nlund
      ident=issn(ind)
      itpind=ityp(ind)
      npidid=npidec(ind)
      if(itpind.eq.8.and.npidid.eq.1) then
        if(ranf(0).gt.0.666667) then
          scayes=.true.
        else
          scayes=.false.
        end if
      else
        scayes=.false.
      end if
      call transl(-1,itpind,npidid,kl2)
      ida5=0
      if(ida(5).ne.0) then
        if(kl2.eq.34.or.kl2.eq.25.or.
     a     (kl2.eq.33.and.npidid.eq.2).or.kl2.eq.35) then
          ida5=1
        end if
      end if
      if(ida(5).gt.1) then
        if(kl2.eq.24) then
          ida5=1
        end if
      end if
      if(ida5.eq.1) then
        write(lun10,1663) kl2,p(0,ind),(-p(i,ind),i=1,3),em(ind)
 1663 format(1x,i4,1x,5(f7.3,1x))
      end if
      if(iabs(kl2).lt.100)then
        idcold=iabs(kl2)
      else
        idcold=0
        call errex('lddec:hadron flavor out of range')
      end if
      nlund=nlund+1
      if(nlund.ge.2000)
     a       call errex('lund storage too small, abort in lddec')
      k(nlund,1)=0
      k(nlund,2)=kl2
      pp=p(0,ind)*p(0,ind)
      do 10 i=1,3
      pp=pp-p(i,ind)*p(i,ind)
  10  plund(nlund,i)=p(i,ind)
      plund(nlund,4)=p(0,ind)
      if(kl2.eq.1) then
         plund(nlund,5)=0.
      else
         if(pp.lt.0.) then
             write(lun8,*) 'lddec: pp.lt.0. pp=',pp,'???????? '
             plund(nlund,5)=0.
         else
             plund(nlund,5)=sqrt(pp)
         end if
      end if
      kfa=iabs(kl2)
      if(ifndnx.eq.1) then
         idb(23)=-idb(23)
         if(kfa.gt.100) call luiflv(kfa,ifla,iflb,iflc,ksp)
         if(kfa.gt.100) kfa=76+5*ifla+ksp
         if(idb(kfa).ge.1) call luexec
         idb(23)=-idb(23)
         if(nsave+1.eq.nlund) then
            nlund=nsave
            decay(ind)=1.e+35
            return
         end if
         call sveifo(ind,1)
         decay(ind)=x(0,ind)
      else
         if(kfa.gt.70) then
           write(lun8,*) 'exotic hadron in lddec',kl2
         else
           if(idb(kfa).lt.0) then
              write(lun8,*) ident,ityp(ind),npidec(ind)
              write(lun8,*) (itdth(i,ident),i=1,4)
              call errex('lddec:stable hadron in decay routine? ')
           end if
         end if
         ipnd=nlund
         call ludecy(ipnd)
      end if
      call luiflv(kl2,ifla,iflb,iflc,ksp)
      if(iflc.eq.0) then
        ldbar=0
      else
        ldbar=isign(1,iflc)
        if( (ifla*iflc.lt. 0).or.(ifla*iflb.lt.0))
     a      call errex('wrong quark content in subr. lddec, 15')
      end if
      delttr=decay(ind)-x(0,ind)
      if(qdot(0,ind).gt.0.) then
        do 207 i=0,3
  207   veloc(i)=qdot(i,ind)/qdot(0,ind)
      else
        do 208 i=0,3
  208   veloc(i)=0.0
        if(abs(delttr).gt.0.001) then
          write(lun8,*) 'warning:  qdot(0)=0', ind,issn(ind),
     a               ityp(ind),npidec(ind),x(0,ind),decay(ind)
          call errex('lddec: qdot(0)=0 ?????? ')
        end if
      end if
      do 201 i=0,3
         x(i,ind)=x(i,ind)+veloc(i)*delttr
         xold(i)=x(i,ind)
  201 continue
      do 69 i=0,3
   69 ptot(i)=p(i,ind)
      if(xold(0).lt.tdtg(ident).and.itdth(2,ident).ne.0) then
         ilogo=itdth(2,ident)
         iexpon=isign(1,ilogo)*mod(iabs(ilogo),100)
      else
         iexpon=0
      end if
      lindf=1
      bx=ptot(1)/ptot(0)
      by=ptot(2)/ptot(0)
      bz=ptot(3)/ptot(0)
      if(em(ind).ne.0.) then
          gam=ptot(0)/em(ind)
      else
          write(lun8,*) ind,'p=',(p(i,ind),i=0,3),'em=',em(ind)
          write(lun8,*) 'ityp=',ityp(ind),'npid=',npidec(ind)
          call errex('unstable photon in lddec???? ')
      end if
      b2=max(cvalu7,bx**2+by**2+bz**2)
      if(ida(25).eq.1.and.ntag.eq.0.and.(ifndnx.eq.0.or.
     a                                 prtgam(idcold).gt.0.)) then
           if(switch(23)) then
             ken=itripl
           else
             ken=kdt
           end if
           ihatot=0
           do 22 lloop=nsave+1,nlund
            if(k(lloop,1)/10000.gt.1) go to 22
            ihatot=ihatot+1
   22      continue
           write(lun15,661)
     a      irun,ken,2,0,ihatot,0,issn(ind)*1000+nclcnt(issn(ind)),0
  661      format(1x,i3,1x,i3,1x,i1,1x,i5,1x,i3,1x,i2,1x,i8,1x,i8)
  662    format(1x,i4,1x,i4,1x,f8.3,1x,2(f7.3,1x),f8.3,1x,
     a               f7.3,i3,1x,i8,1x,f8.3,2(1x,f7.3),1x,f8.3)
           call oldat(1,itold,npold,p0old,pxold,pyold,pzold,emold)
           write(lun15,662)itold,npold,p0old,pxold,pyold,pzold,emold,
     a                            iexpon,ident,xold(0),
     b                               xold(1),xold(2),xold(3)
      end if
      kl2abs=iabs(kl2)
      if(ida(50).eq.1.and.
     a         (kl2abs.eq.27.or.kl2abs.eq.28.or.
     a          kl2abs.eq.29.or.kl2abs.eq.33.or.kl2abs.eq.35)
     b                                                    ) then
        ijet=0
        nll=0
        do 14 nl=1,nlund
         kh=mod(k(nl,1),100000)
         ks=k(nl,1)/100000
         if(ks.eq.4) then
           if(kh.eq.ident ) then
             if(ijet.ne.0) call errex('lddec:no unique jetsystem')
             ijet=1
             klflag=k(nl,2)
             klchar=k(nl+1,2)
             mst(1)=nl
             mst(2)=nl+1
             bex=-bx
             bey=-by
             bez=-bz
             call lurobo(0.,0.,bex,bey,bez)
             mst(1)=0
             mst(2)=0
             pabs=sqrt(plund(nl,1)*plund(nl,1)+
     a                   plund(nl,2)*plund(nl,2)+
     b                   plund(nl,3)*plund(nl,3)  )
             thetqq=acos(max(-cvalu1,min(cvalu1,plund(nl,3)/pabs)))
             if(plund(nl,2).eq.0.0.and.plund(nl,1).eq.0.) then
               phiqq=pi2*ranf(0)
             else
               phiqq=atan2(plund(nl,2),plund(nl,1))
             end if
           end if
         end if
  13    continue
         if(ijet.eq.0.or.ijet.gt.2) then
           nll=nll+1
           do 522 i=1,5
 522       plund(nll,i)=plund(nl,i)
           k(nll,1)=k(nl,1)
           k(nll,2)=k(nl,2)
         else
           ijet=ijet+1
         end if
  14    continue
        if(ijet.eq.3) then
          nsave=nsave-2
          nlund=nlund-2
          if(ihatot.eq.2) then
            nl=nlund+1
            mst(1)=nl
            mst(2)=nl
            thetlu=thetqq
            philu=phiqq
            if(klchar.eq.2) then
              zrand=2.*ranf(0)-1.0
              if(zrand.lt.0.) then
                ct=-(-zrand)**0.333333
              else
                ct=zrand**0.333333
              end if
            else
              ct=1.0
            end if
            st=sqrt(1.-ct*ct)
            plund(nl,4)=0.0
            plund(nl,3)=ct
            plund(nl,1)=st
            plund(nl,2)=0.0
            call lurobo(thetlu,philu,0.0,0.0,0.0)
            emmoth=sqrt(pp)
            emda=plund(nlund-1,5)
            emdb=plund(nlund,5)
            if(emmoth.lt.emda+emdb) then
              call errex('lddec: trouble, ida(50)')
            else
              pabs=pcmsr(emmoth,emda,emdb)
            end if
            do 501 j=1,3
             plund(nl,j)=pabs*plund(nl,j)
             plund(nl+1,j)=-plund(nl,j)
  501       continue
            plund(nl,4)=sqrt(emda**2+pabs**2)
            plund(nl+1,4)=sqrt(emdb**2+pabs**2)
            mst(2)=nl+1
            bex=bx
            bey=by
            bez=bz
            call lurobo(0.,0.,bex,bey,bez)
            do 502 j=1,4
             plund(nlund-1,j)=plund(nl,j)
             plund(nlund,j)=plund(nl+1,j)
  502       continue
            mst(1)=0
            mst(2)=0
          end if
        end if
      end if
      do 20 lloop=nsave+1,nlund
      ks=k(lloop,1)/10000
      kfm=k(lloop,2)
      if(ks.gt.1) go to 20
      if(scayes) then
        if(iabs(kfm).ne.17) then
          call errex('lddec:rho0==>pi+ +pi- expected')
        end if
        kfm=23
      end if
      call luiflv(kfm,ifla,iflb,iflc,ksp)
      call transl(1,itpl,npidl,kfm)
      if(iflc.eq.0) then
         lnbar=0
      else
         lnbar=isign(1,iflc)
      end if
      lfill=0
      if(lindf.eq.1.and.((kfm.ne.1.or.lloop.eq.nlund)
     a                                 .or.kdt.ge.ndt)) then
         if(lnbar.eq.ldbar) then
           lfill=1
         end if
      end if
      if(lfill.eq.1) then
          l=ind
          lindf=0
      else
                npion=npion+1
                if((nrmes(kclst)+nrbar(kclst).eq.iclusz(kclst))
     a            .or.(kfm.eq.1.and.kdt.lt.ndt)) then
                   if(kclst.eq.itripl .and. kdt.lt.idtcl
     b                                         .and. kfm.ne.1) then
                      call errex('lddec: iclusz(itripl) too low')
                   end if
                   io=0
                   do 45 kcl=1,nrclst
  45               io=io+iclusz(kcl)
                   nrclst=nrclst+1
                   nrbar(nrclst)=0
                   nrmes(nrclst)=1
                   iclusz(nrclst)=1
                   nonrel(nrclst)=.false.
                   l=io+1
                   lmax=l
                else if(nrmes(kclst)+nrbar(kclst).lt.iclusz(kclst))then
                   nrmes(kclst)=nrmes(kclst)+1
                   l=iofset+nrbar(kclst)+nrmes(kclst)
                else
                   call errex('lddec:nrbar+nrmes.gt.iclusz  ???? ')
                end if
                nprtcl=nprtcl+1
                if(nprtcl.gt.ntotma) then
                   call errex('lddec:nprtcl>ntotma, abort')
                end if
                issn(l)=nprtcl
      end if
      if(kdt.le.ndt) then
        lastcl(l)=ievnt
      else
        lastcl(l)=-1
      end if
      if(l.eq.ind) then
        nidhad=ident
      else
        nidhad=nprtcl
      end if
      eml=plund(lloop,5)
      p1(0)=plund(lloop,4)
      do 21 i=1,3
  21  p1(i)=plund(lloop,i)
      iposit=0
      if(l.ne.ind) then
        iposit=1
        if(iabs(kfm).le.10) then
          iposit=-1
        end if
      end if
      if(iposit.eq.1) then
         deltr=drind*sqrt(ranf(0))
         phi=pi2*ranf(0)
         costet=1.-2.*ranf(0)
         sintet=sqrt(1.-costet*costet)
         xrel=deltr* sintet* sin(phi)
         yrel=deltr* sintet* cos(phi)
         zrel=deltr* costet
         xb=bx*xrel+by*yrel+bz*zrel
         gg=(gam-1.)*xb/b2
         dr(0)=gam*xb
         dr(1)=gg*bx+xrel
         dr(2)=gg*by+yrel
         dr(3)=gg*bz+zrel
         do 31 i=0,3
  31     x(i,l)=xold(i)+dr(i)
         wait=100.
         ixnew=0
         twait=timelf(wait,eml,p1(1),p1(2),p1(3))
  27     continue
          ixnew=ixnew+1
          if(ixnew.gt.5) then
              write(lun8,*) 'ixnew>5 in lddec'
              write(lun8,*) ident
              write(lun8,*) (p1(i),i=0,3),eml
              write(lun8,*) 'tw=',twait,'xnew(0)=',xnew(0)
              do 128 i=0,3
               x(i,l)=xold(i)
 128          continue
              twait=0.001*p1(0)
          end if
          do 228 i=0,3
           xnew(i)=x(i,l)+p1(i)/p1(0)*twait
           qlk(i)=xnew(i)-xold(i)
 228      continue
          irturn=0
          dqlksq=qlk(0)*qlk(0)
          do 19 i=1,3
  19       dqlksq=dqlksq-qlk(i)*qlk(i)
          if(ixnew.lt.10) then
            if(dqlksq.le.0..or.qlk(0).le.0.) then
                irturn=1
            end if
          end if
          if(irturn.eq.1) then
             delqp=qlk(0)*ptot(0)
             pindsq=ptot(0)*ptot(0)
             do 33 i=1,3
              pindsq=pindsq-ptot(i)*ptot(i)
              delqp=delqp-qlk(i)*ptot(i)
  33         continue
             val=delqp/pindsq
             arg=(0.01-dqlksq)/pindsq+val*val
             if(arg.lt.0.) then
                if(-arg.gt.0.01) then
                   write(lun8,*) 'arg.lt.0 in lddec,33  ???????? ',arg
                   call errex('numerical problem in lddec')
                end if
                arg=0.
             else
                arg=sqrt(arg)
             end if
             delts=-val+arg
             do 32 i=0,3
               x(i,l)=xnew(i)+ptot(i)*delts
  32         continue
             twait=0.01
             go to 27
          end if
          do 26 i=0,3
            x(i,l)=xnew(i)
  26      continue
      else if(iposit.eq.-1) then
        do 34 i=0,3
  34    x(i,l)=xold(i)
      end if
      tlast(l)=x(0,l)
      ylast(nidhad)=0.5*log((p1(0)+p1(3))/(p1(0)-p1(3)))
      zlast(nidhad)=x(3,l)-(pnorm(0)*x(0,l)-pnorm(3)*x(3,l))*pnorm(3)
      ichbig(l)=0
      ityp(l)=itpl
      npidec(l)=npidl
      em(l)=eml
      do 28 i=0,3
   28 p(i,l)=p1(i)
      kfa=iabs(kfm)
      if(kfa.lt.100)then
         idc=kfa
      else
         idc=76+5*ifla+ksp
      end if
      if(l.ne.ind.or.kfa.le.16) then
        tdtg(nidhad)=0.0
        itdth(1,nidhad)=0
        itdth(2,nidhad)=0
        itdth(3,nidhad)=0
        itdth(4,nidhad)=0
      end if
      itdth(5,nidhad)=0
      if(ntag.eq.0) then
        if(ida(38).eq.3.or.ida(38).eq.4) then
          idntl=issn(l)
          kstor(idntl,1)=kl2
          if(ifndnx.eq.1.and.prtgam(idcold).lt.0.) then
            kstor(idntl,1)=0
          end if
          if(ida(38).eq.3) then
            do 203 i=1,4
  203       stork(idntl,i)=x(i-1,l)
          else
            do 204 i=1,4
  204       stork(idntl,i)=stork(ident,i)
          end  if
          do 403 i=6,8
           stork(idntl,i)=p(i-5,l)
  403     continue
        else if(ida(38).eq.1.or.ida(38).eq.2.or.
     a                            ida(38).eq.7) then
          if(ida(38).eq.1.or.ida(38).eq.2) then
            jeng=1
          else
            jeng=0
          end if
          emil=em(l)
          if(issers(jeng,ida(38),ityp(l),npidec(l),emil))then
                 idntl=issn(l)
                 stork(idntl,1)=stork(ident,1)
                 stork(idntl,2)=stork(ident,2)
                 stork(idntl,3)=stork(ident,3)
                 stork(idntl,4)=stork(ident,4)
                 stork(idntl,5)=stork(ident,5)
                 kstor(idntl,1)=kstor(ident,1)
                 kstor(idntl,2)=kstor(ident,2)
                 kstor(idntl,3)=kstor(ident,3)
                 kstor(idntl,4)=kstor(ident,4)
                 kstor(idntl,5)=kstor(ident,5)
                 kstor(idntl,6)=kstor(ident,6)
                 kstor(idntl,7)=kstor(ident,7)
  888            format(1x,5(f7.3,1x))
  889            format(1x,5(i7,1x),2(i4,1x))
  890            format(1x,4(i7,1x),1x,4(f7.3,1x))
          end if
        end if
      end if
        if(prtgam(idc).gt.0.) then
          gamact=prtgam(idc)
          decay(l)=x(0,l)+
     a           timelf(gamact,eml,p1(1),p1(2),p1(3))
        else
          decay(l)=1.e+35
        end if
        iswprp=0
        if(ida(15).ne.0) then
          if(lnbar.ne.0.or.itdth(2,nidhad).ne.0) then
          else
            do 346 i=0,3
 346        qdot(i,l)=0.
            ichbig(l)=3
          end if
        end if
        if(kdt.le.ndt.and.l.le.iofset+iclusz(kclst).and.ntag.eq.0) then
          iexpo=0
          if(xold(0).lt.tdtg(nidhad).and.
     a                       itdth(2,nidhad).ne.0) then
            call qdrot(l,nidhad,bx,by,bz)
            decay(l)=tdtg(nidhad)
            iexpo=iexpon
          end if
          if(iexpo.eq.0.or.qdot(0,l).eq.0.0) then
            do 206 i=0,3
  206       xform(i)=x(i,l)
          else
            do 202 i=0,3
  202       xform(i)=x(i,l)+qdot(i,l)/qdot(0,l)*
     a                          (decay(l)-x(0,l))
          end if
          if(ida(25).eq.1.and.ntag.eq.0.and.(ifndnx.eq.0.or.
     a                                 prtgam(idcold).gt.0.)) then
            write(lun15,662) ityp(l),npidec(l),(p(i,l),i=0,3),em(l),
     a                     iexpo,issn(l),xform(0),
     b                          xform(1),xform(2),xform(3)
          end if
          if(ida(42).eq.1.and.ifndnx.eq.0) then
            identl=issn(l)
            write(lun7)
     &           ityp(l),issn(l),npidec(l),
     &           x(0,l),x(1,l),x(2,l),x(3,l),
     &           p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &           tdtg(identl),itdth(2,identl),itdth(3,identl)
            if(iexpo.ne.0) then
              write(lun7)
     &           ityp(l),issn(l),npidec(l),
     &           (xform(i),i=0,3),
     &           p(0,l),p(1,l),p(2,l),p(3,l),em(l),
     &           0.0,0,0
            end if
          end if
          call propag(l,-2,iswprp)
        else
          do 347 i=0,3
 347      qdot(i,l)=0.
        end if
  20   continue
       if(ida(25).eq.1.and.ntag.eq.0.and.(ifndnx.eq.0.or.
     a                                 prtgam(idcold).gt.0.)) then
         if(ida(36).eq.1) then
           if(ifndnx.eq.0) then
             call dnscal(1,ind,-1,dens1)
             write(lun15,663) dens1
           else
             write(lun15,663)  0.
           end if
         end if
  663    format(1x,1(f6.3,1x))
       end if
       nlund=nsave
      return
      end
      subroutine  jetcon(inew,nchain,
     a          ema,emb,px,py,pz,emj,itp,npid,identj,bxj,byj,bzj)
      include 'scatter7'
#include "amsrqmd.h"
      real*4 bex,bey,bez,thetlu,philu
      real*4 bextst,beytst,beztst
      real*4 plund,par
      include 'partblk7'
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
      common /seabk/kchain,iofcha,isea(18),psea(0:3,18),isoan,iqqst,
     a              emsmb
      data lang /5/
       ijet=0
       ilist=nlund+1
       nlu=nlund
       do 13 nl=1,nlund
        kh=mod(k(nl,1),100000)
        ks=k(nl,1)/100000
        if(ks.eq.4) then
          if(kh.eq.identj) then
            ilist=nl
            ijet=1
          end if
        end if
   13  continue
      call transl(-1,itp,npid,kl2)
       kl2=(-1)**iqcnvt*kl2
       if(ijet.eq.0)then
          nlund=nlund+2
          if(nlund.ge.2000)
     a       call errex('lund storage too small, abort in string')
       end if
       pp=px*px+py*py+pz*pz
       plund(ilist,5)=ema
       plund(ilist+1,5)=emb
       if(mod(inew,2).eq.0) then
         aq=0.5*(1.+sqrt(1.+emj*emj/pp))
         plund(ilist,4)=aq*sqrt(pp)
       else
         aq=0.5/sqrt(pp)*emj
         plund(ilist,4)=0.5*emj
         plund(ilist+1,4)=0.5*emj
       end if
       plund(ilist,1)=aq*px
       plund(ilist,2)=aq*py
       plund(ilist,3)=aq*pz
       if(mod(inew,2).eq.0) then
         aq=1.-aq
         plund(ilist+1,4)=abs(aq)*sqrt(pp)
       else
         aq=-aq
       end if
       plund(ilist+1,1)=aq*px
       plund(ilist+1,2)=aq*py
       plund(ilist+1,3)=aq*pz
       bex=bxj
       bey=byj
       bez=bzj
       nstrin=0
       if(nchain.lt.0) then
         nlund=nlund-2
         kchain=kchain-1
         nchain=nchain+1
       else if(nchain.gt.0) then
         if(mod(inew,2).ne.0)
     a        call errex('jetcon:nchain/inew.ne.0 conflict')
         zqsum=0.
         zqbsum=0.
         kncha=0
         do 1  incha=1,9
          ncha=9*iofcha+incha
          if(isea(ncha).ne.0) then
            kncha=kncha+1
            zqsum=zqsum+psea(0,ncha)
            zqbsum=zqbsum+psea(3,ncha)
          end if
    1    continue
         if(abs(zqsum).gt.1.0.or.abs(zqbsum).gt.1.0)
     a       call errex('jetcon: wrong zqsum/zqbsum')
         emstcq=sqrt((1.-zqsum)*(1.-zqbsum))*emj
         kt=-1
         call torsts(emstcq,kl2,idum1,idum2,dum1,dum2,kt)
         if(kt.eq.-1) then
           nchain=nchain-kncha
           do 11 incha=1,9
            ncha=9*iofcha+incha
            isea(ncha)=0
   11      continue
         else
           zqsum=1.
           zqbsum=1.
           do 5  incha=1,9
            ncha=9*iofcha+incha
            if(isea(ncha).ne.0) then
              zq=psea(0,ncha)
              zqbar=psea(3,ncha)
              if(zq.lt.0.0.or.zq.gt.1.0) then
                call errex('jetcon: wrong zq ')
              end if
              if(zqbar.lt.0.0.or.zqbar.gt.1.0) then
                call errex('jetcon: wrong zqbar ')
              end if
              iliup=max(nlu,ilist+1)+2*nstrin+1
              if(iliup.ge.2000)
     a        call errex('lund storage too small, abort in string')
              do 2 i=1,4
               plund(iliup,i)=zq*plund(ilist,i)
               plund(iliup+1,i)=zqbar*plund(ilist+1,i)
    2         continue
              plund(iliup,5)=0.
              plund(iliup+1,5)=0.
              emsea=(plund(iliup,4)+plund(iliup+1,4))**2
              do 3 i=1,3
               emsea=emsea-(plund(iliup,i)+plund(iliup+1,i))**2
    3         continue
              emsea=sqrt(emsea)
              if(emsea.gt.0.28) then
                nstrin=nstrin+1
                kchain=kchain+1
                psea(0,ncha)=plund(iliup,4)+plund(iliup+1,4)
                do 6 i=1,3
    6           psea(i,ncha)=plund(iliup,i)+plund(iliup+1,i)
                zqsum=zqsum-zq
                zqbsum=zqbsum-zqbar
                nlund=nlund+2
                mst(1)=iliup
                mst(2)=iliup+1
                bextst=psea(1,ncha)/psea(0,ncha)
                beytst=psea(2,ncha)/psea(0,ncha)
                beztst=psea(3,ncha)/psea(0,ncha)
                philu=pi2*ranf(0)
                cang=0.10/emsea
                aang=(1.-lang)/((cang+1.)**(1-lang)-cang**(1-lang))
                dang=-aang/(1.-lang)*cang**(1-lang)
                sthet=((1-lang)*
     a                      (ranf(0)-dang)/aang)**(1./(1.-lang))-cang
                if(sthet.lt.0. .or.sthet.gt.1.0) then
                  write(lun8,*) 'sthet unclear in jetcon',sthet
                  cthet=cvalu1
                else
                  cthet=sqrt(cvalu1-sthet)
                end if
                thetlu=acos(cthet)
                if(switch(19)) thetlu=0.
                call lurobo(0.,0.,-bextst,-beytst,-beztst)
                call lurobo(thetlu,philu,bextst,beytst,beztst)
                call lurobo(0.,0.,bex,bey,bez)
                mst(1)=0
                mst(2)=0
                k(iliup,1)=400000+nprtcl+kchain
                k(iliup,2)=40
                k(iliup+1,1)=400000
                k(iliup+1,2)=0
              else
                isea(ncha)=0
                nchain=nchain-1
              end if
            end if
    5      continue
           if(nstrin.gt.0) then
             do 4 i=1,4
              plund(ilist,i)=zqsum*plund(ilist,i)
              plund(ilist+1,i)=zqbsum*plund(ilist+1,i)
    4        continue
             emj=sqrt(zqsum*zqbsum)*emj
             px=plund(ilist,1)+plund(ilist+1,1)
             py=plund(ilist,2)+plund(ilist+1,2)
             pz=plund(ilist,3)+plund(ilist+1,3)
           end if
         end if
       end if
       mst(1)=ilist
       mst(2)=ilist+1
       call lurobo(0.,0.,bex,bey,bez)
       mst(1)=0
       mst(2)=0
       if(identj.ge.100000) then
         call errex('jetcon:identj>100000 not allowed')
       end if
       k(ilist,1)=400000+identj
       k(ilist,2)=iqqst
       k(ilist+1,1)=400000
       k(ilist+1,2)=0
       if(isoan.ne.0) then
         k(ilist+1,2)=isoan
       else if(inew.eq.1) then
         k(ilist+1,2)=2
       else if(inew.eq.2.or.ijet.eq.1) then
         k(ilist+1,2)=3
       else if(inew.eq.4) then
         k(ilist+1,2)=1
       end if
       inew=ijet
      return
      end
      subroutine makjet(ind)
       include 'scatter7'
#include "amsrqmd.h"
       include 'partblk7'
       common /seabk/kchain,iofcha,isea(18),psea(0:3,18),isoan,iqqst,
     a              emsmb
       logical jets
         ident=issn(ind)
         nchain=0
         isoan=0
         iqqst=0
         emsmb=0.0
         inew=0
         emind=em(ind)
         itpind=ityp(ind)
         npid=npidec(ind)
         if(jets(itpind,npid,emind,0)) then
           bx=p(1,ind)/p(0,ind)
           by=p(2,ind)/p(0,ind)
           bz=p(3,ind)/p(0,ind)
           thet=pi*ranf(0)
           phi=pi2*ranf(0)
           pz=cos(thet)
           px=sin(thet)*cos(phi)
           py=sin(thet)*sin(phi)
           ema=emind
           emb=0.0
           call jetcon(inew,nchain,
     a          ema,emb,px,py,pz,emind,itpind,npid,ident,bx,by,bz)
         end if
      return
      end
      subroutine purglu(ident)
      include 'scatter7'
#include "amsrqmd.h"
      real*4 plund
      include 'partblk7'
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      data ncrit/600/
       ijet=0
       nll=0
       do 13 nl=1,nlund
        kh=mod(k(nl,1),100000)
        ks=k(nl,1)/100000
        if(ks.eq.4) then
          if(kh.eq.0) then
          else if(kh.eq.ident) then
            ilist=nl
            ijet=1
          else if(ijet.ne.2) then
            if(nlund.gt.ncrit) then
              do 18 l=iofset+1,iofset+nrbar(kclst)+nrmes(kclst)
               if(kh.eq.issn(l).and.ityp(l).eq.-9999) then
                 if(ityp(l).eq.-9999) then
                   ijet=1
                   go to 19
                 else if(decay(l).gt.1.0e+10) then
                   ijet=1
                   go to 19
                 end if
               end if
   18         continue
   19         continue
            end if
          end if
        end if
        if(ijet.eq.0.or.ijet.gt.2) then
          nll=nll+1
          do 11 i=1,5
   11     plund(nll,i)=plund(nl,i)
          k(nll,1)=k(nl,1)
          k(nll,2)=k(nl,2)
        else
          ijet=ijet+1
        end if
   13  continue
       if(ijet.ne.0) nlund=nll
      return
      end
CPAT,STRIST   .
      subroutine strist
      include 'scatter7'
#include "amsrqmd.h"
      real*4 plund,par
      real*4 bex,bey,bez,thetlu,philu
      real*4 embang,bpli,emtrue,sigptr
      logical reject
      parameter (kbpmax=750)
      logical icross(2,kbpmax),newbp(kbpmax)
      dimension ptot(0:3),xbang(0:3)
      dimension pq(0:3),pqbar(0:3)
      dimension p1(0:3),p2(0:3),psum(0:3),ptsum(2)
      include 'partblk7'
      parameter (mxs=200)
      parameter (mxs1=mxs+1)
      common /rop1bk/ lstar(mxs),lende(mxs),iroin,iroout
      dimension pqt(0:3,mxs)
      dimension  isingl(mxs),jqpart(mxs),iflstr(2,mxs),psingl(2)
      dimension  kstar(mxs),kende(mxs)
      real*4  barwgh,para11
      dimension  iqqkf(2,mxs),mqflav(2,mxs)
      common /rop2bk/ kparnt(3,mxs),
     a   xori(0:3,mxs),pqu(0:3,mxs),pqb(0:3,mxs)
      logical nghbor
      parameter (kbpmd2=kbpmax/2+1)
      real*4 xhad(4,kbpmd2)
      logical manip
      common /rop3bk/manip(mxs)
      dimension xlcrop(2),plcrop(2),plcfor(2),pspent(2),ps(2)
      dimension
     a                iflv(2,mxs),jord(mxs),iord(2,mxs),
     b                ipdgr(2,mxs1),iqdgr(2,mxs1),
     c                pt(2,mxs),plc(2,mxs),
     c                ptstor(2,mxs),jflv(2,mxs),plcone(2,mxs),
     d                korig(mxs),korsto(mxs)
      real*4 xlcbp,xlcmx,equark,ptr
      real*4 dquark(2,kbpmax)
      dimension jetzhd(2,kbpmax)
      common /ropblk/
     a                ivlc(2,kbpmax),lord(2,kbpmax),
     b                ipact(2,kbpmax),iqact(2,kbpmax),ipiq(kbpmax),
     c                iquark(2,kbpmax),icomb(2,kbpmax),
     d                xlcbp(2,kbpmax),xlcmx(2,kbpmax),
     e                equark(2,kbpmax),ptr(2,2,kbpmax)
      real*4 atrmax,emqcns,emq,ems,prbrop,qmass,atrel,tnsmax,dndx4m
      parameter (iprbr1=16,iprbr2=iprbr1*(iprbr1+3)/2)
      common /ptubeb/ atrmax,
     a               tnsmax,dndx4m,emqcns,emq,ems,prbrop(14,152)
      common /bplibk/ libpmx,bpli(2,kbpmax)
      common /lujets/ nlund,k(2000,2),plund(2000,5)
      common/ludat1s/mst(40),par(80)
      real*4 angmxv,angeff
      common /su3mix/ angmxv,angeff
      logical ttvers
      data xcutf /2.5 /
      data  para11 /0.15/
      data qqdqqs /0.6667/
      data ttvers/.true./
      save  gprd
      data nsupp,ssupp,qsupp/ 3*0/
      dimsu3(ipd,iqd)=0.5*(ipd+1.0)*(iqd+1.0)*(ipd+iqd+2.0)
      casop(ipd,iqd)=0.333333*(ipd-iqd)**2+ipd+iqd+ipd*iqd
      if(ttvers) then
        ttvers=.false.
        if(tprd.gt.1.e-30) then
           gprd=1./tprd*hc/pi2
        else
           gprd=1.e+29
        end if
      end if
       if(iroin.eq.1.or.iroin.eq.0) return
       if(iroin.eq.-1) then
         nstrin=1
         iroin=1
       else
         nstrin=0
       end if
       nmult=0
       if(para11/par(11).gt.1.0) then
         call errex('strist problem with para11')
       end if
       par2=par(2)
       par11=par(11)
       atre=da(17)**2/0.49
       if(iroin.gt.mxs) then
         call errex('iroin>mxs in strist, abort')
         return
       end if
       do 30 i=0,3
        psum(i)=0.0
        ptot(i)=0.0
        xbang(i)=0.0
   30  continue
       do 40 iro=1,iroin
        manip(iro)=.false.
        ksta=lstar(iro)
        ke=lende(iro)
        kstar(iro)=ksta
        kende(iro)=ke
        do 26 i=0,3
   26   pqt(i,iro)=0.0
        do 28 ik=ksta,ke
         do 27 i=0,3
   27    pqt(i,iro)=pqt(i,iro)+p(i,ik)
   28   continue
        do 29 i=0,3
         ptot(i)=ptot(i)+pqu(i,iro)+pqb(i,iro)
         psum(i)=psum(i)+pqt(i,iro)
   29   continue
   40  continue
       betax=psum(1)/psum(0)
       betay=psum(2)/psum(0)
       betaz=psum(3)/psum(0)
       bex=-betax
       bey=-betay
       bez=-betaz
       nsave=nlund
       if(nlund+2*iroin+1.ge.2000) then
         call errex('strist:nlund>2000, abort')
       else
         nlund=nlund+2*iroin
         nl=nsave
         do 42 iro=1,iroin
          plund(nl+1,4)=pqu(0,iro)
          plund(nl+2,4)=pqb(0,iro)
          do 41 i=1,3
           plund(nl+1,i)=pqu(i,iro)
           plund(nl+2,i)=pqb(i,iro)
   41     continue
          nl=nl+2
   42    continue
       end if
       mst(1)=nsave+1
       mst(2)=nlund
       call lurobo(0.,0.,bex,bey,bez)
       pabmax=0.0
       iwo=0
       do 31 nl=nsave+1,nlund,2
        pabs=sqrt((plund(nl,4)+plund(nl+1,4))**2
     a            -((plund(nl,1)+plund(nl+1,1))**2+
     b                  (plund(nl,2)+plund(nl+1,2))**2+
     c                          (plund(nl,3)+plund(nl+1,3))**2))
        if(pabs.gt.pabmax) then
           pabmax=pabs
           iwo=nl
        end if
   31  continue
       nmax=nlund
       nlund=nlund+1
       do 11 i=1,4
   11  plund(nlund,i)=0.0
       do  8 nl=nsave+1,nmax,2
        cthet1=0.0
        cthet2=0.0
        pqabs=0.0
        pqbabs=0.0
        do  9 i=1,3
         cthet1=cthet1+plund(nl,i)*plund(iwo,i)
         cthet2=cthet2+plund(nl+1,i)*plund(iwo,i)
         pqabs=pqabs+plund(nl,i)**2
         pqbabs=pqbabs+plund(nl+1,i)**2
    9   continue
        pqabs=sqrt(pqabs)
        pqbabs=sqrt(pqbabs)
        cthet1=cthet1/pabmax/pqabs
        cthet2=cthet2/pabmax/pqbabs
        if(nl.eq.iwo.or.nl+1.eq.iwo) then
          if(nl.eq.iwo) then
            ivz1=1
            ivz2=-1
          else
            ivz1=-1
            ivz2=1
          end if
        else if(cthet1.gt.cthet2) then
         ivz1=1
         ivz2=-1
        else
         ivz2=1
         ivz1=-1
        end if
        do 12 i=1,4
   12   plund(nlund,i)=plund(nlund,i)+ivz1*
     a                 plund(nl,i)+ivz2*plund(nl+1,i)
   8   continue
       pabs=sqrt(plund(nlund,1)*plund(nlund,1)+
     a                  plund(nlund,2)*plund(nlund,2)+
     b                          plund(nlund,3)*plund(nlund,3))
       thetr=acos(max(-cvalu1,min(cvalu1,plund(nlund,3)/pabs)))
       if(plund(nlund,2).eq.0.0.and.
     a                         plund(nlund,1).eq.0.0) then
            phir=cvalu0
       else
            phir=atan2(plund(nlund,2),plund(nlund,1))
       end if
       thetlu=-thetr
       philu=-phir
       kbaryo=0
       kstran=0
       kcharg=0
       nlund=nsave+3
       mst(1)=nsave+1
       mst(2)=nlund
       do 51 iro=1,iroin
        plund(nsave+1,4)=pqb(0,iro)
        do  44 i=1,3
   44   plund(nsave+1,i)=pqb(i,iro)
        plund(nsave+2,4)=pqu(0,iro)
        do 45 i=1,3
   45   plund(nsave+2,i)=pqu(i,iro)
        plund(nlund,4)=pqt(0,iro)
        do 43 i=1,3
   43   plund(nlund,i)=pqt(i,iro)
        call lurobo(0.,0.,bex,bey,bez)
        call lurobo(0.,philu,0.,0.,0.)
        call lurobo(thetlu,0.,0.,0.,0.)
        pqbar(0)=plund(nsave+1,4)
        do 46 i=1,3
   46   pqbar(i)=plund(nsave+1,i)
        pq(0)=plund(nsave+2,4)
        do 47 i=1,3
   47   pq(i)=plund(nsave+2,i)
        if(pq(3)*pqbar(3).lt.0.) then
          if(pq(3).gt.0.) then
            iturn=1
          else
            iturn=-1
          end if
          if(kende(iro).gt.kstar(iro)) then
            iflv(2,iro)=0
          else
            iflv(2,iro)=1
          end if
        else
          if(pq(3).gt.pqbar(3)) then
            iturn=1
          else
            iturn=-1
          end if
          iflv(2,iro)=1
        end if
        iflv(1,iro)=iturn
        mpar1=kparnt(1,iro)
        mpar2=kparnt(2,iro)
        if(iturn.eq.-1) then
          kparnt(1,iro)=-mpar1
          kparnt(2,iro)=-mpar2
        end if
        do 38 i=1,2
   38   ptstor(i,iro)=plund(nlund,i)
        pplus=plund(nlund,4)+plund(nlund,3)
        pminus=plund(nlund,4)-plund(nlund,3)
        plcone(1,iro)=pplus
        plcone(2,iro)=pminus
   51  continue
       do 15 iro=1,iroin
        if(iflv(2,iro).eq.0) go to 15
        jdir=0
        mpar1=kparnt(1,iro)
        mpar2=kparnt(2,iro)
        if(mpar1.lt.0.or.mpar2.lt.0) then
          mpar1=-mpar1
          mpar2=-mpar2
          call iswap(mpar1,mpar2)
        end if
        if(mpar1.gt.n1old+n2old.and.mpar2.gt.n1old+n2old) go to 15
        do 14 iroeff=1,iroin
         if(iflv(2,iroeff).ne.0) go to 14
         if(iro.eq.iroeff) go to 14
         npar1=kparnt(1,iroeff)
         npar2=kparnt(2,iroeff)
         if(npar1.lt.0.or.npar2.lt.0) then
           npar1=-npar1
           npar2=-npar2
           call iswap(npar1,npar2)
         end if
         if(mpar1.gt.n1old.and.mpar1.le.n1old+n2old) then
           if(npar1.gt.n1old.and.npar1.le.n1old+n2old) then
             jdir=jdir+1
           else if(npar1.le.n1old) then
             jdir=jdir-1
           end if
           if(npar2.gt.n1old.and.npar2.le.n1old+n2old) then
             jdir=jdir-1
           else if(npar2.le.n1old) then
             jdir=jdir+1
           end if
         else if(mpar1.le.n1old) then
           if(npar1.gt.n1old.and.npar1.le.n1old+n2old) then
             jdir=jdir-1
           else if(npar1.le.n1old) then
             jdir=jdir+1
           end if
           if(npar2.gt.n1old.and.npar2.le.n1old+n2old) then
             jdir=jdir+1
           else if(npar2.le.n1old) then
             jdir=jdir-1
           end if
         end if
         if(mpar2.gt.n1old.and.mpar2.le.n1old+n2old) then
           if(npar2.gt.n1old.and.npar2.le.n1old+n2old) then
             jdir=jdir+1
           else if(npar2.le.n1old) then
             jdir=jdir-1
           end if
           if(npar1.gt.n1old.and.npar1.le.n1old+n2old) then
             jdir=jdir-1
           else if(npar1.le.n1old) then
             jdir=jdir+1
           end if
         else if(mpar2.le.n1old) then
           if(npar2.gt.n1old.and.npar2.le.n1old+n2old) then
             jdir=jdir-1
           else if(npar2.le.n1old) then
             jdir=jdir+1
           end if
           if(npar1.gt.n1old.and.npar1.le.n1old+n2old) then
             jdir=jdir+1
           else if(npar1.le.n1old) then
             jdir=jdir-1
           end if
         end if
   14   continue
        if(jdir.lt.0) then
          kparnt(1,iro)=-kparnt(1,iro)
          kparnt(2,iro)=-kparnt(2,iro)
          iflv(1,iro)=-iflv(1,iro)
        end if
   15  continue
       nlund=nsave+1
       mst(1)=nlund
       mst(2)=nlund
       do 160 iro=1,iroin
       do 160 jt=1,2
  160  iflstr(jt,iro)=0
       do 16 iro=1,iroin
        do 19 igo=1,2
         if(kparnt(3,iro).eq.-1) go to 16
         ifrgn1=0
         ifrgn2=0
         mpar1=kparnt(1,iro)
         mpar2=kparnt(2,iro)
         if(mpar1.lt.0.or.mpar2.lt.0) then
           mpar1=-mpar1
           mpar2=-mpar2
           call iswap(mpar1,mpar2)
         end if
         pyes1=0.0
         pyes2=0.0
         pno1=0.0
         pno2=0.0
         nyes1=0
         nyes2=0
         nno1=0
         nno2=0
         kdabei=0
         do 17 iroeff=1,iroin
          if(iro.eq.iroeff) go to 17
          if(kparnt(3,iroeff).eq.-1) go to 17
          npar1=kparnt(1,iroeff)
          npar2=kparnt(2,iroeff)
          if(npar1.lt.0.or.npar2.lt.0) then
            npar1=-npar1
            npar2=-npar2
            call iswap(npar1,npar2)
          end if
          kforb=0
          if(mpar1.ne.npar1.and.mpar1.ne.npar2.and.
     a            mpar2.ne.npar1.and.mpar2.ne.npar2) then
            kdabei=1
            pno1=pno1+plcone(1,iroeff)
            pno2=pno2+plcone(2,iroeff)
          else if(mpar1+mpar2.eq.npar1+npar2) then
            kforb=1
            nyes1=nyes1+1
            nyes2=nyes2+1
            pyes1=pyes1+plcone(1,iroeff)
            pyes2=pyes2+plcone(2,iroeff)
          else
            kdabei=1
            if(mpar1.eq.npar1) then
              pyes1=pyes1+plcone(1,iroeff)
            else
              pno1=pno1+plcone(1,iroeff)
            end if
            if(mpar2.eq.npar2) then
              pyes2=pyes2+plcone(2,iroeff)
            else
              pno2=pno2+plcone(2,iroeff)
            end if
          end if
          if(kforb.eq.0) then
            if(iflstr(1,iroeff).eq.0) then
              nno1=nno1+1
              if(igo.eq.2.and.nno1.eq.nfrgn1) ifrgn1=iroeff
            else
              nyes1=nyes1+1
            end if
            if(iflstr(2,iroeff).eq.0) then
              nno2=nno2+1
              if(igo.eq.2.and.nno2.eq.nfrgn2) ifrgn2=iroeff
            else
              nyes2=nyes2+1
            end if
          end if
   17    continue
         psum1=pyes1+pno1
         psum2=pyes2+pno2
         if(igo.eq.1) then
           if(kdabei.eq.0) then
             kparnt(3,iro)=-1
           else
             nfrgn1=min(int(ranf(0)*nno1)+1,nno1)
             nfrgn2=min(int(ranf(0)*nno2)+1,nno2)
           end if
         else if(psum1.eq.cvalu0.or.psum2.eq.cvalu0) then
           kparnt(3,iro)=-1
         else
           if(ranf(0).gt.pno1/psum1) then
             jcut1=1
           else
             jcut1=0
           end if
           if(ranf(0).gt.pno2/psum2) then
             jcut2=1
           else
             jcut2=0
           end if
           if(jcut1+jcut2.eq.0) go to 16
           if(ifrgn1.gt.iroin.or.ifrgn2.gt.iroin)
     a     call errex('strist:ifrgn problem')
           if(ifrgn1.eq.0) then
             kparnt(3,iro)=-1
             go to 16
           else
             plcmx1=plcone(1,ifrgn1)
           end if
           if(ifrgn2.eq.0) then
             kparnt(3,iro)=-1
             go to 16
           else
             plcmx2=plcone(2,ifrgn2)
           end if
           lb=kstar(iro)
           le=kende(iro)
   49      continue
           if(jcut1.eq.1) then
             if(plcone(1,iro).le.plcmx1) jcut1=0
           end if
           if(jcut2.eq.1) then
             if(plcone(2,iro).le.plcmx2) jcut2=0
           end if
           if(jcut1+jcut2.eq.0) then
             go to 48
           else if(jcut1*jcut2.eq.1) then
             if(ranf(0).gt.0.5) then
               jt=1
             else
               jt=2
             end if
           else if(jcut1.eq.1) then
             jt=1
           else
             jt=2
           end if
           if(jt.eq.1) then
             iflstr(1,ifrgn1)=1
           else
             iflstr(2,ifrgn2)=1
           end if
           if((kparnt(1,iro).gt.0.and.jt.eq.1).or.
     a        (kparnt(2,iro).lt.0.and.jt.eq.2)) then
             lact=lb
           else
             lact=le
           end if
           if(lb.gt.le) then
             kparnt(3,iro)=-1
             go to 16
           end if
           do 69 i=1,4
   69      plund(nlund,i)=p(mod(i,4),lact)
           call lurobo(0.,0.,bex,bey,bez)
           call lurobo(0.,philu,0.,0.,0.)
           call lurobo(thetlu,0.,0.,0.,0.)
           ppnlu=plund(nlund,4)+plund(nlund,3)
           pmnlu=plund(nlund,4)-plund(nlund,3)
           if(plcone(1,iro)-ppnlu.le.plcmx1) jcut1=0
           if(plcone(2,iro)-pmnlu.le.plcmx2) jcut2=0
           if(jcut1+jcut2.eq.0)  go to 48
           plcone(1,iro)=plcone(1,iro)-ppnlu
           plcone(2,iro)=plcone(2,iro)-pmnlu
           ptstor(1,iro)=ptstor(1,iro)-plund(nlund,1)
           ptstor(2,iro)=ptstor(2,iro)-plund(nlund,2)
           if(lact.eq.lb) then
             lb=lb+1
           else
             le=le-1
           end if
           go to 49
   48      continue
           kb=kstar(iro)
           ke=kende(iro)
           if(lb.ne.kb) then
             if(kparnt(3,iro).eq.40) kparnt(3,iro)=0
             iroout=iroout+1
             if(iroout.gt.mxs) call errex('strist48-abort')
             kstar(iroout)=kb
             kende(iroout)=lb-1
             manip(iroout)=.false.
           end if
           if(le.ne.ke) then
             if(kparnt(3,iro).eq.40) kparnt(3,iro)=0
             iroout=iroout+1
             if(iroout.gt.mxs) call errex('strist48-abort')
             kstar(iroout)=le+1
             kende(iroout)=ke
             manip(iroout)=.false.
           end if
           kstar(iro)=lb
           kende(iro)=le
         end if
   19   continue
   16  continue
       nlund=nsave
       if(kparnt(3,1).eq.-1) then
         write(lun8,*) 'early return'
         iroout=iroin
         return
       end if
       do 57 iro=1,iroin
        if(kparnt(3,iro).eq.-1) go to 57
        ksta=kstar(iro)
        ke=kende(iro)
        ibend=0
        istend=0
        iqend=0
        ksta=kstar(iro)
        ke=kende(iro)
        nflav=1
        ik=ksta
   58   continue
        iqtun=nclcnt(issn(ik))
        if(iqtun.gt.100) iqtun=-mod(iqtun,100)
        call transl(-1,ityp(ik),npidec(ik),kf1)
        istat=0
        if(nflav.eq.1) then
           call fndq(kf1,ifle1,iqtun,istat)
           kqr=ifle1
        else
           ifle1=iqtun
           kql=ifle1
        end if
        if(istat.eq.-1) then
          go to 50
        else
          iqend=iqend+lchar(ifle1)
          ifle1a=mod(iabs(ifle1),10)
          ifle1b=iabs(ifle1)/10
          if(ifle1a.eq.3.or.ifle1b.eq.3) then
            if(ifle1a.eq.3)
     a      istend=istend+isign(1,ifle1)
            if(ifle1b.eq.3)
     a      istend=istend+isign(1,ifle1)
          end if
          if(iabs(ifle1).gt.10) then
            ibend=ibend+isign(2,ifle1)
          else
            ibend=ibend+isign(1,ifle1)
          end if
        end if
        if(nflav.eq.1) then
          ik=ke
          nflav=2
          go to 58
        end if
        ichrgs=0
        ibarys=0
        istras=0
        do 61 l=ksta,ke
         call transl(-1,ityp(l),npidec(l),k2l)
         call luiflv(k2l,ifla1,iflb1,iflc1,ksp)
         if(iabs(ifla1).eq.3) istras=istras+isign(1,ifla1)
         if(iabs(iflb1).eq.3) istras=istras+isign(1,iflb1)
         if(iabs(iflc1).eq.3) istras=istras+isign(1,iflc1)
         ichrgs=ichrgs+luchge(k2l)
         k2labs=iabs(k2l)
         if(k2labs.le.90) then
            if(kspin(k2labs).ge.2) then
              ibarys=ibarys+3*isign(1,k2l)
            endif
         else
            call errex('strist:unidentified hadron')
         endif
   61   continue
        if(istras.ne.istend.or.
     a        ichrgs.ne.iqend.or.
     b            ibarys.ne.ibend) then
          write(lun8,*) 'kqr/kql=',kqr,kql
          write(lun8,*) 'charge:',ichrgs,iqend
          write(lun8,*) 'baryno:',ibarys,ibend
          write(lun8,*) 'strang:',istras,istend
          write(lun8,*) 'strist:flavor does not add up correctly'
          go to 50
        end if
        kbaryo=kbaryo+ibend
        kstran=kstran+istend
        kcharg=kcharg+iqend
        nmult=nmult+1
        manip(iro)=.true.
        iturn=iflv(1,iro)
        if(iturn.eq.-1) then
         jflv(2,iro)=kqr
         jflv(1,iro)=kql
        else
         jflv(1,iro)=kqr
         jflv(2,iro)=kql
        end if
        korsto(iro)=kparnt(3,iro)
        do 102 i=0,3
  102   xbang(i)=xbang(i)+xori(i,iro)
   50   continue
        if(.not.manip(iro)) then
          kstar(iro)=lstar(iro)
          kende(iro)=lende(iro)
          jflv(1,iro)=0
          jflv(2,iro)=0
          do 56 iroa=iroin+1,iroout
           if(kstar(iroa).ge.kstar(iro).and.
     a        kende(iroa).le.kende(iro)) then
             kstar(iroa)=0
             kende(iroa)=0
           end if
   56     continue
        end if
   57  continue
       nlund=nsave
       if(nmult.le.1.and.(nmult.eq.0.or.nstrin.eq.0)) then
         do 191 iro=2,iroin
  191    manip(iro)=.false.
         iroout=iroin
         return
       end if
       do 106 i=0,3
  106  xbang(i)=xbang(i)/nmult
  444  format(3x,a18,1x,14(i3,1x))
       do 68 iro=1,iroout
        if(manip(iro)) go to 68
        ksta=kstar(iro)
        if(ksta.eq.0) go to 68
        ke=kende(iro)
        do 67 ik=ksta,ke
        do 67 i=0,3
   67   psum(i)=psum(i)-p(i,ik)
   68  continue
       ppltot=0.
       pmitot=0.
       do 21 i=1,2
   21  ptsum(i)=0.0
       if(kbpmd2.lt.iroin) then
         call errex('strist70:kbpmd2.lt.iroin')
       end if
       ransm1=0.0
       ransm2=0.0
       do 70 iro=1,iroin
        xhad(1,iro)=0.0
        xhad(2,iro)=0.0
        if(.not.manip(iro))go to 70
        xhad(1,iro)=ranf(0)
        xhad(2,iro)=ranf(0)
        ransm1=ransm1+xhad(1,iro)
        ransm2=ransm2+xhad(2,iro)
        ppltot=ppltot+plcone(1,iro)
        pmitot=pmitot+plcone(2,iro)
        do 62 i=1,2
   62   ptsum(i)=ptsum(i)+ptstor(i,iro)
   70  continue
       do 270 iro=1,iroin
        if(.not.manip(iro))go to 270
        ptstor(1,iro)=xhad(1,iro)/ransm1*ptsum(1)
        ptstor(2,iro)=xhad(2,iro)/ransm2*ptsum(2)
  270  continue
       nlund=nlund+1
       mst(1)=nlund
       mst(2)=mst(1)
       do 71 i=1,2
   71  plund(nlund,i)=ptsum(i)
       ps(1)=ppltot
       ps(2)=pmitot
       emtrue=sqrt(ps(1)*ps(2))
       plund(nlund,4)=0.5*(ppltot+pmitot)
       plund(nlund,3)=0.5*(ppltot-pmitot)
       bex=-bex
       bey=-bey
       bez=-bez
       thetlu=-thetlu
       philu=-philu
       call lurobo(thetlu,philu,bex,bey,bez)
       ptot(0)=plund(nlund,4)
       do 72 i=1,3
   72  ptot(i)=plund(nlund,i)
       nlund=nlund-1
       if((abs(ptot(0)-psum(0)).gt.0.015).or.
     a        (abs(ptot(1)-psum(1)).gt.0.015).or.
     b            (abs(ptot(2)-psum(2)).gt.0.015).or.
     c               (abs(ptot(3)-psum(3)).gt.0.015)) then
        write(lun8,166) '   ',iroin,'psum=',psum
        write(lun8,166) '   ',iroin,'ptot=',ptot
  166   format(1x,a6,i4,1x,a6,1x,4(f8.4,1x))
        call errex('strist:72 no energy/mom. conservation')
       end if
       nbsstr=0
       nbqstr=0
       nhstri=0
       kadel=0
       do 171 iro=1,iroin
        if(.not.manip(iro)) go to 171
        nhstri=nhstri+1+kende(iro)-kstar(iro)
        do 179 il=kstar(iro),kende(iro)
         iqbr=nclcnt(issn(il))
         if(iqbr.gt.100) iqbr=-(iqbr-100)
         if(il.eq.kende(iro)) then
         else if(iabs(iqbr).le.2) then
           nbqstr=nbqstr+1
         else if(iabs(iqbr).eq.3) then
           nbsstr=nbsstr+1
         end if
         call transl(-1,ityp(il),npidec(il),kf)
         if(iabs(kf).eq.18.or.iabs(kf).eq.28.or.
     a        iabs(kf).eq.19.or.iabs(kf).eq.29) then
           kadel=kadel+1
         end if
  179   continue
  171  continue
       ndif1=iroin-nmult
       nmulol=nmult
       mloop=0
       mlinit=1
  100  continue
       if(mloop.gt.30) then
         write(lun8,*) 'strist call no success:mloop.gt.30,return'
         do 192 iro=2,iroin
  192    manip(iro)=.false.
         iroout=iroin
         return
       end if
       do 173 iro=1,iroin
        mqflav(1,iro)=1
        mqflav(2,iro)=1
        if(.not.manip(iro)) go to 173
        do 172 i=1,2
         pt(i,iro)=ptstor(i,iro)
         plc(i,iro)=plcone(i,iro)
         iflv(i,iro)=jflv(i,iro)
         mqflav(i,iro)=0
  172   continue
        if(korsto(iro).eq.40) then
          if(iabs(iflv(1,iro)).lt.10) then
            iflqew=isign(1,iflv(1,iro))*(int(ranf(0)*(2.+par2))+1)
            iflv(1,iro)=iflqew
            iflv(2,iro)=-iflqew
          end if
        else
          do  63 iroa=1,iro-1
           if(.not.manip(iroa)) go to 63
           if(korsto(iroa).eq.40) go to 63
           if(iabs(iflv(1,iroa)).gt.10.or.
     a             iabs(iflv(2,iroa)).gt.10) go to 63
           if(iflv(1,iro)+iflv(1,iroa).eq.0) then
             iflqew=isign(1,iflv(1,iro))*(int(ranf(0)*(2.+par2))+1)
             iflv(1,iro)=iflqew
             iflv(1,iroa)=-iflqew
           end if
           if(iflv(2,iro)+iflv(2,iroa).eq.0) then
             iflqew=isign(1,iflv(2,iro))*(int(ranf(0)*(2.+par2))+1)
             iflv(2,iro)=iflqew
             iflv(2,iroa)=-iflqew
           end if
           if(iflv(2,iro)+iflv(1,iroa).eq.0) then
             iflqew=isign(1,iflv(2,iro))*(int(ranf(0)*(2.+par2))+1)
             iflv(2,iro)=iflqew
             iflv(1,iroa)=-iflqew
           end if
           if(iflv(1,iro)+iflv(2,iroa).eq.0) then
             iflqew=isign(1,iflv(1,iro))*(int(ranf(0)*(2.+par2))+1)
             iflv(1,iro)=iflqew
             iflv(2,iroa)=-iflqew
           end if
   63     continue
        end if
  173  continue
       izr=0
       qqspin=1.0
       nsingl=0
       psingl(1)=0.0
       psingl(2)=0.0
       mrop=2*iroin
       par(11)=para11
       ip=0
       iq=0
       do 73 iro=1,iroin
        if(.not.manip(iro)) go to 73
        jqpart(iro)=0
        jetzhd(1,iro)=0
        jetzhd(2,iro)=0
        iqqkf(1,iro)=0
        iqqkf(2,iro)=0
        iflq=iflv(1,iro)
        iflr=iflv(2,iro)
        if((iflq.gt.0.and.iflq.lt.10).or.
     a                         (iflq.lt.-10)) then
          if(iflq.lt.-10) iqqkf(1,iro)=-1
          if(iflr.gt.10) iqqkf(2,iro)=-1
          ppl1q=dimsu3(ip+1,iq)
          if(ip.gt.0.and.iflq.gt.0.and.-iflr.gt.0) then
            pm1qp1=dimsu3(ip-1,iq+1)
          else
            pm1qp1=0.0
          end if
          if(iq.gt.0) then
            pqmi1=dimsu3(ip,iq-1)
          else
            pqmi1=0.0
          end if
          izr=izr+1
          if(mlinit.eq.1)  dquark(1,izr)=ranf(0)
          pmlsum=pm1qp1+ppl1q+pqmi1
          if(dquark(1,izr).lt.pm1qp1/pmlsum) then
            iof=int(ranf(0)*iro)+1
            iyes=0
            do 74 iroant=iof+1,iof+iro-1
             iroa=mod(iroant,iro-1)+1
             if(.not.manip(iroa)) go to 74
             ifla=iflv(1,iroa)
             iflb=iflv(2,iroa)
             if(ifla.gt.0.and.ifla.lt.10) then
              if(-iflb.gt.0.and.-iflb.lt.10) then
                  iyes=1
                  goto 75
              end if
             end if
   74       continue
   75       continue
            if(iyes.eq.1) then
              ip=ip-1
              iq=iq+1
              jqpart(iroa)=iro
              do 115 j=1,2
               if(iro.eq.0) then
                 if(plc(j,iroa).gt.plc(j,iro)) then
                   iqqkf(j,iroa)=iroa
                 else
                   iqqkf(j,iroa)=iro
                 end if
               end if
               plc(j,iroa)=plc(j,iroa)+plc(j,iro)
               pt(j,iroa)=pt(j,iroa)+pt(j,iro)
               pt(j,iro)=0.0
               plc(j,iro)=0.0
               iflv(j,iro)=0
               mqflav(j,iro)=1
               mqflav(j,iroa)=1
               if(j.eq.1) then
                 ifl1=ifla
                 ifl2=iflq
               else
                 ifl1=iflb
                 ifl2=iflr
               end if
               if(iqqkf(j,iroa).eq.iroa) then
                 iflv(j,iroa)=10*ifl1+ifl2
               else if(iqqkf(j,iroa).eq.iro) then
                 iflv(j,iroa)=10*ifl2+ifl1
               else
                 iflv(j,iroa)=kqqret(ifl1,ifl2)
                 if(ifl1.ne.ifl2) qqspin=qqspin*qqdqqs
               end if
  115         continue
            else
              ip=ip+1
            end if
          else if(dquark(1,izr).lt.(pqmi1+pm1qp1)/pmlsum) then
            iof=int(ranf(0)*iro)+1
            iyes=0
            do 174 iroant=iof+1,iof+iro-1
             iroa=mod(iroant,iro-1)+1
             if(.not.manip(iroa)) go to 174
             if(plc(1,iroa).eq.0.0) go to 174
             ifla=iflv(1,iroa)
             iflb=iflv(2,iroa)
             if(itrip(ifla)*itrip(iflq).eq.10.and.
     a                              iabs(ifla*iflq).lt.100) then
               if(itrip(iflb)*itrip(iflr).eq.10.and.
     a                              iabs(iflb*iflr).lt.100) then
                 iyes=1
                 goto 175
               end if
             end if
  174       continue
  175       continue
            if(iyes.eq.1) then
              if(max(iro,iroa).ge.1000)
     a        call errex('strist:isingl array overflow')
              isingl(nsingl+1)=iro+jqpart(iro)*1000
              isingl(nsingl+2)=iroa+jqpart(iroa)*1000
              do 65 j=1,2
               iflst1=iflv(j,iro)
               iflst2=iflv(j,iroa)
               iroact=0
               if(iabs(iflst1).gt.10) then
                 iroact=iro
               else if(iabs(iflst2).gt.10) then
                 iroact=iroa
               end if
               iswa=0
               if(iroact.gt.0) then
                 if(iabs(iflst1).lt.10) then
                   call iswap(iflst1,iflst2)
                   iswa=1
                 end if
                 if(iqqkf(j,iro).gt.0.or.iqqkf(j,iroa).gt.0) then
                   ifls11=iflst1/10
                   if(ifls11+10*ifls11.ne.iflst1) then
                     qqspin=qqspin*qqdqqs
                   end if
                 end if
                 iflcom=0
                 ichar=0
   24            continue
                 if(iflcom.ne.0) then
                   jro=0
                   mof=int(ranf(0)*(mrop+1))+1
                   do 324 ma=mof+1,mof+mrop
                    mb=mod(ma,mrop)+1
                    if(mb.gt.iroin) then
                      mb=mb-iroin
                      lt=2
                    else
                      lt=1
                    end if
                    if(mqflav(lt,mb).ne.0) go to 324
                    if(mb.eq.iro.or.mb.eq.iroa) go to 324
                    if(iflcom.eq.-iflv(lt,mb)) then
                      jro=mb
                      mt=lt
                      ifln=isign(1,iflcom)*(int(ranf(0)*(2.+par2))+1)
                      go to 325
                    end if
  324              continue
  325              continue
                 end if
                 if(ichar.eq.1.and.jro.gt.0) then
                   iflm=ifln
                 else
                   iflm=iflst2
                 end if
                 barw=barwgh(para11,iflst1,iflm)
                 if(mlinit.eq.0) then
                   if(ranf(0).gt.barw) then
                     iflcom=iflst2
                     ichar=1
                     go to 24
                   end if
                 else
                   qqspin=qqspin*barw
                 end if
                 call luifld(iflst1,0,iflm,ifldum,kf)
                 jetzhd(j,iro)=kf
                 if(ichar.eq.1.and.jro.gt.0) then
                   iflv(mt,jro)=-ifln
                   iflst2=ifln
                 end if
               end if
               mqflav(j,iro)=1
               mqflav(j,iroa)=1
               if(iswa.eq.1) then
                 call iswap(iflst1,iflst2)
               end if
               iflstr(j,nsingl+1)=iflst1
               iflstr(j,nsingl+2)=iflst2
               psingl(j)=psingl(j)+plc(j,iro)+plc(j,iroa)
               plc(j,iro)=0.0
               pt(j,iro)=0.0
               iflv(j,iro)=0
               plc(j,iroa)=0.0
               pt(j,iroa)=0.0
               iflv(j,iroa)=0
   65         continue
              nsingl=nsingl+2
              iq=iq-1
            else
              ip=ip+1
            end if
          else
              ip=ip+1
          end if
        else
          if(iflq.gt.10) iqqkf(1,iro)=-1
          if(iflr.lt.-10) iqqkf(2,iro)=-1
          qpl1p=dimsu3(ip,iq+1)
          if(iq.gt.0.and.-iflq.gt.0.and.iflr.gt.0) then
            qm1pp1=dimsu3(ip+1,iq-1)
          else
            qm1pp1=0.0
          end if
 
          if(ip.gt.0) then
            pmi1q=dimsu3(ip-1,iq)
          else
            pmi1q=0.0
          end if
          izr=izr+1
          if(mlinit.eq.1)  dquark(1,izr)=ranf(0)
          pmlsum=qm1pp1+qpl1p+pmi1q
          if(dquark(1,izr).lt.qm1pp1/pmlsum) then
            iof=int(ranf(0)*iro)+1
            iyes=0
            do 76 iroant=iof+1,iof+iro-1
             iroa=mod(iroant,iro-1)+1
             if(.not.manip(iroa)) go to 76
             ifla=iflv(1,iroa)
             iflb=iflv(2,iroa)
             if(-ifla.gt.0.and.-ifla.lt.10) then
              if(iflb.gt.0.and.iflb.lt.10) then
                  iyes=1
                  goto 77
              end if
             end if
   76       continue
   77       continue
            if(iyes.eq.1) then
              iq=iq-1
              ip=ip+1
              jqpart(iroa)=iro
              do 116 j=1,2
               if(iro.eq.0) then
                 if(plc(j,iroa).gt.plc(j,iro)) then
                   iqqkf(j,iroa)=iroa
                 else
                   iqqkf(j,iroa)=iro
                 end if
               end if
               plc(j,iroa)=plc(j,iroa)+plc(j,iro)
               pt(j,iroa)=pt(j,iroa)+pt(j,iro)
               pt(j,iro)=0.0
               plc(j,iro)=0.0
               iflv(j,iro)=0
               mqflav(j,iro)=1
               mqflav(j,iroa)=1
               if(j.eq.1) then
                 ifl1=ifla
                 ifl2=iflq
               else
                 ifl1=iflb
                 ifl2=iflr
               end if
               if(iqqkf(j,iroa).eq.iroa) then
                 iflv(j,iroa)=10*ifl1+ifl2
               else if(iqqkf(j,iroa).eq.iro) then
                 iflv(j,iroa)=10*ifl2+ifl1
               else
                 iflv(j,iroa)=kqqret(ifl1,ifl2)
                 if(ifl1.ne.ifl2) qqspin=qqspin*qqdqqs
               end if
  116         continue
            else
              iq=iq+1
            end if
          else if(dquark(1,izr).lt.(pmi1q+qm1pp1)/pmlsum) then
            iof=int(ranf(0)*iro)+1
            iyes=0
            do 176 iroant=iof+1,iof+iro-1
             iroa=mod(iroant,iro-1)+1
             if(.not.manip(iroa)) go to 176
             if(plc(1,iroa).eq.0.0) go to 176
             ifla=iflv(1,iroa)
             iflb=iflv(2,iroa)
             if(itrip(ifla)*itrip(iflq).eq.10.and.
     a                              iabs(ifla*iflq).lt.100) then
               if(itrip(iflb)*itrip(iflr).eq.10.and.
     a                              iabs(iflb*iflr).lt.100) then
                 iyes=1
                 goto 177
               end if
             end if
  176       continue
  177       continue
            if(iyes.eq.1) then
              if(max(iro,iroa).ge.1000)
     a        call errex('strist:isingl array overflow')
              isingl(nsingl+1)=iro+jqpart(iro)*1000
              isingl(nsingl+2)=iroa+jqpart(iroa)*1000
              do 66 j=1,2
               iflst1=iflv(j,iro)
               iflst2=iflv(j,iroa)
               iroact=0
               if(iabs(iflst1).gt.10) then
                 iroact=iro
               else if(iabs(iflst2).gt.10) then
                 iroact=iroa
               end if
               iswa=0
               if(iroact.gt.0) then
                 if(iabs(iflst1).lt.10) then
                   call iswap(iflst1,iflst2)
                   iswa=1
                 end if
                 if(iqqkf(j,iro).gt.0.or.iqqkf(j,iroa).gt.0) then
                   ifls11=iflst1/10
                   if(ifls11+10*ifls11.ne.iflst1) then
                     qqspin=qqspin*qqdqqs
                   end if
                 end if
                 iflcom=0
                 ichar=0
   25            continue
                 if(iflcom.ne.0) then
                   jro=0
                   mof=int(ranf(0)*(mrop+1))+1
                   do 326 ma=mof+1,mof+mrop
                    mb=mod(ma,mrop)+1
                    if(mb.gt.iroin) then
                      mb=mb-iroin
                      lt=2
                    else
                      lt=1
                    end if
                    if(mqflav(lt,mb).ne.0) go to 326
                    if(mb.eq.iro.or.mb.eq.iroa) go to 326
                    if(iflcom.eq.-iflv(lt,mb)) then
                      jro=mb
                      mt=lt
                      ifln=isign(1,iflcom)*(int(ranf(0)*(2.+par2))+1)
                      go to 327
                    end if
  326              continue
  327              continue
                 end if
                 if(ichar.eq.1.and.jro.gt.0) then
                   iflm=ifln
                 else
                   iflm=iflst2
                 end if
                 barw=barwgh(para11,iflst1,iflm)
                 if(mlinit.eq.0) then
                   if(ranf(0).gt.barw) then
                     iflcom=iflst2
                     ichar=1
                     go to 25
                   end if
                 else
                   qqspin=qqspin*barw
                 end if
                 call luifld(iflst1,0,iflm,ifldum,kf)
                 jetzhd(j,iro)=kf
                 if(ichar.eq.1.and.jro.gt.0) then
                   iflv(mt,jro)=-ifln
                   iflst2=ifln
                 end if
               end if
               mqflav(j,iro)=1
               mqflav(j,iroa)=1
               if(iswa.eq.1) then
                 call iswap(iflst1,iflst2)
               end if
               iflstr(j,nsingl+1)=iflst1
               iflstr(j,nsingl+2)=iflst2
               psingl(j)=psingl(j)+plc(j,iro)+plc(j,iroa)
               plc(j,iro)=0.0
               pt(j,iro)=0.0
               iflv(j,iro)=0
               plc(j,iroa)=0.0
               pt(j,iroa)=0.0
               iflv(j,iroa)=0
   66         continue
              nsingl=nsingl+2
              ip=ip-1
            else
              iq=iq+1
            end if
          else
            iq=iq+1
          end if
        end if
   73  continue
       par(11)=par11
       mlinit=0
       if(ranf(0).gt.qqspin)  go to 100
       mlinit=1
       mloop=mloop+1
       if(ip.gt.iprbr1.or.iq.gt.iprbr1) then
         write(lun8,*) 'strist warning:'
         write(lun8,*)
     a     'fieldstrength larger than (ip>iprbr1,iq.le.ip):',ip,iq
       end if
       ndif2=nmulol-(ip+iq)
       nd1=0
       nd2=0
       nm=0
       do 78 iro=1,iroin
        if(.not.manip(iro)) then
          nd1=nd1+1
        else if(plc(1,iro).eq.0.0) then
          nd2=nd2+1
        else
          nm=nm+1
          do  87 jt=1,2
           pt(jt,nm)=pt(jt,iro)
           iflv(jt,nm)=iflv(jt,iro)
           plc(jt,nm)=plc(jt,iro)
           mqflav(jt,nm)=mqflav(jt,iro)
           iqqkf(jt,nm)=iqqkf(jt,iro)
           if(iqqkf(jt,nm).gt.0) then
             iroa=iqqkf(jt,nm)
             if(iroa.gt.iroin)
     a       call errex('strist:iqqkf value out of range')
             plc(jt,nm)=plc(jt,nm)-plcone(jt,iroa)
             psingl(jt)=psingl(jt)+plcone(jt,iroa)
           end if
   87     continue
        end if
   78  continue
       do 101  nsi=1,nsingl-1,2
        iro1=mod(isingl(nsi),1000)
        do 101 jt=1,2
         iqqkf(jt,mxs+1-nsi)=jetzhd(jt,iro1)
  101  continue
       if(nd1.ne.ndif1) then
          call errex('strist:nd1.ne.ndif1')
       else if(nd2.ne.ndif2) then
          write(lun8,*) 'nd2=',nd2,'ndif2=',ndif2
          call errex('strist:nd2.ne.ndif2')
       else if(nm.ne.ip+iq) then
          call errex('strist:nm.ne.ip+iq')
       end if
       nmult=ip+iq
       ipmax=ip
       iqmax=iq
c      write(lun8,*) 'nmult,ipmax,iqmax=',nmult,ip,iq
       do 80 nm=1,nmult
        iord(1,nm)=1
        iord(2,nm)=1
        do 79 mn=1,nm-1
         if(plc(1,nm).gt.plc(1,mn))then
          iord(1,nm)=iord(1,nm)+1
         else
          iord(1,mn)=iord(1,mn)+1
         end if
         if(plc(2,nm).gt.plc(2,mn))then
          iord(2,nm)=iord(2,nm)+1
         else
          iord(2,mn)=iord(2,mn)+1
         end if
   79   continue
   80  continue
       do 81 nm=1,nmult
        jord(nm)=iord(1,nm)
   81  continue
       isum=0
       do 82 nm=1,nmult
        i=jord(nm)
        isum=isum+i
        if(i.lt.1.or.i.gt.nmult) then
           call errex('strist:iord problem')
        end if
        iord(1,i)=nm
   82  continue
       if(isum.ne.nmult*(nmult+1)/2) then
           call errex('strist 82:iord problem')
       end if
       do 83 nm=1,nmult
        jord(nm)=iord(2,nm)
   83  continue
       isum=0
       do 84 nm=1,nmult
        i=jord(nm)
        isum=isum+i
        if(i.lt.1.or.i.gt.nmult) then
           call errex('strist:iord problem')
        end if
        iord(2,i)=nm
   84  continue
       if(isum.ne.nmult*(nmult+1)/2) then
           call errex('strist 84:iord problem')
       end if
       ipdgr(1,1)=ipmax
       iqdgr(1,1)=iqmax
       ipdgr(2,1)=iqmax
       iqdgr(2,1)=ipmax
       nstep=1
       do 96 nm=1,nmult
        nstep=nstep+1
        do 97 jt=1,2
         if(itrip(iflv(jt,iord(jt,nm))).eq.1) then
           iqdgr(jt,nstep)=iqdgr(jt,nstep-1)-1
           ipdgr(jt,nstep)=ipdgr(jt,nstep-1)
         else if(itrip(iflv(jt,iord(jt,nm))).eq.10) then
           ipdgr(jt,nstep)=ipdgr(jt,nstep-1)-1
           iqdgr(jt,nstep)=iqdgr(jt,nstep-1)
         end if
   97   continue
   96  continue
       if(ipdgr(1,nstep).ne.0.or.ipdgr(2,nstep).ne.0.or.
     a        iqdgr(1,nstep).ne.0.or.iqdgr(2,nstep).ne.0) then
         write(lun8,*) 'ipdgr(1)=',(ipdgr(1,i),i=1,nstep)
         write(lun8,*) 'iqdgr(1)=',(iqdgr(1,i),i=1,nstep)
         write(lun8,*) 'ipdgr(2)=',(ipdgr(2,i),i=1,nstep)
         write(lun8,*) 'iqdgr(2)=',(iqdgr(2,i),i=1,nstep)
         call errex('strist:chromoelectric field not confined? ')
       end if
         do 95 jt=1,2
          plcprv=0.0
          do 90 nm=1,nmult
   90     dquark(jt,nm)=0.0
          do 92 nm=1,nmult-1
           tnsave=0.75*casop(ipdgr(jt,nm),iqdgr(jt,nm))/(nmult-nm+1)
           xlcfbp=(plc(jt,iord(jt,nm))-plcprv)/tnsave
           if(xlcfbp.le.0.0) then
             call errex(
     a           'strist91:decreasing series of quark momenta???? ')
           end if
           plcprv=plc(jt,iord(jt,nm))
           do 91 nn=nm,nmult
            nnpls1=nn+1
            tnsaft=0.75*(casop(ipdgr(jt,nn),iqdgr(jt,nn))-
     a                     casop(ipdgr(jt,nnpls1),iqdgr(jt,nnpls1)))
            if(tnsaft.le.0.0) then
              call errex(
     a              'strist91:increasing chromoelectric field???? ')
            end if
            dquark(jt,iord(jt,nn))=dquark(jt,iord(jt,nn))+
     a                                   xlcfbp*(tnsaft-tnsave)
   91      continue
   92     continue
          dqsum=0.0
          do 94 nm=1,nmult
           plc(jt,iord(jt,nm))=plc(jt,iord(jt,nm))+
     a                             dquark(jt,iord(jt,nm))
           dqsum=dqsum+dquark(jt,iord(jt,nm))
   94     continue
          if(abs(dqsum).gt.1.e-3) then
             call errex(
     a           'strist91:plc increments do not add up to 0???? ')
          end if
   95    continue
      if(nmult.gt.0) then
         xlcrop(1)=plc(1,iord(1,nmult))
         xlcrop(2)=plc(2,iord(2,nmult))
       else
         xlcrop(1)=0.0
         xlcrop(2)=0.0
       end if
       tnsmax=0.75*casop(ipmax,iqmax)
       plcrop(1)=xlcrop(1)*tnsmax
       plcrop(2)=xlcrop(2)*tnsmax
       embang=sqrt(plcrop(1)*plcrop(2))
       pspent(1)=0.0
       pspent(2)=0.0
       nstep=1
       ibpfor=0
       do 86 nm=1,nmult
        nstep=nstep+1
        call luptdi(0,ptx,pty)
        do 85 jt=1,2
         ibpfor=ibpfor+1
         jr=3-jt
         iquark(jt,ibpfor)=0
         iquark(jr,ibpfor)=iflv(jt,iord(jt,nm))
         ptr(jr,1,ibpfor)=0.5*pt(1,iord(jt,nm))
         ptr(jr,2,ibpfor)=0.5*pt(2,iord(jt,nm))
         ptr(jr,1,ibpfor)=ptr(jr,1,ibpfor)+(3-2*jt)*ptx
         ptr(jr,2,ibpfor)=ptr(jr,2,ibpfor)+(3-2*jt)*pty
         ptr(jt,1,ibpfor)=0.
         ptr(jt,2,ibpfor)=0.
         tnsdif=0.75*(casop(ipdgr(jt,nstep-1),iqdgr(jt,nstep-1))-
     a                     casop(ipdgr(jt,nstep),iqdgr(jt,nstep)))
         if(tnsdif.le.0.0) then
           call errex('strist:increasing chromoelectric field???? ')
         end if
         xlcbp(jt,ibpfor)=plc(jt,iord(jt,nm))/tnsdif
         lloop=0
   89    lloop=lloop+1
         if(lloop.gt.100) then
           call errex('strist89:lloop>100')
         end if
         if(xlcbp(jt,ibpfor).lt.xlcbp(jt,max(1,ibpfor-2))) then
           fract=0.1*ranf(0)
           do 88 ibpf=jt,ibpfor-2,2
            nmold=(ibpf+1)/2
            pfract=fract*plc(jt,iord(jt,nmold))
            tnsold=plc(jt,iord(jt,nmold))/xlcbp(jt,ibpf)
            pspent(jt)=pspent(jt)+pfract
            plc(jt,iord(jt,nmold))=plc(jt,iord(jt,nmold))-pfract
            xlcbp(jt,ibpf)=plc(jt,iord(jt,nmold))/tnsold
            xlcmx(jt,ibpf)=xlcbp(jt,ibpf)
            plc(jt,iord(jt,nm))=plc(jt,iord(jt,nm))+pfract
   88      continue
           xlcbp(jt,ibpfor)=plc(jt,iord(jt,nm))/tnsdif
           go to 89
         end if
         if(xlcbp(jt,ibpfor).gt.xlcrop(jt)+0.01) then
           write(lun8,*) xlcbp(jt,ibpfor),xlcrop(jt),jt,ibpfor,nstep
           call errex('strist:wrong quark turning point')
         end if
         xlcbp(jr,ibpfor)=0.0
         xlcmx(jt,ibpfor)=xlcbp(jt,ibpfor)
         xlcmx(jr,ibpfor)=0.0
         plcfor(jt)=(xlcrop(jt)-xlcbp(jt,ibpfor))*tnsdif
         plcfor(jr)=0.0
         pspent(jt)=pspent(jt)+plcfor(jt)
         newbp(ibpfor)=.false.
   85   continue
   86  continue
       if(abs(plcrop(1)+psingl(1)-pspent(1)-ps(1)).gt.0.05.or.
     a      abs(plcrop(2)+psingl(2)-pspent(2)-ps(2)).gt.0.05) then
         write(lun8,*) 'ps=',ps
         write(lun8,*) 'pspent=',pspent
         write(lun8,*) 'psingl=',psingl
         write(lun8,*) 'plcrop=',plcrop
         call errex('strist:wrong formal turning point momentum? ')
       end if
       ibptru=ibpfor
       atrel=atre
       if(ipmax+iqmax.gt.0) then
         call bplist(ipmax,iqmax,embang,emtrue,atrel)
       else
         libpmx=0
       end if
       if(ibpfor+libpmx.gt.kbpmax) then
         do 98 iro=1,iroin
   98    manip(iro)=.false.
         write(lun8,*) 'libpmx,ibpfor,kbpmax=',
     a                     libpmx,ibpfor,kbpmax
         call errex('strist:kbpmax-arrays have too small dimension')
       end if
       do 99 ibpl=1,libpmx
        ibptru=ibptru+1
        xlcbp(1,ibptru)=plcrop(1)/embang*bpli(1,ibpl)
        xlcbp(2,ibptru)=plcrop(2)/embang*bpli(2,ibpl)
        xlcmx(1,ibptru)=xlcbp(1,ibptru)
        xlcmx(2,ibptru)=xlcbp(2,ibptru)
        ptr(1,1,ibptru)=0.0
        ptr(1,2,ibptru)=0.0
        ptr(2,1,ibptru)=0.0
        ptr(2,2,ibptru)=0.0
        newbp(ibptru)=.true.
        iquark(1,ibptru)=0
        iquark(2,ibptru)=0
   99  continue
       do 110 ibp=1,ibptru
        do 108 jt=1,2
         icomb(jt,ibp)=0
         ivlc(jt,ibp)=0
         ipact(jt,ibp)=0
         iqact(jt,ibp)=0
         lord(jt,ibp)=1
         equark(jt,ibp)=0.0
         dquark(jt,ibp)=0.0
  108   continue
        do 109 jbp=1,ibp-1
         if(xlcbp(1,ibp).gt.xlcbp(1,jbp))then
          lord(1,ibp)=lord(1,ibp)+1
         else if(xlcbp(1,ibp).eq.xlcbp(1,jbp))then
           if(xlcbp(2,ibp).gt.xlcbp(2,jbp))then
              lord(1,ibp)=lord(1,ibp)+1
           else if(xlcbp(2,ibp).eq.xlcbp(2,jbp))then
              call errex(
     a         'strist:two identical break point positions, abort')
           else
              lord(1,jbp)=lord(1,jbp)+1
           end if
         else
          lord(1,jbp)=lord(1,jbp)+1
         end if
         if(xlcbp(2,ibp).gt.xlcbp(2,jbp))then
          lord(2,ibp)=lord(2,ibp)+1
         else if(xlcbp(2,ibp).eq.xlcbp(2,jbp))then
           if(xlcbp(1,ibp).gt.xlcbp(1,jbp))then
              lord(2,ibp)=lord(2,ibp)+1
           else if(xlcbp(1,ibp).eq.xlcbp(1,jbp))then
              call errex(
     a         'strist:two identical break point positions, abort')
           else
              lord(2,jbp)=lord(2,jbp)+1
           end if
         else
          lord(2,jbp)=lord(2,jbp)+1
         end if
  109   continue
  110  continue
       ibptot=0
       do 200 nm=1,nmult
       do 150 ibp=1,ibptru
        if(max(lord(1,ibp),lord(2,ibp)).gt.ibptru.or.
     a                  min(lord(1,ibp),lord(2,ibp)).lt.0) then
          call errex('strist:wrong lord value')
        else if(lord(1,ibp).eq.0) then
          go to 150
        else if(icomb(1,ibp).ne.0.and.
     a                       icomb(2,ibp).ne.0) then
          go to 150
        end if
        if(nm.eq.1) then
          if(ibp.le.ibpfor) then
           jt=2-mod(ibp,2)
           jr=3-jt
           ivord=(ibp-jt)/2
           ivlc(jr,ibp)=ivord
           ivlc(jt,ibp)=nmult
           ipact(jt,ibp)=0
           iqact(jt,ibp)=0
           ipact(jr,ibp)=iqdgr(jt,ivord+1)
           iqact(jr,ibp)=ipdgr(jt,ivord+1)
          else
           ipact(1,ibp)=ipdgr(1,1)+ipact(1,ibp)
           iqact(1,ibp)=iqdgr(1,1)+iqact(1,ibp)
           ipact(2,ibp)=ipdgr(2,1)+ipact(2,ibp)
           iqact(2,ibp)=iqdgr(2,1)+iqact(2,ibp)
           do 119 jbp=1,ibpfor
            if(lord(1,ibp).gt.lord(1,jbp).and.
     a            lord(2,ibp).gt.lord(2,jbp)) then
              jt=2-mod(jbp,2)
              jr=3-jt
              itrjt=itrip(iquark(jr,jbp))
              ivlc(1,ibp)=ivlc(1,ibp)+1
              ivlc(2,ibp)=ivlc(2,ibp)+1
              if(itrjt.eq.10) then
                 ipact(jt,ibp)=ipact(jt,ibp)-1
                 iqact(jr,ibp)=iqact(jr,ibp)-1
              else
                 iqact(jt,ibp)=iqact(jt,ibp)-1
                 ipact(jr,ibp)=ipact(jr,ibp)-1
              end if
              if(ipact(1,ibp).lt.0.or.iqact(1,ibp).lt.0.or.
     a                ipact(2,ibp).lt.0.or.iqact(2,ibp).lt.0) then
               lord(1,ibp)=0
               lord(2,ibp)=0
               go to 150
              end if
            end if
  119      continue
          end if
        end if
        ivord1=ivlc(1,ibp)
        ivord2=ivlc(2,ibp)
        ivord=min(ivord1,ivord2)
        if(.not.newbp(ibp)) then
        else if(ivord+1.gt.nm) then
        else
          if(ivord+1.lt.nm) then
            call errex(
     a         'strist conflict:new break point in past field region')
          else
            if(ibp.le.ibpfor) then
            else
               if(ivord1.ne.ivord2) then
                 call errex('strist:ambiguous field for break point')
               end if
               ipa=ipact(1,ibp)
               iqa=iqact(1,ibp)
               ipiq(ibp)=100*ipa+iqa
               ibptot=max(ibptot,ibp)
               if(iqa.ne.ipact(2,ibp).or.
     a                  ipa.ne.iqact(2,ibp)) then
                    call errex(
     a                 'strist:field for new break not well defined')
               end if
               newbp(ibp)=.false.
               if(ipa.lt.0.or.iqa.lt.0) then
                 lord(1,ibp)=0
                 lord(2,ibp)=0
                 go to 150
               end if
               atrel=atre
               if(reject(ipa,iqa,atrel)) then
                 lord(1,ibp)=0
                 lord(2,ibp)=0
                 go to 150
               end if
               call flavor(ipa,iqa,ifl)
               iquark(1,ibp)=ifl
               iquark(2,ibp)=-ifl
               if(par(12).gt.0.) then
                  kqqbar=(isign(1,(ipa-iqa)*ifl)+3)/2
                  par12=par(12)
                  par(12)=sigptr(ipa,iqa,kqqbar)
                  call luptdi(ifl,ptr(1,1,ibp),ptr(1,2,ibp))
                  ptr(2,1,ibp)=-ptr(1,1,ibp)
                  ptr(2,2,ibp)=-ptr(1,2,ibp)
                  par(12)=par12
               else
                  ptr(1,1,ibp)=0.0
                  ptr(1,2,ibp)=0.0
                  ptr(2,1,ibp)=0.0
                  ptr(2,2,ibp)=0.0
               end if
               jbpcrl=0
               jbpcrr=0
               xdifmn=xlcrop(1)
               ydifmn=xlcrop(2)
               do 125 jbp=1,ibptru
                ivor2=ivlc(2,jbp)
                if(ibp.eq.jbp) then
                   go to 125
                else if(lord(1,jbp).lt.lord(1,ibp)) then
                   go to 124
                else if(lord(1,jbp).eq.0) then
                   go to 124
                else if(ivor2+1.gt.nm) then
                  go to 124
                else if(icomb(2,jbp).ne.0) then
                  go to 124
                else if(iquark(2,jbp).eq.0) then
                  go to 124
                end if
                if(lord(2,ibp).gt.lord(2,jbp).and.
     a                xlcmx(2,jbp).lt.xlcbp(2,ibp).and.
     b                 xlcmx(1,ibp).lt.xlcbp(1,jbp)) then
                  xdif=xlcbp(1,jbp)-xlcbp(1,ibp)
                  if(xdif.lt.xdifmn) then
                     xdifmn=xdif
                     jbpcrl=jbp
                  end if
                end if
  124           continue
                ivor1=ivlc(1,jbp)
                if(lord(2,jbp).lt.lord(2,ibp)) then
                   go to 125
                else if(lord(1,jbp).eq.0) then
                   go to 125
                else if(ivor1+1.gt.nm) then
                  go to 125
                else if(icomb(1,jbp).ne.0) then
                  go to 125
                else if(iquark(1,jbp).eq.0) then
                  go to 125
                end if
                if(lord(1,ibp).gt.lord(1,jbp).and.
     a                xlcmx(1,jbp).lt.xlcbp(1,ibp).and.
     b                 xlcmx(2,ibp).lt.xlcbp(2,jbp)) then
                  ydif=xlcbp(2,jbp)-xlcbp(2,ibp)
                  if(ydif.lt.ydifmn) then
                     ydifmn=ydif
                     jbpcrr=jbp
                  end if
                end if
  125          continue
              if(jbpcrl.eq.0) then
                call errex('strist:no jbpcrl found')
              end if
              if(jbpcrr.eq.0) then
                call errex('strist:no jbpcrr found')
              end if
               jt=1
               jr=2
               itrjt=itrip(iquark(jt,ibp))
               do 145 jbp=ibp+1,ibptru
                if(lord(1,ibp).lt.lord(1,jbp).and.
     a                   lord(2,ibp).lt.lord(2,jbp)) then
                  ivlc(1,jbp)=ivlc(1,jbp)+1
                  ivlc(2,jbp)=ivlc(2,jbp)+1
                  if(itrjt.eq.1) then
                    ipact(jt,jbp)=ipact(jt,jbp)-1
                    iqact(jr,jbp)=iqact(jr,jbp)-1
                  else
                    iqact(jt,jbp)=iqact(jt,jbp)-1
                    ipact(jr,jbp)=ipact(jr,jbp)-1
                  end if
                end if
                if(ivlc(1,jbp)+1.gt.nmult) then
                   lord(1,jbp)=0
                   lord(2,jbp)=0
                end if
  145          continue
            end if
          end if
        end if
  150  continue
       do 151 ibp=1,ibptru
        icross(1,ibp)=.false.
        icross(2,ibp)=.false.
        if(iquark(2,ibp).eq.0) then
          icross(2,ibp)=.true.
        end if
        if(iquark(1,ibp).eq.0) then
          icross(1,ibp)=.true.
        end if
        if(icomb(1,ibp).ne.0) then
          icross(1,ibp)=.true.
        end if
        if(icomb(2,ibp).ne.0) then
          icross(2,ibp)=.true.
        end if
        if(lord(1,ibp).eq.0) then
          icross(1,ibp)=.true.
          icross(2,ibp)=.true.
        end if
        if(ivlc(1,ibp)+1.gt.nm) then
          icross(1,ibp)=.true.
        end if
        if(ivlc(2,ibp)+1.gt.nm) then
          icross(2,ibp)=.true.
        end if
  151  continue
       do 170 ibp=1,ibptru
        ivord=ivlc(1,ibp)
        if(lord(1,ibp).eq.0) then
          go to 170
        else if(ivord+1.gt.nm) then
          go to 170
        else if(icomb(1,ibp).ne.0) then
          go to 170
        else if(iquark(1,ibp).eq.0) then
          if(ibp.gt.ibpfor) then
             call errex(
     a           'strist:breakpoint without rightmoving quark')
          end if
          go to 170
        end if
        jbpcrs=0
        xdifmn=xlcrop(1)+1.0
        do 155 jbp=1,ibptru
         ivor2=ivlc(2,jbp)
         if(jbp.eq.ibp) then
           go to 155
         else if(lord(1,jbp).lt.lord(1,ibp)) then
           go to 155
         else if(lord(1,jbp).eq.0) then
           go to 155
         else if(ivor2+1.gt.nm) then
           go to 155
         else if(icomb(2,jbp).ne.0) then
           go to 155
         else if(iquark(2,jbp).eq.0) then
           if(jbp.gt.ibpfor) then
              call errex(
     a           'strist:breakpoint without leftmoving quark')
           end if
           go to 155
         end if
         if(lord(2,ibp).gt.lord(2,jbp).and.
     a         xlcmx(2,jbp).lt.xlcbp(2,ibp).and.
     b            xlcmx(1,ibp).lt.xlcbp(1,jbp)) then
           xdif=xlcbp(1,jbp)-xlcmx(1,ibp)
           if(xdif.lt.xdifmn) then
             xdifmn=xdif
             jbpcrs=jbp
           end if
         end if
  155   continue
        if(jbpcrs.eq.0) then
          write(lun8,*) 'ibp=',ibp
          call errex('strist:no jbpcrs found')
        else
          dif1=xdifmn
          dif2=xlcbp(2,ibp)-xlcmx(2,jbpcrs)
          xlcmx(1,ibp)=xlcbp(1,jbpcrs)
          xlcmx(2,jbpcrs)=xlcbp(2,ibp)
          icross(1,ibp)=.true.
          if(icross(2,jbpcrs)) then
            call errex('strist:left jbpcrs quark trajektory used up')
          end if
          icross(2,jbpcrs)=.true.
        end if
        jbp=jbpcrs
        iq1i=iquark(1,ibp)
        iq2j=iquark(2,jbp)
        itr1i=itrip(iq1i)
        itr2j=itrip(iq2j)
        ivor2=ivlc(2,jbp)
        if(itr1i.eq.1) then
          ipi=0
          iqi=1
        else
          ipi=1
          iqi=0
        end if
        tnsdi=0.75*(casop(ipact(1,ibp),iqact(1,ibp))-
     a               casop(iqact(1,ibp)-ipi,ipact(1,ibp)-iqi))
        if(itr2j.eq.1) then
          ipi=0
          iqi=1
        else
          ipi=1
          iqi=0
        end if
        tnsdj=0.75*(casop(ipact(2,jbp),iqact(2,jbp))-
     a               casop(iqact(2,jbp)-ipi,ipact(2,jbp)-iqi))
        equark(1,ibp)=equark(1,ibp)+tnsdi*dif1
        equark(2,jbp)=equark(2,jbp)+tnsdj*dif2
        ivlc(1,ibp)=ivlc(1,ibp)+1
        ivlc(2,jbp)=ivlc(2,jbp)+1
        if(itr2j.eq.10) then
          ipact(1,ibp)=ipact(1,ibp)-1
        else
          iqact(1,ibp)=iqact(1,ibp)-1
        end if
        if(itr1i.eq.10) then
          ipact(2,jbp)=ipact(2,jbp)-1
        else
          iqact(2,jbp)=iqact(2,jbp)-1
        end if
        iuseup=0
        if(itr1i.eq.10) then
          irmain=iqact(1,ibp)
        else if(itr1i.eq.1) then
          irmain=ipact(1,ibp)
        end if
        if(itr2j.eq.10) then
          irmain=irmain*iqact(2,jbp)
        else if(itr2j.eq.1) then
          irmain=irmain*ipact(2,jbp)
        end if
        if(ivord+1.eq.nmult) then
          if(ivor2+1.ne.nmult) then
            call errex('strist:ivord.ne.ivor2')
          end if
          icomb(1,ibp)=jbp
          icomb(2,jbp)=ibp
        else if(itr1i*itr2j.eq.10.and.
     a             ranf(0).le.1./(1.+irmain)) then
          icomb(1,ibp)=jbp
          icomb(2,jbp)=ibp
          iuseup=1
        else
          if(itr1i.eq.10.and.
     a                   iqact(1,ibp).eq.0) then
             icomb(1,ibp)=jbp
             icomb(2,jbp)=ibp
             iuseup=1
          else if(itr1i.eq.1.and.
     a                       ipact(1,ibp).eq.0) then
             icomb(1,ibp)=jbp
             icomb(2,jbp)=ibp
             iuseup=1
          else if(itr2j.eq.10.and.
     a                       iqact(2,jbp).eq.0) then
             icomb(1,ibp)=jbp
             icomb(2,jbp)=ibp
             iuseup=1
          else if(itr2j.eq.1.and.
     a                       ipact(2,jbp).eq.0) then
             icomb(1,ibp)=jbp
             icomb(2,jbp)=ibp
             iuseup=1
          end if
        end if
        if(icomb(1,ibp).ne.0) then
          if(itr1i*itr2j.ne.10) then
            call errex('strist:two quarks do not match for hadron')
          end if
          lor1=lord(1,jbp)
          lor2=lord(2,ibp)
          if(iuseup.eq.1) then
            do 169 kbp=ibp+1,ibptru
             if(lor1.lt.lord(1,kbp).and.
     a                   lor2.lt.lord(2,kbp)) then
               if(min(ivlc(1,kbp),ivlc(2,kbp)).le.nm) then
                 call errex(
     a            'strist:break point in lc of xpoint,wrong ivlc')
               end if
               ivlc(1,kbp)=ivlc(1,kbp)-1
               ivlc(2,kbp)=ivlc(2,kbp)-1
               if(itr1i.eq.10) then
                 iqact(1,kbp)=iqact(1,kbp)+1
               else
                 ipact(1,kbp)=ipact(1,kbp)+1
               end if
               if(itr2j.eq.10) then
                 iqact(2,kbp)=iqact(2,kbp)+1
               else
                 ipact(2,kbp)=ipact(2,kbp)+1
               end if
             end if
  169       continue
          end if
        end if
  170  continue
       do 180 ibp=1,ibptru
        if(.not.icross(1,ibp).or..not.icross(2,ibp)) then
           call errex('strist:icross=f afterwards')
        end if
  180  continue
  200  continue
       do 140 ibp=1,ibpfor
        if(iquark(1,ibp).eq.0) then
          jt=2
        else
          jt=1
        end if
        iqibp=iquark(jt,ibp)
        if(iabs(iqibp).lt.10) go to 140
        jr=3-jt
        par(11)=para11
        jbp=icomb(jt,ibp)
        iqjbp=iquark(jr,jbp)
        if(iabs(iqjbp).gt.10.and.jbp.le.ibpfor) then
          lbp=0
          do 131 kbp=1+mod(jr-1,2),ibpfor-mod(jr,2),2
           if(kbp.eq.ibp) go to 131
           iqkbp=iquark(jt,kbp)
           if(iabs(iqkbp).gt.10) go to 131
           if(itrip(iqibp).ne.itrip(iqkbp)) go to 131
           if(iabs(iquark(jr,icomb(jt,kbp))).gt.10) go to 131
           lbp=kbp
           go to 128
  131     continue
  128     continue
          if(lbp.eq.0) then
            go to 100
          else
            iquark(jt,ibp)=iqkbp
            iquark(jt,lbp)=iqibp
          end if
        end if
  140  continue
       do 201  nsi=1,nsingl-1,2
        ibpl=0
        ibpr=0
        ibptr=ibptru
  202   continue
        if(ibptru.eq.0) then
          ibptru=1
          ibptr=1
        else if(lord(1,ibptr).eq.0) then
        else if(ibptr.gt.ibpfor+1) then
          ibptr=ibptr-1
          go to 202
        else if(ibptru.lt.kbpmax) then
          ibptru=ibptru+1
          ibptr=ibptru
        else
          call errex('strist 201 no array element free')
        end if
        if(ibpr.eq.0) then
          ibpr=ibptr
          lord(1,ibpr)=-1
          lord(2,ibpr)=-2
          go to 202
        else
          ibpl=ibptr
          lord(1,ibpl)=-1
          lord(2,ibpl)=-2
        end if
        iro1=mod(isingl(nsi),1000)
        iro2=mod(isingl(nsi+1),1000)
        iro3=isingl(nsi)/1000
        if(iro3.eq.0) iro3=isingl(nsi+1)/1000
        equark(1,ibpr)=plcone(1,iro1)+plcone(1,iro2)
        if(iro3.gt.0)
     a  equark(1,ibpr)=equark(1,ibpr)+plcone(1,iro3)
        equark(2,ibpr)=plcone(2,iro1)+plcone(2,iro2)
        if(iro3.gt.0)
     a  equark(2,ibpr)=equark(2,ibpr)+plcone(2,iro3)
        equark(1,ibpl)=0.0
        equark(2,ibpl)=0.0
        call luptdi(94,pxr,pyr)
        ptr(1,1,ibpr)=pxr+ptstor(1,iro1)
        ptr(1,2,ibpr)=pyr+ptstor(2,iro1)
        if(isingl(nsi).gt.1000) then
          ptr(1,1,ibpr)=ptr(1,1,ibpr)+ptstor(1,iro3)
          ptr(1,2,ibpr)=ptr(1,2,ibpr)+ptstor(2,iro3)
        end if
        ptr(2,1,ibpr)=-pxr+ptstor(1,iro2)
        ptr(2,2,ibpr)=-pyr+ptstor(2,iro2)
        if(isingl(nsi+1).gt.1000) then
          ptr(2,1,ibpr)=ptr(2,1,ibpr)+ptstor(1,iro3)
          ptr(2,2,ibpr)=ptr(2,2,ibpr)+ptstor(2,iro3)
        end if
        ptr(1,1,ibpl)=0.0
        ptr(1,2,ibpl)=0.0
        ptr(2,1,ibpl)=0.0
        ptr(2,2,ibpl)=0.0
        xlcbp(1,ibpr)=equark(1,ibpr)
        xlcbp(2,ibpr)=0.0
        xlcmx(1,ibpr)=xlcbp(1,ibpr)
        xlcmx(2,ibpr)=sqrt(ptr(1,1,ibpr)**2+ptr(1,2,ibpr)**2)/
     a                 xlcbp(1,ibpr)
        xlcbp(2,ibpl)=equark(2,ibpr)
        xlcbp(1,ibpl)=0.0
        xlcmx(2,ibpl)=xlcbp(2,ibpl)
        xlcmx(1,ibpl)=sqrt(ptr(2,1,ibpr)**2+ptr(2,2,ibpr)**2)/
     a                 xlcbp(2,ibpl)
        do 203 jt=1,2
         icomb(jt,ibpr)=ibpl
         icomb(jt,ibpl)=ibpr
         iquark(jt,ibpr)=iflstr(jt,nsi)
         iquark(3-jt,ibpl)=iflstr(jt,nsi+1)
         ibp=0
         if(iabs(iflstr(jt,nsi)).gt.10) then
           ibp=ibpr
           jtact=jt
         else if(iabs(iflstr(jt,nsi+1)).gt.10) then
           ibp=ibpl
           jtact=3-jt
         end if
         if(ibp.ne.0) then
           jetzhd(jtact,ibp)=iqqkf(jt,mxs+1-nsi)
           if(iabs(jetzhd(jtact,ibp)).le.1) then
             call errex('strist:iqqkf  is empty')
           end if
         end if
         dquark(jt,ibpr)=0.0
         dquark(jt,ibpl)=0.0
  203   continue
        ipiq(ibpr)=100
        ipiq(ibpl)=1
  201  continue
       do 205  ibp=1,ibpfor
        io=(ibp+mod(ibp,2))/2
        jt=1
        if(mod(ibp,2).eq.1) jt=2
        jr=3-jt
        if(iquark(jt,ibp).eq.0)
     a  call errex('strist205: empty iquark')
        nm=iord(jr,io)
        if(iqqkf(jr,nm).le.0) go to 205
        iqibp=iquark(jt,ibp)
        if(iabs(iqibp).lt.10)
     a  call errex('strist205: no diquark')
        ibpl=0
        ibpr=0
        ibptr=ibptru
  204   continue
        if(ibptru.eq.0) then
          ibptru=1
          ibptr=1
        else if(lord(1,ibptr).eq.0) then
        else if(ibptr.gt.ibpfor+1) then
          ibptr=ibptr-1
          go to 204
        else if(ibptru.lt.kbpmax) then
          ibptru=ibptru+1
          ibptr=ibptru
        else
          call errex('strist205 no array element free')
        end if
        if(ibpr.eq.0) then
          ibpr=ibptr
          lord(1,ibpr)=-1
          lord(2,ibpr)=-1
          go to 204
        else
          ibpl=ibptr
          lord(1,ibpl)=-1
          lord(2,ibpl)=-1
        end if
        iro1=iqqkf(jr,nm)
        if(iro1.gt.iroin)
     a  call errex('strist205: iro1 out of range')
        equark(jr,ibpr)=plcone(jr,iro1)
        equark(jt,ibpr)=0.0
        ifl1=iqibp/10
        ifl2=iqibp-10*ifl1
        if(iqibp.lt.0) then
          isig=-1
        else
          isig=1
        end if
        ipa=ipdgr(jr,io)+isig
        iqa=iqdgr(jr,io)-isig
        if(ipa.lt.0.or.iqa.lt.0)
     a  call errex('strist205:ipa/iqa problem')
        mtry=0
  225   continue
        mtry=mtry+1
        if(mtry.gt.50) call errex('strist225 abort')
        call flavor(ipa,iqa,ifl3)
        if(iabs(ifl3).gt.10) go to 225
        ifl3=-ifl3
        if(ifl3*iqibp.lt.0) go to 225
        if(ifl2.ne.ifl3.and.ranf(0).gt.qqdqqs) go to 225
        iquark(jr,ibpr)=ifl1
        iquark(jt,ibpr)=0
        iquark(jt,ibp)=kqqret(ifl2,ifl3)
        iquark(jt,ibpl)=-ifl3
        iquark(jr,ibpl)=0
        if(par(12).gt.0.) then
          kqqbar=(isign(1,(ipa-iqa)*ifl3)+3)/2
          par12=par(12)
          par(12)=sigptr(ipa,iqa,kqqbar)
          call luptdi(ifl,pxr,pyr)
          par(12)=par12
        else
          pxr=0.0
          pyr=0.0
        end if
        ptr(jr,1,ibpr)=pxr
        ptr(jr,2,ibpr)=pyr
        ptr(jt,1,ibp)=-pxr+ptr(jt,1,ibp)
        ptr(jt,2,ibp)=-pyr+ptr(jt,2,ibp)
        xlcbp(jr,ibpr)=xlcbp(jr,ibp)+0.5*equark(jr,ibpr)
        xlcbp(jt,ibpr)=0.0
        xlcmx(jr,ibpr)=xlcbp(jr,ibpr)
        xlcmx(jt,ibpr)=sqrt(ptr(jr,1,ibpr)**2+ptr(jr,2,ibpr)**2)/
     a                 (0.5*equark(jr,ibpr))
        icomb(jr,ibpr)=ibpl
        icomb(jt,ibpr)=0
        icomb(jt,ibpl)=ibpr
        icomb(jr,ibpl)=0
        do 206 jn=1,2
         xlcbp(jn,ibpl)=xlcbp(jn,ibpr)
         xlcmx(jn,ibpl)=xlcmx(jn,ibpr)
         ptr(jt,jn,ibpr)=0.0
         ptr(1,jn,ibpl)=0.0
         ptr(2,jn,ibpl)=0.0
         equark(jn,ibpl)=0.0
         dquark(jn,ibpr)=0.0
         dquark(jn,ibpl)=0.0
  206   continue
        ipiq(ibpr)=100*ipa+iqa
        ipiq(ibpl)=100*ipa+iqa
  205  continue
       pplall=0.0
       pmiall=0.0
       do 210  ibp=1,ibptru
        if(lord(1,ibp).lt.0) then
          do 224 jt=1,2
           if(iabs(iquark(jt,ibp)).gt.10) then
             jbp=icomb(jt,ibp)
             jetzhd(3-jt,jbp)=-1
             kf1=jetzhd(jt,ibp)
             if(iabs(kf1).le.40) then
               call errex('strist204,no baryon')
             end if
             bpli(jt,ibp)=getmas(0,kf1,0,-1.0)
           else
             jetzhd(jt,ibp)=0
             bpli(jt,ibp)=0.0
           end if
  224     continue
        else
          jetzhd(1,ibp)=0
          jetzhd(2,ibp)=0
          bpli(1,ibp)=0.0
          bpli(2,ibp)=0.0
        end if
        pplall=pplall+equark(1,ibp)+dquark(1,ibp)
        pmiall=pmiall+equark(2,ibp)+dquark(2,ibp)
  210  continue
       if(abs(pplall-ps(1)).gt.0.003.or.
     a      abs(pmiall-ps(2)).gt.0.003) then
          write(lun8,*) pplall,pmiall,ps(1),ps(2)
          call errex('strist:no energy/mom. conservation, 210')
       end if
       kbreak=0
       ibpsto=0
  220  ibpsto=ibpsto+1
       ibp=ibpsto
  221  continue
        if(ibp.gt.ibptru) go to 222
        if(ibp.le.ibpfor) then
          if(iquark(1,ibp).eq.0) then
            jt=2
          else
            jt=1
          end if
          iqibp=iquark(jt,ibp)
          if(iabs(iqibp).lt.10) go to 220
          jr=3-jt
          par(11)=para11
          jbp=icomb(jt,ibp)
          iqjbp=iquark(jr,jbp)
          if(iabs(iqjbp).gt.10.and.jbp.le.ibpfor) then
            call errex('strist:unexpected qq-qbqb configuration')
          else if(
     a       jbp.le.ibpfor.or.
     b       (jbp.gt.ibpfor.and.jbp.le.ibptot.and.
     c        (jetzhd(1,jbp).eq.-1.or.jetzhd(2,jbp).eq.-1))) then
            mtry=0
            iqibpb=0
            iqqibp=iqibp
  211       continue
            mtry=mtry+1
            if(mtry.gt.100) then
              call errex('strist211:mtry>100')
            end if
            if(ranf(0).gt.barwgh(para11,iqqibp,iqjbp)) then
              iqibpb=0
              mof=int(ranf(0)*(nmult+1))
              do 209 ma=mof+1,mof+nmult
               nbp=2*(mod(ma,nmult)+1)
               if(jt.eq.2) nbp=nbp-1
               if(nbp.le.0.or.nbp.gt.ibpfor) then
                 call errex('strist:loop209 problem')
               end if
               if(iquark(jt,nbp).eq.0) then
                 call errex('strist:loop209 problem')
               else
                 iqnbp=iquark(jt,nbp)
               end if
               if(iabs(iqnbp).gt.10) go to 209
               if(jetzhd(jt,nbp).ne.0) go to 209
               iqibp1=iqibp/10
               iqibp2=iqibp-10*iqibp1
               if(iqibp1.eq.iqibp2) then
                 if(iqibp1+iqnbp.ne.0) go to 209
                 iqibpa=iqibp1
               else
                 if(iqibp1.eq.-iqnbp) then
                   iqibpa=iqibp2
                 else if(iqibp2.eq.-iqnbp) then
                   iqibpa=iqibp1
                 else
                   go to 209
                 end if
               end if
  207          iqibpb=isign(1,iqibpa)*(int(ranf(0)*(2.+par2))+1)
               if(iqibpb.ne.iqibpa.and.ranf(0).gt.qqdqqs) then
                 go to 207
               end if
               go to 208
  209         continue
              if(mtry.gt.1.and.iqibp.eq.0) then
                call errex('strist 208,iqibp problem')
              end if
  208         continue
              if(iqibpb.ne.0) then
                iqqibp=kqqret(iqibpa,iqibpb)
                go to 211
              end if
            end if
            if(iqibpb.ne.0) then
              iquark(jt,ibp)=iqqibp
              iquark(jt,nbp)=-iqibpb
            end if
            call luifld(iqqibp,0,iqjbp,ifldum,kf1)
            jetzhd(1,jbp)=-1
            jetzhd(2,jbp)=-1
            jetzhd(jt,ibp)=kf1
            bpli(jt,ibp)=getmas(0,kf1,0,-1.0)
          else if(jbp.gt.ibpfor.and.jbp.le.ibptot) then
            if(jetzhd(1,jbp).eq.-1.or.jetzhd(2,jbp).eq.-1) then
              call errex('strist:dead branch')
            else
              ipbrk=ipiq(jbp)
              iqbrk=mod(ipbrk,100)
              ipbrk=ipbrk/100
              if(ipbrk.gt.iprbr1) ipbrk=iprbr1
              if(iqbrk.gt.iprbr1) iqbrk=iprbr1
              iquabr=iquark(1,jbp)
              if(iqbrk.gt.ipbrk) then
                iquabr=-iquabr
                ientry=iqbrk*(iqbrk+1)/2+ipbrk
              else
                ientry=ipbrk*(ipbrk+1)/2+iqbrk
              end if
              if(itrip(iquabr).eq.1) then
                ike=1
              else
                ike=2
              end if
              if(prbrop(2*ike-1,ientry).eq.0.0) then
                write(lun8,*)jt,ipiq(jbp),jbp,ike,iquark(jt,jbp),ientry
                call errex('strist abort when generating qqbar')
              end if
              par(2)=prbrop(ike*2,ientry)/prbrop(2*ike-1,ientry)
              call luifld(iqibp,0,0,ifld,kf1)
            end if
            jetzhd(jt,ibp)=kf1
            bpli(jt,ibp)=getmas(0,kf1,0,-1.0)
            iquark(jr,jbp)=ifld
            iquark(jt,jbp)=-ifld
            jetzhd(1,jbp)=-1
            jetzhd(2,jbp)=-1
            par(2)=par2
          end if
          par(11)=par11
          go to 220
        end if
        if(iquark(1,ibp).eq.0) go to 220
        if(lord(1,ibp).eq.0) go to 220
        kbreak=kbreak+1
        if(nlund+kbreak+ibpfor/2.gt.2000) then
          call errex('strist:jetset array too small')
        end if
  212   continue
        iqlibp=iquark(2,ibp)
        if(iabs(iqlibp).lt.10) go to 220
        jbpl=icomb(2,ibp)
        jbpr=icomb(1,ibp)
        if(lord(1,ibp).lt.0.and.lord(2,jbpl).lt.0) go to 220
        if(lord(2,ibp).lt.0.and.lord(1,jbpr).lt.0) go to 220
        jqlibp=iquark(1,jbpl)
        jqribp=iquark(2,jbpr)
        if(iabs(jqlibp).gt.10.or.
     a          iabs(jqribp).gt.10) then
          if((jbpl.lt.ibp.and.jbpl.gt.ibpfor.
     a                and.iabs(jqlibp).gt.10).or.
     b       (jbpr.lt.ibp.and.jbpr.gt.ibpfor.
     c                and.iabs(jqribp).gt.10)) then
            call errex('strist:lower entry contains diquark')
          else
            ipbrk=ipiq(ibp)
            iqbrk=mod(ipbrk,100)
            ipbrk=ipbrk/100
            ltry=0
  214       continue
            ltry=ltry+1
            if(ltry.gt.100) then
              call errex('strist214:ltry>100')
            end if
            call flavor(ipbrk,iqbrk,ifl)
            if(itrip(-iqlibp).ne.itrip(ifl)) then
               go to 214
            else if(iabs(ifl).lt.10) then
               iquark(1,ibp)=ifl
               iquark(2,ibp)=-ifl
            else
               go to 214
            end if
          end if
          go to 212
        else
          par1=par(1)
          par3=par(3)
          par4=par(4)
          par5=par(5)
          if(ranf(0).gt.0.5) then
            igolr=1
            if(jbpr.le.ibpfor.or.
     a         jetzhd(1,jbpr).eq.-1.or.
     b                 jetzhd(2,jbpr).eq.-1) igolr=2
          else
            igolr=2
            if(jbpl.le.ibpfor.or.
     a         jetzhd(1,jbpl).eq.-1.or.
     b                 jetzhd(2,jbpl).eq.-1) igolr=1
          end if
          if(igolr.eq.2) then
            iflqq=-iqlibp
            iflq=iquark(2,jbpr)
            jetzhd(1,jbpr)=-1
            jetzhd(2,jbpr)=-1
          else
            iflqq=iqlibp
            iflq=iquark(1,jbpl)
            jetzhd(1,jbpl)=-1
            jetzhd(2,jbpl)=-1
          end if
          ipbrk=ipiq(ibp)
          iqbrk=mod(ipbrk,100)
          ipbrk=ipbrk/100
          if(ipbrk.gt.iprbr1) ipbrk=iprbr1
          if(iqbrk.gt.iprbr1) iqbrk=iprbr1
          iquabr=-iqlibp
          if(iqbrk.gt.ipbrk) then
            iquabr=-iquabr
            ientry=iqbrk*(iqbrk+1)/2+ipbrk
          else
            ientry=ipbrk*(ipbrk+1)/2+iqbrk
          end if
          if(iquabr.gt.0) then
            rnons=2.*prbrop(1,ientry)/
     a                        (2.*prbrop(1,ientry)+prbrop(2,ientry))
            pqs=1.-rnons
            pss=pqs*pqs
          else
            call errex('strist: qq attracted to wrong side')
          end if
          par(1)=10.0
          par(3)=1.0
          par(4)=1.0
          par(5)=0.0
          par(11)=1.0
          ktry=0
  213     continue
          ktry=ktry+1
          if(ktry.gt.500) then
            call errex('strist213:ktry>200')
          end if
          par(2)=1.0
          call luifld(iflq,0,0,iflnew,kfb)
          if(iabs(iflnew).gt.10) then
           if1new=mod(iabs(iflnew),10)
           if2new=iabs(iflnew)/10
          else
            go to 213
          end if
          if(if1new.eq.3.and.if2new.eq.3) then
            if(ranf(0).gt.pss) go to 213
          else if(if1new.eq.3.or.if2new.eq.3) then
            if(ranf(0).gt.pqs) go to 213
          end if
          bpli(3-igolr,ibp)=getmas(0,kfb,0,-1.0)
          jetzhd(3-igolr,ibp)=kfb
          if(igolr.eq.2) then
            iquark(1,ibp)=iflnew
            iquark(2,ibp)=-iflnew
          else
            iquark(2,ibp)=iflnew
            iquark(1,ibp)=-iflnew
          end if
          par(1)=par1
          par(3)=par3
          par(4)=par4
          jbp=jbpl
          ifle=isign(1,iqlibp)*iabs(iflnew)
          jt=1
          jr=2
  215     continue
          if(igolr.eq.jt) go to 216
          if(jbp.le.ibpfor.or.
     a       jetzhd(1,jbp).eq.-1.or.
     b                 jetzhd(2,jbp).eq.-1) then
            ifld=iquark(jt,jbp)
            call luifld(ifle,0,ifld,ifldum,kf1)
          else
            ipbrk=ipiq(jbp)
            iqbrk=mod(ipbrk,100)
            ipbrk=ipbrk/100
            if(ipbrk.gt.iprbr1) ipbrk=iprbr1
            if(iqbrk.gt.iprbr1) iqbrk=iprbr1
            iquabr=iquark(1,jbp)
            if(iqbrk.gt.ipbrk) then
              iquabr=-iquabr
              ientry=iqbrk*(iqbrk+1)/2+ipbrk
            else
              ientry=ipbrk*(ipbrk+1)/2+iqbrk
            end if
            if(iquabr.lt.0) then
              ike=1
            else
              ike=2
            end if
            if(prbrop(2*ike-1,ientry).eq.0.0) then
              call errex('strist215 abort,prbrop=0')
            end if
            par(2)=prbrop(ike*2,ientry)/prbrop(2*ike-1,ientry)
            call luifld(ifle,0,0,ifld,kf1)
          end if
          if(ifld.eq.0.or.kf1.eq.0) then
             call errex('strist:luifld didnot generate quark')
          end if
          p10sup=1.
          if(iabs(kfb).gt.60) p10sup=para11
          if(iabs(kf1).gt.60) p10sup=p10sup*para11
          if(ranf(0).gt.p10sup) go to 213
          if(jbp.gt.ibpfor) then
            iquark(jt,jbp)=ifld
            iquark(jr,jbp)=-ifld
          end if
          bpli(igolr,ibp)=getmas(0,kf1,0,-1.0)
          jetzhd(igolr,ibp)=kf1
          jetzhd(1,jbp)=-1
          jetzhd(2,jbp)=-1
  216     continue
          if(jbp.eq.jbpl) then
            if(jbp.eq.jbpr) then
              call errex('strist:ibp has identical partners,l and r')
            end if
            ifle=-ifle
            jbp=jbpr
            jt=2
            jr=1
            go to 215
          end if
          par(2)=par2
          par(5)=par5
          par(11)=par11
        end if
        if(ibp.lt.ibptru) go to 220
  222  continue
       pxsum=0.0
       pysum=0.0
       do 229  ibp=1,ibptru
        pxsum=pxsum+ptr(1,1,ibp)+ptr(2,1,ibp)
        pysum=pysum+ptr(1,2,ibp)+ptr(2,2,ibp)
  229  continue
       if(abs(pxsum-ptsum(1)).gt.0.001.or.
     a           abs(pysum-ptsum(2)).gt.0.001) then
         write(lun8,*) 'px/ysum=',pxsum,pysum
         write(lun8,*) 'ptsum=',(ptsum(i),i=1,2)
         call errex('strist:no transv.mom. conservation, 229')
       end if
       nsave=nlund
       iposi=0
       embum=0.0
       do 230  ibp=1,ibptru
        if(lord(1,ibp).eq.0) go to 230
        if(iquark(1,ibp).eq.0) go to 230
        ifla=iquark(1,ibp)
        jbp=icomb(1,ibp)
        iflb=iquark(2,jbp)
        itra=itrip(ifla)
        itrb=itrip(iflb)
        if(itra*itrb.ne.10) then
          call errex('strist 230:quarks not in color singlet')
        end if
        if(iabs(ifla).gt.10) then
          kf=jetzhd(1,ibp)
          eml=bpli(1,ibp)
        else if(iabs(iflb).gt.10) then
          kf=jetzhd(2,jbp)
          eml=bpli(2,jbp)
        else
          call luifld(ifla,0,iflb,ifldum,kf)
          if(kf.ne.34.and.kf.ne.35)
     a    eml=getmas(0,kf,1,-1.0)
        end if
        if(kf.eq.0) call errex('strist:kf=0 230')
        if(kf.eq.25.and.ranf(0).gt.par(80)) then
          kf=124
          eml=getmas(0,kf,0,-1.0)
        end if
        if(ida(51).ne.0) then
          probch=0.6667*(sin(angmxv)-cos(angmxv)/sqrt(2.0))**2
          if(kf.eq.34) then
            if(ranf(0).lt.probch) kf=35
          else if(kf.eq.35) then
            if(ranf(0).lt.probch) kf=34
          end if
        end if
        if(kf.eq.34.or.kf.eq.35)
     a                 eml=getmas(0,kf,1,-1.0)
        nlund=nlund+1
        ivlc(1,nlund-nsave)=0
        ipact(1,ibp)=nlund
        if(iquark(2,ibp).eq.0) then
          ipact(2,ibp)=0
        end if
        ipact(2,jbp)=nlund
        if(iquark(1,jbp).eq.0) then
          ipact(1,jbp)=0
        end if
        k(nlund,2)=kf
        plund(nlund,1)=ptr(1,1,ibp)+ptr(2,1,jbp)
        plund(nlund,2)=ptr(1,2,ibp)+ptr(2,2,jbp)
        plund(nlund,4)=0.5*(equark(1,ibp)+equark(2,jbp)+
     a                      dquark(2,ibp)+dquark(1,jbp))
        plund(nlund,3)=0.5*(equark(1,ibp)-equark(2,jbp)-
     a                      dquark(2,ibp)+dquark(1,jbp))
        plund(nlund,5)=eml
        embum=embum+sqrt(eml*eml+plund(nlund,1)**2+plund(nlund,2)**2)
        iposi=iposi+1
        xhad(4,iposi)=xlcmx(1,ibp)
        xhad(3,iposi)=xlcmx(2,jbp)
        if(mod(ida(16),2).eq.0) then
          vf=0.5
        else
          vf=1.0
        end if
        if(lord(1,ibp).lt.0) then
          vf=0.0
          if(lord(2,jbp).eq.-2) then
            xhad(3,iposi)=xlcmx(2,ibp)
          end if
        end if
        ppnl=plund(nlund,4)+plund(nlund,3)
        pmnl=plund(nlund,4)-plund(nlund,3)
        xhad(4,iposi)=xhad(4,iposi)-vf*ppnl
        xhad(3,iposi)=xhad(3,iposi)-vf*pmnl
        if(ibp.le.ibpfor) then
          if(xhad(4,iposi).lt.xlcbp(1,jbp))
     a    xhad(4,iposi)=xlcbp(1,jbp)
        else
          if(xhad(4,iposi).lt.
     a        min(xlcbp(1,ibp),xlcbp(1,jbp))) then
            xhad(4,iposi)=min(xlcbp(1,ibp),xlcbp(1,jbp))
          end if
        end if
        if(jbp.le.ibpfor) then
          if(xhad(3,iposi).lt.xlcbp(2,ibp))
     a    xhad(3,iposi)=xlcbp(2,ibp)
        else
          if(xhad(3,iposi).lt.
     a        min(xlcbp(2,ibp),xlcbp(2,jbp))) then
            xhad(3,iposi)=min(xlcbp(2,ibp),xlcbp(2,jbp))
          end if
        end if
        thad=0.5*(xhad(4,iposi)+xhad(3,iposi))*tprd
        zhad=0.5*(xhad(4,iposi)-xhad(3,iposi))*tprd
        xhad(4,iposi)=thad
        xhad(3,iposi)=zhad
        if(xhad(4,iposi).le.abs(xhad(3,iposi))) then
          write(lun8,*) 't,z=',thad,zhad
          call errex(
     a          'strist502:produced hadron not in forward lc')
        else
          dtinv2=sqrt(xhad(4,iposi)**2-xhad(3,iposi)**2)
        end if
        ntri=0
  502   ntri=ntri+1
        if(ntri.gt.50) then
            call errex('strist:ntri>50')
            return
        endif
        fihad=pi2*ranf(0)
        xdist=min(da(17),dtinv2)*sqrt(ranf(0))
        xhad(1,iposi)=xdist*cos(fihad)*tprd
        xhad(2,iposi)=xdist*sin(fihad)*tprd
        tinv2=xhad(4,iposi)**2
        if(ntri.gt.30) then
          write(lun8,*)'strist problem: xhad=',
     a                        (xhad(i,iposi),i=1,4)
        end if
        do 501 i=1,3
  501   tinv2=tinv2-xhad(i,iposi)**2
        if(tinv2.lt.0.0) go to 502
  230  continue
       if(embum.ge.emtrue) then
         nlund=nsave
         go to 100
       end if
       ihad=kbreak+ibpfor/2
       if(nlund-nsave.ne.ihad) then
         write(lun8,*) 'ihad,kbreak,ibpfor',ihad,kbreak,ibpfor
         call errex('strist:wrong no. of final hadrons')
       end if
       nlmnsv=nlund-nsave
       nlstrt=int(ranf(0)*(nlmnsv))
       do 240  nll=nlstrt,nlstrt+nlmnsv-1
        nl=nsave+mod(nll,nlmnsv)+1
        if(ivlc(1,nl-nsave).eq.1) go to 240
        eml=plund(nl,5)
        if(ranf(0).gt.0.5) then
          jt1=1
          jt2=2
          ivzjt=1
        else
          jt1=2
          jt2=1
          ivzjt=-1
        end if
        do 239 jt=jt1,jt2,ivzjt
         jr=3-jt
         ibp=0
         do 232 ibptst=1,ibptru
          if(nl.eq.ipact(jt,ibptst)) then
            ibp=ibptst
            go to 233
          end if
  232    continue
  233    continue
         if(ibp.eq.0) then
           call errex('strist 233:ibp=0')
         end if
         itry=0
  234    continue
         itry=itry+1
         nk=0
         jbpsto=0
         rmeasu=max(xlcrop(1)*xlcrop(2),xcutf*xcutf)
         jbstrt=int(ranf(0)*ibptru)
         do 235 jbpp=jbstrt,jbstrt+ibptru-1
          jbp=mod(jbpp,ibptru)+1
          if(lord(1,jbp).eq.0) go to 235
          if(lord(1,jbp).gt.lord(1,ibp).and.
     a        lord(2,jbp).gt.lord(2,ibp).and.
     b           ((ibp.gt.ibpfor.and.lord(1,ibp).gt.0).or.
     c            (jbp.gt.ibpfor.and.lord(2,jbp).gt.0))
     d                                                 ) go to 235
          do 236 ntr=1,itry-1
  236     if(ivlc(2,ntr).eq.jbp) go to 235
          rmeas=(xlcbp(1,ibp)-xlcbp(1,jbp))*
     a                (xlcbp(2,jbp)-xlcbp(2,ibp))
          if(rmeas.lt.rmeasu) then
            if(jbp.ne.icomb(jt,ibp).and.
     a                rmeas.gt.xcutf**2) go to 235
            if(iquark(jt,jbp).eq.0.or.
     a                     lord(jt,jbp).lt.0) then
               nact=ipact(jr,jbp)
            else if(iquark(jr,jbp).eq.0.or.
     a                     lord(jr,jbp).lt.0) then
               nact=ipact(jt,jbp)
            elseif(jbp.eq.icomb(jt,ibp))then
               nact=ipact(jt,jbp)
            else
              if(lord(jt,jbp).gt.lord(jt,ibp)) then
                nact=ipact(jr,jbp)
              else
                nact=ipact(jt,jbp)
              end if
            end if
            if(nact.eq.0) go to 235
            if(nact.eq.nl) go to 235
            rmeasu=rmeas
            nk=nact
            jbpsto=jbp
          end if
  235    continue
         if(nk.eq.0) then
           if(jt.eq.jt1) then
             go to 239
           else
             nlund=nsave
             go to 100
           end if
         end if
         ivlc(2,itry)=jbpsto
         emk=plund(nk,5)
         do 237 i=1,3
          p1(i)=plund(nl,i)
          p2(i)=plund(nk,i)
  237    continue
         p1(0)=plund(nl,4)
         p2(0)=plund(nk,4)
         pplav=p1(0)+p1(3)+p2(0)+p2(3)
         pmiav=p1(0)-p1(3)+p2(0)-p2(3)
         emb1=sqrt(eml**2+p1(1)**2+p1(2)**2)
         emb2=sqrt(emk**2+p2(1)**2+p2(2)**2)
         nkk=nk-nsave-1
         if(nkk.lt.nlstrt) nkk=nkk+nlmnsv
         if((emb1+emb2)**2.ge.pplav*pmiav) then
           plsq=p1(0)**2-p1(3)**2
           pksq=p2(0)**2-p2(3)**2
           if(emb1**2.gt.pplav*pmiav) then
             isccss=0
           else if(plsq.gt.emb1**2) then
             isccss=-1
             emb2=sqrt(pksq)
           else if(nkk.gt.nll) then
             ivlc(1,nk-nsave)=0
             isccss=-1
             emb2=sqrt(pplav*pmiav)-emb1-1.e-3
           else
             isccss=0
           end if
           if(emb2.lt.1.e-3) isccss=0
         else
           isccss=1
         end if
         if(iabs(isccss).eq.1) then
           if(p1(0)+p1(3).gt.p2(0)+p2(3).and.
     a             p1(0)-p1(3).lt.p2(0)-p2(3))  then
             jdir=1
           else if(p1(0)+p1(3).lt.p2(0)+p2(3).and.
     a             p1(0)-p1(3).gt.p2(0)-p2(3))  then
             jdir=2
           else
             if(ranf(0).lt.0.5) then
               jdir=1
             else
               jdir=2
             end if
           end if
           call newlcp(pplav,pmiav,emb1,emb2,
     a                          p1pl,p1mi,p2pl,p2mi,jdir)
           p1(0)=0.5*(p1pl+p1mi)
           p1(3)=0.5*(p1pl-p1mi)
           p2(0)=0.5*(p2pl+p2mi)
           p2(3)=0.5*(p2pl-p2mi)
         end if
         if(iabs(isccss).ne.1) then
           go to 234
         else
           ivlc(1,nl-nsave)=1
           if(isccss.eq.1) ivlc(1,nk-nsave)=1
           do 238 i=1,3
            plund(nl,i)=p1(i)
            plund(nk,i)=p2(i)
  238      continue
           plund(nl,4)=p1(0)
           plund(nk,4)=p2(0)
           go to 240
         end if
  239   continue
  240  continue
       if(nsingl.gt.0)
     a   write(lun8,*) 'singlets involved in decay',nsingl
       jchrgs=0
       jbarys=0
       jstras=0
       do 241  nl=nsave+1,nlund
        kf=isign(1,k(nl,2))*mod(iabs(k(nl,2)),100)
        call luiflv(kf,ifla1,iflb1,iflc1,ksp)
        if(iabs(ifla1).eq.3) jstras=jstras+isign(1,ifla1)
        if(iabs(iflb1).eq.3) jstras=jstras+isign(1,iflb1)
        if(iabs(iflc1).eq.3) jstras=jstras+isign(1,iflc1)
        jchrgs=jchrgs+luchge(kf)
        k2labs=iabs(kf)
        if(k2labs.le.90) then
           if(kspin(k2labs).ge.2) then
             jbarys=jbarys+3*isign(1,kf)
           endif
        else
           call errex('strist:unidentified hadron')
        endif
  241  continue
       if(jstras.ne.kstran.or.
     a        jchrgs.ne.kcharg.or.
     b            jbarys.ne.kbaryo) then
          write(lun8,*) 'charge:',jchrgs,kcharg
          write(lun8,*) 'baryno:',jbarys,kbaryo
          write(lun8,*) 'strange',jstras,kstran
          call errex('strist 240:no quantum no. conservation')
       end if
       mst(1)=nsave+1
       mst(2)=nlund
       call lurobo(thetlu,philu,bex,bey,bez)
       do 248 i=0,3
  248  ptot(i)=0.0
       do 250  nl=nsave+1,nlund
        do 249 i=1,3
  249   ptot(i)=ptot(i)+plund(nl,i)
        ptot(0)=ptot(0)+plund(nl,4)
  250  continue
       if((abs(ptot(0)-psum(0)).gt.0.005).or.
     a        (abs(ptot(1)-psum(1)).gt.0.005).or.
     b            (abs(ptot(2)-psum(2)).gt.0.005).or.
     c               (abs(ptot(3)-psum(3)).gt.0.005)) then
        write(lun8,*) 'psum=',psum
        write(lun8,*) 'ptot=',ptot
        call errex('strist:250 no energy/mom. conservation')
       end if
       do 251 iro=1,iroout
        lstar(iro)=kstar(iro)
        lende(iro)=kende(iro)
  251  continue
       nbsrop=0
       nbqrop=0
       do 272 ibp=ibpfor+1,ibptru
         if(lord(1,ibp).le.0) go to 272
         if(icomb(1,ibp).eq.0) go to 272
         ifl=iquark(1,ibp)
         if(iabs(ifl).le.2) then
          nbqrop=nbqrop+1
          ipa=ipiq(ibp)/100
          iqa=mod(ipiq(ibp),100)
          if(ipa.gt.iqa) then
            ientry=min(iprbr2,ipa*(ipa+1)/2+iqa)
          else
            ientry=min(iprbr2,iqa*(iqa+1)/2+ipa)
          end if
          prbt
     a       =2.*prbrop(1,ientry)+prbrop(2,ientry)+2.*prbrop(3,ientry)
     a         +prbrop(4,ientry)+2.*prbrop(5,ientry)+prbrop(6,ientry)+
     b                        4.*prbrop(7,ientry)+2.*prbrop(8,ientry)+
     c                        4.*prbrop(9,ientry)+2.*prbrop(10,ientry)
          ssupp=ssupp+(prbrop(2,ientry)+prbrop(4,ientry))/prbt
          qsupp=qsupp+(prbrop(1,ientry)+prbrop(3,ientry))/prbt
          nsupp=nsupp+1
         else if(iabs(ifl).eq.3) then
          nbsrop=nbsrop+1
          ipa=ipiq(ibp)/100
          iqa=mod(ipiq(ibp),100)
          if(ipa.gt.iqa) then
            ientry=min(iprbr2,ipa*(ipa+1)/2+iqa)
          else
            ientry=min(iprbr2,iqa*(iqa+1)/2+ipa)
          end if
          prbt
     a       =2.*prbrop(1,ientry)+prbrop(2,ientry)+2.*prbrop(3,ientry)
     a         +prbrop(4,ientry)+2.*prbrop(5,ientry)+prbrop(6,ientry)+
     b                        4.*prbrop(7,ientry)+2.*prbrop(8,ientry)+
     c                        4.*prbrop(9,ientry)+2.*prbrop(10,ientry)
          ssupp=ssupp+(prbrop(2,ientry)+prbrop(4,ientry))/prbt
          qsupp=qsupp+(prbrop(1,ientry)+prbrop(3,ientry))/prbt
          nsupp=nsupp+1
        end if
  272  continue
       if(nlund-nsave.ne.iposi) then
          write(lun8,*) nlund-nsave,iposi
          call errex('strist:nlund-nsave.ne.iposi')
       end if
       if(nlund+iposi.gt.2000) then
          write(lun8,*) nlund,nsave,iposi
          call errex('strist:nlund+iposi>2000')
       end if
       do 280 nlu=nlund+1,nlund+iposi
        nl=nlu-nlund
        do 271 i=1,4
  271   plund(nlu,i)=xhad(i,nl)
  280  continue
       mst(1)=nlund+1
       nlund=nlund+iposi
       mst(2)=nlund
       call lurobo(thetlu,philu,bex,bey,bez)
       px=0.0
       py=0.0
       pz=0.0
       kaprod=0
       do 290 nlu=nlund-iposi+1,nlund
        nl=nlu-iposi
        kf=k(nl,2)
        if(iabs(kf).eq.18.or.iabs(kf).eq.28.or.
     a        iabs(kf).eq.19.or.iabs(kf).eq.29) then
             kaprod=kaprod+1
        end if
        eml=plund(nl,5)
        twait=0.0
        do 281 i=1,3
  281   plund(nlu,i)=plund(nlu,i)+xbang(i)+twait*plund(nl,i)/eml
        plund(nlu,4)=plund(nlu,4)+xbang(0)+twait*plund(nl,4)/eml
  290  continue
       nhfina=iposi
       write(lun8,*) 'nhstri,nhfina=',nhstri,nhfina
       write(lun8,*) 'kadel,kaprod=',kadel,kaprod
       write(lun8,412) nhstri,kadel,nbqstr,nbsstr,
     a                  nhfina,kaprod,nbqrop,nbsrop
       if(nsupp.gt.0)
     a write(lun8,*) 'ssupp=',ssupp/qsupp,nsupp
  412  format(4x,9(i4,1x))
       write(lun8,*) 'strist run successfully finished'
      return
      end
CPAT,SVEIFO   .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine sveifo(ip,is)
        include 'scatter7'
#include "amsrqmd.h"
        dimension pkeep(0:3,2),ekeep(2),itkeep(2),deceep(2),npkeep(2)
        save  pkeep,ekeep,itkeep,deceep,npkeep
        include 'partblk7'
      if ((is .le. 0) .or. (is .gt. 2)) call errex('is -- save')
      pkeep(0,is)=p(0,ip)
      pkeep(1,is)=p(1,ip)
      pkeep(2,is)=p(2,ip)
      pkeep(3,is)=p(3,ip)
      ekeep(is)=em(ip)
      itkeep(is)=ityp(ip)
      deceep(is)=decay(ip)
      npkeep(is)=npidec(ip)
      return
      entry rstifo(ip,is)
      if ((is .le. 0) .or. (is .gt. 2)) call errex('is -- restore')
      p(0,ip)=pkeep(0,is)
      p(1,ip)=pkeep(1,is)
      p(2,ip)=pkeep(2,is)
      p(3,ip)=pkeep(3,is)
      em(ip)=ekeep(is)
      ityp(ip)=itkeep(is)
      decay(ip)=deceep(is)
      npidec(ip)=npkeep(is)
      return
      entry oldat(is,itold,npold,p0old,pxold,pyold,pzold,emold)
      if ((is .le. 0) .or. (is .gt. 2)) call errex('is -- oldat  ')
      itold=itkeep(is)
      p0old=pkeep(0,is)
      pxold=pkeep(1,is)
      pyold=pkeep(2,is)
      pzold=pkeep(3,is)
      emold=ekeep(is)
      npold=npkeep(is)
      return
      end
CPAT,TRANSL   .  PDS = UF09.RQMD9.FORT  DATE = 951006  TIME = 215431562
      subroutine transl(iref,itp,npid,kl2)
#include "amsrqmd.h"
      if(iref.eq.-1) then
          if(itp.eq. 1 .or. itp.eq.10) then
              kl2= 42
          else if(itp.eq. 2 .or. itp .eq.11) then
              kl2= 41
          else if(itp.eq. 3) then
              kl2= 64
          else if(itp.eq. 4) then
              kl2= 63
          else if(itp.eq. 5) then
              kl2= 62
          else if(itp.eq. 6) then
              kl2= 61
          else if(itp.eq. 7) then
              if(npid.eq.0.or.npid.eq.3) then
                kl2= -17
              else
                kl2= -27
              end if
          else if(itp.eq. 8) then
              if(npid.eq.0.or.npid.eq.3) then
                kl2=  23
              else
                kl2=  33
              end if
          else if(itp.eq. 9) then
              if(npid.eq.0.or.npid.eq.3) then
                kl2=  17
              else
                kl2=  27
              end if
          else if(itp.eq.12) then
              kl2=  24
          else if(itp.eq.13) then
              kl2=  57
          else if(itp.eq.14) then
              if(iabs(npid).eq.2) then
                kl2= isign(1,npid) * 18
              else if(iabs(npid).eq.1) then
                kl2= isign(1,npid) * 19
              end if
          else if(itp.eq.15) then
              if( npid.eq.1) then
                 kl2= 43
              else if( npid.eq.0) then
                 kl2= 44
              else if( npid.eq.-1) then
                 kl2= 45
              end if
          else if(itp.ge.85.and.itp.le.99) then
              kl2=npid
          else if(itp.eq.-9999) then
              kl2=0
          else
              write(lun8,*) 'itp=',itp,'npid=',npid,'iref=',iref
c              idiv=0
c              idiv=10/idiv
c              write(lun8,*) idiv
c              call errex('itp not known in transl')
          end if
      else if(iref.eq. 1) then
          if(kl2.eq.42) then
              itp=1
              npid=0
          else if(kl2.eq.41) then
              itp=2
              npid=0
          else if(kl2.eq.64) then
              itp=3
              npid=1
          else if(kl2.eq.63) then
              itp=4
              npid=1
          else if(kl2.eq.62) then
              itp=5
              npid=1
          else if(kl2.eq.61) then
              itp=6
              npid=1
          else if(kl2.eq.17) then
              itp=9
              npid=0
          else if(kl2.eq.-17) then
              itp=7
              npid=0
          else if(iabs(kl2).eq.23) then
              itp=8
              npid=0
          else if(kl2.eq.27) then
              itp=9
              npid=2
          else if(kl2.eq.-27) then
              itp=7
              npid=2
          else if(iabs(kl2).eq.33) then
              itp=8
              npid=2
          else if(iabs(kl2).eq.24) then
              itp=12
              npid=2
          else if(kl2.eq.57) then
              itp=13
              npid=0
          else if(iabs(kl2).eq.18) then
              itp=14
              npid= isign(1,kl2)* 2
          else if(iabs(kl2).eq.19) then
              itp=14
              npid= isign(1,kl2)* 1
          else if(kl2.eq.43) then
              itp=15
              npid=1
          else if(kl2.eq.44) then
              itp=15
              npid=0
          else if(kl2.eq.45) then
              itp=15
              npid=-1
          else if(kl2.eq.0) then
              itp=-9999
              npid=0
          else
              ivz=kl2/iabs(kl2)
              kl2=iabs(kl2)
              inkre=kl2/100
              if(inkre.eq.0) then
                itp=99
              else
                itp=84+inkre
              end if
              if(itp.lt.85.or.itp.gt.99) then
                write(lun8,*) kl2,ivz,inkre
                call errex('transl:itp<85/>99')
              end if
              kl2=ivz*mod(kl2,100)
              npid= kl2
          end if
      end if
      return
      end
