#  $Id: ntuple02.doc,v 1.1.1.1 2007/11/13 09:56:11 zuccon Exp $

This is AMS02 Ntuple Description 
(to open:  /offline/paw/(linux,osf1)/pawX11; nt/chain ChainName FileName(s))

NB You must use custom built paw /offline/paw/(linux,osf1)/pawX11 
   and NOT a standard cern paw to safely work with the ntuples.



 *****************************************
* Type *   Range   *  Block   *  Name    *
 *****************************************               
* I*4  *           * EVENTH   * eventno          // Event no
* I*4  *           * EVENTH   * run              // run no
* I*4  *           * EVENTH   * runtype          // run type(data), rndm[0](mc) 
* I*4  *           * EVENTH   * time(2)          // Event time 
                                                 // (1) Unix time (sec)
                                                 // (2) usec time(data), rndm[1](mc)
                                                 // pair of rndms (mc)
                                                 // (1) RNDM (1)
                                                 // (2) RNDM (2)
* I*4  *           * EVENTH   * rawwords         // Event Lenght in bytes 
                                                 // (18 low bits)
                                                 // OS specifics ********)
                                                 // (2 int bit)
                                                 // program version 
                                                 // (12 high bits)
* R*4  *           * EVENTH   * RadS             // ISS Altitude (I2000 cm)
* R*4  *           * EVENTH   * ThetaS           // ISS Lattitude (GTOD rad)
* R*4  *	   * EVENTH   * PhiS             // ISS phi (GTOD rad)
* R*4  *           * EVENTH   * YawS             // ISS yaw (LVLH rad) 
* R*4  *           * EVENTH   * PitchS           //         pitch
* R*4  *           * EVENTH   * RollS            //         roll
* R*4  *           * EVENTH   * VelocityS        // ISS speed (rad/sec)
* R*4  *           * EVENTH   * VelTheta         // speed theta (GTOD rad) 
* R*4  *           * EVENTH   * VelPhi           // speed phi (GTOD rad) 
* R*4  *           * EVENTH   * ThetaM           // Magnetic Latitude ***)
* R*4  *           * EVENTH   * PhiM             // Magnetic Longitude ***)
* R*4  *           * EVENTH   * ISSEqAsc      // ISS Right Ascension (deg)
* R*4  *           * EVENTH   * ISSEqDec      // ISS Declination (deg)
* R*4  *           * EVENTH   * ISSGalLong    // ISS Galactic Latitude (deg)
* R*4  *           * EVENTH   * ISSGalLat     // ISSGalactic Longitude (deg)
* R*4  *           * EVENTH   * AMSEqAsc     // AMS Right Ascension (deg)
* R*4  *           * EVENTH   * AMSEqDec     // AMS Declination (deg)
* R*4  *           * EVENTH   * AMSGalLong    // AMS Galactic Longitude (deg)
* R*4  *           * EVENTH   * AMSGalLat    // AMSGalactic Latitude (deg)
* I*4  *           * EVENTH   * Tracks           // No of Tracks
* I*4  *           * EVENTH   * TrRecHits        // No of 3 dim trackerpoints
* I*4  *           * EVENTH   * TrClusters       // No of Tr Clusters
* I*4  *           * EVENTH   * TrRawClusters    // No of Tr Raw Clusters
* I*4  *           * EVENTH   * TrMCClusters     // No of Tr MC hits
* I*4  *           * EVENTH   * TOFClusters      // No of TOF Clusters
* I*4  *           * EVENTH   * TOFMCClusters    // No of TOF MC Hits
* I*4  *           * EVENTH   * AntiMCClusters   // No of Anti MC Hits
* I*4  *           * EVENTH   * TrdMCClusters    // No of TRD MC Clusters
* I*4  *           * EVENTH   * AntiClusters     // No of Anti clusters
* I*4  *           * EVENTH   * EcalClusters     // No of ECAL Clusters
* I*4  *           * EVENTH   * EcalHits         // No of ECAL Hits
* I*4  *           * EVENTH   * RICMCClusters    // No of RICH MC clusters
* I*4  *           * EVENTH   * RICHits          // No of RICH Hits
* U*4  *           * EVENTH   * TRDRawHits
* U*4  *           * EVENTH   * TRDClusters
* U*4  *           * EVENTH   * TRDSegments
* U*4  *           * EVENTH   * TRDTracks
* I*4  *           * EVENTH   * EventStatus(2)   // EventStatus 
						 // (see status.doc)


* I*4  * [0,10]    * BETA     * nbeta              // betas number
* I*4  *           * BETA     * betastatus(nbeta)  // 4 - ambig
* I*4  *           * BETA     * betapattern(nbeta) // beta pattern
						   // (see beta.doc) 
* R*4  *           * BETA     * beta(nbeta)        // velocity
* R*4  *           * BETA     * betac(nbeta)       // corrected velocity (taking into account true velocity < 1)
* R*4  *           * BETA     * betaerror(nbeta)   // est. error 1/beta 
* R*4  *           * BETA     * betaerrorc(nbeta)  // est. err. 1/corr. beta 
* R*4  *           * BETA     * betachi2(nbeta)    // chi2 of beta fit(time)
* R*4  *           * BETA     * betachi2s(nbeta)   // chi2 of beta fit(space)
* I*4  *           * BETA     * betantof(nbeta)    // number of tof clusters
* I*4  *           * BETA     * betaptof(4,nbeta)  // pointers to tof clusters
* I*4  *           * BETA     * betaptr(nbeta)     // pointer to track


* I*4  * [0,10]    * CHARGE   * ncharge                // charges number
* I*4  *           * CHARGE   * chargestatus(ncharge)  // 1 - refitted
* R*4  *           * CHARGE   * chargebetap(ncharge)   //pointer to velocity
* I*4  *           * CHARGE   * chargetof(ncharge)     // TOF charge
* I*4  *           * CHARGE   * chargetracker(ncharge) // Tracker Charge
* I*4  *           * CHARGE   * chargerich(ncharge) // rich Charge
* R*4  *           * CHARGE   * probtof(4,ncharge)     // TOF highest Probs
* I*4  *           * CHARGE   * chintof(4,ncharge)     // charge indices for 
                                                       // highest Probs (see
                                                       // charge.doc)
* R*4  *           * CHARGE   * probtracker(4,ncharge) // Tra. highest Probs
* I*4  *           * CHARGE   * chintracker(4,ncharge) // charge indices for
                                                       // highest Probs (see
                                                       // charge.doc)
* R*4  *           * CHARGE   * proballtracker(ncharge)// Tracker highest
                                                       // Prob (all hits)
* R*4  *           * CHARGE   * truntof(ncharge)  // Trun (-1) mean (Anodes)
* R*4  *           * CHARGE   * truntofd(ncharge) // Trun (-1) mean (Dynodes)
* R*4  *           * CHARGE   * truntracker(ncharge) // Trun (-1) mean


* I*4  * [0,10]    * PARTICLE * npart             // particles number
* I*4  *           * PARTICLE * pbetap(npart)     // pointer to TOF beta
* I*4  *           * PARTICLE * pchargep(npart)   // pointer to charge
* I*4  *           * PARTICLE * ptrackp(npart)    // pointer to track, or
                                                  // -1 if particle doesn't
                                                  // contain a track
* I*4  *           * PARTICLE * ptrdp(npart)    // pointer to trd track, or
                                                  // -1 if particle doesn't
* I*4  *           * PARTICLE * pvertexp(npart)    // pointer to vertex, or
                                                  // -1 if particle doesn't
                                                  // contains vertex
                                                  // contain a track
* I*4  *           * PARTICLE * prichp(npart)    // pointer to rich ring, or
                                                  // -1 if particle doesn't
                                                  // contain a rich ring
* I*4  *           * PARTICLE * pecalp(npart)    // pointer to ecal shower, or
                                                  // -1 if particle doesn't
                                                  // contain a ecal shower
* I*4  *           * PARTICLE * pid(npart)        // Geant Particle Id
* I*4  *           * PARTICLE * pidvice(npart)    // Geant vice-Particle Id
* R*4  *           * PARTICLE * probpid(2,npart)  // probabilities 
* R*4  *           * PARTICLE * fitmom(npart)     // fitted mom for pid
* R*4  *           * PARTICLE * pmass(npart)      // particle mass 
* R*4  *           * PARTICLE * perrmass(npart)   // error in particle mass
* R*4  *           * PARTICLE * pmom(npart)       // particle momentum (signed)
                                                  // see also pmom def at bottom)
* R*4  *           * PARTICLE * perrmom(npart)    // error in momentum
* R*4  *           * PARTICLE * pcharge(npart)    // charge
* R*4  *           * PARTICLE * pbeta(npart)      // beta (tof + rich)
* R*4  *           * PARTICLE * perrbeta(npart)      // err beta
* R*4  *           * PARTICLE * ptheta(npart)     // theta (1st[last] 
						  // tracker plane)
* R*4  *           * PARTICLE * pphi(npart)       // phi (1st[last] tr. pl.)
* R*4  *           * PARTICLE * thetagl(npart)    // theta global **)
* R*4  *           * PARTICLE * phigl(npart)      // phi global
* R*4  *           * PARTICLE * pcoo(3,npart)     // coo  -----------
* R*4  *           * PARTICLE * cutoff(npart)     // geomag cutoff in GeV/c
* R*4  *           * PARTICLE * cootof(3,4,npart) // tracker extrapol in tof
* R*4  *           * PARTICLE * cooanti(3,2,npart)// tracker extrapol in anti
* R*4  *           * PARTICLE * cooecal(3,3,npart)// tracker extrapol to  
						   // first,cofg,last
						   // ecal planes
* R*4  *           * PARTICLE * cootr(3,8,npart)  // tracker extrapol in
						  // tracker 
* R*4  *           * PARTICLE * cootrd(3,npart)  // trd extrapol in the middle
* R*4  *           * PARTICLE * coorich(3,2,npart)  //rich extrapol in radiator
						    // and PMT array
* R*4  *           * PARTICLE * pathrich(2,npart)  //  Estimated fraction
	                                           //  of ring photons 
	                                           //  within RICH acceptance
						   //  (direct and reflected ones 
						   //   respectively) for beta=1
* R*4  *           * PARTICLE * pathrichb(2,npart)  //  Estimated fraction
                                                   //  of ring photons
                                                   //  within RICH acceptance
                                                   //  (direct and reflected ones
                                                   //   respectively) for 
                                                   //  the particle beta
* R*4  *           * PARTICLE * lengthrich(npart)  // Estimated pathlength of 
						   // particle within rich radiator
* R*4  *           * PARTICLE * trdlikelihood (npart) // TRD likelihood

* I*4  * [0,48]    * TOFCLUST * ntof             // TOF clusters number
* I*4  *           * TOFCLUST * TOFStatus(ntof)  // Status: 
                                                 // bit 4 - ambig
                                                 // bit 128 -> problems with
						 //	    history
                                                 // bit 256 -> "1-sided" counter
                                                 // bit 512 -> bad t-measurement
                                                 //         on one of the sides
                                                 // bit 2048 -> recovered from 
                                                 // 1-sided (bit256 also set)
* I*4  *           * TOFCLUST * TOFpln(ntof)        // Tof plane(layer) no
                                                   // 1..4 up->down
* I*4  *           * TOFCLUST * TOFbar(ntof)       // TOF bar no (1-12)
* I*4  *           * TOFCLUST * TOFmem(ntof)       // Members(bars)/cluster(max.3,
                                                      for current version <=2)
* I*4  *  [0,48]   * TOFCLUST * TOFp2m(3,ntof)     // Pointers to RawClust.members(bars)
* R*4  *           * TOFCLUST * TOFEdep(ntof)      // TOF energy loss (MeV)
                                                   //                      from Anode
* R*4  *           * TOFCLUST * TOFEdepd(ntof)     // TOF energy loss (MeV)
                                                   //                      from Dynode
* R*4  *           * TOFCLUST * TOFTime(ntof)      // TOF time (sec, wrt FastTrig-time)
* R*4  *           * TOFCLUST * TOFETime(ntof)     // Error in TOF time
* R*4  *           * TOFCLUST * TOFCoo(3,ntof)     // TOF Coo (cm)
* R*4  *           * TOFCLUST * TOFErCoo(3,ntof)   //


* I*4  * [0,100]   * TOFMCCLU * ntofmc              // TOF MC hits number
* I*4  *           * TOFMCCLU * TOFMCIdsoft(ntofmc) // Idsoft
                                                    // Ask E. Choumilov
                                                    // if needed
                                                    //
* R*4  *           * TOFMCCLU * TOFMCXcoo(3,ntofmc)// coo
* R*4  *           * TOFMCCLU * TOFMCtof(ntofmc)   // time
* R*4  *           * TOFMCCLU * TOFMCedep(ntofmc)  // energy(meV)
 

* I*4  * [0,50]    * TRCLUSTE * ntrcl              // Tracker clusters number
* I*4  *           * TRCLUSTE * Idsoft(ntrcl)      // Idsoft
                                                   // mod(id,10) layer 
                                                   // mod(id/10,100) ladder
                                                   // i=mod(id/1000,10)
                                                   // i==0 x 1st half
                                                   // i==1 x 2nd half
                                                   // i==2 y 1st half
                                                   // i==3 y 2nd half
                                                   // id/10000 strip
* I*4  *           * TRCLUSTE * Statust(ntrcl)     // Status *)
* I*4  *           * TRCLUSTE * NelemL(ntrcl)   // -Number of strips left to max
* I*4  *           * TRCLUSTE * NelemR(ntrcl)   // Number of strips right to max
* R*4  *           * TRCLUSTE * Sumt(ntrcl)        // Amplitude total
* R*4  *           * TRCLUSTE * Sigmat(ntrcl)      // Sigma total
* R*4  *           * TRCLUSTE * Meant(ntrcl)       // CofG (local)
* R*4  *           * TRCLUSTE * RMSt(ntrcl)        // RMS cluster
* R*4  *           * TRCLUSTE * ErrorMeant(ntrcl)  // error in CofG
* R*4  *           * TRCLUSTE * Amplitude(5,ntrcl) // strips ampl


* I*4  * [0,200]   * TRMCCLUS * ntrclmc           // Tracker MC hits number
* I*4  *           * TRMCCLUS * IdsoftMC(ntrclmc) // Idsoft
                                                  // mod(id,10) layer
                                                  // mod(id/10,100) ladder
                                                  // id/1000 sensor
* I*4  *           * TRMCCLUS * Itra(ntrclmc)     // Particle Id (or 555 if noise)
* I*4  *           * TRMCCLUS * Left(2,ntrclmc)   // left strip no 
* I*4  *           * TRMCCLUS * Center(2,ntrclmc) // center strip no
* I*4  *           * TRMCCLUS * Right(2,ntrclmc)  // right stip no
* R*4  *           * TRMCCLUS * ss(5,2,ntrclmc)   // Strip amplitudes
* R*4  *           * TRMCCLUS * xca(3,ntrclmc)    // local input coo
* R*4  *           * TRMCCLUS * xcb(3,ntrclmc)    // local output coo
* R*4  *           * TRMCCLUS * xgl(3,ntrclmc)    // global coo
* R*4  *           * TRMCCLUS * summc(ntrclmc)    // total amplitude


* I*4  * [0,200]   * TRRECHIT * ntrrh          // tracker 3dim points number
* I*4  *           * TRRECHIT * px(ntrrh)      // pointer to x track clster
* I*4  *           * TRRECHIT * py(ntrrh)      //  --------  y --------
* I*4  *           * TRRECHIT * statusr(ntrrh) // Status *)
* I*4  *           * TRRECHIT * Layer(ntrrh)   // Layer no 1-6 up-down
* R*4  *           * TRRECHIT * hitr(3,ntrrh)  // gl 3dim coordinates
* R*4  *           * TRRECHIT * ehitr(3,ntrrh) // error to above
* R*4  *           * TRRECHIT * sumr(ntrrh)    // Amplitude
* R*4  *           * TRRECHIT * difosum(ntrrh) // (A_x-A_y)/(A_x+A_y)
* R*4  *           * TRRECHIT * cofgx          // local cfg x
* R*4  *           * TRRECHIT * cofgy          // local cfg y


* I*4  * [0,2]     * VERTEX  * ngam               // number of gammas :1 or 0
* R*4  *           * VERTEX  * trgmom(ngam)         // Gamma Momentum according to Fit 5
                                                   //  sometimes junk with <=1 GeV is kept for
                                                   //  offline check purpose
* R*4  *           * VERTEX  * trgerrmom(ngam)     // error to the above  
* R*4  *           * VERTEX  * trgTheta(ngam)     // Gamma Theta 
* R*4  *           * VERTEX  * trgPhi(ngam)       // Gamma Phi 
* R*4  *           * VERTEX  * trgVert(3,ngam)       // Vertex  (affected by energy and spatial resol.) 
* I*4  *           * VERTEX  * trgStatus(ngam)  //   ????
* R*4  *           * VERTEX  * trgdist(ngam)       // distance between tracks (cm)
* R*4  *           * VERTEX  * trgcharge(ngam)       // Gamma charge
            
* I*4  * [-1,254]  * VERTEX  * trgpLeft(ngam)      // pointers to trtrack for left bending (YZ proj.) particle 
* I*4  * [-1,254]  * VERTEX  * trgpRight(ngam)     // pointers to trtrack for right bending (YZ proj.) particle

* I*4  * [0,20]    * TRTRACK  * ntrtr           // tracks number
* I*4  *           * TRTRACK  * trstatus(ntrtr) // Status *)
* I*4  *           * TRTRACK  * pattern(ntrtr) // Pattern (datacards.doc)
* I*4  *           * TRTRACK  * address(ntrtr) // address (trrec.C buildaddress)
* I*4  *           * TRTRACK  * nhits(ntrtr)         // number of hits 
* I*4  *           * TRTRACK  * phits(8,ntrtr)	     // pointers to trrechit
* R*4  *           * TRTRACK  * LocDbAver(ntrtr)     // rel mom from testbeam
* I*4  *           * TRTRACK  * GeaneFitDone(ntrtr)  // != 0 if done
* I*4  *           * TRTRACK  * AdvFitDone(ntrtr) --------------
* R*4  *           * TRTRACK  * Chi2StrLine(ntrtr)   // chi2 sz fit
* R*4  *           * TRTRACK  * Chi2Circle(ntrtr)    // chi2 circular fit
* R*4  *           * TRTRACK  * CircleRig(ntrtr) // circular rigidity
* R*4  *           * TRTRACK  * Chi2FastFit(ntrtr)   // chi2 fast nonl fit
* R*4  *           * TRTRACK  * Rigidity(ntrtr)     // fast nonl rigidity
* R*4  *           * TRTRACK  * ErrRig(ntrtr)  // err to 1/above
* R*4  *           * TRTRACK  * Theta(ntrtr)	     // theta (from fast)
* R*4  *           * TRTRACK  * phi(ntrtr)	     // phi ---------
* R*4  *           * TRTRACK  * p0(3,ntrtr)	     // coords ----------
* R*4  *           * TRTRACK  * gchi2(ntrtr)	     // geane chi2
* R*4  *           * TRTRACK  * grig(ntrtr)    // ------ rigidity
* R*4  *           * TRTRACK  * gerrrig(ntrtr) // error to 1/above
* R*4  *           * TRTRACK  * hchi2(2,ntrtr)	     // two halves chi2s
* R*4  *           * TRTRACK  * HRigidity(2,ntrtr)  // -------- rigities
* R*4  *           * TRTRACK  * HErrRigodoty(2,ntrtr) // errors to 1/above
* R*4  *           * TRTRACK  * htheta(2,ntrtr)	     // ------- thetas
* R*4  *           * TRTRACK  * hphi(2,ntrtr)	     // ------ phis
* R*4  *           * TRTRACK  * hp0(3,2,ntrtr)	     // ------- coords
* R*4  *           * TRTRACK  * fchi2ms(ntrtr)	     // fast chi2 mscat off
* R*4  *           * TRTRACK  * pirigerr(ntrtr)	     // PathInt err(1/rig)
                                             // (<0 means fit wan not succesful)
* R*4  *           * TRTRACK  * rigms(ntrtr) // fast rigidity mscat off
* R*4  *           * TRTRACK  * pirig(ntrtr)  // PathInt rigidity


* I*4  * [0,20]    * MCEVENTG * nmcg // Number of  particles in MC gen ******)
* I*4  *           * MCEVENTG * nskip  //Pos no for test beam data or MC spec
* I*4  *           * MCEVENTG * Particle(nmcg)   // Geant particle id
* R*4  *           * MCEVENTG * coo(3,nmcg)	 // geant particle coos
* R*4  *           * MCEVENTG * dir(3,nmcg)	 // ------- dir cos
* R*4  *           * MCEVENTG * momentum(nmcg)	 // momentum
* R*4  *           * MCEVENTG * mass(nmcg)	 // mass
* R*4  *           * MCEVENTG * charge(nmcg)	 // charge

* I*4  *         * [0,150]      * MCTRACK  * nmct  (activated by SCAN TRUE
                                                    and KINE 48)
* R*4  *         *              * MCTRACK  * radl(nmct) // integrated radiation length 
* R*4  *         *              * MCTRACK  * absl(nmct) // --- absorbption length
* R*4  *         *              * MCTRACK  * pos(3,nmct) // x,y,z (cm) 
* I*4  *         *              * MCTRACK  * vname(nmct) // volume name coded as  integer


* I*4  * [0,8]     * ANTICLUS * nanti              //Number of active sectors(0-8)
* I*4  *           * ANTICLUS * AntiStatus(nanti)  //Bit"256"->1sideSector;"1024"->s2 missing if set,
                                                   //s1 missing if not; Bit"128"->NoFTCoinc on 2sides
* U*4  * [0,8]     * ANTICLUS * AntiSector(nanti)  //Sector number(1-8)           
* U*4  * [0,16]    * ANTICLUS * AnNtimes(nanti)    //Number of time-hits(1st come paired ones)
* U*4  * [0,8]     * ANTICLUS * AnNpairs(nanti)    //Numb.of time-hits, made of 2 side-times(paired)
* R*4  *           * ANTICLUS * AnTimes(16,nanti)  //Time-hits(ns, wrt LEV1trig-time)
* R*4  *           * ANTICLUS * AnTimesE(16,nanti) //Time-hits errors(ns)
* R*4  *           * ANTICLUS * AntiEdep(nanti)    //Edep(mev)
* R*4  *           * ANTICLUS * AntiCoo(3,nanti)   //R(cm),Phi(degr),Z(cm)-coordinates
* R*4  *           * ANTICLUS * AntiErCoo(3,nanti) //Their errors



* I*4  * [0,200]   * ANTIMCCL * nantimc               // MC Anti hits number
* I*4  *           * ANTIMCCL * AMCIdsoft(nantimc) // idsoft 
* R*4  *           * ANTIMCCL * AMCXcoo(3,nantimc) // coo
* R*4  *           * ANTIMCCL * AMCtof(nantimc)    // Tof
* R*4  *           * ANTIMCCL * AMCedep(nantimc)   // energy dep (GeV)


* I*4  * [0,1296]  * ECALHITS * necht              // ECAL hits number
* I*4  *           * ECALHITS * EchtStatus(necht)  // Status: 
* I*4  *           * ECALHITS * EchtIdsoft(necht)  // SSPPC(SupLayer/PM/subCell)
* I*4  *           * ECALHITS * EchtProj(necht)    // projection (0-x,1-y)
* I*4  *           * ECALHITS * EchtPlane(necht)   // ECAL plane number (0,...)
* I*4  *           * ECALHITS * EchtCell(necht)    // ECAL Cell number (0,...)
* R*4  *           * ECALHITS * EchtEdep(necht)    // ECAL measured energy (MeV)
                                                      (e+- energy normalization)  
* R*4  *           * ECALHITS * EchtECor(necht)    // ECAL PMsaturation1-correction(MeV) added to Edep
* R*4  *           * ECALHITS * EchtAttC(necht)    //  Attenuation Correction applied (w/r  to center of ecal) (MeV)
* R*4  *           * ECALHITS * EchtCoo(3,necht)   // ECAL Coo (cm)
* R*4  *           * ECALHITS * EchtADC(3,necht)   // ECAL (ADC-Ped) for Hi/Low/Dynode channels
* R*4  *           * ECALHITS * EchtPed(3,necht)   // ECAL Pedestals
* R*4  *           * ECALHITS * EchtGain(necht)    // ECAL 1/gain used




* I*4  *           * ECALCLUS * neccl   // n8mber of clusters
* I*4  *           * ECALCLUS * EcclStatus(neccl)  //valid statuses are:
                                                     WIDE=2;
                                                     BAD =16;
                                                     USED=32;
                                                     NEAR=1024;
                                                     LEAK=16777216;
                                                     CATASTROPHICLEAK=33554432;
                                                     JUNK=67108864
* U*4  *[0,1]      * ECALCLUS * EcclProj(neccl) // projection (0x, 1y)
* U*4  *[0,17]     * ECALCLUS * EcclPlane(neccl)// plane 
* U*4  *[0,72]     * ECALCLUS * EcclLeft(neccl)// cluster left
* U*4  *[0,72]     * ECALCLUS * EcclCenter(neccl) // cluster max
* U*4  *[0,72]     * ECALCLUS * EcclRight(neccl)  // cluster right
* R*4  *           * ECALCLUS * EcclEdep(neccl) // edep (mev)
* R*4  *           * ECALCLUS * ecclsleak(neccl)  // side leak estimation (mev)
* R*4  *           * ECALCLUS * eccldleak(neccl)  // dead hit leak est (mev)
* R*4  *           * ECALCLUS * EcclCoo(3,neccl)  // cluster coo (cm)
* I*4  *           * ECALCLUS * ecclpleft(neccl)  // hit pointer to leftmost cl
* U*4  *[0,72]     * ECALCLUS * ecclnhits(neccl)  // number of hits in cluster

* I*4  *[0,10]     * ECAL2DCL * nec2d              // number of 2d clus
* U*4  *           * ECAL2DCL * Ec2dstatus(nec2d)  // status
* U*4  *[0,1]      * ECAL2DCL * Ec2dProj(nec2d)  // projection
* I*4  *           * ECAL2DCL * Ec2dNmemb(nec2d) // number of 1d clusters
* R*4  *           * ECAL2DCL * Ec2dEdep(nec2d)  // 1: energy (mev)
* R*4  *           * ECAL2DCL * Ec2dCoo(nec2d)     // str line fit coo
* R*4  *           * ECAL2DCL * ec2dtan(nec2d)     // str line fit tangent
* R*4  *           * ECAL2DCL * ec2dchi2(nec2d)    // str line fit chi2
* U*4  *[0,1000]   * ECAL2DCL * ec2dpcl(18,nec2d)  // pointers to 1d clusters


* I*4  *[0,5]      * ECALSHOW * necsh              // number of showers
* I*4  *           * ECALSHOW * ecshstatus(necsh)  // shower status(see ecclstatus)
* R*4  *           * ECALSHOW * Ecshdir(3,necsh)   // shower direction
* R*4  *           * ECALSHOW * Ecshemdir(3,necsh)   // shower direction if emag
* R*4  *           * ECALSHOW * Ecshentry(3,necsh) // shower entry point (cm)
* R*4  *           * ECALSHOW * Ecshexit(3,necsh)  //        exit point  (cm)
* R*4  *           * ECALSHOW * Ecshcofg(3,necsh)  //        center of grav (cm)
* R*4  *           * ECALSHOW * EcshErdir(necsh)   //  3d angle error 
* R*4  *           * ECALSHOW * ecshchi2dir(necsh) //  chi2 dir fit
* R*4  *           * ECALSHOW * Ecshfrontedep(necsh) // front energy dep (Mev)
                                                     // usefull to e/gamma sep
* R*4  *           * ECALSHOW * EcshEn(necsh)     //   shower energy (gev)
* R*4  *           * ECALSHOW * ecsherat(3,necsh) //  energy(+-2,+-5, +-8 cm)/energy ratios
* R*4  *           * ECALSHOW * Ecshener(necsh)   //  energy error (gev)
* R*4  *           * ECALSHOW * ecshdifosum(necsh) // (E_x-E_y)/(E_x+E_y)
* R*4  *           * ECALSHOW * EcshsLeak(necsh)   // rel side leak
* R*4  *           * ECALSHOW * EcshrLeak(necsh)   // rel rear leak
* R*4  *           * ECALSHOW * EcshdLeak(necsh)   // rel dead cells leak
* R*4  *           * ECALSHOW * EcshaLeak(necsh)   // rel att length correction
* R*4  *           * ECALSHOW * EcshoLeak(necsh)   // out of core leak
* R*4  *           * ECALSHOW * Ecsho2de(necsh)   //  orphaned 2d cluster energy (if any) (geV)
* R*4  *           * ECALSHOW * ecshchi2P(necsh)   // chi2 profile fit (gamma f)
* R*4  *           * ECALSHOW * ecshparP(4,necsh)  // normalization, shower max (cm), rad length, rel rear leak ) for profile fit
* R*4  *           * ECALSHOW * ecshchi2T(necsh) // chi2 transverse fit (sum two exp) 
* R*4  *           * ECALSHOW * ecshspev(3,necsh) // sphericity tensor eigen values
* I*4  *           * ECALSHOW * ecshncl(necsh)   number of 2d clusters attached
* I*4  *           * ECALSHOW * ecshpcl(2,necsh)  pointers to 2d clusters


 * I*4  * [0,2]        * LVL3     * nlvl3             // lvl3trigger number 
 * U*4  * [-1,254]     * LVL3     * LVL3TOF(nlvl3)    // TOF Trigger
                                                      // -1 if rejected by matrix trigger,
                                                      //   0 Too Many Hits
                                                      //   1  tof 0  1 cluster or 2 cluster
                                                      //   2  tof 1  -----
                                                      //   4  tof 2  -----
                                                      //   8  tof 3  -----
                                                      //   16  tof 0  2 cluster
                                                      //   32  tof 1  -----
                                                      //   64  tof 2  -----
                                                      //   128  tof 3  -----

 * U*4  * [0,10]       * LVL3     * LVL3TRD(nlvl3)   // TRD Trigger
                                                     //   0  Nothing found
                                                     //   bit 0:  Segment x found
                                                     //   bit 1:  segment y found
                                                     //   bit 2: too many hits found  
                                                     //   bit 3: high gamma event found 


 * U*4  * [0,10]       * LVL3     * LVL3TRD(nlvl3)   // TRD Trigger
 * U*4  * [0,15]       * LVL3     * LVL3Tr(nlvl3)   //  Tracker  Trigger
                            // 0  - initial state
                            // 1  - No Tr Tracks found
                            // 2  - Too Many Hits in Tracker
                            // 3  - Positive Rigidity found
                            // 4  - Ambigious Comb (A) found 
                            // 5  - Ambigious Comb (B) found 
                            // 6  - Negative Rigidity(Momentum) found
                            // + 8   // Heavy Ion (Tracker)
 * I*4  *              * LVL3     * LVL3Main(nlvl3)   //Main Trigger
                            // bit  0 No Tr Tracks found
                            // bit  1 Too Many Hits in Tracker
                            // bit  2 Too Many Hits in TRD
                            // bit  3 Too Many Hits in TOF
                            // bit  4 No TRD Tracks found
                            // bit  5 Upgoing event found
                            // bit  6 No TOF Time Information found
                            // bit  7 Positive Rigidity(Momentum) found
                            // bit  8 Ambigious Comb (A) found 
                            // bit  9 Ambigious Comb (B) found 
                            // bit  10  Negative Rigidity(Momentum) found
                            // bit  11  High Gamma (TRD)  
                            // bit  12   Heavy Ion (Tracker)
                            // bit  13 Prescaled event
			    // bit  14 No ECAL activity(>=MIP) found
			    // bit  15 ECAL EM-object found(or Eectot>20gev)
			    // bit  16 ECAL track found(line fit chi2x,chi2y ok)
			    // bit  17 ECAL track match to TOF/TRD path  

 * I*4  * [-1,1]       * LVL3     * LVL3Dir(nlvl3)   //Particle Direction
                                                     // -1 Up
                                                     // 0 Unknown
                                                     // 1 Down
 * U*4  * [0,1000]     * LVL3     * LVL3NTrHits(nlvl3) // Number Tr Hits
 * U*4  * [0,10]       * LVL3     * LVL3NPat(nlvl3) // Number "Tracks" found
 * I*4  * [-1,250]     * LVL3     * LVL3Pat(2,nlvl3) // Pattern no
 * R*4  *              * LVL3     * LVL3Res(2,nlvl3) // Aver Residual (cm)
 * R*4  *              * LVL3     * LVL3Time(nlvl3) // Alg Time (sec)
 * R*4  *              * LVL3     * LVL3ELoss(nlvl3) // Aver energy loss
 * U*4  * [0,31]       * LVL3     * LVL3TRDHits(nlvl3) // trd hits no
 * U*4  * [0,31]       * LVL3     * LVL3HMult(nlvl3)  // trd hemnergy hits no
 * R*4  *              * LVL3     * LVL3TRDPar(2,nlvl3) // trd tan x,y
 * I*4  * [-1,1]       * LVL3     * LVL3emag(nlvl3)   // ECelectromagn(-1/0/1=nonEM/noECactivity)/EM)
 * I*4  * [-1,1]       * LVL3     * LVL3ECmat(nlvl3)  // EC-TOF/TRD match(-1/0/1=noMatch/noECtrack/Match)
 * R*4  *              * LVL3     * LVL3ECTRKcr(4,nlvl3) //Xcr/Ycr/TangX/TangY of ECtrack with bottom
                                    plane of Tracker(when ECtrack was found)



 * I*4  * [0,1]    * LVL1     * nlvl1                 // lvl1trigger number

 * I*4  *          * LVL1     * mode(nlvl1)           // 9 lsbits -> pattern of requested & fired)-branches
  		             //   list of branches(preliminary):                                                      
		             // bit1: unbiased trig#1(TOF only, i.e. TofFlag>=0)                          
			     // bit2: unbiased trig#2(EC only, i.e. EcalFlag>0)                           
			     // bit3: unbiased trig#3(TOF && EC, i.e. TofFlag>=0 && EcalFlag>0)           
			     // bit4: unbiased trig#4(TOF || EC, i.e. TofFlag>=0 || EcalFlag>0)           
			     // bit5: Z=1 trig(i.e. TofFlag>=0 & TofFlag%10=0 && NAntiSect<Nmax)     
			     // bit6: Z>=2 trig(TOF above HiZThresh, i.e. TofFlag/10>0)                   
		             // bit7: e+-  trig(TOF && EC-Em,i.e. TofFlag>=0 && ECEtot>LowThr && ShWid=em)
			     // bit8: phot trig(EC-hiEm, i.e. ECEtot>HiThr && ShWid=em)                   
			     // if bit9 set - external trigger
 * I*4  *          * LVL1     * LVL1Flag(nlvl1)       // -1/(0-8)->NoTof/miss.layer.code(was Z>=1 trig)
                                                      //  +10->(Z>=1&Z>=2), +20->(only Z>=2) 
 * I*4  *          * LVL1     * LVL1TOFPatt(4,nlvl1)  // tof pattern(Z>=1)
                                                      // 1-10 bits : paddles of Side-1 
                                                      // 17-26     : paddles of Side-2
 * I*4  *          * LVL1     * LVL1TOFPatt1(4,nlvl1) // Tof pattern (Z>=2)
                                                      // -------------
 * I*4  *          * LVL1     * LVL1AntiPatt(nlvl1)   // antipattern
                                                      // bits (1-8)-> pattern of sectors in    
                                                      // coincidence with FastTrig 
 * I*4  *          * LVL1     * LVL1ECALflag(nlvl1)   // =MN, where M=0/1/2/3->Etot<MipThr/
 *                                                    // >MipThr/>LowThr/>HighThr;
 *                                                    //  N=2/1/0->ShowerWidthTest=OK(em)/Bad/Unknown
						      // 
						      
 * R*4  *          * LVL1     * LVL1ECtrsum(nlvl1)    // EC-energy trig.sum 



 * I*4  * [0,500]  * TRRAWCL  * ntrraw                // trrawcl num
 * I*4  *          * TRRAWCL  * rawaddress(ntrraw)    // see TRCLUSTE Idsoft
 * I*4  *          * TRRAWCL  * rawlength(ntrraw)     // rawcl length
 * R*4  *          * TRRAWCL  * s2n(ntrraw)           // s/n for seed



 * I*4  * [0,48]   * TOFRAWCL * ntofraw                 // tofrawclnum (used)
 * I*4  *          * TOFRAWCL * tofrstatus(ntofraw)     // status
 * I*4  *          * TOFRAWCL * tofrplane(ntofraw)      // tof plane 1-4
 * I*4  *          * TOFRAWCL * tofrbar(ntofraw)        // tof bar 1-10
 * R*4  *          * TOFRAWCL * tofradca(2,ntofraw)    // anode ADC(Hi-chan,2sides) 
 * R*4  *          * TOFRAWCL * tofradcal(2,ntofraw)    // anode ADC(Low-chan,2sides) 
                                                        //
 * R*4  *          * TOFRAWCL * tofradcd(2,ntofraw)    // dynode ADC(Hi-chan,2sides)
 * R*4  *          * TOFRAWCL * tofradcdl(2,ntofraw)    // dynode ADC(Low-chan,2sides)
                                                        //
 * R*4  *          * TOFRAWCL * tofrsdtm(2,ntofraw)     // A-noncorrected
                                                        //  side times
 * R*4  *          * TOFRAWCL * tofreda(ntofraw)        // Edep-A(h/l-combined,mev)
 * R*4  *          * TOFRAWCL * tofredd(ntofraw)        // Edep-D(h/l-combined,mev)
 * R*4  *          * TOFRAWCL * tofrtm(ntofraw)         // Time (ns)
 * R*4  *          * TOFRAWCL * tofrcoo(ntofraw)        // Long.coord.(cm)
 * I*4  * [0,100]  * RICMCCL  * nsignals              // Number of signals in
                                                      // the PMTs including noise
 * I*4  *          * RICMCCL  * sid(nsignals)         // Geant3 code of the particle
                                                      // producing the signal
                                                      // (-666 if it's noise)
 * R*4  *          * RICMCCL  * rimcorg(3,nsignals)   // Generation point of the 
                                                      // particle producing 
                                                      // the signal (geant3 only)
 * R*4  *          * RICMCCL  * rimcdir(3,nsignals)   // Original direction of 
                                                      // the particle producing 
                                                      // the signal (geant3 only)
 * I*4  *          * RICMCCL  * rimcstatus(nsignals)  // Signal status *******)
 * I*4  *          * RICMCCL  * rimcnphg              // Number of cerenkov
                                                      // photons generated
                                                      // in radiator
 * I*4  *          * RICMCCL  * rimcphit(nsignals)    // Pointer to the
                                                      // hit if sid=50 or -666
 * I*4  * [0,100]  * RICEVENT * Rhits                 // Number of hits
 * I*4  *          * RICEVENT * Rchtch(Rhits)         // Channel
 * I*4  *          * RICEVENT * Rchtadc(Rhits)        // ADC counts above the pedestal
 * R*4  *          * RICEVENT * Rnpe(Rhits)           // ADC counts above the 
                                                      // pedestal/gain of the channel 
 * R*4  *          * RICEVENT * Rchtx(Rhits)          // X pos. of the channel
 * R*4  *          * RICEVENT * Rchty(Rhits)          // Y pos. of the channel
 * I*4  *          * RICEVENT * Rhstatus(Rhits)       // Hit status *********) 
 * I*4  * [0,10]   * RING     * nrings                // Nb of rings created in rich rec
 * I*4  *          * RING     * rcritrkn(nrings)      // Pointer to track
 * I*4  *          * RING     * rcrihu(nrings)        // Nb. of RICH hits in a ring 
                                                      //matching the track
 * I*4  *          * RING     * rcrimhu(nrings)       // Nb. of RICH mirrored hits in
                                                      // a ring matching the track
 * R*4  *          * RING     * rcribeta(nrings)      // Reconstructed beta
 * R*4  *          * RING     * rcriebeta(nrings)     // error beta
 * R*4  *          * RING     * rcrichi2(nrings)      // Chi2/ndof for the beta
 * I*4  *          * RING     * rcristatus(nrings)    // Ring status  **********)   
 * R*4  *	   * RING     * rcriprob(nrings)      // Probability of being a true ring 
  							 from the phi distribution of hits
 * R*4  *	   * RING     * rcrinpexp(nrings)     // Number of expected photoelectrons for Z=1  charge
 * R*4  *          * RING     * rcricnpe(nrings)      // Number of collected photoelectrons  	
 * I*4  *          * TRDMCCL  * ntrdmccl              // no of trd clusters
 * U*4  *          * TRDMCCL  * trdlayermc(ntrdmccl)  //layer (up==0)
 * U*4  *          * TRDMCCL  * trdladdermc(ntrdmccl) //ladder (tbd)
 * U*4  *          * TRDMCCL  * trdtubemc(ntrdmccl)   //tubeno
 * U*4  *          * TRDMCCL  * trdpartmc(ntrdmccl)  // particle (primary=0)
 * U*4  *          * TRDMCCL  * trdtrackmc(ntrdmccl)  // track id
 * R*4  *          * TRDMCCL  * trdedepmc(ntrdmccl)   // energy dep (gev)
 * R*4  *          * TRDMCCL  * trdekinmc(ntrdmccl)   // part kin energy (gev)
 * R*4  *          * TRDMCCL  * trdxglmc(3,ntrdmccl)  // hit global coo(cm)
 * R*4  *          * TRDMCCL  * trdstepmc(ntrdmccl)   // step size (cm)
 * I*4  *          * TRDRHT   * ntrdht                // nuber of trd raw hits
 * I*4  *[0,19]    * TRDRHT   * trdhtlayer(ntrdht)    // layer
 * I*4  *[0,17]    * TRDRHT   * trdhtladder(ntrdht)   // ladder
 * I*4  *[0,15]    * TRDRHT   * trdhttube(ntrdht)     // tube
 * R*4  *          * TRDRHT   * trdampht(ntrdht)      // amp-ped (adc ch)
 * I*4  *          * TRDCLU   * ntrdcl                // trd clusters no
 * I*4  *          * TRDCLU   * trdclstatus(ntrdcl)   // status
 * R*4  *          * TRDCLU   * trdclcoo(3,ntrdcl)    // global coo(cm)
 * U*4  *          * TRDCLU   * trdlayer(ntrdcl)      // layer (0==top)
 * R*4  *          * TRDCLU   * trddir(3,ntrdcl)      // tube orientation
 * U*4  *          * TRDCLU   * trdmul(ntrdcl)        // cluster mult
 * U*4  *          * TRDCLU   * trdhmul(ntrdcl)       // cluster high mult
 * R*4  *          * TRDCLU   * trdedep(ntrdcl)       // energy dep (KeV)
 * I*4  *          * TRDCLU   * ptrdrht(ntrdcl)       // pointer to max trdrht
 * I*4  *          * TRDSEG   * ntrdseg
 * I*4  *          * TRDSEG   * trdsegstatus(ntrdseg)
 * U*4  *          * TRDSEG   * trdsegor(ntrdseg)     // segment orientation
                                                         0-1 (x-y)
 * R*4  *          * TRDSEG   * trdsegfpar(2,ntrdseg) // str line fit par 
 * R*4  *          * TRDSEG   * trdsegchi2(ntrdseg)   // -------   chi2
 * U*4  *          * TRDSEG   * trdsegpat(ntrdseg)    // segment pattern no
 * U*4  *          * TRDSEG   * trdsegnh(ntrdseg)     // number of clu
 * I*4  *          * TRDSEG   * trdsegpcl(12,ntrdseg) // pointers to clu
 * I*4  *          * TRDTRK   * ntrdtrk               
 * I*4  *          * TRDTRK   * trdtrkstatus(ntrdtrk) 
 * R*4  *          * TRDTRK   * trdtrkcoo(3,ntrdtrk)  // track x,y,z par
 * R*4  *          * TRDTRK   * trdtrkercoo(3,ntrdtrk)// err to x,y,z
 * R*4  *          * TRDTRK   * trdtrkphi(ntrdtrk)    // phi 
 * R*4  *          * TRDTRK   * trdtrktheta(ntrdtrk)  //theta
 * R*4  *          * TRDTRK   * trdtrkchi2(ntrdtrk)   //chi2
 * U*4  *[0,5]     * TRDTRK   * trdtrkns(ntrdtrk)     // number of segments in track
 * U*4  *[0,100]   * TRDTRK   * trdtrkpat(ntrdtrk)    // pattern no
 * I*4  *          * TRDTRK   * trdtrkps(5,ntrdtrk)   // pointer to segments

---------------------------------------------------------------------------

NOTES:

*) Status bits (counting from 1 to 32)

 1 - REFITTED object                                     (status&1     !=0)
 2 - WIDE in shape (Tracker)                             (status&2     !=0)
 3 - AMBIGously associated                               (status&4     !=0)
 4 - RELEASED object                                     (status&8     !=0)
 5 - BAD                                                 (status&16    !=0)
 6 - USED as a component of a larger object              (status&32    !=0)
 7 - DELETED object                                      (status&64    !=0)
 8 - BADHIStory (TOF)                                    (status&128   !=0)
 9 - ONESIDE measurement (TOF)                           (status&256   !=0)
10 - BADTIME information (TOF)                           (status&512   !=0)
11 - NEAR, close to another object (Trck)                (status&1024  !=0)
12 - WEAK, defined with looser criteria (Trck)           (status&2046  !=0)
13 - AwayTOF, away from TOF predictions (Trck)           (status&4096  !=0)
14 - FalseX, x-coordinate built but not measured (Trck)  (status&8192  !=0)
15 - FalseTOFX, x-coordinates from TOF (Trck)            (status&16384 !=0)
16 - 4th tof plane was recovered using tracker           (status&32768 !=0)
17 - LocalDB was used to align track                     (status&65536 !=0)
18 - GlobalDB was used to align the track                (status&(65536*2)!=0)
19 - Cluster was used to get the charge                  (status&(65536*4)!=0)
20 - TrRecHit was good enough to be used in track find   (status&(65536*8)!=0)
21 - Track->Trladder interpol was done on plane level    (status&(65536*16)!=0)
22 - Track was created using TOF only                    (status&(65536*32)!=0)
23 - Object Overflow                                     (status&(65536*64)!=0)
26 - CATLEAK  (Ecal only)                               (status&(65536*256)!=0) 

**) AMS global system definition: GTOD


***) ISS coordinates in an eccentric dipole coordinate system where
     GEOMz=-d, GEOMy=GEOMz x S (d: dipole direction, S: geographic South)




******) geant3 only particle=pid+256 means heavy ion nonelstic
        scattering occured in for pid with dir & momentum at coo;
        particle=-pid means secondary particle produced with
        dir&momentum at coo

   
*******) For geant4 this value is 0. For geant 3it has several meanings:

Cerenkov photon generated in radiator:

    ricstatus = 100*(mother of Cerenkov if secondary?1:0)+10*(number of
                reflections in mirror) + (photon suffered rayleigh
                scattering?1:0)

PMT noise:

    ricstatus = -1

Cerenkov photon generated in PMT window:

    ricstatus = -(2+100*(mother of Cerenkov if secondary?1:0))


Cerenkov photon generated in light guide:
   
    ricstatus = -(5+100*(mother of Cerenkov if secondary?1:0)) 


No Cerenkov photon:

    ricstatus = -(3+100*(mother of Cerenkov if secondary?1:0))



NOTE: The information of the mother is only available if RICCONT=1 in
      the datacards


********)

0      Unknown
1      alpha-osf 
2      i386-linux
3      reserved for future candidate


*********) Status bits (counting from 1 to 32)

1- Hit used in a larger (ring number 1) object
2- Hit used in a larger (ring number 2) object 
3- Hit used in a larger (ring number 3) object
.
.
.
10- Hit used in a larger (ring number 10) object 
11- Unused
.
.
.
29- Unused
30- Gain mode chosen for the hit: 0=x1(low)  1=x5(high)
31- Hit belongs to a PMT apparently crossed by a charged particle
          



**********) Ring status bits (counting from 1 to 32)
1- Ring has been rebuild after cleaning PMTs apparently crossed by a charged particle.
   If the rebuilding has been succesful it is stored in the next ring.  
   To confirm that the next ring is a rebuilding of the current one check
   if both rcritrkn are pointing to the same track number.   
	    
2- Rins reconstructed using the Naf radiator in the doble radiator configuration






-----------
pmom definition

if( pbetap(i) > 0)then
  
  if(ptrackp(i)>0)then
     pmom(i)=ridgidity(ptrackp(i))*pcharge(i)*sign(beta(pbetap(i)))
  else
     pmom(i)=1000000*sign(beta(pbetap(i)))
  endif
else if(pecalp(i)>0)then
     pmom(i)=ecshen(pecalp(i))
endif




-------------
Known bugs:

a. "HUWFUN: Not space to store COMMON definition"
    after nt/uwfunc 1 blabla.f
  
    Workaround:
    

Use custom built paw /offline/paw/(linux,osf1)/pawX11 
